/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Bool"] = "bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Enum"] = "enum";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["HPA"] = "hectopascals";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["LBS"] = "pounds";
    SimVarValueType["LLA"] = "latlonalt";
    SimVarValueType["Mach"] = "mach";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["MetersPerSecond"] = "meters per second";
    SimVarValueType["MetersPerSecondSquared"] = "meters per second squared";
    SimVarValueType["MillimetersWater"] = "millimeters of water";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["Number"] = "number";
    SimVarValueType["Percent"] = "percent";
    SimVarValueType["PercentOver100"] = "percent over 100";
    SimVarValueType["Pounds"] = "pounds";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["Rankine"] = "rankine";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["SlugsPerCubicFoot"] = "slug per cubic foot";
    SimVarValueType["String"] = "string";
    SimVarValueType["Volts"] = "Volts";
})(SimVarValueType || (SimVarValueType = {}));
const latlonaltRegEx = new RegExp(/latlonalt/i);
const latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
const pbhRegex = new RegExp(/pbh/i);
const pid_structRegex = new RegExp(/pid_struct/i);
const xyzRegex = new RegExp(/xyz/i);
const stringRegex = new RegExp(/string/i);
const boolRegex = new RegExp(/boolean|bool/i);
const numberRegex = new RegExp(/number/i);
const defaultSource = '';
SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
        if (simvar) {
            let output;
            const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (registeredID >= 0) {
                if (numberRegex.test(unit)) {
                    output = simvar.getValueReg(registeredID);
                }
                else if (stringRegex.test(unit)) {
                    output = simvar.getValueReg_String(registeredID);
                }
                else if (latlonaltRegEx.test(unit)) {
                    output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
                }
                else if (pbhRegex.test(unit)) {
                    output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
                }
                else if (pid_structRegex.test(unit)) {
                    output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
                }
                else if (xyzRegex.test(unit)) {
                    output = new XYZ(simvar.getValue_XYZ(name, dataSource));
                }
                else {
                    output = simvar.getValueReg(registeredID);
                }
            }
            return output;
        }
        else {
            console.warn('SimVar handler is not defined (' + name + ')');
        }
    }
    catch (error) {
        console.warn('ERROR ', error, ' GetSimVarValue ' + name + ' unit : ' + unit);
        return null;
    }
    return null;
};
SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == undefined) {
        console.warn(name + ' : Trying to set a null value');
        return Promise.resolve();
    }
    try {
        if (simvar) {
            const regID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (regID >= 0) {
                if (stringRegex.test(unit)) {
                    return Coherent.call('setValueReg_String', regID, value);
                }
                else if (boolRegex.test(unit)) {
                    return Coherent.call('setValueReg_Bool', regID, !!value);
                }
                else if (numberRegex.test(unit)) {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
                else if (latlonaltRegEx.test(unit)) {
                    return Coherent.call('setValue_LatLongAlt', name, value, dataSource);
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    return Coherent.call('setValue_LatLongAltPBH', name, value, dataSource);
                }
                else if (pbhRegex.test(unit)) {
                    return Coherent.call('setValue_PBH', name, value, dataSource);
                }
                else if (pid_structRegex.test(unit)) {
                    return Coherent.call('setValue_PID_STRUCT', name, value, dataSource);
                }
                else if (xyzRegex.test(unit)) {
                    return Coherent.call('setValue_XYZ', name, value, dataSource);
                }
                else {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
            }
        }
        else {
            console.warn('SimVar handler is not defined');
        }
    }
    catch (error) {
        console.warn('error SetSimVarValue ' + error);
    }
    return Promise.resolve();
};

/**
 * A utility class for working with common aeronautical constants and calculations.
 */
class AeroMath {
    // ---- Ideal gas law relationships for air ----
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature, density) {
        return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure, temperature) {
        return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure, density) {
        return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    // ---- Other properties of air ----.
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature) {
        // speed of sound = sqrt(gamma * R * T)
        // gamma = 1.4
        // R = specific gas constant of dry air
        return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    // ---- Pressure ratios ----
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach) {
        return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    // ---- Temperature ratios ----
    /**
     * Gets the ratio of total air temperature to static air temperature for a given mach number.
     * @param mach The mach number.
     * @param recovery The recovery factor. This is a value in the range `[0, 1]` representing the fraction of the
     * kinetic energy of the airflow that is converted to heat. Defaults to 1.
     * @returns The ratio of total air temperature to static air temperature for the specified mach number.
     */
    static totalTemperatureRatioAir(mach, recovery = 1) {
        return 1 + 0.2 * recovery * mach * mach;
    }
    // ---- ISA modeling ----
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude) {
        // We don't use lookup table for perf reasons.
        if (altitude < 11000) {
            return 15 + Math.max(altitude, -610) * -0.0065;
        }
        else if (altitude < 20000) {
            return -56.5;
        }
        else if (altitude < 32000) {
            return -56.5 + (altitude - 20000) * 0.001;
        }
        else if (altitude < 47000) {
            return -44.5 + (altitude - 32000) * 0.0028;
        }
        else if (altitude < 51000) {
            return -2.5;
        }
        else if (altitude < 71000) {
            return -2.5 + (altitude - 51000) * -0.0028;
        }
        else {
            return -58.5 + (Math.min(altitude, 80000) - 71000) * -0.002;
        }
    }
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // P(h) = P(h0) * (1 + dT/dh / T(h0) * (h - h0)) ^ (-g / (R * dT/dh))
        // Temperature constant with altitude:
        // P(h) = P(h0) * e^(-g / (R * T) * (h - h0))
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (altitude < -610) {
            // Modeling stops at -610 meters, so return the pressure for -610 meters for any altitude below this.
            return 1088.707021458965;
        }
        else if (altitude <= 11000) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return 1013.25 * Math.pow(1 - 2.25577e-5 * altitude, 5.25580);
        }
        else if (altitude <= 20000) {
            // Tropopause
            // dT/dh = 0
            return 226.32547681422847 * Math.exp(-1.57686e-4 * (altitude - 11000));
        }
        else if (altitude <= 32000) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 54.7512459834976 * Math.pow(1 + 4.61574e-6 * (altitude - 20000), -34.1627);
        }
        else if (altitude <= 47000) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 8.68079131804552 * Math.pow(1 + 1.22458e-5 * (altitude - 32000), -12.2010);
        }
        else if (altitude <= 51000) {
            // Stratopause
            // dT/dh = 0
            return 1.1091650294132658 * Math.exp(-1.26225e-4 * (altitude - 47000));
        }
        else if (altitude <= 71000) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return 0.6694542213945832 * Math.pow(1 - 1.03455e-5 * (altitude - 51000), 12.2010);
        }
        else if (altitude <= 80000) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return 0.03956893750841349 * Math.pow(1 - 9.31749e-6 * (altitude - 71000), 17.0814);
        }
        else {
            // Modeling stops at 80000 meters, so return the pressure for 80000 meters for any altitude above this.
            return 0.008864013902895545;
        }
    }
    /**
     * Gets the pressure altitude, in meters above MSL, corresponding to a given ISA pressure. The supported pressure
     * altitude range is from -610 to 80000 meters above MSL. This method will return -610 meters for all pressures above
     * the pressure at -610 meters, and 80000 meters for all pressures below the pressure at 80000 meters.
     * @param pressure The ISA pressure for which to get the altitude, in hectopascals.
     * @returns The pressure altitude, in meters above MSL, corresponding to the specified ISA pressure.
     */
    static isaAltitude(pressure) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // h(P) = T(h0) / dT/dh * ((P / P(h0)) ^ (-(R * dT/dh) / g) - 1) + h0
        // Temperature constant with altitude:
        // h(P) = -(R * T) / g * ln(P / P(h0)) + h0
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (pressure > 1088.707021458965) {
            // Modeling stops at -610 meters, so return -610 meters for any pressure above the pressure at this altitude.
            return -610;
        }
        else if (pressure > 226.32547681422847) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return -44330.76067152236 * (Math.pow(pressure / 1013.25, 0.1902659918566155) - 1);
        }
        else if (pressure > 54.7512459834976) {
            // Tropopause
            // dT/dh = 0
            return -6341.717083317479 * Math.log(pressure / 226.32547681422847) + 11000;
        }
        else if (pressure > 8.68079131804552) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 216649.984617851092 * (Math.pow(pressure / 54.7512459834976, -0.02927169105486393) - 1) + 20000;
        }
        else if (pressure > 1.1091650294132658) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 81660.6509987098 * (Math.pow(pressure / 8.68079131804552, -0.08196049504139005) - 1) + 32000;
        }
        else if (pressure > 0.6694542213945832) {
            // Stratopause
            // dT/dh = 0
            return -7922.360863537334 * Math.log(pressure / 1.1091650294132658) + 47000;
        }
        else if (pressure > 0.03956893750841349) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return -96660.38374172345 * (Math.pow(pressure / 0.6694542213945832, 0.08196049504139005) - 1) + 51000;
        }
        else if (pressure > 0.008864013902895545) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return -107325.0414006347 * (Math.pow(pressure / 0.03956893750841349, 0.05854321074385004) - 1) + 71000;
        }
        else {
            // Modeling stops at 80000 meters, so return 80000 meters for any pressure below the pressure at this altitude.
            return 80000;
        }
    }
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude, deltaIsa = 0) {
        return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude, deltaIsa = 0) {
        return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the offset to apply to pressure altitude, in meters, to obtain indicated altitude for a given barometric setting.
     * @param baro The barometic setting for which to get the offset, in hectopascals.
     * @returns The offset to apply to pressure altitude, in meters, to obtain indicated altitude for the specified barometric setting.
     */
    static baroPressureAltitudeOffset(baro) {
        return 44307.694 * (Math.pow(baro / 1013.25, 0.190284) - 1);
    }
    // ---- Speed conversions ----
    // The following section contains methods for converting between different speeds: CAS, TAS, EAS, and mach.
    // All conversions are based on the following:
    // Constants:
    // gamma (adiabatic index of air) = 1.4
    // pressure_sea_level_isa = 1013.25 hPa
    // sound_speed_sea_level_isa = 340.2964 m/s
    // density_sea_level_isa = 1.22498 kg/m^3
    // Relationship between mach and impact pressure (only valid for subsonic flow):
    // mach = sqrt(5 * ((impact_pressure / static_pressure + 1) ^ ((gamma - 1) / gamma)) - 1)
    // impact_pressure = static_pressure * ((1 + 0.2 * mach ^ 2) ^ (gamma / (gamma - 1)) - 1)
    // Relationship between mach and airspeed:
    // mach = airspeed / sound_speed
    // airspeed = mach * sound_speed
    // Relationship between EAS and TAS:
    // eas = tas * sqrt(density / density_sea_level_isa)
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas, soundSpeed) {
        return tas / soundSpeed;
    }
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
        return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach, soundSpeed) {
        return mach * soundSpeed;
    }
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
        return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate mach from CAS by
        // calculating the impact pressure using sea level ISA conditions, then using that impact pressure to calculate
        // mach using ambient static pressure.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas, altitude) {
        return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate CAS from mach by
        // calculating the impact pressure using ambient static pressure, then using that impact pressure to calculate
        // CAS using sea level ISA conditions.
        const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach, altitude) {
        return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas, pressure, temperature) {
        return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
        return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas, pressure, temperature) {
        return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    /**
     * Converts true airspeed (TAS) to equivalent airspeed (EAS).
     * @param tas The true airspeed to convert.
     * @param density The ambient density, in kilograms per cubic meter.
     * @returns The equivalent airspeed corresponding to the specified true airspeed at the specified ambient density.
     * The equivalent airspeed is expressed in the same units as the true airspeed.
     */
    static tasToEas(tas, density) {
        return tas * Math.sqrt(density / AeroMath.DENSITY_SEA_LEVEL_ISA);
    }
    /**
     * Converts true airspeed (TAS) to equivalent airspeed (EAS) under ISA conditions.
     * @param tas The true airspeed to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The equivalent airspeed corresponding to the specified true airspeed at the specified pressure altitude
     * under ISA conditions. The equivalent airspeed is expressed in the same units as the true airspeed.
     */
    static tasToEasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.tasToEas(tas, AeroMath.isaDensity(altitude, deltaIsa));
    }
    /**
     * Converts equivalent airspeed (EAS) to true airspeed (TAS).
     * @param eas The equivalent airspeed to convert.
     * @param density The ambient density, in kilograms per cubic meter.
     * @returns The true airspeed corresponding to the specified equivalent airspeed at the specified ambient density.
     * The true airspeed is expressed in the same units as the equivalent airspeed.
     */
    static easToTas(eas, density) {
        return eas * Math.sqrt(AeroMath.DENSITY_SEA_LEVEL_ISA / density);
    }
    /**
     * Converts equivalent airspeed (EAS) to true airspeed (TAS) under ISA conditions.
     * @param eas The equivalent airspeed to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed corresponding to the specified equivalent airspeed at the specified pressure altitude
     * under ISA conditions. The true airspeed is expressed in the same units as the equivalent airspeed.
     */
    static easToTasIsa(eas, altitude, deltaIsa = 0) {
        return AeroMath.easToTas(eas, AeroMath.isaDensity(altitude, deltaIsa));
    }
    /**
     * Converts mach number to equivalent airspeed (EAS).
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified mach number at the
     * specified ambient static pressure.
     */
    static machToEas(mach, pressure) {
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * mach * Math.sqrt(pressure / 1013.25);
    }
    /**
     * Converts mach number to equivalent airspeed (EAS) under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified mach number at the
     * specified pressure altitude under ISA conditions.
     */
    static machToEasIsa(mach, altitude) {
        return AeroMath.machToEas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts equivalent airspeed (EAS) to mach number.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number corresponding to the specified equivalent airspeed at the specified ambient static
     * pressure.
     */
    static easToMach(eas, pressure) {
        return eas * Math.sqrt(1013.25 / pressure) / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
    }
    /**
     * Converts equivalent airspeed (EAS) to mach number under ISA conditions.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number corresponding to the specified equivalent airspeed at the specified pressure altitude
     * under ISA conditions.
     */
    static easToMachIsa(eas, altitude) {
        return AeroMath.easToMach(eas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to equivalent airspeed (EAS). The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified calibrated airspeed at the
     * specified ambient static pressure.
     */
    static casToEas(cas, pressure) {
        // The below is a slightly optimized concatenation of the CAS-to-mach and mach-to-EAS conversions.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * pressure / 1013.25 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to equivalent airspeed (EAS) under ISA conditions. The conversion is only valid
     * for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified calibrated airspeed at the
     * specified pressure altitude under ISA conditions.
     */
    static casToEasIsa(cas, altitude) {
        return AeroMath.casToEas(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts equivalent airspeed (EAS) to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed, in meters per second, corresponding to the specified equivalent airspeed at the
     * specified ambient static pressure.
     */
    static easToCas(eas, pressure) {
        return AeroMath.machToCas(AeroMath.easToMach(eas, pressure), pressure);
    }
    /**
     * Converts equivalent airspeed (EAS) to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid
     * for subsonic speeds.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed, in meters per second, corresponding to the specified equivalent airspeed at the
     * specified pressure altitude under ISA conditions.
     */
    static easToCasIsa(eas, altitude) {
        return AeroMath.easToCas(eas, AeroMath.isaPressure(altitude));
    }
    // ---- Lift and drag equations ----
    // force_coefficient = force / (dynamic_pressure * area)
    // dynamic_pressure = 0.5 * density * speed ^ 2
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    static flowCoefFromForce(force, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return force / (dynamicPressure * area);
    }
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    static flowForceFromCoef(coef, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return coef * dynamicPressure * area;
    }
}
/** The ideal gas constant, in units of joules per mole per kelvin. */
AeroMath.R = 8.314462618153;
/** The specific gas constant of dry air, in units of joules per kilogram per kelvin. */
AeroMath.R_AIR = 287.057;
/** Approximate value of the adiabatic index of air near room temperature. */
AeroMath.GAMMA_AIR = 1.4;
/** The speed of sound in air at sea level under ISA conditions, in meters per second. */
AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
/** The density of air at sea level under ISA conditions, in kilograms per cubic meter. */
AeroMath.DENSITY_SEA_LEVEL_ISA = AeroMath.isaDensity(0);
AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
AeroMath.lift = AeroMath.flowForceFromCoef;
AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
AeroMath.drag = AeroMath.flowForceFromCoef;

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.canConvert(value.unit)) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number' && (!unit || this.unit.canConvert(unit))) {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
        if (out) {
            return out.set(Math.abs(this.number), this.unit);
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        if (isNaN(converted) && this.isNaN()) {
            return true;
        }
        const diff = this.number - converted;
        return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, out);
        }
        else {
            return this.source.add(arg1, out);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, out);
        }
        else {
            return this.source.subtract(arg1, out);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
        return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i++].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i++].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.family = family;
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
/**
 * Predefined unit families.
 */
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["Distance"] = "distance";
    UnitFamily["Angle"] = "angle";
    UnitFamily["Duration"] = "duration";
    UnitFamily["Weight"] = "weight";
    UnitFamily["Mass"] = "weight";
    UnitFamily["Volume"] = "volume";
    UnitFamily["Pressure"] = "pressure";
    UnitFamily["Temperature"] = "temperature";
    UnitFamily["TemperatureDelta"] = "temperature_delta";
    UnitFamily["Speed"] = "speed";
    UnitFamily["Acceleration"] = "acceleration";
    UnitFamily["WeightFlux"] = "weight_flux";
    UnitFamily["MassFlux"] = "weight_flux";
    UnitFamily["VolumeFlux"] = "volume_flux";
    UnitFamily["Density"] = "density";
    UnitFamily["Force"] = "force";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.Distance, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, 'kilometer', 1000);
/** Statute mile. */
UnitType.MILE = new SimpleUnit(UnitFamily.Distance, 'mile', 1609.34);
/** Nautical mile. */
UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, 'nautical mile', 1852);
/** Great-arc radian. The average radius of Earth. */
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, 'great arc radian', 6378100);
/** 9.80665 meters, for internal use. */
UnitType.G_METER = new SimpleUnit(UnitFamily.Distance, '9.80665 meter', 9.80665);
UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.Weight, 'pound', 0.453592);
UnitType.SLUG = new SimpleUnit(UnitFamily.Weight, 'slug', 14.59390);
UnitType.TON = new SimpleUnit(UnitFamily.Weight, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, 'tonne', 1000);
/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, 'liter', 0.80283679);
/** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'gallon', 3.0390664);
/** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'imperial gallon', 3.6497683);
UnitType.LITER = new SimpleUnit(UnitFamily.Volume, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, 'gallon', 3.78541);
/** Hectopascal. */
UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, 'hectopascal', 1);
/** Atmosphere. */
UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, 'atmosphere', 1013.25);
/** Inch of mercury. */
UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, 'inch of mercury', 33.8639);
/** Millimeter of mercury. */
UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, 'millimeter of mercury', 1.33322);
/** Pound per square inch. */
UnitType.PSI = new SimpleUnit(UnitFamily.Pressure, 'pound per square inch', 68.9476);
UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, 'kelvin', 1, 0);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, '° Fahrenheit', 5 / 9, 459.67);
UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, '° Rankine', 5 / 9, 0);
/** Change in degrees Celsius. */
UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Celsius', 1);
/** Change in degrees Fahrenheit. */
UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Fahrenheit', 5 / 9);
UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], 'knot');
/** Kilometer per hour. */
UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
/** Miles per hour. */
UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
/** Meter per minute. */
UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
/** Meter per second. */
UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
/** Foot per minute. */
UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
/** Foot per second. */
UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
/** Meter per minute per second. */
UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
/** Meter per second per second. */
UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Foot per minute per second. */
UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
/** Foot per second per second. */
UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
/** Knot per second. */
UnitType.KNOT_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.NMILE], [UnitType.HOUR, UnitType.SECOND]);
/** Average gravitational acceleration on Earth at sea level. */
UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);
/** Kilogram per hour. */
UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
/** Pound per hour. */
UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
/** Density in slugs per cubic foot */
UnitType.SLUG_PER_FT3 = new CompoundUnit(UnitFamily.Density, [UnitType.SLUG], [UnitType.FOOT, UnitType.FOOT, UnitType.FOOT]);
/** Density in kilograms per cubic meter */
UnitType.KG_PER_M3 = new CompoundUnit(UnitFamily.Density, [UnitType.KILOGRAM], [UnitType.METER, UnitType.METER, UnitType.METER]);
/** Newton. */
UnitType.NEWTON = new CompoundUnit(UnitFamily.Force, [UnitType.KILOGRAM, UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Pound (force). */
UnitType.POUND_FORCE = new CompoundUnit(UnitFamily.Force, [UnitType.POUND, UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    publish(topic, data, sync = false, isCached = true) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync, isCached);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.resolvedSimVars = new Map();
        this.indexedSimVars = new Map();
        this.subscribed = new Set();
        for (const [topic, entry] of simVarMap) {
            if (entry.indexed) {
                this.indexedSimVars.set(topic, {
                    name: entry.name,
                    type: entry.type,
                    map: entry.map,
                    indexes: entry.indexed === true ? undefined : new Set(entry.indexed),
                    defaultIndex: entry.defaultIndex,
                });
            }
            else {
                this.resolvedSimVars.set(topic, Object.assign({}, entry));
            }
        }
        const handleSubscribedTopic = (topic) => {
            if (this.resolvedSimVars.has(topic)) {
                // If topic matches an already resolved topic -> start publishing.
                this.onTopicSubscribed(topic);
            }
            else {
                // Check if topic matches indexed topic.
                this.tryMatchIndexedSubscribedTopic(topic);
            }
        };
        // Iterate over each subscribed topic on the bus to see if it matches any of our topics. If so, start publishing.
        this.bus.forEachSubscribedTopic(handleSubscribedTopic);
        // Listen to first-time topic subscriptions. If any of them match our topics, start publishing.
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(handleSubscribedTopic);
    }
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    tryMatchIndexedSubscribedTopic(topic) {
        var _a;
        if (this.indexedSimVars.size === 0) {
            return;
        }
        let entry = this.indexedSimVars.get(topic);
        if (entry) {
            // The subscribed topic matches an unsuffixed topic -> check if the unsuffixed topic should be published and if
            // so, resolve the default index.
            if (entry.defaultIndex !== null) {
                const resolved = this.resolveIndexedSimVar(topic, entry, (_a = entry.defaultIndex) !== null && _a !== void 0 ? _a : 1);
                if (resolved !== undefined) {
                    this.onTopicSubscribed(resolved);
                }
            }
            return;
        }
        if (!SimVarPublisher.INDEXED_REGEX.test(topic)) { // Don't generate an array if we don't have to.
            return;
        }
        const match = topic.match(SimVarPublisher.INDEXED_REGEX);
        const [, matchedTopic, index] = match;
        entry = this.indexedSimVars.get(matchedTopic);
        if (entry) {
            const resolved = this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index));
            if (resolved !== undefined) {
                this.onTopicSubscribed(resolved);
            }
        }
    }
    /**
     * Attempts to resolve an indexed topic with an index, generating a version of the topic which is mapped to an
     * indexed simvar. The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic, or `undefined` if the topic could not be resolved with the specified index.
     */
    resolveIndexedSimVar(topic, entry, index) {
        index !== null && index !== void 0 ? index : (index = 1);
        const resolvedTopic = `${topic}_${index}`;
        if (this.resolvedSimVars.has(resolvedTopic)) {
            return resolvedTopic;
        }
        const defaultIndex = entry.defaultIndex === undefined ? 1 : entry.defaultIndex;
        // Ensure that the index we are trying to resolve is a valid index for the topic.
        if (entry.indexes !== undefined && !entry.indexes.has(index)) {
            return undefined;
        }
        this.resolvedSimVars.set(resolvedTopic, {
            name: entry.name.replace('#index#', `${index !== null && index !== void 0 ? index : 1}`),
            type: entry.type,
            map: entry.map,
            unsuffixedTopic: defaultIndex === index ? topic : undefined
        });
        return resolvedTopic;
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry !== undefined) {
            const value = this.getValueFromEntry(entry);
            this.publish(topic, value);
            // Check if we need to publish the same value to the unsuffixed version of the topic.
            if (entry.unsuffixedTopic) {
                this.publish(entry.unsuffixedTopic, value);
            }
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return this.getValueFromEntry(entry);
    }
    /**
     * Gets the current value for a resolved topic entry.
     * @param entry An entry for a resolved topic.
     * @returns The current value for the specified entry.
     */
    getValueFromEntry(entry) {
        return entry.map === undefined
            ? this.getSimVarValue(entry)
            : entry.map(this.getSimVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getSimVarValue(entry) {
        const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}
SimVarPublisher.INDEXED_REGEX = /(.*)_(0|[1-9]\d*)$/;
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class GameVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
        // Start polling all simvars for which there are existing subscriptions.
        for (const topic of this.simvars.keys()) {
            if (bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((topic) => {
            if (this.simvars.has(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const value = this.getValue(topic);
        if (value !== undefined) {
            this.publish(topic, value);
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.simvars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return entry.map === undefined
            ? this.getGameVarValue(entry)
            : entry.map(this.getGameVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getGameVarValue(entry) {
        const svValue = SimVar.GetGameVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for air data computer information.
 */
class AdcPublisher extends SimVarPublisher {
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['ias', { name: 'AIRSPEED INDICATED:#index#', type: SimVarValueType.Knots, indexed: true }],
            ['tas', { name: 'AIRSPEED TRUE:#index#', type: SimVarValueType.Knots, indexed: true }],
            [
                'mach_to_kias_factor',
                {
                    name: 'AIRSPEED INDICATED:#index#',
                    type: SimVarValueType.Knots,
                    map: (kias) => {
                        const factor = kias < 1 || this.mach === 0 ? AeroMath.machToCas(1, this.pressure) : kias / this.mach;
                        return isFinite(factor) ? factor : 1;
                    },
                    indexed: true
                }
            ],
            ['indicated_alt', { name: 'INDICATED ALTITUDE:#index#', type: SimVarValueType.Feet, indexed: true }],
            ['altimeter_baro_setting_inhg', { name: 'KOHLSMAN SETTING HG:#index#', type: SimVarValueType.InHG, indexed: true }],
            ['altimeter_baro_setting_mb', { name: 'KOHLSMAN SETTING MB:#index#', type: SimVarValueType.MB, indexed: true }],
            ['altimeter_baro_preselect_raw', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, indexed: true }],
            ['altimeter_baro_preselect_inhg', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => UnitType.HPA.convertTo(raw / 16, UnitType.IN_HG), indexed: true }],
            ['altimeter_baro_preselect_mb', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => raw / 16, indexed: true }],
            ['altimeter_baro_is_std', { name: 'L:XMLVAR_Baro#index#_ForcedToSTD', type: SimVarValueType.Bool, indexed: true }],
            ['radio_alt', { name: 'RADIO HEIGHT', type: SimVarValueType.Feet }],
            ['pressure_alt', { name: 'PRESSURE ALTITUDE', type: SimVarValueType.Feet }],
            ['vertical_speed', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
            ['ambient_density', { name: 'AMBIENT DENSITY', type: SimVarValueType.SlugsPerCubicFoot }],
            ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_pressure_inhg', { name: 'AMBIENT PRESSURE', type: SimVarValueType.InHG }],
            ['isa_temp_c', { name: 'STANDARD ATM TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ram_air_temp_c', { name: 'TOTAL AIR TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
            ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
            ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
            ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }],
            ['stall_aoa', { name: 'STALL ALPHA', type: SimVarValueType.Degree }],
            ['zero_lift_aoa', { name: 'ZERO LIFT ALPHA', type: SimVarValueType.Degree }],
            ['mach_number', { name: 'AIRSPEED MACH', type: SimVarValueType.Mach }],
        ]);
        super(simvars, bus, pacer);
        this.mach = 0;
        this.pressure = 1013.25;
        (_a = this.needUpdateMachToKiasData) !== null && _a !== void 0 ? _a : (this.needUpdateMachToKiasData = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('mach_to_kias_factor')) {
            this.needUpdateMachToKiasData = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        const isSlewing = SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
        if (!isSlewing) {
            if (this.needUpdateMachToKiasData) {
                this.mach = SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Number);
                this.pressure = SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.HPA);
            }
            super.onUpdate();
        }
    }
}

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags, valuesToSet, mask) {
        return (flags & ~mask) | (valuesToSet & mask);
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values.
 *
 * When a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time
 * elapsed since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The
 * calculation of the weighting is such that the weight of each raw value in the sequence decays exponentially with the
 * "age" (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to
 * the sequence) of the value.
 */
class ExpSmoother {
    /**
     * Creates a new instance of ExpSmoother.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.tau > 0 && this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

/**
 * A calculator for lookahead values based on past trends. The calculator accepts a series of input values separated
 * by discrete time intervals, computes a rate of change at each time step, and uses this rate of change to predict
 * what the input value will be at some arbitrary length of time in the future assuming the rate of change remains
 * constant.
 */
class Lookahead {
    /**
     * Constructor.
     * @param lookahead This calculator's lookahead time.
     * @param valueSmoothingTau The smoothing time constant to apply to the calculator's input values before rate of
     * change is computed. A value of `0` is equivalent to no smoothing. Defaults to `0`.
     * @param trendSmoothingTau The smoothing time constant to apply to the calculator's computed trend values. A value
     * of `0` is equivalent to no smoothing. Defaults to `0`.
     */
    constructor(lookahead, valueSmoothingTau = 0, trendSmoothingTau = 0) {
        this.lookahead = lookahead;
        this.lastSmoothedValue = null;
        this.lastTrendValue = 0;
        this.lastLookaheadValue = null;
        this.lastSmoothedLookaheadValue = null;
        this.valueSmoother = new ExpSmoother(valueSmoothingTau);
        this.trendSmoother = new ExpSmoother(trendSmoothingTau);
    }
    /**
     * Gets this calculator's last computed lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param smoothed Whether to retrieve the lookahead value computed using the last smoothed input value instead of
     * the raw input value as the present (`t = 0`) value. Defaults to `false`.
     * @returns This calculator's last computed lookahead value.
     */
    last(smoothed = false) {
        return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Gets this calculator's last computed trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @returns This calculator's last computed trend value.
     */
    lastTrend() {
        return this.lastTrendValue;
    }
    /**
     * Adds a new input value and gets the next lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @param smoothed Whether to return the lookahead value computed using the smoothed input value instead of the raw
     * input value as the present (`t = 0`) value. Note that this argument does not determine whether smoothing is
     * applied for the purposes of calculating rate of change (smoothing is always applied for this purpose if a positive
     * time constant is defined). Defaults to `false`.
     * @returns The next lookahead value.
     */
    next(value, dt, smoothed = false) {
        const oldSmoothedValue = this.lastSmoothedValue;
        let trend;
        if (dt < 0) {
            return this.reset(value);
        }
        else if (dt > 0) {
            this.lastSmoothedValue = this.valueSmoother.next(value, dt);
            if (oldSmoothedValue === null) {
                this.trendSmoother.reset();
                trend = 0;
            }
            else {
                trend = this.trendSmoother.next((this.lastSmoothedValue - oldSmoothedValue) / dt * this.lookahead, dt);
            }
        }
        else {
            trend = this.lastTrendValue;
            this.lastSmoothedValue = this.valueSmoother.next(value, dt);
        }
        this.lastTrendValue = trend;
        this.lastLookaheadValue = value + trend;
        this.lastSmoothedLookaheadValue = this.lastSmoothedValue + trend;
        return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Adds a new input value and gets the next trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @returns The next trend value.
     */
    nextTrend(value, dt) {
        this.next(value, dt);
        return this.lastTrendValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        this.lastSmoothedValue = this.valueSmoother.reset(value);
        this.trendSmoother.reset();
        this.lastTrendValue = 0;
        this.lastLookaheadValue = this.lastSmoothedValue;
        this.lastSmoothedLookaheadValue = this.lastSmoothedValue;
        return this.lastLookaheadValue;
    }
}

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value, precision = 1) {
        return Math.round(value / precision) * precision;
    }
    /**
     * Ceils a number.
     * @param value The number to ceil.
     * @param precision The precision with which to ceil. Defaults to `1`.
     * @returns The ceiled number.
     */
    static ceil(value, precision = 1) {
        return Math.ceil(value / precision) * precision;
    }
    /**
     * Floors a number.
     * @param value The number to floor.
     * @param precision The precision with which to floor. Defaults to `1`.
     * @returns The floored number.
     */
    static floor(value, precision = 1) {
        return Math.floor(value / precision) * precision;
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
        const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
        return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 360)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in degrees.
     * @param end The ending angle, in degrees.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in degrees, in the range `[0, 360)`.
     */
    static diffAngleDeg(start, end, directional = true) {
        const diff = ((end - start) % 360 + 360) % 360;
        return directional ? diff : Math.min(diff, 360 - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        if (x0 !== x1 && y0 !== y1) {
            const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
            return fraction * (y1 - y0) + y0;
        }
        else {
            return y0;
        }
    }
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        const length = Math.min(y0.length, y1.length, out.length);
        for (let i = 0; i < length; i++) {
            out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
        }
        return out;
    }
}
/** Twice the value of pi. */
MathUtils.TWO_PI = Math.PI * 2;
/** Half the value of pi. */
MathUtils.HALF_PI = Math.PI / 2;
/** Square root of 3. */
MathUtils.SQRT3 = Math.sqrt(3);
/** Square root of 1/3. */
MathUtils.SQRT1_3 = 1 / Math.sqrt(3);

/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
class HandlerSubscription {
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
        this.handler = handler;
        this.initialNotifyFunc = initialNotifyFunc;
        this.onDestroy = onDestroy;
        this._isAlive = true;
        this._isPaused = false;
        this.canInitialNotify = initialNotifyFunc !== undefined;
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
        if (!this._isAlive) {
            throw new Error('HandlerSubscription: cannot notify a dead Subscription.');
        }
        this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        if (initialNotify) {
            this.initialNotify();
        }
        return this;
    }
    /** @inheritdoc */
    destroy() {
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.onDestroy && this.onDestroy(this);
    }
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
class SubscribablePipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let onDestroy;
        if (typeof arg4 === 'function') {
            handler = (fromVal) => {
                to.set(arg3(fromVal, to.get()));
            };
            onDestroy = arg4;
        }
        else {
            handler = (fromVal) => {
                to.set(fromVal);
            };
            onDestroy = arg3;
        }
        super(handler, (sub) => { sub.handler(from.get()); }, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribable {
    constructor() {
        this.isSubscribable = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.notifySubscription(this.singletonSub);
                }
            }
            catch (error) {
                console.error(`AbstractSubscribable: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        this.notifySubscription(sub);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribable: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * An implementation of {@link MappedSubscribable}.
 */
class MappedSubscribableClass extends AbstractSubscribable {
    /**
     * Constructor.
     * @param input This subscribable's input.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     */
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
        super();
        this.input = input;
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.input.get()));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.input.get());
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSub = this.input.sub(inputValue => {
            this.updateValue(inputValue);
        }, true);
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     * @param inputValue The input value.
     */
    updateValue(inputValue) {
        const value = this.mapFunc(inputValue, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot pause a dead subscribable');
        }
        if (this._isPaused) {
            return this;
        }
        this.inputSub.pause();
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot resume a dead subscribable');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this.inputSub.resume(true);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        this.inputSub.destroy();
    }
}

/**
 * A subscribable subject whose value can be freely manipulated.
 */
class Subject extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        super();
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
        sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
        if (typeof this.value !== 'object' || this.value === null) {
            return;
        }
        let changed = false;
        for (const prop in value) {
            changed = value[prop] !== this.value[prop];
            if (changed) {
                break;
            }
        }
        Object.assign(this.value, value);
        changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
        super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
        return this.value;
    }
}

/**
 * Utility methods for working with Subscribables.
 */
class SubscribableUtils {
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isSubscribable === true;
    }
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isMutableSubscribable === true;
    }
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable(value, excludeSubscribables) {
        if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
            return value;
        }
        else {
            return Subject.create(value);
        }
    }
}
/**
 * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
 * `NaN`.
 * @param a The first number to compare.
 * @param b The second number to compare.
 * @returns Whether the two numbers are strictly equal or both `NaN`.
 */
SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || (isNaN(a) && isNaN(b));

/**
 * Utility class for generating common functions for mapping subscribables.
 */
class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity() {
        return (input) => input;
    }
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not() {
        return (input) => !input;
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise.
     */
    static or() {
        return (input) => input.length > 0 && input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if no tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if no tuple member is `true` or there are no
     * tuple members, and to `false` otherwise.
     */
    static nor() {
        return (input) => !input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static and() {
        return (input) => input.length > 0 && !input.includes(false);
    }
    /**
     * Generates a function which maps an input boolean tuple to `false` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static nand() {
        return (input) => input.length < 1 || input.includes(false);
    }
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate() {
        return (input) => -input;
    }
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs() {
        return Math.abs;
    }
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision(precision) {
        return SubscribableUtils.isSubscribable(precision)
            ? (input) => {
                const precisionVal = precision.get();
                return Math.round(input / precisionVal) * precisionVal;
            }
            : (input) => {
                return Math.round(input / precision) * precision;
            };
    }
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy(threshold) {
        return SubscribableUtils.isSubscribable(threshold)
            ? (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal
            : (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency(freq, timeFunc = Date.now) {
        let t0;
        let timeRemaining = 0;
        if (SubscribableUtils.isSubscribable(freq)) {
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    const period = 1000 / freq.get();
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
        else {
            const period = 1000 / freq;
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
    }
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
class MappedSubject extends AbstractSubscribable {
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
        super();
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        this.inputs = inputs;
        this.inputValues = inputs.map(input => input.get());
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.inputValues, undefined));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.inputValues, undefined);
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSubs = this.inputs.map((input, index) => input.sub(inputValue => {
            this.inputValues[index] = inputValue;
            this.updateValue();
        }));
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(...args) {
        let mapFunc, equalityFunc, mutateFunc, initialVal;
        if (typeof args[0] === 'function') {
            // Mapping function was supplied.
            mapFunc = args.shift();
            if (typeof args[0] === 'function') {
                equalityFunc = args.shift();
            }
            else {
                equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
            }
            if (typeof args[0] === 'function') {
                mutateFunc = args.shift();
                initialVal = args.shift();
            }
        }
        else {
            mapFunc = MappedSubject.IDENTITY_MAP;
            equalityFunc = MappedSubject.NEVER_EQUALS;
        }
        return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    updateValue() {
        const value = this.mapFunc(this.inputValues, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot pause a dead subject');
        }
        if (this._isPaused) {
            return this;
        }
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].pause();
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot resume a dead subject');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputValues[i] = this.inputs[i].get();
            this.inputSubs[i].resume();
        }
        this.updateValue();
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].destroy();
        }
    }
}
MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
MappedSubject.NEVER_EQUALS = () => false;

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
class NumberUnitSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Returns a number {@link Subscribable} of this `NumberUnit` converted according to a unit or unit `Subscribable`
     *
     * @param unit the unit to subscribe to
     *
     * @returns a `MappedSubscribable<number>`
     */
    asUnit(unit) {
        return MappedSubject.create(([numberUnit, toUnit]) => numberUnit.asUnit(toUnit), this, SubscribableUtils.toSubscribable(unit, true));
    }
}

/**
 * 2D vector mathematical operations.
 */
class Vec2Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined) {
            vec[0] = x;
            vec[1] = y;
        }
        return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Gets the determinant of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The determinant of the vectors.
     */
    static det(v1, v2) {
        return v1[0] * v2[1] - v1[1] * v2[0];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon, point) {
        //Adapted from https://github.com/rowanwins/point-in-polygon-hao
        let k = 0;
        let f = 0;
        let u1 = 0;
        let v1 = 0;
        let u2 = 0;
        let v2 = 0;
        let currentP = null;
        let nextP = null;
        const x = point[0];
        const y = point[1];
        const contourLen = polygon.length - 1;
        currentP = polygon[0];
        if (currentP[0] !== polygon[contourLen][0] &&
            currentP[1] !== polygon[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for (let i = 0; i < polygon.length - 1; i++) {
            nextP = polygon[i + 1];
            v2 = nextP[1] - y;
            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {
                currentP = nextP;
                v1 = v2;
                u1 = currentP[0] - x;
                continue;
            }
            u2 = nextP[0] - point[0];
            if (v2 > 0 && v1 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f > 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 > 0 && v2 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f < 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v2 === 0 && v1 < 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 < 0) {
                f = u1 * v2 - u2 * v1;
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0) {
                    return undefined;
                }
                else if (u1 <= 0 && u2 >= 0) {
                    return undefined;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
        if (k % 2 === 0) {
            return false;
        }
        return true;
    }
}
/**
 * 3D vector mathematical operations.
 */
class Vec3Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
        const vec = new Float64Array(3);
        if (x !== undefined && y !== undefined && z !== undefined) {
            vec[0] = x;
            vec[1] = y;
            vec[2] = z;
        }
        return vec;
    }
    /**
     * Gets the spherical angle theta (polar angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi (azimuthal angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x The new x-component.
     * @param y The new y-component.
     * @param z The new z-component.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r The new length (magnitude).
     * @param theta The new spherical angle theta (polar angle), in radians.
     * @param phi The new spherical angle phi (azimuthal angle), in radians.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = r * sinTheta * Math.cos(phi);
        vec[1] = r * sinTheta * Math.sin(phi);
        vec[2] = r * Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]) && isFinite(vec[2]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}
/**
 * N-dimensional vector mathematical operations.
 */
class VecNMath {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
        const vec = new Float64Array(length);
        for (let i = 0; i < length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
        for (let i = 0; i < vec.length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
        return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
        if (v1.length !== v2.length) {
            throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
        }
        let dot = 0;
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            dot += v1[i] * v2[i];
        }
        return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            out[i] = v1[i] / mag;
        }
        return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        if (vec1.length !== vec2.length) {
            return false;
        }
        for (let i = 0; i < vec1.length; i++) {
            if (vec1[i] !== vec2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        for (let i = 0; i < vec.length; i++) {
            if (!isFinite(vec[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
        if (from.length !== to.length) {
            throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
        }
        to.set(from);
        return to;
    }
}

/**
 * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
 */
class Transform2D {
    constructor() {
        this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
        let scaleX = arg1;
        if (arg1 instanceof Transform2D) {
            [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewX;
        array[2] = translateX;
        array[3] = skewY;
        array[4] = scaleY;
        array[5] = translateY;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[4] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y) {
        this.array[0] = x;
        this.array[4] = y;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value) {
        this.array[1] = value;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[2] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y) {
        this.array[2] = x;
        this.array[5] = y;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_10 = array[3];
        const e_11 = array[4];
        const e_12 = array[5];
        const i_00 = e_11;
        const i_01 = -e_10;
        const i_10 = -e_01;
        const i_11 = e_00;
        const i_20 = e_01 * e_12 - e_02 * e_11;
        const i_21 = -(e_00 * e_12 - e_02 * e_10);
        const det = e_00 * i_00 + e_01 * i_01;
        return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform2D().set(this);
    }
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
        const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
        return Vec2Math.set(x, y, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y) {
        Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
        Transform2D.offsetOriginCache[1] = this;
        Transform2D.offsetOriginCache[2].toTranslation(x, y);
        return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y) {
        return this.set(1, 0, x, 0, 1, y);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, originX, originY) {
        this.set(x, 0, 0, 0, y, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, originX, originY) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toReflection(theta, originX, originY) {
        const sin = Math.sin(2 * theta);
        const cos = Math.cos(2 * theta);
        this.set(cos, sin, 0, sin, -cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, order = 'after') {
        if (order === 'before') {
            Transform2D.addCache[0].toTranslation(x, y);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            Transform2D.addCache[1].toTranslation(x, y);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, arg3, arg4, arg5) {
        let originX, originY, order;
        if (typeof arg3 === 'number') {
            originX = arg3;
            originY = arg4;
            order = arg5;
        }
        else {
            order = arg3;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, arg2, arg3, arg4) {
        let originX, originY, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            order = arg4;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addReflection(theta, arg2, arg3, arg4) {
        let originX, originY, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            order = arg4;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform2D.concatCache[0];
        const newTransform = Transform2D.concatCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform2D.offsetOriginCache = [new Transform2D(), undefined, new Transform2D()];
Transform2D.addCache = [new Transform2D(), new Transform2D()];
Transform2D.concatCache = [new Transform2D(), new Transform2D()];

/**
 * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
 */
class Transform3D {
    constructor() {
        this.array = new Float64Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0
        ]);
    }
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
        let scaleX = arg1;
        if (arg1 instanceof Transform3D) {
            [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewXY;
        array[2] = skewXZ;
        array[3] = translateX;
        array[4] = skewYX;
        array[5] = scaleY;
        array[6] = skewYZ;
        array[7] = translateY;
        array[8] = skewZX;
        array[9] = skewZY;
        array[10] = scaleZ;
        array[11] = translateZ;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value) {
        this.array[10] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y, z) {
        this.array[0] = x;
        this.array[5] = y;
        this.array[10] = z;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y, z) {
        this.array[1] = y;
        this.array[2] = z;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x, z) {
        this.array[4] = x;
        this.array[6] = z;
        return this;
    }
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x, y) {
        this.array[8] = x;
        this.array[9] = y;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[7] = value;
        return this;
    }
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value) {
        this.array[11] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y, z) {
        this.array[3] = x;
        this.array[7] = y;
        this.array[11] = z;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_03 = array[3];
        const e_10 = array[4];
        const e_11 = array[5];
        const e_12 = array[6];
        const e_13 = array[7];
        const e_20 = array[8];
        const e_21 = array[9];
        const e_22 = array[10];
        const e_23 = array[11];
        const c_00 = e_11 * e_22 - e_12 * e_21;
        const c_01 = e_12 * e_20 - e_10 * e_22;
        const c_02 = e_10 * e_21 - e_11 * e_20;
        const c_10 = e_02 * e_21 - e_01 * e_22;
        const c_11 = e_00 * e_22 - e_02 * e_20;
        const c_12 = e_01 * e_20 - e_00 * e_21;
        const c_20 = e_01 * e_12 - e_02 * e_11;
        const c_21 = e_02 * e_10 - e_00 * e_12;
        const c_22 = e_00 * e_11 - e_01 * e_10;
        const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
        if (det === 0) {
            throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
        }
        const i_00 = c_00 / det;
        const i_01 = c_10 / det;
        const i_02 = c_20 / det;
        const i_10 = c_01 / det;
        const i_11 = c_11 / det;
        const i_12 = c_21 / det;
        const i_20 = c_02 / det;
        const i_21 = c_12 / det;
        const i_22 = c_22 / det;
        const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
        const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
        const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
        return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform3D().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
        const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
        const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
        return Vec3Math.set(x, y, z, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y, z) {
        Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
        Transform3D.offsetOriginCache[1] = this;
        Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
        return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, z, originX, originY, originZ) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationX(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationY(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationZ(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
        const abs = Math.hypot(axisX, axisY, axisZ);
        const ux = axisX / abs;
        const uy = axisY / abs;
        const uz = axisZ / abs;
        const ux_uy = ux * uy;
        const ux_uz = ux * uz;
        const uy_uz = uy * uz;
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        const cosCompl = 1 - cos;
        this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, z, order = 'after') {
        if (order === 'before') {
            Transform3D.addCache[0].toTranslation(x, y, z);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            Transform3D.addCache[1].toTranslation(x, y, z);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
        let originX, originY, originZ, order;
        if (typeof arg4 === 'number') {
            originX = arg4;
            originY = arg5;
            originZ = arg6;
            order = arg7;
        }
        else {
            order = arg4;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationX(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationY(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
        let originX, originY, originZ, order;
        if (typeof arg5 === 'number') {
            originX = arg5;
            originY = arg6;
            originZ = arg7;
            order = arg8;
        }
        else {
            order = arg5;
        }
        if (order === 'before') {
            originX === undefined
                ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ)
                : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined
                ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ)
                : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform3D.concatCache[0];
        const newTransform = Transform3D.concatCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    newArray[j * 4 + i] =
                        oldArray[i] * nextArray[j * 4]
                            + oldArray[4 + i] * nextArray[j * 4 + 1]
                            + oldArray[8 + i] * nextArray[j * 4 + 2]
                            + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform3D.offsetOriginCache = [new Transform3D(), undefined, new Transform3D()];
Transform3D.addCache = [new Transform3D(), new Transform3D()];
Transform3D.concatCache = [new Transform3D(), new Transform3D()];

/**
 * A perspective transformation.
 */
class TransformPerspective {
    constructor() {
        this.cameraPos = Vec3Math.create();
        this.surfacePos = Vec3Math.create(0, 0, 1);
        this.cameraPosTransform = new Transform3D();
        this.cameraRotationTransform = new Transform3D();
        this.cameraRotationInverseTransform = new Transform3D();
        this.allCameraTransforms = [this.cameraPosTransform, this.cameraRotationInverseTransform];
        this.fullTransform = new Transform3D();
    }
    /**
     * Gets the position of this transformation's camera, as `[x, y, z]` in world coordinates.
     * @returns The position of this transformation's camera, as `[x, y, z]` in world coordinates.
     */
    getCameraPosition() {
        return this.cameraPos;
    }
    /**
     * Gets the transformation representing the rotation of this transformation's camera.
     * @returns The transformation representing the rotation of this transformation's camera.
     */
    getCameraRotation() {
        return this.cameraRotationTransform;
    }
    /**
     * Gets the position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns The position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     */
    getSurfacePosition() {
        return this.cameraPos;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        if (arg1 instanceof Float64Array) {
            this._setCameraPosition(arg1);
            this._setCameraRotation(arg2);
            this.setSurfacePosition(arg3);
            Transform3D.concat(this.fullTransform, this.allCameraTransforms);
            return this;
        }
        else {
            return this.set(arg1.getCameraPosition(), arg1.getCameraRotation(), arg1.getSurfacePosition());
        }
    }
    /**
     * Sets the position of this projection's camera. Does not update the full camera transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     */
    _setCameraPosition(cameraPos) {
        Vec3Math.copy(cameraPos, this.cameraPos);
        this.cameraPosTransform.toTranslation(-cameraPos[0], -cameraPos[1], -cameraPos[2]);
    }
    /**
     * Sets the rotation of this projection's camera. Does not update the full camera transformation.
     * @param cameraRotation A transformation representing the rotation of the camera.
     */
    _setCameraRotation(cameraRotation) {
        this.cameraRotationTransform.set(cameraRotation);
        this.cameraRotationInverseTransform.set(cameraRotation).invert();
    }
    /**
     * Sets the position of this projection's camera.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @returns This transformation, after it has been changed.
     */
    setCameraPosition(cameraPos) {
        this._setCameraPosition(cameraPos);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
    }
    /**
     * Sets the rotation of this projection's camera.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @returns This transformation, after it has been changed.
     */
    setCameraRotation(cameraRotation) {
        this._setCameraRotation(cameraRotation);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
    }
    /**
     * Sets the position of this transformation's projection surface relative to the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    setSurfacePosition(surfacePos) {
        Vec3Math.copy(surfacePos, this.surfacePos);
        return this;
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new TransformPerspective().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector, in world coordinates.
     * @param out The 2D vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const transformedVec = this.fullTransform.apply(vec, TransformPerspective.vec3Cache[0]);
        if (Vec3Math.abs(transformedVec) < 1e-7) {
            return Vec2Math.set(0, 0, out);
        }
        if (transformedVec[2] < 0) {
            // vector is behind the camera.
            return Vec2Math.set(NaN, NaN, out);
        }
        const ratio = this.surfacePos[2] / transformedVec[2];
        return Vec2Math.set(transformedVec[0] * ratio + this.surfacePos[0], transformedVec[1] * ratio + this.surfacePos[1], out);
    }
}
TransformPerspective.vec3Cache = [Vec3Math.create()];

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0]) && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1]);
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
class Vec3Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        let x, y, z;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
            z = arg3;
        }
        else {
            x = arg1[0];
            y = arg1[1];
            z = arg1[2];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(z, this.value[2]);
        if (!equals) {
            Vec3Math.set(x, y, z, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
class VecNSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static create(initialVal) {
        return new VecNSubject(initialVal);
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     * @deprecated Use `VecNSubject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new VecNSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
        let array;
        if (typeof arg1 === 'number') {
            array = args;
            args.unshift(arg1);
        }
        else {
            array = arg1;
        }
        if (array.length > this.value.length) {
            throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
        }
        let equals = true;
        const len = array.length;
        for (let i = 0; i < len; i++) {
            if (!SubscribableUtils.NUMERIC_NAN_EQUALITY(array[i], this.value[i])) {
                equals = false;
                break;
            }
        }
        if (!equals) {
            this.value.set(array);
            this.notify();
        }
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.antipode(out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /** @inheritdoc */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out) {
        return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    /** @inheritdoc */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        if (other) {
            if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
                return true;
            }
            const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
            const distance = this.distance(other);
            return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
        if (arg1 instanceof Float64Array) {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else if (typeof arg1 === 'number') {
            return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
        if (arg1 instanceof Float64Array) {
            return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
        }
        else {
            let lat1, lon1, lat2, lon2;
            if (typeof arg1 === 'number') {
                lat1 = arg1;
                lon1 = arg2;
                lat2 = arg3;
                lon2 = arg4;
            }
            else {
                lat1 = arg1.lat;
                lon1 = arg1.lon;
                lat2 = arg2.lat;
                lon2 = arg2.lon;
            }
            lat1 *= Avionics.Utils.DEG2RAD;
            lon1 *= Avionics.Utils.DEG2RAD;
            lat2 *= Avionics.Utils.DEG2RAD;
            lon2 *= Avionics.Utils.DEG2RAD;
            // haversine formula
            const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
            const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
            const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === 'number') {
            lat1 = arg1 * Avionics.Utils.DEG2RAD;
            lon1 = arg2 * Avionics.Utils.DEG2RAD;
            lat2 = arg3 * Avionics.Utils.DEG2RAD;
            lon2 = arg4 * Avionics.Utils.DEG2RAD;
        }
        else if (arg1 instanceof Float64Array) {
            const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
            lat1 = point1.lat;
            lon1 = point1.lon;
            const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
            lat2 = point2.lat;
            lon2 = point2.lon;
        }
        else {
            lat1 = arg1.lat;
            lon1 = arg1.lon;
            lat2 = arg2.lat;
            lon2 = arg2.lon;
        }
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
        return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this._sinRadius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return this._sinRadius * angle;
    }
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length) {
        return length / this._sinRadius;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        this._sinRadius = Math.sin(this._radius);
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
        Vec3Math.multScalar(this._center, -1, this._center);
        this._radius = Math.PI - this._radius;
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
        return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading) {
        return NavMath.normalizeHeading(heading + 180);
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="@microsoft/msfs-types/coherent/facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
class GeoPointSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    constructor(value, tolerance) {
        super();
        this.value = value;
        this.tolerance = tolerance;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal, tolerance) {
        return new GeoPointSubject(initialVal, tolerance);
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
}

/**
 * A publisher for AHRS information.
 */
class AhrsPublisher extends SimVarPublisher {
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['pitch_deg', { name: 'ATTITUDE INDICATOR PITCH DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['roll_deg', { name: 'ATTITUDE INDICATOR BANK DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg_true', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, map: (heading) => MagVar.magneticToTrue(heading, this.magVar), indexed: true }],
            ['delta_heading_rate', { name: 'DELTA HEADING RATE:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
            ['actual_hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
            ['actual_hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
            ['actual_pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
            ['actual_roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
        ]);
        super(simvars, bus, pacer);
        this.magVar = 0;
        (_a = this.needUpdateMagVar) !== null && _a !== void 0 ? _a : (this.needUpdateMagVar = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('hdg_deg_true')) {
            this.needUpdateMagVar = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needUpdateMagVar) {
            this.magVar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        }
        super.onUpdate();
    }
}

/**
 * Ambient precipitation states.
 */
var AmbientPrecipState;
(function (AmbientPrecipState) {
    AmbientPrecipState[AmbientPrecipState["None"] = 2] = "None";
    AmbientPrecipState[AmbientPrecipState["Rain"] = 4] = "Rain";
    AmbientPrecipState[AmbientPrecipState["Snow"] = 8] = "Snow";
})(AmbientPrecipState || (AmbientPrecipState = {}));
/**
 * A publisher for ambient environment information.
 */
class AmbientPublisher extends SimVarPublisher {
    /**
     * Creates an AmbientPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['ambient_precip_state', { name: 'AMBIENT PRECIP STATE', type: SimVarValueType.Number }],
            ['ambient_precip_rate', { name: 'AMBIENT PRECIP RATE', type: SimVarValueType.MillimetersWater }],
            ['ambient_visibility', { name: 'AMBIENT VISIBILITY', type: SimVarValueType.Meters }],
            ['ambient_in_cloud', { name: 'AMBIENT IN CLOUD', type: SimVarValueType.Bool }],
            ['ambient_qnh_inhg', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.InHG }],
            ['ambient_qnh_mb', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.MB }],
        ]);
        super(simvars, bus, pacer);
    }
}

/**
 * A basic implementation of {@link Consumer}.
 */
class BasicConsumer {
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe, state = {}, currentHandler) {
        this.subscribe = subscribe;
        this.state = state;
        this.currentHandler = currentHandler;
        /** @inheritdoc */
        this.isConsumer = true;
        this.activeSubs = new Map();
    }
    /** @inheritdoc */
    handle(handler, paused = false) {
        let activeHandler;
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            activeHandler = (data) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentHandler(data, this.state, handler);
            };
        }
        else {
            activeHandler = handler;
        }
        let activeSubArray = this.activeSubs.get(handler);
        if (!activeSubArray) {
            activeSubArray = [];
            this.activeSubs.set(handler, activeSubArray);
        }
        const onDestroyed = (destroyed) => {
            const activeSubsArray = this.activeSubs.get(handler);
            if (activeSubsArray) {
                activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
                if (activeSubsArray.length === 0) {
                    this.activeSubs.delete(handler);
                }
            }
        };
        const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
        // Need to handle the case where the subscription is destroyed immediately
        if (sub.isAlive) {
            activeSubArray.push(sub);
        }
        else if (activeSubArray.length === 0) {
            this.activeSubs.delete(handler);
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        var _a;
        const activeSubArray = this.activeSubs.get(handler);
        if (activeSubArray) {
            (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
            if (activeSubArray.length === 0) {
                this.activeSubs.delete(handler);
            }
        }
    }
    /** @inheritdoc */
    atFrequency(frequency, immediateFirstPublish = true) {
        const initialState = {
            previousTime: Date.now(),
            firstRun: immediateFirstPublish
        };
        return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime || state.firstRun) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                if (state.firstRun) {
                    state.firstRun = false;
                }
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    withPrecision(precision) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
        return (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
                state.hasLastValue = true;
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        };
    }
    /** @inheritdoc */
    whenChangedBy(amount) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
        return (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (!state.hasLastValue || diff >= amount) {
                state.hasLastValue = true;
                state.lastValue = dataValue;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    whenChanged() {
        return new BasicConsumer(this.subscribe, { lastValue: '', hasLastValue: false }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
        return (data, state, next) => {
            if (!state.hasLastValue || state.lastValue !== data) {
                state.hasLastValue = true;
                state.lastValue = data;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    onlyAfter(deltaTime) {
        return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
        return (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}
/**
 * A {@link Subscription} for a {@link BasicConsumer}.
 */
class ConsumerSubscription {
    /**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
        this.sub = sub;
        this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
        return this.sub.canInitialNotify;
    }
    /** @inheritdoc */
    pause() {
        this.sub.pause();
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        this.sub.resume(initialNotify);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this.sub.destroy();
        this.onDestroy(this);
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new BasicConsumer((handler, paused) => {
            return this.bus.on(topic, handler, paused);
        });
    }
}

var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_yd_status', { name: 'AUTOPILOT YAW DAMPER', type: SimVarValueType.Bool }],
    ['ap_disengage_status', { name: 'AUTOPILOT DISENGAGED', type: SimVarValueType.Bool }],
    ['ap_heading_hold', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_hold', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_max_bank_id', { name: 'AUTOPILOT MAX BANK ID', type: SimVarValueType.Number }],
    ['ap_max_bank_value', { name: 'AUTOPILOT MAX BANK', type: SimVarValueType.Degree }],
    ['ap_wing_lvl_hold', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_hold', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['ap_toga_hold', { name: 'AUTOPILOT TAKEOFF POWER ACTIVE', type: SimVarValueType.Bool }],
    ['ap_heading_selected', { name: 'AUTOPILOT HEADING LOCK DIR:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_altitude_selected', { name: 'AUTOPILOT ALTITUDE LOCK VAR:#index#', type: SimVarValueType.Feet, indexed: true }],
    ['ap_pitch_selected', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['ap_vs_selected', { name: 'AUTOPILOT VERTICAL HOLD VAR:#index#', type: SimVarValueType.FPM, indexed: true }],
    ['ap_fpa_selected', { name: 'L:WT_AP_FPA_Target:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_ias_selected', { name: 'AUTOPILOT AIRSPEED HOLD VAR:#index#', type: SimVarValueType.Knots, indexed: true }],
    ['ap_mach_selected', { name: 'AUTOPILOT MACH HOLD VAR:#index#', type: SimVarValueType.Number, indexed: true }],
    ['ap_selected_speed_is_mach', { name: 'AUTOPILOT MANAGED SPEED IN MACH', type: SimVarValueType.Bool }],
    ['ap_selected_speed_is_manual', { name: 'L:XMLVAR_SpeedIsManuallySet', type: SimVarValueType.Bool }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_is_active_1', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:1', type: SimVarValueType.Bool }],
    ['flight_director_is_active_2', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:2', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_on', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_off', true);
    }
    /**
     * Publish a YD engage event
     */
    publishYdEngage() {
        this.publish('ap_yd_on', true);
    }
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage() {
        this.publish('ap_yd_off', true);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        // console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('ap_yd_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishYdEngage();
            }
            else {
                this.publisher.publishYdDisengage();
            }
        });
        this.simVarSubscriber.on('ap_alt_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/**
 * Utility functions for working with arrays.
 */
class ArrayUtils {
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create(length, init) {
        const newArray = [];
        for (let i = 0; i < length; i++) {
            newArray[i] = init(i);
        }
        return newArray;
    }
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at(array, index) {
        if (index < 0) {
            index += array.length;
        }
        if (index < 0 || index >= array.length) {
            throw new RangeError();
        }
        return array[index];
    }
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt(array, index) {
        if (index < 0) {
            index += array.length;
        }
        return array[index];
    }
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[0];
    }
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst(array) {
        return array[0];
    }
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[array.length - 1];
    }
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast(array) {
        return array[array.length - 1];
    }
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes(array, searchElement, fromIndex) {
        return array.includes(searchElement, fromIndex);
    }
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!equalsFunc(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap(array, map) {
        const out = [];
        for (let i = 0; i < array.length; i++) {
            const mapped = map(array[i], i, array);
            if (Array.isArray(mapped)) {
                for (let j = 0; j < mapped.length; j++) {
                    out[out.length] = mapped[j];
                }
            }
            else {
                out[out.length] = mapped;
            }
        }
        return out;
    }
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat(array, depth = 1) {
        const out = [];
        this.flatHelper(array, depth, 0, out);
        return out;
    }
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    static flatHelper(array, maxDepth, depth, out) {
        for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (Array.isArray(element) && depth < maxDepth) {
                this.flatHelper(element, maxDepth, depth + 1, out);
            }
            else {
                out[out.length] = element;
            }
        }
    }
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy(source, target = []) {
        target.length = source.length;
        for (let i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    }
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch(array, element, comparator, first = true) {
        let min = 0;
        let max = array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = comparator(element, array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array) {
        return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
}
ArrayUtils.STRICT_EQUALS = (a, b) => a === b;

/** A collection of helper functions dealing with radios and frequencies. */
class RadioUtils {
    /**
     * Checks whether a frequency is a NAV frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a NAV frequency.
     */
    static isNavFrequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 108e3 || freqKhz > 117950) {
            return false;
        }
        return freqKhz % 50 === 0;
    }
    /**
     * Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check, in megahertz.
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd.
     */
    static isLocalizerFrequency(freq) {
        return freq >= 108.1 && freq <= 111.95 && (Math.trunc(freq * 10) % 2 === 1);
    }
    /**
     * Checks whether a frequency is a 8.33 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 8.33 kHz-spacing COM frequency.
     */
    static isCom833Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136990) {
            return false;
        }
        return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    /**
     * Checks whether a frequency is a 25 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 25 kHz-spacing COM frequency.
     */
    static isCom25Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136975) {
            return false;
        }
        return freqKhz % 25 === 0;
    }
    /**
     * Checks whether a frequency is an ADF frequency.
     * @param freq The frequency to check, in kilohertz.
     * @returns Whether the specified frequency is an ADF frequency.
     */
    static isAdfFrequency(freq) {
        const freqHz = Math.round(freq * 1000);
        if (freqHz < 190e3 || freqHz > 1799500) {
            return false;
        }
        return freqHz % 500 === 0;
    }
}
RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];

/**
 * VOR signal to/from flags.
 */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));
/**
 * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
 */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of NavComSimVarPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ...NavComSimVarPublisher.createNavRadioDefinitions(),
            ...NavComSimVarPublisher.createComRadioDefinitions(),
            ...NavComSimVarPublisher.createAdfRadioDefinitions(),
            ...NavComSimVarPublisher.createMarkerBeaconDefinitions(),
            ...NavComSimVarPublisher.createGpsDefinitions()
        ]);
        super(simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions.
     * @returns An array of nav radio sim var event definitions.
     */
    static createNavRadioDefinitions() {
        return [
            ['nav_active_frequency', { name: 'NAV ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_standby_frequency', { name: 'NAV STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_signal', { name: 'NAV SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_sound', { name: 'NAV SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_ident', { name: 'NAV IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_volume', { name: 'NAV VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_obs', { name: 'NAV OBS:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_dme', { name: 'NAV HAS DME:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_nav', { name: 'NAV HAS NAV:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_cdi', { name: 'NAV CDI:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme', { name: 'NAV DME:#index#', type: SimVarValueType.NM, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial', { name: 'NAV RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial_error', { name: 'NAV RADIAL ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_to_from', { name: 'NAV TOFROM:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer', { name: 'NAV HAS LOCALIZER:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer_crs', { name: 'NAV LOCALIZER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_airport_ident', { name: 'NAV LOC AIRPORT IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_designator', { name: 'NAV LOC RUNWAY DESIGNATOR:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_number', { name: 'NAV LOC RUNWAY NUMBER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_glideslope', { name: 'NAV HAS GLIDE SLOPE:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_error', { name: 'NAV GLIDE SLOPE ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_raw_gs', { name: 'NAV RAW GLIDE SLOPE:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_lla', { name: 'NAV VOR LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme_lla', { name: 'NAV DME LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_lla', { name: 'NAV GS LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_magvar', { name: 'NAV MAGVAR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of com radio sim var event definitions.
     * @returns An array of com radio sim var event definitions.
     */
    static createComRadioDefinitions() {
        return [
            ['com_active_frequency', { name: 'COM ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_standby_frequency', { name: 'COM STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_name', { name: 'COM ACTIVE FREQ NAME:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_type', { name: 'COM ACTIVE FREQ TYPE:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_ident', { name: 'COM ACTIVE FREQ IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            // Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
            // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
            ['com_receive', { name: 'COM RECEIVE EX1:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_status', { name: 'COM STATUS:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_transmit', { name: 'COM TRANSMIT:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_spacing_mode', { name: 'COM SPACING MODE:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_volume', { name: 'COM VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3], defaultIndex: null }],
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions.
     * @returns An array of ADF radio sim var event definitions.
     */
    static createAdfRadioDefinitions() {
        return [
            ['adf_active_frequency', { name: 'ADF ACTIVE FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_standby_frequency', { name: 'ADF STANDBY FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_sound', { name: 'ADF SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['adf_volume', { name: 'ADF VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2], defaultIndex: null }],
            ['adf_ident', { name: 'ADF IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2], defaultIndex: null }],
            ['adf_signal', { name: 'ADF SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['adf_bearing', { name: 'ADF RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2], defaultIndex: null }],
            ['adf_lla', { name: 'ADF LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createMarkerBeaconDefinitions() {
        return [
            ['marker_beacon_hisense_on', { name: 'MARKER BEACON SENSITIVITY HIGH', type: SimVarValueType.Bool }],
            ['marker_beacon_sound', { name: 'MARKER SOUND', type: SimVarValueType.Bool }],
            ['marker_beacon_state', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
            ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createGpsDefinitions() {
        return [
            ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
            ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
            ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
            ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
            ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
            ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
            ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
        ];
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
 *
 * @deprecated Please use `NavComSimVarPublisher` instead.
 */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
        return [
            [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
            [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
            [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
            [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
            [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
            [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`nav_radial_error_${index}`, { name: `NAV RADIAL ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
            [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
            [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
            [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
            [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
            [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
        return [
            [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
        ];
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));

/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 *
 * Requires that the topics defined in {@link NavComEvents} are published to the event bus.
 */
class APRadioNavInstrument {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.navRadioData = ArrayUtils.create(5, index => {
            index = Math.max(1, index);
            return {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index, type: NavSourceType.Nav }),
                radialError: 0,
                magVar: 0
            };
        });
        this.currentCdiIndex = 1;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
        const navComSubscriber = this.bus.getSubscriber();
        for (let i = 1; i < 5; i++) {
            navComSubscriber.on(`nav_glideslope_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_gs_lla_${i}`).handle(this.setGlideslopePosition.bind(this, i));
            navComSubscriber.on(`nav_gs_error_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_raw_gs_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'gsAngle'));
            navComSubscriber.on(`nav_localizer_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_localizer_crs_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'course'));
            navComSubscriber.on(`nav_cdi_${i}`).whenChanged().handle(this.setCDIValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_has_nav_${i}`).whenChanged().handle(hasNav => !hasNav && this.setCDIValue(i, 'deviation', null));
            navComSubscriber.on(`nav_obs_${i}`).whenChanged().handle(this.setOBSValue.bind(this, i, 'heading'));
            navComSubscriber.on(`nav_lla_${i}`).handle(this.setNavPosition.bind(this, i));
            navComSubscriber.on(`nav_radial_error_${i}`).whenChanged().handle(this.setRadialError.bind(this, i));
            navComSubscriber.on(`nav_magvar_${i}`).whenChanged().handle(this.setMagVar.bind(this, i));
        }
        const navEvents = this.bus.getSubscriber();
        navEvents.on('cdi_select').handle(source => {
            const oldIndex = this.currentCdiIndex;
            this.currentCdiIndex = source.type === NavSourceType.Nav ? source.index : 0;
            if (oldIndex !== this.currentCdiIndex) {
                const data = this.navRadioData[this.currentCdiIndex];
                this.publisher.pub('nav_radio_active_gs_location', data.gsLocation);
                this.publisher.pub('nav_radio_active_nav_location', data.navLocation);
                this.publisher.pub('nav_radio_active_glideslope', data.glideslope);
                this.publisher.pub('nav_radio_active_localizer', data.localizer);
                this.publisher.pub('nav_radio_active_cdi_deviation', data.cdi);
                this.publisher.pub('nav_radio_active_obs_setting', data.obs);
                this.publisher.pub('nav_radio_active_radial_error', data.radialError);
                this.publisher.pub('nav_radio_active_magvar', data.magVar);
            }
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
        this.navRadioData[index].glideslope[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_glideslope', this.navRadioData[index].glideslope);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_glideslope_1', this.navRadioData[index].glideslope);
                break;
            case 2:
                this.publisher.pub('nav_radio_glideslope_2', this.navRadioData[index].glideslope);
                break;
            case 3:
                this.publisher.pub('nav_radio_glideslope_3', this.navRadioData[index].glideslope);
                break;
            case 4:
                this.publisher.pub('nav_radio_glideslope_4', this.navRadioData[index].glideslope);
                break;
        }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setGlideslopePosition(index, lla) {
        this.navRadioData[index].gsLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_gs_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_gs_location_1', this.navRadioData[index].gsLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_gs_location_2', this.navRadioData[index].gsLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_gs_location_3', this.navRadioData[index].gsLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_gs_location_4', this.navRadioData[index].gsLocation);
                break;
        }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setNavPosition(index, lla) {
        this.navRadioData[index].navLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_nav_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_nav_location_1', this.navRadioData[index].navLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_nav_location_2', this.navRadioData[index].navLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_nav_location_3', this.navRadioData[index].navLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_nav_location_4', this.navRadioData[index].navLocation);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
        this.navRadioData[index].localizer[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_localizer', this.navRadioData[index].localizer);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_localizer_1', this.navRadioData[index].localizer);
                break;
            case 2:
                this.publisher.pub('nav_radio_localizer_2', this.navRadioData[index].localizer);
                break;
            case 3:
                this.publisher.pub('nav_radio_localizer_3', this.navRadioData[index].localizer);
                break;
            case 4:
                this.publisher.pub('nav_radio_localizer_4', this.navRadioData[index].localizer);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
        this.navRadioData[index].cdi[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_cdi_deviation', this.navRadioData[index].cdi);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_cdi_1', this.navRadioData[index].cdi);
                break;
            case 2:
                this.publisher.pub('nav_radio_cdi_2', this.navRadioData[index].cdi);
                break;
            case 3:
                this.publisher.pub('nav_radio_cdi_3', this.navRadioData[index].cdi);
                break;
            case 4:
                this.publisher.pub('nav_radio_cdi_4', this.navRadioData[index].cdi);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
        this.navRadioData[index].obs[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_obs_setting', this.navRadioData[index].obs);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_obs_1', this.navRadioData[index].obs);
                break;
            case 2:
                this.publisher.pub('nav_radio_obs_2', this.navRadioData[index].obs);
                break;
            case 3:
                this.publisher.pub('nav_radio_obs_3', this.navRadioData[index].obs);
                break;
            case 4:
                this.publisher.pub('nav_radio_obs_4', this.navRadioData[index].obs);
                break;
        }
    }
    /**
     * Sets the radial error of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param radialError The radial error to set.
     */
    setRadialError(index, radialError) {
        this.navRadioData[index].radialError = radialError;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_radial_error', radialError);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_radial_error_1', this.navRadioData[index].radialError);
                break;
            case 2:
                this.publisher.pub('nav_radio_radial_error_2', this.navRadioData[index].radialError);
                break;
            case 3:
                this.publisher.pub('nav_radio_radial_error_3', this.navRadioData[index].radialError);
                break;
            case 4:
                this.publisher.pub('nav_radio_radial_error_4', this.navRadioData[index].radialError);
                break;
        }
    }
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    setMagVar(index, magVar) {
        magVar = NavMath.normalizeHeading(-magVar + 180) % 360 - 180;
        this.navRadioData[index].magVar = magVar;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_magvar', magVar);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_magvar_1', this.navRadioData[index].magVar);
                break;
            case 2:
                this.publisher.pub('nav_radio_magvar_2', this.navRadioData[index].magVar);
                break;
            case 3:
                this.publisher.pub('nav_radio_magvar_3', this.navRadioData[index].magVar);
                break;
            case 4:
                this.publisher.pub('nav_radio_magvar_4', this.navRadioData[index].magVar);
                break;
        }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
        return {
            isValid: false,
            course: 0,
            source: id
        };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
        return {
            isValid: false,
            gsAngle: 0,
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
        return {
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
        return {
            heading: 0,
            source: id
        };
    }
}

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name, publisher, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, publisher, this.publishers)) {
            this.publishers.set(name, publisher);
        }
    }
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name, instrument, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, instrument, this.instruments)) {
            this.instruments.set(name, instrument);
        }
    }
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher(name) {
        return this.publishers.get(name);
    }
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument(name) {
        return this.instruments.get(name);
    }
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    static checkAlreadyExists(name, objToCheck, map) {
        if (map.has(name)) {
            console.warn(`${name} already exists in backplane.`);
            return true;
        }
        // check if there already is a publisher with the same type
        for (const p of map.values()) {
            if (p.constructor === objToCheck.constructor) {
                console.warn(`${name} already exists in backplane.`);
                return true;
            }
        }
        return false;
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Brake information.
 */
class BrakeSimvarPublisher extends SimVarPublisher {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['brake_position_left', { name: 'BRAKE LEFT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_right', { name: 'BRAKE RIGHT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_left_raw', { name: 'BRAKE LEFT POSITION EX1', type: SimVarValueType.Percent }],
            ['brake_position_right_raw', { name: 'BRAKE RIGHT POSITION EX1', type: SimVarValueType.Percent }],
            ['left_wheel_rpm', { name: 'LEFT WHEEL RPM', type: SimVarValueType.RPM }],
            ['right_wheel_rpm', { name: 'RIGHT WHEEL RPM', type: SimVarValueType.RPM }],
            ['parking_brake_set', { name: 'BRAKE PARKING POSITION', type: SimVarValueType.Bool }],
            ['autobrake_switch_pos', { name: 'AUTO BRAKE SWITCH CB', type: SimVarValueType.Number }],
            ['autobrake_active', { name: 'AUTOBRAKES ACTIVE', type: SimVarValueType.Bool }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    /**
     * Creates a new instance of ClockPublisher.
     * @param bus The event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
        this.needPublishRealTime = false;
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['simTime', { name: 'E:ABSOLUTE TIME', type: SimVarValueType.Seconds, map: ClockPublisher.absoluteTimeToUNIXTime }],
            ['simRate', { name: 'E:SIMULATION RATE', type: SimVarValueType.Number }]
        ]), bus, pacer);
        if (this.bus.getTopicSubscriberCount('realTime') > 0) {
            this.needPublishRealTime = true;
        }
        else {
            const sub = this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
                if (topic === 'realTime') {
                    this.needPublishRealTime = true;
                    sub.destroy();
                }
            }, true);
            sub.resume();
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
        if (this.hiFreqInterval === undefined) {
            this.hiFreqInterval = setInterval(() => this.publish('simTimeHiFreq', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds'))), 0);
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
        if (this.hiFreqInterval !== undefined) {
            clearInterval(this.hiFreqInterval);
            this.hiFreqInterval = undefined;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needPublishRealTime) {
            this.publish('realTime', Date.now());
        }
        this.simVarPublisher.onUpdate();
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/**
 * A publisher for control surfaces information.
 */
class ControlSurfacesPublisher extends SimVarPublisher {
    /**
     * Create an ControlSurfacesPublisher.
     * @param bus The EventBus to publish to.
     * @param gearCount The number of landing gear to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, gearCount, pacer) {
        const nonIndexedSimVars = [
            ['flaps_handle_index', { name: 'FLAPS HANDLE INDEX', type: SimVarValueType.Number }],
            ['flaps_left_angle', { name: 'TRAILING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_right_angle', { name: 'TRAILING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_left_percent', { name: 'TRAILING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['flaps_right_percent', { name: 'TRAILING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['slats_left_angle', { name: 'LEADING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['slats_right_angle', { name: 'LEADING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['slats_left_percent', { name: 'LEADING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['slats_right_percent', { name: 'LEADING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['spoilers_left_percent', { name: 'SPOILERS LEFT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_right_percent', { name: 'SPOILERS RIGHT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_without_spoilerons_left_percent', { name: 'SPOILERS WITHOUT SPOILERONS LEFT POSITION', type: SimVarValueType.Percent }],
            ['elevator_trim_angle', { name: 'ELEVATOR TRIM POSITION', type: SimVarValueType.Degree }],
            ['elevator_trim_pct', { name: 'ELEVATOR TRIM PCT', type: SimVarValueType.Percent }],
            ['elevator_trim_neutral_pct', { name: 'AIRCRAFT ELEVATOR TRIM NEUTRAL', type: SimVarValueType.Percent }],
            ['aileron_trim_angle', { name: 'AILERON TRIM', type: SimVarValueType.Degree }],
            ['aileron_trim_pct', { name: 'AILERON TRIM PCT', type: SimVarValueType.Percent }],
            ['rudder_trim_angle', { name: 'RUDDER TRIM', type: SimVarValueType.Degree }],
            ['rudder_trim_pct', { name: 'RUDDER TRIM PCT', type: SimVarValueType.Percent }],
            ['aileron_left_percent', { name: 'AILERON LEFT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['aileron_right_percent', { name: 'AILERON RIGHT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['elevator_percent', { name: 'ELEVATOR DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['rudder_percent', { name: 'RUDDER DEFLECTION PCT', type: SimVarValueType.Percent }]
        ];
        const gearIndexedSimVars = [
            ['gear_position', { name: 'GEAR POSITION', type: SimVarValueType.Number }],
            ['gear_is_on_ground', { name: 'GEAR IS ON GROUND', type: SimVarValueType.Bool }]
        ];
        const simvars = new Map(nonIndexedSimVars);
        // set un-indexed simvar topics to pull from index 0
        for (const [topic, simvar] of [...gearIndexedSimVars]) {
            simvars.set(`${topic}`, {
                name: `${simvar.name}:0`,
                type: simvar.type,
                map: simvar.map
            });
        }
        // add landing gear indexed simvar topics
        // HINT: for some reason index 0 is nose. not 1-based.
        gearCount = Math.max(gearCount, 1);
        for (let i = 0; i < gearCount; i++) {
            for (const [topic, simvar] of gearIndexedSimVars) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync = false, shouldResync = true) {
        this._topicSubsMap = new Map();
        this._wildcardSubs = new Array();
        this._notifyDepthMap = new Map();
        this._wildcardNotifyDepth = 0;
        this._eventCache = new Map();
        this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
        this._busId = Math.floor(Math.random() * 2147483647);
        // fallback to flowevent when genericdatalistener not avail (su9)
        useAlternativeEventSync = (typeof RegisterGenericDataListener === 'undefined');
        const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        if (shouldResync === true) {
            this.syncEvent('event_bus', 'resync_request', false);
            this.on('event_bus', (data) => {
                if (data == 'resync_request') {
                    this.resyncEvents();
                }
            });
        }
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
        let subs = this._topicSubsMap.get(topic);
        if (subs === undefined) {
            this._topicSubsMap.set(topic, subs = []);
            this.pub('event_bus_topic_first_sub', topic, false, false);
        }
        const initialNotifyFunc = (sub) => {
            const lastState = this._eventCache.get(topic);
            if (lastState !== undefined) {
                sub.handler(lastState.data);
            }
        };
        const onDestroyFunc = (sub) => {
            var _a;
            // If we are not in the middle of a notify operation, remove the subscription.
            // Otherwise, do nothing and let the post-notify clean-up code handle it.
            if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
                const subsToSplice = this._topicSubsMap.get(topic);
                if (subsToSplice) {
                    subsToSplice.splice(subsToSplice.indexOf(sub), 1);
                }
            }
        };
        const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
        subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
        const handlers = this._topicSubsMap.get(topic);
        const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
        const sub = new HandlerSubscription(handler, undefined, this.onWildcardSubDestroyedFunc);
        this._wildcardSubs.push(sub);
        return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
        const toDestroy = this._wildcardSubs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        var _a;
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const subs = this._topicSubsMap.get(topic);
        if (subs !== undefined) {
            let needCleanUpSubs = false;
            const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
            this._notifyDepthMap.set(topic, notifyDepth + 1);
            const len = subs.length;
            for (let i = 0; i < len; i++) {
                try {
                    const sub = subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(data);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            this._notifyDepthMap.set(topic, notifyDepth);
            if (needCleanUpSubs && notifyDepth === 0) {
                const filteredSubs = subs.filter(sub => sub.isAlive);
                this._topicSubsMap.set(topic, filteredSubs);
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        let needCleanUpSubs = false;
        this._wildcardNotifyDepth++;
        const wcLen = this._wildcardSubs.length;
        for (let i = 0; i < wcLen; i++) {
            const sub = this._wildcardSubs[i];
            if (sub.isAlive && !sub.isPaused) {
                sub.handler(topic, data);
            }
            needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        }
        this._wildcardNotifyDepth--;
        if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
            this._wildcardSubs = this._wildcardSubs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this._wildcardNotifyDepth === 0) {
            this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic) {
        var _a, _b;
        return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn) {
        this._topicSubsMap.forEach((subs, topic) => { subs.length > 0 && fn(topic, subs.length); });
    }
}
/**
 * An abstract class for bus sync implementations.
 */
class EventBusSyncBase {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
        this.isPaused = false;
        this.lastEventSynced = -1;
        this.dataPackageQueue = [];
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.hookReceiveEvent();
        /** Sends the queued up data packages */
        const sendFn = () => {
            if (!this.isPaused && this.dataPackageQueue.length > 0) {
                // console.log(`Sending ${this.dataPackageQueue.length} packages`);
                const syncDataPackage = {
                    busId: this.busId,
                    packagedId: Math.floor(Math.random() * 1000000000),
                    data: this.dataPackageQueue
                };
                if (this.executeSync(syncDataPackage)) {
                    this.dataPackageQueue.length = 0;
                }
                else {
                    console.warn('Failed to send sync data package');
                }
            }
            requestAnimationFrame(sendFn);
        };
        requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
        if (this.busId !== syncData.busId) {
            // HINT: coherent events are still received twice, so check for this
            if (this.lastEventSynced !== syncData.packagedId) {
                this.lastEventSynced = syncData.packagedId;
                syncData.data.forEach((data) => {
                    try {
                        this.recvEventCb(data.topic, data.data !== undefined ? data.data : undefined, false, data.isCached);
                    }
                    catch (e) {
                        console.error(e);
                        if (e instanceof Error) {
                            console.error(e.stack);
                        }
                    }
                });
            }
        }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // stringify data
        const dataObj = data;
        // build a data package
        const dataPackage = {
            topic: topic,
            data: dataObj,
            isCached: isCached
        };
        // queue data package
        this.dataPackageQueue.push(dataPackage);
    }
}
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 * DON'T USE this, it has bad performance implications.
 * @deprecated
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class EventBusCoherentSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // HINT: Stringifying the data again to circumvent the bad perf on Coherent interop
        try {
            this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, undefined, true);
        this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
            try {
                const evt = JSON.parse(e);
                this.processEventsReceived(evt);
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusFlowEventSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // console.log('Sending sync package: ' + syncDataPackage.packagedId);
        try {
            LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        Coherent.on('OnInteractionEvent', (target, args) => {
            // identify if its a busevent
            if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
                return;
            }
            this.processEventsReceived(JSON.parse(args[2]));
        });
    }
}
EventBusFlowEventSync.EB_LISTENER_KEY = 'EB_EVENTS';
//// END GLOBALS DECLARATION
/**
 * A class that manages event bus synchronization via the Generic Data Listener.
 */
class EventBusListenerSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        try {
            this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        // pause the sync until the listener is ready
        this.isPaused = true;
        this.listener = RegisterGenericDataListener(() => {
            this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
                try {
                    this.processEventsReceived(data);
                }
                catch (error) {
                    console.error(error);
                }
            });
            this.isPaused = false;
        });
    }
}
EventBusListenerSync.EB_KEY = 'wt.eb.evt';
EventBusListenerSync.EB_LISTENER_KEY = 'JS_LISTENER_GENERICDATA';

/**
 * Captures the state of a value from a consumer.
 */
class ConsumerValue {
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    constructor(consumer, initialValue) {
        this.consumerHandler = (v) => { this.value = v; };
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialValue;
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Gets the current value.
     * @returns The current value.
     */
    get() {
        return this.value;
    }
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     * @returns This object, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        this.isDestroyed = true;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create(consumer, initialValue) {
        return new ConsumerValue(consumer, initialValue);
    }
}

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        // console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync, false);
    }
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
class ConsumerSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
        super();
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.consumerHandler = this.onEventConsumed.bind(this);
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialVal;
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
        return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
        if (!this.equalityFunc(this.value, value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isDestroyed = true;
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** The kind of data to return. */
var CompositeLogicXMLValueType;
(function (CompositeLogicXMLValueType) {
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Any"] = 0] = "Any";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Number"] = 1] = "Number";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["String"] = 2] = "String";
})(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
/**
 *
 */
class CompositeLogicXMLHost {
    /**
     * Ctor
     * @param startPaused True to start paused.
     */
    constructor(startPaused = false) {
        this.anyHandlers = new Array();
        this.stringHandlers = new Array();
        this.numberHandlers = new Array();
        this.anyResultCache = new Array();
        this.stringResultCache = new Array();
        this.numberResultCache = new Array();
        this.context = new LogicXMLContext();
        this.isPaused = false;
        this.isPaused = startPaused;
    }
    /**
     * Set to pause the logic update loop.
     * @param isPaused True to pause, false to resume.
     */
    setIsPaused(isPaused) {
        this.isPaused = isPaused;
    }
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic, handler) {
        this.anyHandlers.push({ logic: logic, handler: handler });
        return logic.getValue(this.context);
    }
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @param smoothFactor An optional linear smoothing factor to apply to the value when updating.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic, handler, precision, smoothFactor) {
        this.numberHandlers.push({ logic: logic, handler: handler, precision: precision, smoothFactor: smoothFactor });
        return logic.getValueAsNumber(this.context);
    }
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic, handler) {
        this.stringHandlers.push({ logic: logic, handler: handler });
        return logic.getValueAsString(this.context);
    }
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec) {
        const func = new LogicXMLFunction();
        func.name = funcSpec.name;
        func.callback = funcSpec.logic;
        this.context.addFunction(func);
        return funcSpec.logic.getValue(this.context);
    }
    /**
     * Update every logic element and publish updates.
     * @param deltaTime The time since the last update, in ms.
     */
    update(deltaTime) {
        if (!this.isPaused) {
            for (let i = 0; i < this.anyHandlers.length; i++) {
                const newVal = this.anyHandlers[i].logic.getValue(this.context);
                if (newVal !== this.anyResultCache[i]) {
                    this.anyResultCache[i] = newVal;
                    this.anyHandlers[i].handler(newVal);
                }
            }
            for (let i = 0; i < this.stringHandlers.length; i++) {
                const newVal = this.stringHandlers[i].logic.getValueAsString(this.context);
                if (newVal !== this.stringResultCache[i]) {
                    this.stringResultCache[i] = newVal;
                    this.stringHandlers[i].handler(newVal);
                }
            }
            for (let i = 0; i < this.numberHandlers.length; i++) {
                let newVal = this.numberHandlers[i].logic.getValueAsNumber(this.context);
                let precision = this.numberHandlers[i].precision;
                if (precision !== undefined) {
                    precision = Math.pow(10, precision);
                    newVal = Math.round(newVal * precision) / precision;
                }
                if (this.numberHandlers[i].smoothFactor !== undefined && this.numberHandlers[i].smoothFactor !== 0) {
                    // A smoothFactor of 0 means no smoothing.  We don't trigger this update if the factor is
                    // undefined or 0, but typescript still thinks is could be undefined due to the array indexing.
                    // The 'or-0' here is just to get around that without having to do a temporary assignment.
                    newVal = Utils.SmoothLinear(this.numberResultCache[i], newVal, this.numberHandlers[i].smoothFactor || 0, deltaTime);
                }
                if (newVal !== this.numberResultCache[i]) {
                    this.numberResultCache[i] = newVal;
                    this.numberHandlers[i].handler(newVal);
                }
            }
            this.context.update();
        }
    }
}

/**
 * A utility class which provides the current game state.
 */
class GameStateProvider {
    /**
     * Constructor.
     */
    constructor() {
        this.gameState = Subject.create(undefined);
        window.document.addEventListener('OnVCockpitPanelAttributesChanged', this.onAttributesChanged.bind(this));
        this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
        var _a;
        if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute('gamestate')) {
            const attribute = window.parent.document.body.getAttribute('gamestate');
            if (attribute !== null) {
                const state = GameState[attribute];
                // The game state is set briefly to ingame after loading is finished before changing to briefing. In order to
                // not notify subscribers of this erroneous ingame state, we will debounce any state changes into ingame by two
                // frames.
                if (state === GameState.ingame && this.gameState.get() !== GameState.ingame) {
                    setTimeout(() => {
                        setTimeout(() => {
                            const newAttribute = window.parent.document.body.getAttribute('gamestate');
                            if (newAttribute !== null) {
                                this.gameState.set(GameState[newAttribute]);
                            }
                        });
                    });
                }
                else {
                    this.gameState.set(state);
                }
                return;
            }
        }
        this.gameState.set(undefined);
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
        var _a;
        return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : (GameStateProvider.INSTANCE = new GameStateProvider())).gameState;
    }
}

/**
 * A manager for key events. Allows key events to be triggered and intercepted, and also publishes intercepted key
 * events on the event bus.
 */
class KeyEventManager {
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    constructor(keyListener, bus) {
        this.keyListener = keyListener;
        this.bus = bus;
        Coherent.on('keyIntercepted', this.onKeyIntercepted.bind(this));
    }
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param value1 The second data value of the key event.
     * @param value0 The first data value of the key event.
     * @param value2 The third data value of the key event.
     */
    onKeyIntercepted(key, value1, value0, value2) {
        // Even though values are uint32, we will do what the sim does and pretend they're actually sint32
        if (value0 !== undefined && value0 >= 2147483648) {
            value0 -= 4294967296;
        }
        this.bus.pub('key_intercept', { key, value0, value1, value2 }, false, false);
    }
    /**
     * Triggers a key event.
     * @param key The key to trigger.
     * @param bypass Whether the event should bypass intercepts.
     * @param value0 The first data value of the key event. Defaults to `0`.
     * @param value1 The second data value of the key event. Defaults to `0`.
     * @param value2 The third data value of the key event. Defaults to `0`.
     * @returns A Promise which is fulfilled after the key event has been triggered.
     */
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
        return Coherent.call('TRIGGER_KEY_EVENT', key, bypass, value0, value1, value2);
    }
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key, passThrough) {
        Coherent.call('INTERCEPT_KEY_EVENT', key, passThrough ? 0 : 1);
    }
    /**
     * Gets an instance of KeyEventManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyEventManager.
     */
    static getManager(bus) {
        if (KeyEventManager.INSTANCE) {
            return Promise.resolve(KeyEventManager.INSTANCE);
        }
        if (!KeyEventManager.isCreatingInstance) {
            KeyEventManager.createInstance(bus);
        }
        return new Promise(resolve => {
            KeyEventManager.pendingPromiseResolves.push(resolve);
        });
    }
    /**
     * Creates an instance of KeyEventManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    static async createInstance(bus) {
        KeyEventManager.isCreatingInstance = true;
        KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
        KeyEventManager.isCreatingInstance = false;
        for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
            KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
        }
    }
    /**
     * Creates an instance of KeyEventManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyEventManager after it has been created.
     */
    static create(bus) {
        return new Promise((resolve, reject) => {
            const gameState = GameStateProvider.get();
            const sub = gameState.sub(state => {
                if (window['IsDestroying']) {
                    sub.destroy();
                    reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    sub.destroy();
                    const keyListener = RegisterViewListener('JS_LISTENER_KEYEVENT', () => {
                        if (window['IsDestroying']) {
                            reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                            return;
                        }
                        resolve(new KeyEventManager(keyListener, bus));
                    });
                }
            }, false, true);
            sub.resume(true);
        });
    }
}
KeyEventManager.isCreatingInstance = false;
KeyEventManager.pendingPromiseResolves = [];

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
/**
 * The class of airport facility.
 */
var AirportClass;
(function (AirportClass) {
    /** No other airport class could be identified. */
    AirportClass[AirportClass["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClass[AirportClass["HardSurface"] = 1] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClass[AirportClass["SoftSurface"] = 2] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClass[AirportClass["AllWater"] = 3] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClass[AirportClass["HeliportOnly"] = 4] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClass[AirportClass["Private"] = 5] = "Private";
})(AirportClass || (AirportClass = {}));
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
var AirportClassMask;
(function (AirportClassMask) {
    /** No other airport class could be identified. */
    AirportClassMask[AirportClassMask["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClassMask[AirportClassMask["HardSurface"] = 2] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClassMask[AirportClassMask["SoftSurface"] = 4] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClassMask[AirportClassMask["AllWater"] = 8] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClassMask[AirportClassMask["HeliportOnly"] = 16] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClassMask[AirportClassMask["Private"] = 32] = "Private";
})(AirportClassMask || (AirportClassMask = {}));
/**
 * An enumeration of possible intersection types.
 */
var IntersectionType;
(function (IntersectionType) {
    IntersectionType[IntersectionType["None"] = 0] = "None";
    IntersectionType[IntersectionType["Named"] = 1] = "Named";
    IntersectionType[IntersectionType["Unnamed"] = 2] = "Unnamed";
    IntersectionType[IntersectionType["Vor"] = 3] = "Vor";
    IntersectionType[IntersectionType["NDB"] = 4] = "NDB";
    IntersectionType[IntersectionType["Offroute"] = 5] = "Offroute";
    IntersectionType[IntersectionType["IAF"] = 6] = "IAF";
    IntersectionType[IntersectionType["FAF"] = 7] = "FAF";
    IntersectionType[IntersectionType["RNAV"] = 8] = "RNAV";
    IntersectionType[IntersectionType["VFR"] = 9] = "VFR";
})(IntersectionType || (IntersectionType = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a lateral and vertical discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
    /** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */
    LegType[LegType["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["All"] = 0] = "All";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
    FacilitySearchType[FacilitySearchType["Visual"] = 7] = "Visual";
    FacilitySearchType[FacilitySearchType["AllExceptVisual"] = 8] = "AllExceptVisual";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
        return icao.substr(3, 4).trim();
    }
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao, type) {
        switch (icao[0]) {
            case 'A':
                return type === undefined || type === FacilityType.Airport;
            case 'W':
                return type === undefined || type === FacilityType.Intersection;
            case 'V':
                return type === undefined || type === FacilityType.VOR;
            case 'N':
                return type === undefined || type === FacilityType.NDB;
            case 'U':
                return type === undefined || type === FacilityType.USR;
            case 'R':
                return type === undefined || type === FacilityType.RWY;
            case 'S':
                return type === undefined || type === FacilityType.VIS;
            default:
                return false;
        }
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao) {
        return icao.substr(1, 2).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';
/**
 * Utility functions for working with facilities.
 */
class FacilityUtils {
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType(facility, type) {
        // Need to check for the intersection version of VOR/NDB facilities - these facilities have identical ICAOs
        // to their VOR/NDB counterparts, so we need to manually check the __Type property on the facility object.
        if (facility['__Type'] === 'JS_FacilityIntersection') {
            return type === FacilityType.Intersection;
        }
        return ICAO.isFacility(facility.icao, type);
    }
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            return -facility.magneticVariation; // VOR facility magvar is positive west instead of the standard positive east
        }
        else {
            return MagVar.get(facility.lat, facility.lon);
        }
    }
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
        return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
        const magVar1 = FacilityUtils.getMagVar(reference1);
        const magVar2 = FacilityUtils.getMagVar(reference2);
        const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
        const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
        const radial1IncludesRef2 = radialCircle1.includes(reference2);
        const radial2IncludesRef1 = radialCircle2.includes(reference1);
        if (radial1IncludesRef2 && radial2IncludesRef1) {
            // Radials are parallel or antiparallel, and therefore do not have a unique intersection point.
            return out.set(NaN, NaN);
        }
        else if (radial1IncludesRef2) {
            // Reference 2 lies along the great circle of radial 1. The intersection point therefore is either reference 2
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
        }
        else if (radial2IncludesRef1) {
            // Reference 1 lies along the great circle of radial 2. The intersection point therefore is either reference 1
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
        }
        // Radials, unlike great circles, do not circumscribe the globe. Therefore, we choose the order of the intersection
        // operation carefully to ensure that the first solution (if it exists) is the "correct" intersection.
        const numIntersections = radialCircle1.encircles(reference2)
            ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache)
            : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
        if (numIntersections === 0) {
            return out.set(NaN, NaN);
        }
        return out.set(FacilityUtils.intersectionCache[0]);
    }
}
FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Utility functions for working with user facilities.
 */
class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
        const fac = {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat,
            lon,
            userFacilityType: UserFacilityType.LAT_LONG,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(lat, lon)
        };
        return fac;
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_DISTANCE,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference.icao,
            reference1Radial: radial,
            reference1MagVar: FacilityUtils.getMagVar(reference),
            reference1Distance: distance
        };
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
        if (isNaN(location.lat) || isNaN(location.lon)) {
            return undefined;
        }
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_RADIAL,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference1.icao,
            reference1Radial: radial1,
            reference1MagVar: FacilityUtils.getMagVar(reference1),
            reference2Icao: reference2.icao,
            reference2Radial: radial2,
            reference2MagVar: FacilityUtils.getMagVar(reference2)
        };
    }
}
UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];

var RunwaySurfaceCategory;
(function (RunwaySurfaceCategory) {
    RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Water"] = 8] = "Water";
})(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
        const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
        return lowerCase
            ? letter.toLowerCase()
            : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            elevationEnd: 0,
            gradient: 0,
            latitude: 0,
            longitude: 0,
            length: 0,
            width: 0,
            startThresholdLength: 0,
            endThresholdLength: 0,
            surface: RunwaySurfaceType.Concrete,
            lighting: RunwayLightingType.Unknown
        };
    }
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport) {
        const runways = [];
        airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach(d => {
            runways.push(d[0]);
            runways.push(d[1]);
        });
        runways.sort(RunwayUtils.sortRunways);
        return runways;
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let endThresholdElevation = 0;
            let ilsFrequency;
            let startThresholdLength = 0, endThresholdLength = 0;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                endThresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
                startThresholdLength = runway.primaryThresholdLength;
                endThresholdLength = runway.secondaryThresholdLength;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                endThresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
                startThresholdLength = runway.secondaryThresholdLength;
                endThresholdLength = runway.primaryThresholdLength;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                elevationEnd: endThresholdElevation,
                gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency,
                length: runway.length,
                width: runway.width,
                startThresholdLength,
                endThresholdLength,
                surface: runway.surface,
                lighting: runway.lighting
            });
        }
        return splitRunways;
    }
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway, padded = true) {
        const pad = padded ? 2 : 0;
        const dashIndex = runway.designation.search('-');
        const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
        const secondary = dashIndex < 0 ? '' : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
        return primary + secondary;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return parseInt(runway.designation);
        }
        else {
            return parseInt(runway.designation.substring(0, dashIndex));
        }
    }
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return undefined;
        }
        else {
            return parseInt(runway.designation.substring(dashIndex + 1));
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
        let runway;
        if (typeof arg1 === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else if (typeof arg1 === 'number') {
            const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else {
            runway = arg1;
        }
        const runwayDesignation = runway.designation;
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            // Note: drop the leading zero in the runway designation for the search because some third-party sceneries
            // format the frequency names without the leading zero.
            const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ''));
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
        const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
        if (!matchedRunway) {
            return undefined;
        }
        return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
        let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        switch (runwayDesignator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
                break;
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
                break;
            default:
                oppositeRunwayDesignator = runwayDesignator;
                break;
        }
        return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        const icao = typeof airport === 'string' ? airport : airport.icao;
        return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway) {
        const surface = typeof runway === 'object' ? runway.surface : runway;
        if (this.SURFACES_HARD.includes(surface)) {
            return RunwaySurfaceCategory.Hard;
        }
        else if (this.SURFACES_SOFT.includes(surface)) {
            return RunwaySurfaceCategory.Soft;
        }
        else if (this.SURFACES_WATER.includes(surface)) {
            return RunwaySurfaceCategory.Water;
        }
        else {
            return RunwaySurfaceCategory.Unknown;
        }
    }
}
RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: '',
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 'L',
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 'R',
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 'C',
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 'W',
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 'A',
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 'B',
};
RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A utility class for working with approach procedures.
 */
class ApproachUtils {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query) {
        const rnavTypeFlags = typeof query === 'number' ? query : query.rnavTypeFlags;
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach) {
        return approach.approachType === ApproachType.APPROACH_TYPE_RNAV
            && approach.rnavTypeFlags === RnavTypeFlags.None
            && approach.runwayNumber !== 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getFrequencyFromAirport(facility, approach) {
        if (typeof approach === 'number') {
            approach = facility.approaches[approach];
        }
        if (approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_SDF:
                    return RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    return RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
            }
        }
        return undefined;
    }
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static async getReferenceFacility(approach, facLoader) {
        let facilityType;
        let isLoc = false;
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
                isLoc = true;
            // eslint-disable-next-line no-fallthrough
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                facilityType = FacilityType.VOR;
                break;
            case ApproachType.APPROACH_TYPE_NDB:
            case ApproachType.APPROACH_TYPE_NDBDME:
                facilityType = FacilityType.NDB;
                break;
            default:
                return undefined;
        }
        const finalLegs = approach.finalLegs;
        // Find the faf
        let fafLeg = undefined;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = finalLegs[i];
            if (BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
                fafLeg = leg;
                break;
            }
        }
        if (!fafLeg) {
            return undefined;
        }
        if (!ICAO.isFacility(fafLeg.originIcao, facilityType)) {
            return undefined;
        }
        try {
            const facility = await facLoader.getFacility(facilityType, fafLeg.originIcao);
            if (isLoc && facility.type !== VorType.ILS) {
                return undefined;
            }
            else {
                return facility;
            }
        }
        catch (_a) {
            return undefined;
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
const airportIcaoRegionPattern = new RegExp(/^A../);
/**
 * A type map of facility type to facility search type.
 */
({
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User,
    /** Visual facility type. */
    [FacilityType.VIS]: FacilitySearchType.Visual
});
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => FacilityLoader.init(), 2000);
            }, true);
        }
        this.awaitInitialization().then(() => this.onInitialized());
    }
    /**
     * Initializes this facility loader.
     */
    static init() {
        FacilityLoader.isInitialized = true;
        for (const resolve of this.initPromiseResolveQueue) {
            resolve();
        }
        this.initPromiseResolveQueue.length = 0;
    }
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization() {
        if (FacilityLoader.isInitialized) {
            return Promise.resolve();
        }
        else {
            return new Promise(resolve => {
                FacilityLoader.initPromiseResolveQueue.push(resolve);
            });
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        // Remove the region code from the icao
        if (type === FacilityType.Airport) {
            icao = icao.replace(airportIcaoRegionPattern, 'A  ');
        }
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const cachedFac = cache.get(icao);
        if (cachedFac !== undefined) {
            return Promise.resolve(cachedFac);
        }
        const currentTime = Date.now();
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            if (request !== undefined) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                Coherent.call(type, icao).then((isValid) => {
                    if (!isValid) {
                        rejection(`Facility ${icao} could not be found.`);
                        queue.delete(icao);
                    }
                });
            });
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            queue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
        switch (type) {
            case FacilitySearchType.User:
            case FacilitySearchType.Visual:
                return this.startRepoNearestSearchSession(type);
            case FacilitySearchType.AllExceptVisual:
                return this.startCoherentNearestSearchSession(FacilitySearchType.All);
            default:
                return this.startCoherentNearestSearchSession(type);
        }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestVorSearchSession(sessionId);
                break;
            case FacilitySearchType.Boundary:
                session = new NearestBoundarySearchSession(sessionId);
                break;
            default:
                session = new CoherentNearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
        // Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
        // them all to negative numbers
        const sessionId = FacilityLoader.repoSearchSessionId--;
        switch (type) {
            case FacilitySearchType.User:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            case FacilitySearchType.Visual:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            default:
                throw new Error();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        let results;
        if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
            const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
            results = await Coherent.call('SEARCH_BY_IDENT', ident, coherentFilter, maxItems);
        }
        else {
            results = [];
        }
        const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
        if (facRepositorySearchTypes) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
        const results = await this.searchByIdent(filter, ident, maxItems);
        if (!results) {
            return [];
        }
        const promises = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i];
            const facIdent = ICAO.getIdent(icao);
            if (facIdent === ident) {
                const facType = ICAO.getFacilityType(icao);
                promises.push(this.getFacility(facType, icao));
            }
        }
        const foundFacilities = await Promise.all(promises);
        if (foundFacilities.length > 1) {
            foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
            return foundFacilities;
        }
        else if (foundFacilities.length === 1) {
            return foundFacilities;
        }
        else {
            return [];
        }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const isMismatch = facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W';
        const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
        const request = queue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, isMismatch);
            queue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session instanceof CoherentNearestSearchSession) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
};
FacilityLoader.repoSearchSessionId = -1;
FacilityLoader.isInitialized = false;
FacilityLoader.initPromiseResolveQueue = [];
/**
 * A session for searching for nearest facilities through Coherent.
 */
class CoherentNearestSearchSession {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
        Coherent.call('SET_NEAREST_EXTENDED_AIRPORT_FILTERS', this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
}
/**
 * Default filters for the nearest airports search session.
 */
NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
};
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     * @param showTerminalWaypoints Whether or not to show terminal waypoints. Defaults to true.
     */
    setIntersectionFilter(typeMask, showTerminalWaypoints = true) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask, showTerminalWaypoints ? 1 : 0);
    }
}
/**
 * Default filters for the nearest intersections search session.
 */
NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
};
/**
 * A session for searching for nearest VORs.
 */
class NearestVorSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
        Coherent.call('SET_NEAREST_VOR_FILTER', this.sessionId, classMask, typeMask);
    }
}
/**
 * Default filters for the nearest VORs search session.
 */
NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
};
/**
 * A session for searching for nearest airspace boundaries.
 */
class NearestBoundarySearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
        Coherent.call('SET_NEAREST_BOUNDARY_FILTER', this.sessionId, classMask);
    }
}
/**
 * A session for searching for nearest facilities that uses the facility repository.
 */
class NearestRepoFacilitySearchSession {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
        this.repo = repo;
        this.sessionId = sessionId;
        this.filter = undefined;
        this.cachedResults = new Set();
        this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
        const added = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i].icao;
            if (this.cachedResults.has(icao)) {
                this.cachedResults.delete(icao);
            }
            else {
                added.push(icao);
            }
        }
        const removed = Array.from(this.cachedResults);
        this.cachedResults.clear();
        for (let i = 0; i < results.length; i++) {
            this.cachedResults.add(results[i].icao);
        }
        return Promise.resolve({
            sessionId: this.sessionId,
            searchId: this.searchId++,
            added,
            removed
        });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
        this.filter = filter;
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
class BinaryHeap {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
        this.comparator = comparator;
        this.tree = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
        return this.tree.length;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
        return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
        if (this.tree.length === 0) {
            return undefined;
        }
        const min = this.tree[0];
        this.swap(0, this.tree.length - 1);
        this.tree.length--;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
        this.tree.push(element);
        this.heapifyUp(this.tree.length - 1);
        return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
        if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
            return element;
        }
        return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
        const min = this.tree[0];
        this.tree[0] = element;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
        this.tree.length = 0;
        return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
        let parent = BinaryHeap.parent(index);
        while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
            this.swap(parent, index);
            index = parent;
            parent = BinaryHeap.parent(index);
        }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
        const len = this.tree.length;
        while (index < len) {
            const left = BinaryHeap.left(index);
            const right = BinaryHeap.right(index);
            let needSwapFlags = 0;
            if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
                needSwapFlags |= 1;
            }
            if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
                needSwapFlags |= 2;
            }
            if (needSwapFlags === 3) {
                needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
            }
            if (needSwapFlags === 0) {
                break;
            }
            const swapChild = needSwapFlags === 1 ? left : right;
            this.swap(index, swapChild);
            index = swapChild;
        }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
        const old1 = this.tree[index1];
        this.tree[index1] = this.tree[index2];
        this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
        return index * 2 + 2;
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index) {
        if (index < 0 || index >= this._array.length) {
            throw new RangeError();
        }
        return this._array[index];
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[0];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[this._array.length - 1];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index) {
        if (index < 0 || index >= this._array.length) {
            return undefined;
        }
        return this._array.splice(index, 1)[0];
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
        return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Re-sorts this array using its sorting function.
     */
    resort() {
        this._array.sort(this.comparatorFunc);
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A linearly interpolated N-dimensional lookup table.
 */
class LerpLookupTable {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg) {
        this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg === 'number') {
            this._dimensionCount = isFinite(arg) ? Math.max(0, arg) : 0;
            return;
        }
        const leastDimension = arg.reduce((accum, current) => (current.length < accum.length) ? current : accum);
        this._dimensionCount = Math.max(0, leastDimension ? (leastDimension.length - 1) : 0);
        if (this._dimensionCount === 0) {
            return;
        }
        for (let i = 0; i < arg.length; i++) {
            this.insertBreakpoint(arg[i]);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table);
        if (value === undefined) {
            throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray) {
        const dimensionKey = key[dimension];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        if (startValue === endValue) {
            return startValue;
        }
        return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpLookupTable.tempBreakpoint = { key: 0 };

/**
 * A k-dimensional search tree.
 */
class KdTree {
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
        this.keyFunc = keyFunc;
        this.elements = [];
        this.keys = [];
        this.nodes = [];
        this.minDepth = -1;
        this.maxDepth = -1;
        this.dimensionCount = Math.trunc(dimensionCount);
        if (this.dimensionCount < 2) {
            throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
        }
        this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
        this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
            return (a, b) => {
                const aKey = this.keys[a];
                const bKey = this.keys[b];
                for (let i = 0; i < this.dimensionCount; i++) {
                    const dimension = (i + index) % this.dimensionCount;
                    if (aKey[dimension] < bKey[dimension]) {
                        return -1;
                    }
                    else if (aKey[dimension] > bKey[dimension]) {
                        return 1;
                    }
                }
                return 0;
            };
        });
        this.keyCache = [
            new Float64Array(this.dimensionCount)
        ];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
        return this.elements.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(undefined, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(undefined, key, radius, arg3);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
        const key = this.keyFunc(element, this.keyCache[0]);
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(element, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(element, key, radius, arg3);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            return visitor(elementInner, keyInner, distance, queryKey, queryElement);
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            return searchRadius + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
        if (maxResultCount <= 0) {
            out.length = 0;
            return out;
        }
        const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
                if (heap.size === maxResultCount) {
                    heap.insertAndRemoveMin(elementIndex);
                }
                else {
                    heap.insert(elementIndex);
                }
            }
            return true;
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            let maxDist = searchRadius;
            if (heap.size === maxResultCount) {
                maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
            }
            return maxDist + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
        out.length = heap.size;
        for (let i = out.length - 1; i >= 0; i--) {
            out[i] = this.elements[heap.removeMin()];
        }
        return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
        const elementIndex = this.nodes[nodeIndex];
        if (elementIndex === undefined) {
            return true;
        }
        const nodeKey = this.keys[elementIndex];
        const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
        if (distanceFromNode <= radius) {
            if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
                return false;
            }
        }
        const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        const lesserNodeIndex = KdTree.lesser(nodeIndex);
        const greaterNodeIndex = KdTree.greater(nodeIndex);
        if (this.nodes[lesserNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, -1)) {
            if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        if (this.nodes[greaterNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, 1)) {
            if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        const insertDepth = this.insertElementInTree(element) + 1;
        this.maxDepth = Math.max(this.maxDepth, insertDepth);
        if (insertDepth === this.minDepth + 1) {
            this.minDepth = KdTree.depth(this.nodes.indexOf(undefined, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
        }
        // Rebalance the tree if max depth is greater than twice the min depth.
        if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
            this.rebuild();
        }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        for (const element of elements) {
            this.elements.push(element);
            this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
            const insertedIndex = this.elements.length - 1;
            for (let i = 0; i < this.dimensionCount; i++) {
                this.indexArrays[i].push(insertedIndex);
            }
        }
        this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
        const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
        let index = 0;
        let depth = 0;
        let elementIndex;
        while ((elementIndex = this.nodes[index]) !== undefined) {
            const pivotDimension = depth % this.dimensionCount;
            const keyToCompare = key[pivotDimension];
            if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
                index = KdTree.lesser(index);
            }
            else {
                index = KdTree.greater(index);
            }
            depth++;
        }
        this.elements.push(element);
        this.keys.push(key);
        const insertedIndex = this.elements.length - 1;
        this.nodes[index] = insertedIndex;
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].push(insertedIndex);
        }
        return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        if (!this.removeElementFromArrays(element)) {
            return false;
        }
        this.resetIndexArrays();
        this.rebuild();
        return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        let removed = false;
        for (const element of elements) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
            this.rebuild();
        }
        return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
        const index = this.elements.indexOf(element);
        if (index < 0) {
            return false;
        }
        const lastIndex = this.elements.length - 1;
        this.elements[index] = this.elements[lastIndex];
        this.keys[index] = this.keys[lastIndex];
        this.elements.length--;
        this.keys.length--;
        return true;
    }
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    resetIndexArrays() {
        for (let i = 0; i < this.dimensionCount; i++) {
            const array = this.indexArrays[i];
            array.length = this.elements.length;
            for (let j = 0; j < array.length; j++) {
                array[j] = j;
            }
        }
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        let removed = false;
        for (const element of toRemove) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
        }
        this.insertAll(toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        // clear the tree structure
        this.nodes.length = 0;
        if (this.size === 0) {
            return;
        }
        // sort index arrays
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].sort(this.indexSortFuncs[i]);
        }
        this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
        const log = Math.log2(this.elements.length + 1);
        this.minDepth = Math.floor(log) - 1;
        this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
        const tempArray = this.indexArrays[this.dimensionCount];
        const sortedArray = this.indexArrays[0];
        const medianIndex = Math.trunc((start + end) / 2);
        const medianKeyIndex = sortedArray[medianIndex];
        // Insert median into its position in the tree
        this.nodes[nodeIndex] = medianKeyIndex;
        if (end - start === 1) {
            return;
        }
        if (end - start <= 3) {
            const lesserIndex = medianIndex - 1;
            const greaterIndex = medianIndex + 1;
            if (lesserIndex >= start) {
                this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
            }
            if (greaterIndex < end) {
                this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
            }
            return;
        }
        for (let i = start; i < end; i++) {
            tempArray[i] = sortedArray[i];
        }
        // Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
        // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
        // index 0.
        for (let i = 1; i < this.dimensionCount; i++) {
            const targetArray = this.indexArrays[i - 1];
            const toPartitionArray = this.indexArrays[i];
            let lesserCount = 0;
            let greaterCount = 0;
            for (let j = start; j < end; j++) {
                const keyIndex = toPartitionArray[j];
                if (keyIndex === medianKeyIndex) {
                    targetArray[medianIndex] = keyIndex;
                }
                else {
                    const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
                    if (comparison <= 0) {
                        const index = start + (lesserCount++);
                        targetArray[index] = keyIndex;
                    }
                    else {
                        const index = medianIndex + 1 + (greaterCount++);
                        targetArray[index] = keyIndex;
                    }
                }
            }
        }
        // Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
        const newSortedArray = this.indexArrays[this.dimensionCount - 1];
        for (let i = start; i < end; i++) {
            newSortedArray[i] = tempArray[i];
        }
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
        this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.elements.length = 0;
        this.keys.length = 0;
        this.nodes.length = 0;
        for (let i = 0; i < this.indexArrays.length; i++) {
            this.indexArrays[i].length = 0;
        }
        this.minDepth = -1;
        this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
        return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
        return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
        return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
        let sumSq = 0;
        for (let i = 0; i < dimensionCount; i++) {
            const diff = key1[i] - key2[i];
            sumSq += diff * diff;
        }
        return Math.sqrt(sumSq);
    }
}

/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
class GeoKdTree {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
        this.keyFunc = keyFunc;
        this.cartesianTree = new KdTree(3, (element, out) => {
            const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
            out[0] = vec[0];
            out[1] = vec[1];
            out[2] = vec[2];
            return out;
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
        let center, radius;
        let argA, argB, argC;
        if (typeof arg1 === 'number') {
            center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
            radius = arg3;
            argA = arg4;
            argB = arg5;
            argC = arg6;
        }
        else if (!(arg1 instanceof Float64Array)) {
            center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        else {
            center = arg1;
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
        if (typeof argA === 'number') {
            return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
        }
        else {
            this.doVisitorSearch(center, radiusCartesian, argA);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
        this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
            const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
            const greatCircleDist = GeoPoint.distance(vec, center);
            return visitor(element, vec, greatCircleDist, center);
        });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
        const cartesianFilter = filter
            ? (element, key) => {
                const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
                const greatCircleDist = GeoPoint.distance(vec, center);
                return filter(element, vec, greatCircleDist, center);
            }
            : undefined;
        return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        return this.cartesianTree.removeAll(elements);
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.cartesianTree.clear();
    }
}
GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];

/**
 * Types of facility repository sync events.
 */
var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType["Add"] = "Add";
    FacilityRepositorySyncType["Remove"] = "Remove";
    FacilityRepositorySyncType["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType["DumpResponse"] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRepository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.repos = new Map();
        this.trees = {
            [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
            [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        };
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        // Request a dump from any existing instances on other instruments to initialize the repository.
        this.pubSyncEvent({
            type: FacilityRepositorySyncType.DumpRequest, uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
        });
    }
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types) {
        var _a, _b;
        let size = 0;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                size += repo.size;
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
            }
        }
        return size;
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
        if (type !== FacilityType.USR && type !== FacilityType.VIS) {
            throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
        }
        if (typeof arg5 === 'number') {
            return this.trees[type].search(lat, lon, radius, arg5, out, filter);
        }
        else {
            this.trees[type].search(lat, lon, radius, arg5);
        }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
        }
        this.addToRepo(fac);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs) {
        this.addMultipleToRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        if (!ICAO.isFacility(icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
        }
        this.removeFromRepo(icao);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs) {
        this.removeMultipleFromRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map(fac => typeof fac === 'object' ? fac.icao : fac) });
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                repo.forEach(fn);
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
            }
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === undefined) {
            this.repos.set(facilityType, repo = new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            if (existing === undefined) {
                this.trees[facilityType].insert(fac);
            }
            else {
                this.trees[facilityType].removeAndInsert([existing], [fac]);
            }
        }
        if (existing === undefined) {
            this.publisher.pub('facility_added', fac, false, false);
        }
        else {
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    addMultipleToRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const addedFacilities = [];
        const changedFacilitiesRemoved = [];
        const changedFacilitiesAdded = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const facilityType = ICAO.getFacilityType(fac.icao);
            let repo = this.repos.get(facilityType);
            if (repo === undefined) {
                this.repos.set(facilityType, repo = new Map());
            }
            const existing = repo.get(fac.icao);
            repo.set(fac.icao, fac);
            if (existing === undefined) {
                addedFacilities.push(fac);
            }
            else {
                changedFacilitiesRemoved.push(existing);
                changedFacilitiesAdded.push(fac);
            }
        }
        const addedUserFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (addedUserFacilities.length > 0) {
            const removedUserFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
            this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
        }
        const addedVisFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (addedVisFacilities.length > 0) {
            const removedVisFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
            this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
        }
        for (let i = 0; i < addedFacilities.length; i++) {
            const fac = addedFacilities[i];
            this.publisher.pub('facility_added', fac, false, false);
        }
        for (let i = 0; i < changedFacilitiesAdded.length; i++) {
            const fac = changedFacilitiesAdded[i];
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    removeFromRepo(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        const facilityType = ICAO.getFacilityType(icao);
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === undefined) {
            return;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === undefined) {
            return;
        }
        repo.delete(icao);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            this.trees[facilityType].remove(facilityInRepo);
        }
        this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
        this.publisher.pub('facility_removed', facilityInRepo, false, false);
    }
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    removeMultipleFromRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const removedFacilities = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const icao = typeof fac === 'string' ? fac : fac.icao;
            const repo = this.repos.get(ICAO.getFacilityType(icao));
            if (repo === undefined) {
                continue;
            }
            const facilityInRepo = repo.get(icao);
            if (facilityInRepo === undefined) {
                continue;
            }
            repo.delete(icao);
            removedFacilities.push(facilityInRepo);
        }
        const removedUserFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (removedUserFacilities.length > 0) {
            this.trees[FacilityType.USR].removeAll(removedUserFacilities);
        }
        const removedVisFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (removedVisFacilities.length > 0) {
            this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
        }
        for (let i = 0; i < removedFacilities.length; i++) {
            const removedFac = removedFacilities[i];
            this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
            this.publisher.pub('facility_removed', removedFac, false, false);
        }
    }
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    pubSyncEvent(data) {
        this.ignoreSync = true;
        this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.DumpResponse:
                // Only accept responses to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    break;
                }
                else {
                    this.lastDumpRequestUid = undefined;
                }
            // eslint-disable-next-line no-fallthrough
            case FacilityRepositorySyncType.Add:
                if (data.facs.length === 1) {
                    this.addToRepo(data.facs[0]);
                }
                else {
                    this.addMultipleToRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.Remove:
                if (data.facs.length === 1) {
                    this.removeFromRepo(data.facs[0]);
                }
                else {
                    this.removeMultipleFromRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.DumpRequest:
                // Don't respond to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRepository.INSTANCE = new FacilityRepository(bus));
    }
}
FacilityRepository.SYNC_TOPIC = 'facilityrepo_sync';
FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
};

/**
 * The transition type to which a flight path vector belongs.
 */
var FlightPathVectorFlags;
(function (FlightPathVectorFlags) {
    FlightPathVectorFlags[FlightPathVectorFlags["None"] = 0] = "None";
    /** A turn to a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"] = 1] = "TurnToCourse";
    /** An arcing turn to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Arc"] = 2] = "Arc";
    /** A direct course to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Direct"] = 4] = "Direct";
    /** A path to intercept a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["InterceptCourse"] = 8] = "InterceptCourse";
    /** Inbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    /** Outbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    /** A direct hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    /** A teardrop hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    /** A parallel hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    /** A course reversal. */
    FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"] = 512] = "CourseReversal";
    /** A turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"] = 1024] = "LegToLegTurn";
    /** An anticipated turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    /** A fallback path. */
    FlightPathVectorFlags[FlightPathVectorFlags["Fallback"] = 4096] = "Fallback";
})(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        // *********************************************************************************************************
        // ******** When adding new fields, they MUST be initialized, even if it just gets set to undefined ********
        // ******** This is so that it can be used with Object.keys()                                       ********
        // *********************************************************************************************************
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction. */
        this.originRunway = undefined;
        /** The ICAO for the facility associated with the departure procedure. */
        this.departureFacilityIcao = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The ICAO for the facility associated with the arrival procedure. */
        this.arrivalFacilityIcao = undefined;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The arrival runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.arrivalRunway = undefined;
        /** The ICAO for the facility associated with the approach procedure. */
        this.approachFacilityIcao = undefined;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /** The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
/**
 * Bitflags describing a leg definition.
 */
var LegDefinitionFlags;
(function (LegDefinitionFlags) {
    LegDefinitionFlags[LegDefinitionFlags["None"] = 0] = "None";
    LegDefinitionFlags[LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags[LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags[LegDefinitionFlags["Obs"] = 4] = "Obs";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
})(LegDefinitionFlags || (LegDefinitionFlags = {}));
/**
 * Vertical flight phase.
 */
var VerticalFlightPhase;
(function (VerticalFlightPhase) {
    VerticalFlightPhase["Climb"] = "Climb";
    VerticalFlightPhase["Descent"] = "Descent";
})(VerticalFlightPhase || (VerticalFlightPhase = {}));
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit[SpeedUnit["IAS"] = 0] = "IAS";
    SpeedUnit[SpeedUnit["MACH"] = 1] = "MACH";
})(SpeedUnit || (SpeedUnit = {}));
/** Types of speed restrictions on legs. */
var SpeedRestrictionType;
(function (SpeedRestrictionType) {
    SpeedRestrictionType[SpeedRestrictionType["Unused"] = 0] = "Unused";
    SpeedRestrictionType[SpeedRestrictionType["At"] = 1] = "At";
    SpeedRestrictionType[SpeedRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType[SpeedRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType[SpeedRestrictionType["Between"] = 4] = "Between";
})(SpeedRestrictionType || (SpeedRestrictionType = {}));

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            flags: FlightPathVectorFlags.None,
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
        vector.flags = flags;
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector) {
        return vector.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector) {
        return Math.min(vector.radius, Math.PI - vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg, point, magVarFacility) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const magVar = magVarFacility
            ? -magVarFacility.magneticVariation // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.reverse();
        }
        return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
        return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > MathUtils.HALF_PI
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the great circle tangent to a given path at a given tangent point. The tangent circle will contain the
     * tangent point and have the same direction as the path at the tangent point.
     * @param point The tangent point. If the point does not lie on the path, it will be projected onto the path.
     * @param path The geo circle describing the path.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified path at the specified point.
     */
    static getGreatCircleTangentToPath(point, path, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(path.center, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Gets the great circle tangent to a given flight path vector at a given tangent point. The tangent circle will
     * contain the tangent point and have the same direction as the vector at the tangent point.
     * @param point The tangent point. If the point does not lie on the vector, it will be projected onto the vector.
     * @param vector The flight path vector.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified flight path vector at the specified point.
     */
    static getGreatCircleTangentToVector(point, vector, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const centerVec = Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[1]);
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(centerVec, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
        }
        const radius = turnDirection === 'left'
            ? turnRadius
            : Math.PI - turnRadius;
        const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
        const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
        return out.set(turnCenter, radius);
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
            return posAngularDistance >= Math.PI ? -Infinity : Infinity;
        }
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angularTolerance = circle.angularWidth(tolerance);
        if (typeof end !== 'number') {
            end = circle.angleAlong(start, end, Math.PI, angularTolerance);
        }
        if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const angle = circle.angleAlong(start, pos, Math.PI);
        if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
        return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static projectVelocityToCircle(speed, position, direction, projectTo) {
        if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return NaN;
        }
        if (speed === 0) {
            return 0;
        }
        if (!(position instanceof Float64Array)) {
            position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
        }
        const velocityPath = typeof direction === 'number'
            ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction)
            : direction.isGreatCircle()
                ? direction
                : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
        const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
        const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
        const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
        const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
        const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
        return speed * sinTheta * sign;
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j, _k, _l, _m;
        const vectors = legCalc.ingressToEgress;
        let vectorIndex = 0;
        let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
        const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
        const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
        const firstEgressVector = legCalc.egress[0];
        const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
        if (lastIngressVector && ingressJoinVector) {
            // Check if the last ingress vector joins the base flight path before the end of a vector. If so, we need to
            // replace the base flight path vector the ingress joins with a shortened version starting where the ingress
            // ends.
            const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
            const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector
                ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon)
                : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
            const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
            const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
            if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
                // Ingress joins the base flight path before the end of the joined vector.
                if (ingressEndAlongVectorDistance > normalizedTolerance) {
                    // Ingress joins the base flight path after the start of the joined vector.
                    ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
                    FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : (vectors[_g] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
                }
                else {
                    // Ingress joins the base flight path at or before the start of the joined vector.
                    Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : (vectors[_h] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVector);
                }
            }
            flightPathVectorIndex++;
        }
        const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
        for (let i = flightPathVectorIndex; i < end; i++) {
            Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : (vectors[_j] = FlightPathUtils.createEmptyCircleVector()), legCalc.flightPath[i]);
            flightPathVectorIndex++;
        }
        if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
            if (firstEgressVector) {
                // Check if the first egress vector joins the base flight path in after the start of a vector. If so, we need
                // to replace the base flight path vector the egress joins with a shortened version starting where the egress
                // starts.
                const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
                const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
                const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
                const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
                if (egressStartAlongVectorDistance > normalizedTolerance) {
                    // Egress joins the base flight path after the start of the joined vector.
                    if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
                        // Egress joins the base flight path before the end of the joined vector.
                        egressJoinVectorCircle.closest(egressStart, egressStart);
                        FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : (vectors[_k] = FlightPathUtils.createEmptyCircleVector()), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                    }
                    else {
                        // Egress joins the base flight path at or after the end of the joined vector.
                        Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : (vectors[_l] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
                    }
                }
            }
            else {
                // There is no egress, but there is a base flight path vector flagged as the vector with which the egress
                // joins. This is technically an invalid state, but we can easily just treat this as a regular "no-egress"
                // case and copy the entire egress join vector into the resolved vectors array.
                Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : (vectors[_m] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
            }
        }
        vectors.length = vectorIndex;
        return legCalc;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
}
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        if (turnEndPoint.equals(start)) {
            return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const intersectionIndex = (numIntersections === 1 || circle.encircles(start)) ? 0 : 1;
        const endVec = intersections[intersectionIndex];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
[
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
[new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
class InterceptGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
        }
        const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
        if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // initial and final paths are parallel
            return 0;
        }
        const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
        const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
        // The set of centers of great circles that intersect the end path at the desired intercept angle
        const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
        const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
        if (startTurnDirection === undefined) {
            // Calculate the intercept point if the intercept path were to pass through the start point.
            const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
            if (interceptCount === 0) {
                // No great-circle path passing through the start point can intercept the final path at the desired intercept angle.
                startTurnDirection = startPath.encircles(end) ? 'left' : 'right';
            }
            else {
                let intersectionIndex = 0;
                if (interceptCount > 1) {
                    // There are two great-circle paths passing through the start point that intercept the final path at the
                    // desired angle. One of them will be directed toward the end path and the other will be directed away from
                    // it. We want to choose the one directed toward it.
                    intersectionIndex = endPath.encircles(start) ? 0 : 1;
                }
                let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                // sin x ~= x for x near 0, so to check if the angle between the start path and intercept path is parallel or
                // antiparallel we just have to check the magnitude of their cross product instead of the arcsine of the
                // magnitude.
                if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                    // If start and intercept paths are parallel or antiparallel, it doesn't really matter which direction we
                    // turn, so we will just turn in the direction that aligns us with the end path.
                    cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                    if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                        // If start and end paths are antiparallel (they can't be parallel since we would have returned from the
                        // method by now), then we just arbitrarily choose to turn right.
                        startTurnDirection = 'right';
                    }
                    else {
                        startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                    }
                }
                else {
                    startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                }
            }
        }
        const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
        const endTurnRadiusRad = endTurnRadius === undefined ? undefined : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
        if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // If the desired intercept angle is 0 degrees, the only valid path is when the starting turn ends exactly on the
            // path to intercept and the end of the turn lies before the end point
            if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
                // starting turn is not tangent to path to intercept
                return 0;
            }
            const startTurnEnd = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd, end, Math.PI);
            if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                // the end of the starting turn lies after the end point.
                return 0;
            }
            return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        // Find the great-circle path that intersects the path to intercept at the desired intercept angle and is tangent
        // to the starting turn.
        // The set of centers of great circles that are tangent to the starting turn
        const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
        const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
        if (interceptPathCount === 0) {
            return 0;
        }
        const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
        let interceptCrossSign;
        if (startToEndPathAngleRad >= interceptAngleRad) {
            // The start turn is considered to overshoot if it crosses to the contralateral side of the final path before
            // joining the intercept path that requires the shortest turn to join. The contralateral side is defined as the
            // right side for left turns and the left side for right turns. If this occurs, we need to choose the second
            // intercept path (if it exists). This is because choosing the first intercept path would trigger a case below
            // that attempts to end the start turn early, which could produce a path that requires the plane to track toward
            // the final path at an angle greater than the intercept angle.
            const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
            const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
            interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
            interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === 'right') ? 1 : -1;
        }
        else {
            // If the start path intersects the final path at a shallower angle than the intercept path, then we always want
            // to choose the intercept path that requires the shortest turn to join. Even if the turn has overshot the final
            // path by the time it can join the chosen intercept path, we handle that case below by attempting to end the
            // start turn early. We are guaranteed that ending the start turn early will not result in a path that requires
            // the plane to track toward the final path at an angle greater than the intercept angle because if it did, that
            // would mean the start turn does not overshoot the final path and therefore we wouldn't have needed to end the
            // start turn early in the first place.
            interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
            interceptCrossSign = startTurnDirection === 'right' ? 1 : -1;
        }
        const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
        const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        // Required turn anticipation for the end turn to join the intercept and final paths.
        let minDInterceptEnd = 0;
        if (endTurnRadiusRad !== undefined) {
            const endTheta = Math.PI - interceptAngleRad;
            minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
            if (isNaN(minDInterceptEnd)) {
                // Turn radius is too large for the end turn to join the intercept and final paths
                return 0;
            }
        }
        const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
        if (interceptToEndOffset < minDInterceptEnd) {
            // The intercept path does not intercept the final path early enough to make the end turn before the end point
            return 0;
        }
        let vectorIndex = index;
        if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            // The start turn ends too late to make a turn to join the final path or the start turn overshoots the end path
            // before reaching the intercept course -> attempt to end the start turn early
            if (endTurnRadiusRad === undefined) {
                // We don't need to calculate a final turn, so attempt to end the start turn where it intersects the end path
                const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
                if (startTurnEndPathIntersectionCount === 0) {
                    return 0;
                }
                const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === 'right' ? 0 : 1];
                if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The start turn intercepts the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
            }
            else {
                // We need to calculate a final turn to join the end path. This final turn must be tangent to the starting turn
                // and the end path.
                const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the starting turn
                const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the end path
                const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === 'left' ? 1 : -1));
                const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
                if (endTurnCircleCount === 0) {
                    return 0;
                }
                const endTurnCenter = intersections[0];
                const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === 'left' ? 'right' : 'left', InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
                endTurnCircle.closest(startTurnCenter, startTurnEnd);
                const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The end turn joins the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
            }
        }
        else {
            if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
            }
            let interceptPathEnd = intercept;
            if (endTurnRadiusRad !== undefined) {
                interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
            }
            if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
            }
            if (endTurnRadius !== undefined) {
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
            }
        }
        return vectorIndex - index;
    }
}
InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
        this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
        }
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        // Calculate the relative directions of the start point, intersection point, and end point.
        const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
        // positive -> start point lies after the intersection (with respect to the direction of start path)
        const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        // positive -> end point lies after the intersection (with respect to the direction of end path)
        const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        // along-track distance from the intersection point to the start/end of the minimum-radius turn from start path to end path
        let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        if (isNaN(minD)) {
            // Turn radius is too large for any turn to join the start and end paths
            minD = Infinity;
        }
        const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
        const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
        const towardEndPointTurnDirection = startPath.encircles(end, false) ? 'left' : 'right';
        let needCalculateTwoTurnPath = false;
        let needCalculateOneTurnPath = false;
        if (isEndForwardOfIntersection) {
            if (desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection) {
                const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
                const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
                if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
                    // The minimum turn radius is too large to intercept the final path before the end point
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
                else {
                    // Make a single constant-radius turn either starting at the start point, or ending at the end point,
                    // depending on which is closer to the intersection point.
                    const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
                    if (intersectionStartDistance <= intersectionEndDistance) {
                        // start turn at start point
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
                        if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
                        }
                    }
                    else {
                        // end turn at end point
                        let turnStart = start;
                        if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
                        }
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                    }
                }
            }
            else {
                if (pathDot >= 0) {
                    // The start and end paths intersect at an angle <= 90 degrees. This means that for a turn away from the end
                    // point, the total flight path distance is minimized when the turn joins the start and end paths directly.
                    if (intersectionStartOffset <= minD) {
                        // The start point lies at or before the required turn start point to minimize the flight path distance.
                        needCalculateOneTurnPath = true;
                    }
                    else {
                        needCalculateTwoTurnPath = !preferSingleTurn;
                        needCalculateOneTurnPath = preferSingleTurn;
                    }
                }
                else {
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
            }
        }
        else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
        }
        let needDirectFallback = false;
        if (needCalculateTwoTurnPath) {
            const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
            // Attempt to make a turn to intercept the end path at 45 degrees. At this point we are in fallback territory
            // so we won't honor the desired starting turn direction.
            const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, undefined, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
            if (numInterceptVectors === 0) {
                needDirectFallback = allowDirectFallback;
            }
            else {
                vectorIndex += numInterceptVectors;
                const lastVector = vectors[vectorIndex - 1];
                const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
                }
            }
        }
        else if (needCalculateOneTurnPath) {
            // Make a single constant-radius turn from the start path to join the end path. The turn must start after the
            // intersection of the start and end paths (the only case where the turn starts before the intersection is
            // handled above).
            if (minD > Math.PI / 2) {
                // No amount of anticipation can provide a turn which joins the start and end paths of the desired radius.
                needDirectFallback = allowDirectFallback;
            }
            else {
                const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
                const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
                const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
                const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
                if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
                }
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
                }
            }
        }
        if (needDirectFallback) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45; // degrees
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, undefined, flags);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, undefined, flags);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
class DirectToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
        let vectorIndex = index;
        if (typeof startPath === 'number') {
            startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
        }
        const endPos = DirectToPointBuilder.geoPointCache[0];
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            endPos.set(end);
            end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
        }
        else {
            endPos.setFromCartesian(end);
        }
        const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
        if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
            return vectorIndex - index;
        }
        else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
            return vectorIndex - index;
        }
        const startPathEncirclesTerminator = startPath.encircles(end);
        const startPathIncludesTerminator = startPath.includes(end);
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right');
        const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === 'left'
            ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2])
            : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
        const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
        // The angle between the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
        const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
        flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
        if (!GeoPoint.equals(turnEndVec, start)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
        }
        if (!GeoPoint.equals(turnEndVec, end)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, undefined, flags);
        }
        return vectorIndex - index;
    }
}
DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    getLegMagVar(leg, point) {
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR)) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR)) ? leg.fixIcao
                : undefined;
        const facility = facIcao !== undefined ? this.facilityCache.get(facIcao) : undefined;
        // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
        return facility === undefined ? MagVar.get(point) : -facility.magneticVariation;
    }
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
        var _a, _b, _c;
        var _d;
        const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : (_d.calculated = {
            courseMagVar: 0,
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            distance: 0,
            distanceWithTransitions: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTransitions: 0,
            flightPath: [],
            ingress: [],
            ingressJoinIndex: -1,
            ingressToEgress: [],
            egressJoinIndex: -1,
            egress: [],
            endsInFallback: false
        });
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            state.isFallback = calcs.endsInFallback;
            return calcs;
        }
        try {
            this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
            this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
            resolveIngressToEgress && this.resolveIngressToEgress(calcs);
            calcs.endsInFallback = state.isFallback;
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
            vectors.length = 0;
            calcs.ingress.length = 0;
            calcs.ingressJoinIndex = 0;
            calcs.egress.length = 0;
            calcs.egressJoinIndex = -1;
            calcs.ingressToEgress.length = 0;
            calcs.endsInFallback = false;
            state.isFallback = false;
        }
        return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
        FlightPathUtils.resolveIngressToEgress(legCalc);
    }
}
/**
 * Calculates flight path vectors for legs with no path.
 */
class NoPathLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.courseMagVar = 0;
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.flightPath.length = 0;
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            vectors.length = 0;
            state.isFallback = false;
            return;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            if (state.isFallback && state.currentCourse !== undefined) {
                vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
            }
            else {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            }
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        let initialCourse;
        if (leg.course !== 0) {
            // If a course is defined on the leg, then honor it.
            initialCourse = leg.trueDegrees ? leg.course % 360 : MagVar.magneticToTrue(leg.course, startPoint);
        }
        else {
            if (state.currentCourse === undefined) {
                // If the current course from the previous leg is undefined, then attempt to select an initial course from
                // the definition of the previous leg, if one exists.
                const prevLeg = legs[calculateIndex - 1];
                switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) {
                    case LegType.CA:
                    case LegType.CF:
                    case LegType.CR:
                    case LegType.FA:
                    case LegType.FC:
                    case LegType.FD:
                    case LegType.FM:
                    case LegType.VA:
                    case LegType.VD:
                    case LegType.VM:
                    case LegType.VR:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.HA:
                        // If the previous leg defines a course, then use that course.
                        initialCourse = this.getLegTrueCourse(prevLeg.leg, startPoint);
                        break;
                    case LegType.IF:
                        // If the previous leg is an IF for a runway fix, then use runway heading as the initial course.
                        if (ICAO.isFacility(prevLeg.leg.fixIcao, FacilityType.RWY)) {
                            const runwayFix = this.facilityCache.get(prevLeg.leg.fixIcao);
                            if (runwayFix) {
                                initialCourse = runwayFix.runway.course;
                                break;
                            }
                        }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        // If we can't select an initial course from the previous leg, then default to the course that puts us on a
                        // great-circle path from the start point to the terminator fix.
                        initialCourse = startPoint.bearingTo(terminatorPos);
                        // If the calculated course is NaN (only happens when the start and end points are coincident or antipodal),
                        // then just arbitrarily use true north.
                        if (isNaN(initialCourse)) {
                            initialCourse = 0;
                        }
                }
            }
            else {
                // If the current course from the previous leg is defined, use it.
                initialCourse = state.currentCourse;
            }
        }
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? 'left' : leg.turnDirection === LegTurnDirection.Right ? 'right' : undefined);
        state.currentPosition.set(terminatorPos);
        if (vectorIndex > 0) {
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            vectors.length = vectorIndex;
            return;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    /** @inheritdoc */
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, true);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.turnBuilder = new TurnToCourseBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
        this.interceptInfo = {
            circle: undefined,
            start: undefined,
            end: undefined
        };
        this.handleInvalidInterceptCache = {
            vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
            intersection: [new Float64Array(3), new Float64Array(3)]
        };
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
        if (course === undefined || !interceptInfo.circle || !state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        const effectiveInterceptPathStartVec = interceptInfo.start
            ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0])
            : interceptInfo.end
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI)
                : undefined;
        const effectiveInterceptPathEndVec = interceptInfo.end
            ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1])
            : interceptInfo.start
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI)
                : undefined;
        const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end
            ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI)
            : effectiveInterceptPathStartVec
                ? Math.PI
                : MathUtils.TWO_PI;
        const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
        const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
        const interceptPathStartVec = Vec3Math.copy(initialVec, this.vec3Cache[3]);
        let initialTurnVector = undefined;
        if (includeInitialTurn) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            initialTurnVector = vectors[vectorIndex - 1];
            GeoPoint.sphericalToCartesian(initialTurnVector.endLat, initialTurnVector.endLon, interceptPathStartVec);
        }
        const interceptPath = this.geoCircleCache[0].setAsGreatCircle(interceptPathStartVec, course);
        const startPath = this.geoCircleCache[1].set(interceptPath.center, interceptPath.radius);
        // If an initial turn exists, check if a fallback intercept is required because the end of the initial turn lies
        // past the path to intercept. If an initial turn does not exist, check if any fallback intercept is required.
        let fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, initialTurnVector !== undefined, false, this.vec3Cache[4]);
        if (initialTurnVector !== undefined) {
            if (fallbackInterceptVec === undefined) {
                // An initial turn exists and does not end past the path to intercept. Check if a fallback intercept is required
                // for another reason.
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, false, this.vec3Cache[4]);
            }
            else {
                // An initial turn exists and ends past the path to intercept. First check if the initial turn intersects the
                // path to intercept
                const turnCircle = FlightPathUtils.setGeoCircleFromVector(initialTurnVector, this.geoCircleCache[2]);
                const intersections = this.intersectionCache;
                const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
                if (numIntersections > 1) {
                    // Order intersections such that the one closer to the turn end is at index 0.
                    if (interceptInfo.circle.radius > MathUtils.HALF_PI !== interceptInfo.circle.encircles(initialVec)) {
                        const temp = intersections[0];
                        intersections[0] = intersections[1];
                        intersections[1] = temp;
                    }
                }
                for (let i = 0; i < numIntersections; i++) {
                    const intersection = intersections[i];
                    if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, interceptPathStartVec, intersection)
                        && (!effectiveInterceptPathStartVec
                            || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
                        // End the turn early at the intercept point
                        const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
                        if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                            const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                            initialTurnVector.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                            initialTurnVector.endLat = intersectionPoint.lat;
                            initialTurnVector.endLon = intersectionPoint.lon;
                            state.currentPosition.set(initialTurnVector.endLat, initialTurnVector.endLon);
                            state.currentCourse = FlightPathUtils.getVectorFinalCourse(initialTurnVector);
                        }
                        else {
                            vectorIndex--;
                        }
                        vectors.length = vectorIndex;
                        return;
                    }
                }
                // The initial turn does not intersect the path to intercept -> calculate a fallback intercept
                // without an initial turn (i.e. change the intercept path to start at the start of the leg).
                vectorIndex = 0;
                Vec3Math.copy(initialVec, interceptPathStartVec);
                interceptPath.setAsGreatCircle(interceptPathStartVec, course);
                startPath.setAsGreatCircle(interceptPathStartVec, startCourse);
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, true, this.vec3Cache[4]);
            }
        }
        if (fallbackInterceptVec === undefined) {
            vectorIndex += this.interceptBuilder.build(vectors, vectorIndex, interceptPathStartVec, course, interceptInfo.circle);
        }
        else {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, interceptPathStartVec, startPath, fallbackInterceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    calculateFallbackIntercept(start, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, onlyHandleInitialPointPastIntercept, forceFallback, out) {
        if (pathToInterceptCircle.includes(start)) {
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
                // Initial point already lies on the path to intercept.
                return forceFallback ? Vec3Math.copy(start, out) : undefined;
            }
        }
        // Determine if the starting position is "past" the path to intercept.
        let isInitialPosPastPath = false;
        const intersections = this.handleInvalidInterceptCache.intersection;
        const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
        let desiredIntersection;
        if (numIntersections === 2) {
            const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
            const prevIntersectionIndex = 1 - nextIntersectionIndex;
            const nextIntersection = intersections[nextIntersectionIndex];
            const prevIntersection = intersections[prevIntersectionIndex];
            // Define the desired intercept point as the one that requires the shortest distance traveled along the initial
            // path and path to intercept circle from the initial position to some point along the path to intercept. Then,
            // determine if the initial position lies before or after the desired intercept point, relative to the direction
            // of the initial path.
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
                isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
            }
            else {
                const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
                const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
                const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
                const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
                let prevIntersectionInterceptPathDistance = 0;
                let nextIntersectionInterceptPathDistance = 0;
                if (pathToInterceptStart && pathToInterceptEnd) {
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
                        const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
                        const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
                        prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
                    }
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
                        const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
                        const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
                        nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
                    }
                }
                const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
                const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
                // Only consider the starting position past the path to intercept if the path to intercept has a defined start
                // and end (i.e. is not a DME circle) OR the distance to one of the two intercept points is greater than pi/2
                // great-arc radians.
                if ((pathToInterceptStart !== undefined && pathToInterceptEnd !== undefined)
                    || (prevIntersectionTotalDistance >= MathUtils.HALF_PI || nextIntersectionTotalDistance >= MathUtils.HALF_PI)) {
                    isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
                }
            }
            desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
        }
        else if (numIntersections === 1) {
            const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
            isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
            desiredIntersection = intersections[0];
        }
        if ((onlyHandleInitialPointPastIntercept && !isInitialPosPastPath)) {
            return undefined;
        }
        let needHandleFallback = isInitialPosPastPath;
        if (!desiredIntersection) {
            // The intercept course does not intersect with the path to intercept circle at all -> define the desired
            // intercept point as the point on the path to intercept circle closest to the start point.
            desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
            needHandleFallback = true;
        }
        let fallbackIntercept;
        if ((!pathToInterceptStart || !pathToInterceptEnd)
            || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
            // The desired intercept point is within the bounds of the path to intercept -> only handle the fallback if we
            // need to (i.e. if the starting point is past the path to intercept, if the starting path does not intersect
            // the path to intercept, or fallback is forced)
            if (needHandleFallback || forceFallback) {
                fallbackIntercept = desiredIntersection;
            }
        }
        else {
            // The desired intercept point is not within the bounds of the path to intercept -> set the fallback intercept
            // point to the start or end of the path to intercept, whichever is closer to the desired intercept point.
            const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
            const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
            const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
            fallbackIntercept = distanceFromStart <= distanceFromEnd ? pathToInterceptStart : pathToInterceptEnd;
        }
        return fallbackIntercept === undefined ? undefined : Vec3Math.copy(fallbackIntercept, out);
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const dmeFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = dmeFacility === undefined ? 0 : this.getLegMagVar(leg.leg, dmeFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const radialFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = radialFacility === undefined ? 0 : this.getLegMagVar(leg.leg, radialFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (radialFacility) {
            const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
                ? -radialFacility.magneticVariation
                : MagVar.get(radialFacility);
            this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
            out.circle = this.radialCircle;
            out.start = radialFacility;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.predictLegPathCache = {
            geoPoint: [new GeoPoint(0, 0)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0)]
        };
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        const leg = legs[calculateIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = state.currentPosition === undefined ? 0 : this.getLegMagVar(leg.leg, state.currentPosition);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        out.circle = undefined;
        out.start = undefined;
        out.end = undefined;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return out;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
                    if (terminator) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    if (facility) {
                        out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = this.facilityCache.get(leg.fixIcao);
                    }
                    break;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    if (terminator && centerFacility) {
                        out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    if (origin) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
                        out.start = origin;
                    }
                    break;
                }
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (!pathStartPoint || !dmeFacility) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const dmeCircle = this.geoCircleCache[1].set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const interceptVec = this.vec3Cache[1];
        const intersections = this.intersectionCache;
        const numIntersections = path.intersection(dmeCircle, intersections);
        if (numIntersections === 0) {
            // The path along the leg's defined course does not intercept the DME circle -> define the intercept to be the
            // closest point on the DME circle to the initial fix.
            dmeCircle.closest(pathStartVec, interceptVec);
        }
        else {
            // The path along the leg's defined course intercepts the DME circle -> choose the first intercept when
            // proceeding along the path from the initial fix.
            const intersectionIndex = (numIntersections === 1 || dmeCircle.encircles(pathStartVec)) ? 0 : 1;
            Vec3Math.copy(intersections[intersectionIndex], interceptVec);
        }
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, interceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, interceptVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, interceptVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!pathStartPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const endVec = path.offsetDistanceAlong(pathStartVec, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN), this.vec3Cache[1], Math.PI);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, endVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, endVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            // We are in a fallback state -> plot a direct course to the terminator fix
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, undefined, FlightPathVectorFlags.Fallback);
            state.isFallback = false;
        }
        else {
            state.isFallback = false;
            const endCourse = this.getLegTrueCourse(leg, endPoint);
            const endVec = endPoint.toCartesian(this.vec3Cache[1]);
            const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
            if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
                // ---- CASE A ----
                // The leg begins at a discontinuity OR the previous leg is a manual termination leg.
                // Create a great-circle vector with a start point arbitrarily placed 5 NM from the terminator fix.
                const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
            }
            else {
                const startVec = startPoint.toCartesian(this.vec3Cache[0]);
                const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
                const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
                const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
                const isStartEqualToEnd = startPoint.equals(endPoint);
                const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
                // A great circle defining the threshold of the terminator fix - everything to the LEFT of (i.e. encircled by)
                // this great circle is past the terminator fix as projected along the end path.
                const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
                const isStartPastThreshold = threshold.encircles(startVec, false);
                // 175 degrees
                const areStartEndPathsAntiParallel = pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE;
                let isDone = false;
                if (!areStartEndPathsAntiParallel && isStartPastThreshold) {
                    // ---- CASE B ----
                    // The start and end paths are not antiparallel and the start point is past the terminator threshold.
                    let shouldTryFallback = true;
                    const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                        : leg.turnDirection === LegTurnDirection.Right ? 'right'
                            : undefined;
                    if (pathAngleDiff >= MathUtils.HALF_PI
                        && (desiredTurnDirection === undefined || (desiredTurnDirection === 'left') === startPath.encircles(endVec))) {
                        // The start path is either heading toward the terminator threshold or is parallel to it and the desired
                        // turn direction is not away from the end point. We now need to find the intersections between the start
                        // and end paths. There should be two intersections since both paths are great circles and they are not
                        // parallel or antiparallel.
                        const intersections = this.intersectionCache;
                        const solutionCount = startPath.intersection(endPath, intersections);
                        if (solutionCount === 2) {
                            // There are two general cases:
                            //
                            // 1. The end point lies past the intersection as measured along the end path.
                            // 2. The end point lies before the intersection as measured along the end path.
                            //
                            // In case 1, we can use the default algorithm for joining the start and end paths. Therefore there is
                            // nothing to do here; we just need to make sure the code falls through to Case E below.
                            //
                            // In case 2, we will try to join the start and end paths with a single constant radius turn. This will
                            // generate a "loop" where the path follows the start path initially away from the end point and then
                            // turns back onto the end path to head back to the end point. If that is not possible or the generated
                            // path is too long, we will fall through to Case E.
                            shouldTryFallback = false;
                            // Choose the intersection closest to the start point.
                            const intersection = Vec3Math.dot(intersections[0], startVec) > 0
                                ? intersections[0]
                                : intersections[1];
                            const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, this.vec3Cache[2]), endVec);
                            const isEndPastIntersection = intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE;
                            if (!isEndPastIntersection) {
                                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius, true, false, intersection);
                                if (vectorIndex !== 0) {
                                    // Find all the great-circle vectors in the path. These are all guaranteed to be parallel to either
                                    // the start or end paths. If the total distance of all these vectors is greater than a maximum
                                    // threshold, erase the vectors and let the code fall through to Case E, which will generate a
                                    // shorter path.
                                    let distance = 0;
                                    for (let i = 0; i < vectorIndex; i++) {
                                        const vector = vectors[i];
                                        if (FlightPathUtils.isVectorGreatCircle(vector)) {
                                            distance += vector.distance;
                                        }
                                    }
                                    if (distance > 37040 /* 20 nautical miles */) {
                                        vectorIndex = 0;
                                    }
                                }
                                isDone = vectorIndex > 0;
                            }
                        }
                    }
                    if (shouldTryFallback && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type)) {
                        // The leg does not end in a fly-over fix and the next leg is eligible for fallback -> end the current leg
                        // at the start point and set a fallback state.
                        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                        (_d = state.currentCourse) !== null && _d !== void 0 ? _d : (state.currentCourse = currentCourse);
                        state.isFallback = true;
                        isDone = true;
                    }
                }
                if (!isDone) {
                    if (areStartEndPathsAntiParallel) {
                        // ---- CASE C ----
                        // The start and end paths are antiparallel. We need to execute a procedure turn to do a 180.
                        let desiredTurnDirection;
                        switch (leg.turnDirection) {
                            // If the leg defines a turn direction, respect it.
                            case LegTurnDirection.Left:
                                desiredTurnDirection = 'left';
                                break;
                            case LegTurnDirection.Right:
                                desiredTurnDirection = 'right';
                                break;
                            default: {
                                const endDistanceFromStartPath = startPath.distance(endVec);
                                if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                                    // If the end point lies on the start path, then we want to turn toward the end path after passing
                                    // the end point along the start path (defaulting to a right turn if the start and end paths are
                                    // exactly antiparallel).
                                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? 'left' : 'right';
                                }
                                else {
                                    // If the end point does not lie on the start path, then we want to turn toward the end point from
                                    // the start path.
                                    desiredTurnDirection = endDistanceFromStartPath < 0 ? 'left' : 'right';
                                }
                            }
                        }
                        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
                        // procTurnBuilder will only build vectors up to the point where the proc turn intercepts the end path.
                        // So we need to check if we need to add a vector to connect the intercept point to the end point.
                        if (vectorIndex > 0) {
                            const lastVector = vectors[vectorIndex - 1];
                            const interceptVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                            if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) { // ~60 meter tolerance
                                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector.endLat, lastVector.endLon), endPoint);
                            }
                        }
                    }
                    else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE
                        && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE
                            || (!isStartEqualToEnd
                                && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                                    || (((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))))) {
                        // ---- CASE D ----
                        // The start and end paths are parallel, so we can just connect the start and end with a track.
                        // Or the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                        // least one calculated vector. In this case we will simply create a track from the start to end and let turn
                        // anticipation handle the initial turn into the final course.
                        if (!isStartEqualToEnd) {
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
                        }
                    }
                    else {
                        // ---- CASE E ----
                        // The default case. We will attempt to join the start and end paths with a single constant-radius turn
                        // toward the end point. If that is not possible, we will fall back to using two constant-radius turns. If
                        // that is not possible, we will fall back to a direct-to path from the start point to the end point.
                        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                                : undefined;
                        vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
                        const lastVector = vectors[vectorIndex - 1];
                        if (lastVector !== undefined
                            && !leg.flyOver
                            && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                            const lastVectorEndVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const lastVectorEndPath = FlightPathUtils.getGreatCircleTangentToVector(lastVectorEndVec, lastVector, this.geoCircleCache[3]);
                            const lastVectorCourseDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(lastVectorEndPath.center, endPath.center), -1, 1));
                            if (lastVectorCourseDiff > 0.0174533 /* 1 degree */) {
                                // We are allowed to use a fallback path which does not end at the defined terminator fix and a fallback
                                // direct-to path was calculated. We need to determine if we should end the direct-to path early if it
                                // crosses past the terminator threshold or remove it entirely and end the leg immediately at the start
                                // point.
                                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                                let useImmediateFallback = false;
                                let startTurnCircle;
                                let startTurnEnd;
                                // The direct-to path can consist of either a single turn vector, a single great-circle vector, or a
                                // starting turn vector followed by a great-circle vector.
                                if (FlightPathUtils.isVectorGreatCircle(lastVector)) {
                                    if (vectorIndex < 2) {
                                        // The direct-to path has a single great-circle vector. If the direct-to course differs from the end
                                        // course by more than 90 degrees, then the entire direct-to path is past the terminator threshold.
                                        // In that case we will end this leg at the start point and set a fallback state. If the direct-to
                                        // course is within 90 degrees of the end course, then the path must be entirely behind the
                                        // threshold. In that case we will leave the path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            useImmediateFallback = true;
                                        }
                                    }
                                    else {
                                        // The direct-to path consists of a starting turn followed by a great-circle vector. If the course of
                                        // the great-circle vector differs from the end course by more than 90 degrees, then we need to
                                        // deal with the possibility that the direct-to path starts behind the terminator threshold and then
                                        // crosses past the threshold. If the courses differ by 90 or degrees or less, then we will leave
                                        // the direct-to path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            if (isStartPastThreshold) {
                                                // If the start point is past the terminator threshold, then the entire direct-to path is
                                                // guaranteed to be past the terminator threshold. Therefore we will end this leg at the start
                                                // point and set a fallback state.
                                                useImmediateFallback = true;
                                            }
                                            else {
                                                // If the start point is not past the terminator threshold, then that means at some point the
                                                // direct-to path (specifically the starting turn) must cross the threshold. Therefore we will
                                                // trigger the evaluation code below to find out where we need to end the path early as it
                                                // crosses the threshold.
                                                const startTurnVector = vectors[vectorIndex - 2];
                                                startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                                                startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[3]);
                                            }
                                        }
                                    }
                                }
                                else {
                                    // The direct-to path is a single turn vector.
                                    if (isStartPastThreshold) {
                                        // If the start point is past the terminator threshold, we will end this leg at the start point and
                                        // set a fallback state.
                                        useImmediateFallback = true;
                                    }
                                    else {
                                        // If the start point is behind the terminator threshold, then it is possible the turn crosses past
                                        // the threshold before it ends. Therefore we will trigger the evaluation code below to find out if
                                        // we need to end the path early as it crosses the threshold.
                                        // If the direct course calculation produced only a single turn vector, it possibly reduced the radius
                                        // of the starting turn below the minimum radius in order to build a valid path to the terminator.
                                        // We always want the starting turn to respect the minimum turn radius, so we will define it ourselves.
                                        startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPath.encircles(endVec) ? 'left' : 'right'), this.geoCircleCache[3]);
                                        // If the direct course turn radius was reduced, then the terminator fix lies inside the starting turn
                                        // circle of minimum radius. Therefore, the turn technically never ends because there is no point on
                                        // the turn circle that either includes the terminator fix or is tangent to a great-circle path which
                                        // includes the terminator fix.
                                        if (Math.min(lastVector.radius, Math.PI - lastVector.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                                            startTurnEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[3]);
                                        }
                                    }
                                }
                                if (startTurnCircle !== undefined) {
                                    // Find the intersections of the direct-to starting turn circle with the terminator threshold.
                                    const intersections = this.intersectionCache;
                                    const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                                    // If the starting turn is tangent to the threshold, then the entire turn must be behind the threshold
                                    // because we are guaranteed that the start point is behind the threshold if we made it into this case.
                                    // Therefore, we only care about starting turns that are secant to the threshold.
                                    if (intersectionCount === 2) {
                                        // Because the start point is guaranteed to be behind the threshold, the next intersection of the
                                        // starting turn circle with the threshold will take the path past the threshold.
                                        const thresholdCrossing = intersections[0];
                                        const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                                        if (startTurnEnd === undefined
                                            || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                                            // The starting turn crosses the terminator threshold before the end of the turn (or the turn has
                                            // no end) -> end the turn at the crossing point and set the fallback state.
                                            vectorIndex = 0;
                                            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                                            state.isFallback = true;
                                        }
                                    }
                                }
                                if (useImmediateFallback) {
                                    vectorIndex = 0;
                                    ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                                    (_h = state.currentCourse) !== null && _h !== void 0 ? _h : (state.currentCourse = currentCourse);
                                    state.isFallback = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        const lastVector = vectors[vectorIndex - 1];
        if (lastVector !== undefined) {
            ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
];
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const originFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = originFacility === undefined ? 0 : MagVar.get(originFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            vectors.length = vectorIndex;
            return;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            vectors.length = vectorIndex;
            return;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            vectors.length = vectorIndex;
            return;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            vectors.length = vectorIndex;
            return;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
        state.currentPosition = undefined;
        state.currentCourse = undefined;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
            if (fixPosition) {
                state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
            }
        }
        if (!state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const holdFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = holdFacility === undefined ? 0 : this.getLegMagVar(leg.leg, holdFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const calcs = legs[calculateIndex].calculated;
        const vectors = calcs.flightPath;
        const ingress = calcs.ingress;
        let vectorIndex = 0, ingressVectorIndex = 0;
        const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            vectors.length = 0;
            ingress.length = 0;
            calcs.ingressJoinIndex = -1;
            return;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const turnRadiusMeters = state.desiredHoldTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
        const turnRadiusRad = state.desiredHoldTurnRadius.asUnit(UnitType.GA_RADIAN);
        const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        const oppositeCourse = NavMath.normalizeHeading(course + 180);
        const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
        const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
        const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
        if (isDirectEntry) {
            // direct entry
            if (directionalEntryCourse > 0) {
                // The entry course is toward the outbound leg, so we just intercept the outbound leg directly, bypassing
                // the turn from the inbound to outbound leg.
                ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, true, undefined, FlightPathVectorFlags.HoldDirectEntry);
                calcs.ingressJoinIndex = 1;
            }
            else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
                // Don't erase turn anticipation for direct entries
                ingressVectorIndex = ingress.length;
            }
        }
        else if (directionalEntryCourse > 110) {
            // teardrop entry
            if (directionalEntryCourse > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
                if (numTurnVectorsAdded > 0) {
                    ingressVectorIndex += numTurnVectorsAdded;
                    const turnVector = ingress[ingressVectorIndex - 1];
                    state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                    state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
                }
            }
            ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, true, undefined, FlightPathVectorFlags.HoldTeardropEntry);
            if (skipRacetrack) {
                // If we skip the racetrack, remove the part of the hold entry that is coincident with the inbound leg
                const lastEntryVector = ingress[ingressVectorIndex - 1];
                if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
                    if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
                        const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
                        lastEntryVector.endLat = lastEntryVectorEnd.lat;
                        lastEntryVector.endLon = lastEntryVectorEnd.lon;
                        lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                    }
                    else {
                        ingressVectorIndex--;
                    }
                }
            }
            calcs.ingressJoinIndex = 0;
        }
        else if (directionalEntryCourse < -70) {
            // parallel entry
            const parallelCourse = course + 180;
            const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
            if (numTurnVectorsAdded > 0) {
                ingressVectorIndex += numTurnVectorsAdded;
                const turnVector = ingress[ingressVectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            }
            ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
            calcs.ingressJoinIndex = 0;
        }
        ingress.length = ingressVectorIndex;
        if (ingress.length === 0) {
            calcs.ingressJoinIndex = -1;
        }
        let inboundStart;
        if (skipRacetrack) {
            inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
        }
        else {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, undefined, FlightPathVectorFlags.HoldOutboundLeg);
            const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            inboundStart = inboundTurnEnd;
        }
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, undefined, FlightPathVectorFlags.HoldInboundLeg);
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        vectors.length = vectorIndex;
    }
}

/**
 * Utility class for working with flight plans.
 */
class FlightPlanUtils {
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg) {
        switch (leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
                return leg.fixIcao;
            default:
                return undefined;
        }
    }
}
/** Array of "to altitude" leg types. */
FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
/** Array of "heading to" leg types. */
FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold" leg types. */
FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
/** Array of manual termination leg types that end in a discontinuity. */
FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
/** Array of discontinuity leg types. */
FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];

/**
 * A flight path calculator for turns between legs.
 */
class FlightPathTurnCalculator {
    constructor() {
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
        var _a, _b, _c, _d;
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const fromLeg = legs[currentIndex];
            const toLeg = legs[currentIndex + 1];
            const fromLegCalc = fromLeg === null || fromLeg === void 0 ? void 0 : fromLeg.calculated;
            const toLegCalc = toLeg === null || toLeg === void 0 ? void 0 : toLeg.calculated;
            if (fromLegCalc
                && toLegCalc
                && !FlightPlanUtils.isManualDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(toLeg.leg.type)) {
                const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
                const toVector = toLegCalc.flightPath[0];
                if (fromVector && toVector
                    && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))
                    && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                    if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
                        continue;
                    }
                    else if (toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                    else if (fromVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                }
            }
            if (fromLegCalc && BitFlags.isAll((_b = (_a = fromLegCalc.egress[0]) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, FlightPathVectorFlags.LegToLegTurn)) {
                fromLegCalc.egress.length = 0;
                fromLegCalc.egressJoinIndex = -1;
            }
            if (toLegCalc && BitFlags.isAll((_d = (_c = toLegCalc.ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
                toLegCalc.ingress.length = 0;
                toLegCalc.ingressJoinIndex = -1;
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        if (trackAngleDiff > 175) {
            return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (isRestrictedByPrevTurn) {
            if (previousTanTheta === undefined) {
                // Check to see if there is a ingress transition on the from leg and if it shares a common flight path vector
                // with the one involved in the turn currently being calculated.
                if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
                    const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
                    restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
                }
            }
            else {
                // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
                // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
                // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
                // previous turn. This will maximize min(radius_current, radius_prev).
                const tanThetaRatio = previousTanTheta / tanTheta;
                const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
                const cosTotalD = Math.cos(totalD);
                let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
                if (prevTurnRestrictedD > totalD) {
                    prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
                }
                restrictedD = prevTurnRestrictedD;
            }
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            // prevent zero-length turns
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        // Let the course reversal "cut"
        let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
                }
            }
        }
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
        const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? 'left' : 'right';
        const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === 'left' ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
        toLegCalc.ingress.length = length;
        toLegCalc.ingressJoinIndex = 0;
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        var _a, _b;
        var _c, _d;
        const fromLeg = legs[fromIndex];
        const toLeg = legs[toIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = fromLeg.calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = toLeg.calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        const areLegsContinuous = fromVectorEndPoint.equals(toVectorStartPoint, 1e-5);
        if (!areLegsContinuous) {
            // The from-leg does not end within ~60 meters of the start of the to-leg.
            let shouldQuit = true;
            // Either the from- or to- leg is an AF or RF leg. These legs often end up discontinuous with the preceding or
            // proceeding leg due to the arcs being slightly offset from the intended origin and/or terminator fixes.
            if (fromLeg.leg.type === LegType.AF
                || fromLeg.leg.type === LegType.RF
                || toLeg.leg.type === LegType.AF
                || toLeg.leg.type === LegType.RF) {
                shouldQuit = false;
            }
            if (shouldQuit) {
                return toIndex;
            }
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        // Define the circles
        const arcPath = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(arcPath, FlightPathTurnCalculator.geoPointCache[2]);
        const arcRadiusRad = FlightPathUtils.getTurnRadiusFromCircle(arcPath);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(arcPath);
        const arcCircle = FlightPathTurnCalculator.geoCircleCache[1].set(arcCenter, arcRadiusRad);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[2]);
        const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
        const fromVectorPath = isArcFirst ? arcPath : trackPath;
        const toVectorPath = isArcFirst ? trackPath : arcPath;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
        const arcTrackIntersectionCount = arcCircle.intersection(trackPath, arcTrackIntersections);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const fromVectorEndVec = fromVectorEndPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
        const toVectorStartVec = toVectorStartPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[1]);
        const fromVectorHalfDistanceRad = UnitType.METER.convertTo(fromVector.distance / 2, UnitType.GA_RADIAN);
        const toVectorHalfDistanceRad = UnitType.METER.convertTo(toVector.distance / 2, UnitType.GA_RADIAN);
        const intersectionPoint = FlightPathTurnCalculator.geoPointCache[4];
        const intersectionVec = FlightPathTurnCalculator.vector3Cache[2];
        let intersectionFromVectorEndOffset = 0;
        let intersectionToVectorStartOffset = 0;
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // The arc circle and track path are tangent.
            if (areLegsContinuous) {
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
            }
            else {
                // The from-leg does not end within ~60 meters of the start of the to-leg.
                Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                intersectionFromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, intersectionVec);
                intersectionToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, toVectorStartVec);
                if (!this.isArcTrackIntersectionValid(intersectionVec, fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersectionFromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersectionToVectorStartOffset)) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
            }
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                if (intersectionFromVectorEndOffset === 0 && intersectionToVectorStartOffset === 0) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                }
                else {
                    if (intersectionFromVectorEndOffset !== 0) {
                        // The intersection is not coincident with the end of the from-vector. The egress path will start 1
                        // nautical mile before the intersection point or at the end of the from-vector, whichever comes
                        // earlier (without going past the mid-point of the from-vector) and follow the from-vector path.
                        if (fromVectorHalfDistanceRad + intersectionFromVectorEndOffset <= 1e-5) {
                            // The intersection is at the mid-point of the from-vector.
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const egressStartVec = fromVectorPath.offsetDistanceAlong(intersectionVec, -Math.min(0.00029, Math.max(0, intersectionFromVectorEndOffset), fromVectorHalfDistanceRad + intersectionFromVectorEndOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, egressStartVec, intersectionVec);
                        }
                    }
                    if (intersectionToVectorStartOffset !== 0) {
                        // The intersection is not coincident with the start of the to-vector. The ingress path will end 1
                        // nautical mile after the intersection point or at the start of the to-vector, whichever comes
                        // later (without going past the mid-point of the to-vector) and follow the to-vector path.
                        if (toVectorHalfDistanceRad + intersectionToVectorStartOffset <= 1e-5) {
                            // The intersection is at the mid-point of the to-vector.
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const ingressEndVec = toVectorPath.offsetDistanceAlong(intersectionVec, Math.min(0.00029, Math.max(0, intersectionToVectorStartOffset), toVectorHalfDistanceRad + intersectionToVectorStartOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, ingressEndVec);
                        }
                    }
                }
                return toIndex;
            }
            else {
                intersectionPoint.setFromCartesian(intersectionVec);
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            // The arc circle and track path are secant.
            let arcStartVec;
            let arcEndVec;
            let fromVectorIntersectionBearing;
            let toVectorIntersectionBearing;
            if (areLegsContinuous) {
                intersectionPoint.set(fromVectorEndPoint);
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
                arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                fromVectorIntersectionBearing = fromVectorEndBearing;
                toVectorIntersectionBearing = toVectorStartBearing;
            }
            else {
                const intersection0FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[0]);
                const intersection0ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[0], toVectorStartVec);
                const intersection1FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[1]);
                const intersection1ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[1], toVectorStartVec);
                const isIntersection0Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[0], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection0FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection0ToVectorStartOffset);
                const isIntersection1Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[1], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection1FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection1ToVectorStartOffset);
                if (!isIntersection0Valid && !isIntersection1Valid) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
                let intersectionIndex;
                if (!isIntersection0Valid) {
                    intersectionIndex = 1;
                }
                else if (!isIntersection1Valid) {
                    intersectionIndex = 0;
                }
                else {
                    // Both intersections are valid. We will bias toward intersections that lie after the end of the from-vector
                    // and before the start of the to-vector.
                    if (intersection0FromVectorEndOffset + intersection0ToVectorStartOffset >= intersection1FromVectorEndOffset + intersection1ToVectorStartOffset) {
                        intersectionIndex = 0;
                    }
                    else {
                        intersectionIndex = 1;
                    }
                }
                if (intersectionIndex === 0) {
                    Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                    intersectionFromVectorEndOffset = intersection0FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection0ToVectorStartOffset;
                }
                else if (isIntersection1Valid) {
                    Vec3Math.copy(arcTrackIntersections[1], intersectionVec);
                    intersectionFromVectorEndOffset = intersection1FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection1ToVectorStartOffset;
                }
                intersectionPoint.setFromCartesian(intersectionVec);
                if (isArcFirst) {
                    arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                    arcEndVec = intersectionVec;
                }
                else {
                    arcStartVec = intersectionVec;
                    arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                }
                fromVectorIntersectionBearing = fromVectorPath.bearingAt(intersectionVec, Math.PI);
                toVectorIntersectionBearing = toVectorPath.bearingAt(intersectionVec, Math.PI);
            }
            const arcStartRadial = arcCircle.bearingAt(arcStartVec, Math.PI) + 90;
            const arcEndRadial = arcCircle.bearingAt(arcEndVec, Math.PI) + 90;
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), toVectorIntersectionBearing)) >= 90
                : Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), fromVectorIntersectionBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, intersectionVec, FlightPathTurnCalculator.vector3Cache[5]);
            // If the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadiusRad))
                : Infinity;
            const trackLimitPoint = FlightPathTurnCalculator.geoPointCache[5];
            if (isArcFirst) {
                const trackLimitDistance = Math.min(toVectorHalfDistanceRad + intersectionToVectorStartOffset, maxTrackLimitDistance);
                intersectionPoint.offset(toVectorStartBearing, trackLimitDistance, trackLimitPoint);
            }
            else {
                const trackLimitDistance = Math.min(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset, maxTrackLimitDistance);
                intersectionPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, trackLimitPoint);
            }
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(trackPath.center, arcCircle.center);
            const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // Compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = FlightPathTurnCalculator.geoCircleCache[4].setAsGreatCircle(arcDirection === 'left' ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            // the angular width of the portion of the arc path from the intersection to the mid-point of the arc vector
            const arcMidPointAngularWidth = Avionics.Utils.RAD2DEG * (isArcFirst
                ? fromVectorPath.angularWidth(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset)
                : toVectorPath.angularWidth(toVectorHalfDistanceRad + intersectionToVectorStartOffset));
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcMidPointAngularWidth);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * ((arcDirection === 'left') === isArcFirst ? 1 : -1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadiusRad, FlightPathTurnCalculator.geoPointCache[5]);
                const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadiusRad));
                        arcTurnRadiusLimit = (arcRadiusRad - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[5]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[6]), FlightPathTurnCalculator.vector3Cache[6]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[3].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[4].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || intersectionPoint.distance(intersections[0]) >= intersectionPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
        const turnRadiusMeters = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusMeters, turnCenter, turnStart, turnMiddle, turnEnd, areLegsContinuous);
        // If the from- and to- legs are not continuous, then we need to check if we need to extend the turn anticipation
        // path beyond the turn vector to join the from- and to- vectors. If the legs are continuous, we don't need to
        // check because the turn vector is guaranteed to begin before the end of the from-vector and end after the start
        // of the to-vector.
        if (!areLegsContinuous) {
            const intersectionTurnStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, turnStart, intersectionVec);
            const intersectionTurnEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, turnEnd);
            if (intersectionTurnStartOffset > intersectionFromVectorEndOffset + 1e-5) {
                // The turn begins after the end of the from-vector. We need to join the turn vector to the end of the
                // from-vector.
                Object.assign((_a = (_c = fromLegCalc.egress)[1]) !== null && _a !== void 0 ? _a : (_c[1] = FlightPathUtils.createEmptyCircleVector()), fromLegCalc.egress[0]);
                FlightPathUtils.setCircleVector(fromLegCalc.egress[0], fromVectorPath, fromVectorEndPoint, turnStart, fromLegCalc.egress[0].flags);
                fromLegCalc.egress.length = 2;
            }
            else {
                fromLegCalc.egress.length = 1;
            }
            if (intersectionTurnEndOffset < intersectionToVectorStartOffset - 1e-5) {
                // The turn ends before the start of the to-vector. We need to join the turn vector to the start of the
                // to-vector.
                (_b = (_d = toLegCalc.ingress)[1]) !== null && _b !== void 0 ? _b : (_d[1] = FlightPathUtils.createEmptyCircleVector());
                FlightPathUtils.setCircleVector(toLegCalc.ingress[1], toVectorPath, turnEnd, toVectorStartPoint, toLegCalc.ingress[0].flags);
                toLegCalc.ingress.length = 2;
            }
            else {
                toLegCalc.ingress.length = 1;
            }
        }
        return toIndex;
    }
    /**
     * Checks if an intersection between an arc path and a track path is valid for computing turn anticipation between
     * arc and track vectors. The intersection is considered valid if and only if all the following conditions are true:
     * - The intersection is within one nautical mile of the end of the vector on which the turn begins.
     * - The intersection is within one nautical mile of the start of the vector on which the turn ends.
     * - The intersection is located after the mid-point of the vector on which the turn begins.
     * - The intersection is located before the mid-point of the vector on which the turn ends.
     * @param intersection The intersection to check.
     * @param fromVectorPath A geo circle defining the path of the vector on which the turn begins.
     * @param fromVectorEnd The end point of the vector on which the turn begins.
     * @param fromVectorHalfDistance Half of the distance covered by the vector on which the turn begins.
     * @param intersectionFromVectorEndOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the end point of the vector on which the turn begins. Positive offsets indicate the intersection is located
     * after the end point.
     * @param toVectorPath A geo circle defining the path of the vector on which the turn ends.
     * @param toVectorStart The start point of the vector on which the turn ends.
     * @param toVectorHalfDistance Half of the distance covered by the vector on which the turn ends.
     * @param intersectionToVectorStartOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the start point of the vector on which the turn ends. Positive offsets indicate the intersection is located
     * before the start point.
     * @returns Whether the specified intersection is valid for computing turn anticipation between arc and track
     * vectors.
     */
    isArcTrackIntersectionValid(intersection, fromVectorPath, fromVectorEnd, fromVectorHalfDistance, intersectionFromVectorEndOffset, toVectorPath, toVectorStart, toVectorHalfDistance, intersectionToVectorStartOffset) {
        const fromVectorMidVec = fromVectorPath.offsetDistanceAlong(fromVectorEnd, -fromVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[0], Math.PI);
        const toVectorMidVec = toVectorPath.offsetDistanceAlong(toVectorStart, toVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[1], Math.PI);
        return (Math.abs(intersectionFromVectorEndOffset) <= 2.9e-4
            && Math.abs(intersectionToVectorStartOffset) <= 2.9e-4
            && FlightPathUtils.isPointAlongArc(fromVectorPath, fromVectorMidVec, Math.PI, intersection)
            && !FlightPathUtils.isPointAlongArc(toVectorPath, toVectorMidVec, Math.PI, intersection));
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        toLegCalc.ingress.length = 0;
        toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressEgressArrayLengths Whether to set the ingress and egress vector array lengths to 1. Defaults to
     * `true`.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end, setIngressEgressArrayLengths = true) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
        this.setAnticipatedTurnEgress(fromLegCalc, circle, start, middle, setIngressEgressArrayLengths);
        this.setAnticipatedTurnIngress(toLegCalc, circle, middle, end, setIngressEgressArrayLengths);
    }
    /**
     * Adds an egress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn begins.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the turn.
     * @param end The location of the end of the egress portion of the turn.
     * @param setEgressArrayLength Whether to set the egress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnEgress(legCalc, circle, start, end, setEgressArrayLength = true) {
        var _a;
        var _b;
        const egress = (_a = (_b = legCalc.egress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setEgressArrayLength) {
            legCalc.egress.length = 1;
        }
        legCalc.egressJoinIndex = legCalc.flightPath.length - 1;
        const egressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(egress, circle, start, end, egressFlags);
    }
    /**
     * Adds an ingress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn ends.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the ingress portion of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressArrayLength Whether to set the ingress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnIngress(legCalc, circle, start, end, setIngressArrayLength = true) {
        var _a;
        var _b;
        const ingress = (_a = (_b = legCalc.ingress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setIngressArrayLength) {
            legCalc.ingress.length = 1;
        }
        legCalc.ingressJoinIndex = 0;
        const ingressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(ingress, circle, start, end, ingressFlags);
    }
    /**
     * Gets the along-circle offset distance from a reference point to a query point, in great-arc radians. The offset
     * is signed, with positive values indicating offsets in the direction of the circle. The calculated offset has the
     * range `[-c / 2, c / 2)`, where `c` is the circumference of the circle.
     * @param circle The geo circle along which to measure the offset.
     * @param reference The reference point.
     * @param query The query point.
     * @param equalityTolerance The tolerance for considering the reference and query points to be equal, in great-arc
     * radians. If the absolute (direction-agnostic) along-circle distance between the reference and query points is less
     * than or equal to this value, then zero will be returned. Defaults to `0`.
     * @returns The along-circle offset distance from the specified reference point to the query point, in great-arc
     * radians.
     */
    static getAlongCircleOffset(circle, reference, query, equalityTolerance) {
        const circumference = circle.arcLength(MathUtils.TWO_PI);
        const halfCircumference = circumference / 2;
        return (circle.distanceAlong(reference, query, Math.PI, equalityTolerance) + halfCircumference) % circumference - halfCircumference;
    }
}
FlightPathTurnCalculator.vector3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
];
FlightPathTurnCalculator.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.isArcTrackIntersectionValidCache = {
    vec3: [Vec3Math.create(), Vec3Math.create()]
};
FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
};

/**
 * Modes for calculating airplane speed for use in flight path calculations.
 */
var FlightPathAirplaneSpeedMode;
(function (FlightPathAirplaneSpeedMode) {
    /** The default airplane speed is always used. */
    FlightPathAirplaneSpeedMode["Default"] = "Default";
    /** Ground speed is used. */
    FlightPathAirplaneSpeedMode["GroundSpeed"] = "GroundSpeed";
    /** True airspeed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeed"] = "TrueAirspeed";
    /** True airspeed plus wind speed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
})(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader, options, bus) {
        this.facilityLoader = facilityLoader;
        this.bus = bus;
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.turnCalculator = new FlightPathTurnCalculator();
        this.state = new FlightPathStateClass();
        this.calculateQueue = [];
        this.isBusy = false;
        this.options = Object.assign({}, options);
        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
        this.bus.getSubscriber().on('flightpath_set_options').handle(newOptions => this.setOptions(newOptions));
    }
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    setOptions(newOptions) {
        for (const key in newOptions) {
            const option = newOptions[key];
            if (option !== undefined) {
                this.options[key] = option;
                switch (key) {
                    case 'bankAngle':
                        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
                        break;
                    case 'holdBankAngle':
                        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
                        break;
                    case 'courseReversalBankAngle':
                        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
                        break;
                    case 'turnAnticipationBankAngle':
                        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
                        break;
                }
            }
        }
    }
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    buildBankAngleTable(angle) {
        if (typeof angle === 'number') {
            return new LerpLookupTable([[angle, 0]]);
        }
        else {
            return new LerpLookupTable(angle);
        }
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDmeLegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDmeLegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: calc = new NoPathLegCalculator(this.facilityCache),
            [LegType.ThruDiscontinuity]: calc
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        if (this.isBusy || this.calculateQueue.length > 0) {
            return new Promise((resolve, reject) => {
                this.calculateQueue.push(() => { this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count); });
            });
        }
        else {
            return new Promise((resolve, reject) => {
                this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
            });
        }
    }
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    async doCalculate(resolve, reject, legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        this.isBusy = true;
        try {
            initialIndex = Math.max(0, initialIndex);
            count = Math.max(0, Math.min(legs.length - initialIndex, count));
            this.state.updatePlaneState(this.options, this.bankAngleTable, this.holdBankAngleTable, this.courseReversalBankAngleTable, this.turnAnticipationBankAngleTable);
            // Because some facilities can be mutated, we always want to get the most up-to-date version from the facility loader
            this.facilityCache.clear();
            await this.loadFacilities(legs, initialIndex, count);
            this.initCurrentLatLon(legs, initialIndex);
            this.initCurrentCourse(legs, initialIndex);
            this.initIsFallback(legs, initialIndex);
            this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
            this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER), this.state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), this.state.desiredTurnAnticipationTurnRadius.asUnit(UnitType.METER));
            this.resolveLegsIngressToEgress(legs, initialIndex, count);
            this.updateLegDistances(legs, initialIndex, count);
            this.isBusy = false;
            resolve();
        }
        catch (e) {
            this.isBusy = false;
            reject(e);
        }
        const nextInQueue = this.calculateQueue.shift();
        if (nextInQueue !== undefined) {
            nextInQueue();
        }
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (ICAO.isFacility(icao)) {
            facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                .then(facility => {
                this.facilityCache.set(icao, facility);
                return true;
            })
                .catch(() => false));
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) || FlightPlanUtils.isManualDiscontinuityLeg(leg.leg.type)) {
                break;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initIsFallback(legs, initialIndex) {
        var _a, _b, _c;
        this.state.isFallback = (_c = (_b = (_a = legs[Math.min(initialIndex, legs.length) - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endsInFallback) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        const definition = legs[calculateIndex];
        const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
        const start = calcs.flightPath[0];
        const end = calcs.flightPath[calcs.flightPath.length - 1];
        calcs.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            calcs.endLat = this.state.currentPosition.lat;
            calcs.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const legCalc = legs[i].calculated;
            legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
        var _a, _b, _c, _d, _e, _f;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            // Calculate distance without transitions
            calc.distance = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distance += calc.flightPath[j].distance;
            }
            calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
            // Calculate distance with transitions
            calc.distanceWithTransitions = 0;
            const ingressLen = calc.ingress.length;
            for (let j = 0; j < ingressLen; j++) {
                calc.distanceWithTransitions += calc.ingress[j].distance;
            }
            const ingressToEgressLen = calc.ingressToEgress.length;
            for (let j = 0; j < ingressToEgressLen; j++) {
                calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
            }
            const egressLen = calc.egress.length;
            for (let j = 0; j < egressLen; j++) {
                calc.distanceWithTransitions += calc.egress[j].distance;
            }
            calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
    }
}
/**
 * An implementation of {@link FlightPathState}
 */
class FlightPathStateClass {
    constructor() {
        this.isFallback = false;
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
        this._desiredHoldTurnRadius = UnitType.METER.createNumber(0);
        this.desiredHoldTurnRadius = this._desiredHoldTurnRadius.readonly;
        this._desiredCourseReversalTurnRadius = UnitType.METER.createNumber(0);
        this.desiredCourseReversalTurnRadius = this._desiredCourseReversalTurnRadius.readonly;
        this._desiredTurnAnticipationTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnAnticipationTurnRadius = this._desiredTurnAnticipationTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     * @param bankAngleTable A lookup table for general turn bank angle, in degrees, versus airplane speed.
     * @param holdBankAngleTable A lookup table for hold turn bank angle, in degrees, versus airplane speed, in knots.
     * If not defined, the general turn bank angle table will be used instead.
     * @param courseReversalBankAngleTable A lookup table for course reversal turn bank angle, in degrees, versus
     * airplane speed, in knots. If not defined, the general turn bank angle table will be used instead.
     * @param turnAnticipationBankAngleTable A lookup table for turn anticipation bank angle, in degrees, versus airplane
     * speed, in knots. If not defined, the general turn bank angle table will be used instead.
     */
    updatePlaneState(options, bankAngleTable, holdBankAngleTable, courseReversalBankAngleTable, turnAnticipationBankAngleTable) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        switch (options.airplaneSpeedMode) {
            case FlightPathAirplaneSpeedMode.GroundSpeed:
                this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
                break;
            case FlightPathAirplaneSpeedMode.TrueAirspeed:
            case FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind: {
                const trueAirspeed = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots);
                const windSpeed = options.airplaneSpeedMode === FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
                    ? SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', SimVarValueType.Knots)
                    : 0;
                this._planeSpeed.set(Math.max(trueAirspeed + windSpeed, options.defaultSpeed));
                break;
            }
            default:
                this._planeSpeed.set(options.defaultSpeed);
        }
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        const planeSpeedKnots = this._planeSpeed.asUnit(UnitType.KNOT);
        this._desiredTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(bankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        if (holdBankAngleTable) {
            this._desiredHoldTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(holdBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredHoldTurnRadius.set(this._desiredTurnRadius);
        }
        if (courseReversalBankAngleTable) {
            this._desiredCourseReversalTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(courseReversalBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredCourseReversalTurnRadius.set(this._desiredTurnRadius);
        }
        if (turnAnticipationBankAngleTable) {
            this._desiredTurnAnticipationTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(turnAnticipationBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredTurnAnticipationTurnRadius.set(this._desiredTurnRadius);
        }
    }
}

/** Utility functions for working with UUIDs. */
class UUID {
    /**
     * A function to generate a spec-compliand v4 UUID in a 32-bit safe way.
     * @returns A UUID in standard 8-4-4-4-12 notation.
     */
    static GenerateUuid() {
        const scale = 2 ** 32;
        const first = UUID.bytesToHexString(Math.random() * scale);
        const fourth = UUID.bytesToHexString(Math.random() * scale);
        let secondBits = Math.random() * scale;
        let thirdBits = Math.random() * scale;
        // 4 MSB of seventh byte = 0100
        secondBits |= 0b00000000000000000100000000000000;
        secondBits &= 0b11111111111111110100111111111111;
        const second = UUID.bytesToHexString(secondBits);
        // 2 MSB of ninth byte = 10;
        thirdBits |= 0b10000000000000000000000000000000;
        thirdBits &= 0b10111111111111111111111111111111;
        const third = UUID.bytesToHexString(thirdBits);
        return `${first}-${second.substring(0, 4)}-${second.substring(4)}-${third.substring(0, 4)}-${third.substring(4)}${fourth}`;
    }
    /**
     * Take a number and return its hexadecimal representation.
     * @param bits The bytes to format.
     * @returns The input bits as a hexadecimal string.
     */
    static bytesToHexString(bits) {
        let string = (bits >>> 0).toString(16);
        string = '00000000'.substring(string.length) + string;
        return string;
    }
}

var LegEventType;
(function (LegEventType) {
    LegEventType["Added"] = "Added";
    LegEventType["Removed"] = "Removed";
    LegEventType["Changed"] = "Changed";
})(LegEventType || (LegEventType = {}));
var SegmentEventType;
(function (SegmentEventType) {
    SegmentEventType["Added"] = "Added";
    SegmentEventType["Removed"] = "Removed";
    SegmentEventType["Changed"] = "Changed";
    SegmentEventType["Inserted"] = "Inserted";
})(SegmentEventType || (SegmentEventType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
        this.batchEntryStack = [];
        this.batchToCloseIndex = undefined;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex, endIndex) {
        return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex = 0, endIndex = this.length) {
        endIndex = Math.min(this.length, endIndex);
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.min(segment.legs.length, endIndex - segment.offset);
                if (end <= 0) {
                    return;
                }
                for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
        endIndex = Math.max(-1, endIndex);
        for (let i = this.planSegments.length - 1; i > -1; i--) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.max(-1, endIndex - segment.offset);
                if (end >= segment.legs.length) {
                    return;
                }
                for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        const segment = this.tryGetSegment(segmentIndex);
        if (segment === null) {
            throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
        }
        else {
            return segment;
        }
    }
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
        const leg = this._tryGetLeg(arg1, arg2);
        if (leg) {
            return leg;
        }
        throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
        return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
        var _a, _b;
        if (arg2 === undefined) {
            const legIndex = arg1;
            for (const segment of this.segments()) {
                if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                    return segment.legs[legIndex - segment.offset];
                }
            }
            return null;
        }
        else {
            const segmentIndex = arg1;
            const segmentLegIndex = arg2;
            return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
        }
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
        const segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex === -1) {
            return -1;
        }
        return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Gets the current modification batch stack.
     * @returns The current modification batch stack, or `undefined` if there are no open batches.
     */
    getBatchStack() {
        return this.batchEntryStack.length > 0 ? this.batchEntryStack.map(entry => entry.batch) : undefined;
    }
    /**
     * Opens a new modification batch. The new batch will be nested within the most recently opened batch that has not
     * yet been closed. While a batch is open, all modifications made to this flight plan will be assigned to the batch.
     * The use of batches is informational only and will not affect the timing or execution of flight plan modifications.
     * All modifications are carried out immediately when the corresponding method is called regardless of whether they
     * are assigned to a batch.
     * @param name The name to assign to the new batch.
     * @returns The UUID of the new batch.
     */
    openBatch(name) {
        const parent = this.batchEntryStack[this.batchEntryStack.length - 1];
        const uuid = UUID.GenerateUuid();
        const batch = { uuid, name };
        const entry = {
            batch,
            parent,
            isClosed: false,
            pendingCalculateCount: 0,
        };
        this.batchEntryStack.push(entry);
        this.events.onBatchOpened && this.events.onBatchOpened(batch);
        return uuid;
    }
    /**
     * Closes a modification batch.
     * @param uuid The UUID of the batch to close. If defined, then the batch with the specified UUID and all open
     * batches that are nested within it will be closed (with the most-nested batch closed first, followed by the next
     * most-nested batch, and so on). If not defined, then the most recently opened batch that has not yet been closed
     * (i.e. the most-nested open batch) will be closed.
     */
    closeBatch(uuid) {
        let stopIndex = this.batchEntryStack.length;
        if (uuid === undefined) {
            if (this.batchEntryStack.length > 0) {
                stopIndex = this.batchEntryStack.length - 1;
            }
        }
        else {
            const index = this.batchEntryStack.findIndex(entry => entry.batch.uuid === uuid);
            if (index >= 0) {
                stopIndex = index;
            }
        }
        this.closeBatchIndex(stopIndex);
    }
    /**
     * Closes all currently open modification batches.
     */
    closeAllBatches() {
        this.closeBatchIndex(0);
    }
    /**
     * Closes an indexed modification batch and all batches that are nested within it.
     * @param index The index of the batch to close.
     */
    closeBatchIndex(index) {
        index = Math.max(index, 0);
        // Check if a batch closure operation is currently in progress. If one is not, then start a new batch closure
        // operation. If one is in progress, then mark the index of the new batch to close if and only if it is less-
        // nested than the in-progress operation's current batch to close.
        if (this.batchToCloseIndex === undefined) {
            this.batchToCloseIndex = index;
            while (this.batchEntryStack.length > this.batchToCloseIndex) {
                const entry = this.batchEntryStack.pop();
                const currentBatchToCloseIndex = this.batchToCloseIndex;
                const isClosingLast = this.batchEntryStack.length === currentBatchToCloseIndex + 1;
                entry.isClosed = true;
                this.events.onBatchClosed && this.events.onBatchClosed(entry.batch);
                if (entry.pendingCalculateCount === 0) {
                    this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(entry.batch);
                }
                // If we closed the last batch and no less-nested batches were marked for closure, then we will end the
                // loop. This is to prevent us from closing any batches that were newly opened in the callbacks for closing
                // the last batch.
                if (isClosingLast && this.batchToCloseIndex === currentBatchToCloseIndex) {
                    break;
                }
            }
            this.batchToCloseIndex = undefined;
        }
        else {
            this.batchToCloseIndex = Math.min(this.batchToCloseIndex, index);
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment, this.getBatchStack());
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment, this.getBatchStack());
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = {
            name: this.onLegNameRequested(leg),
            leg,
            flags,
            verticalData: {
                phase: VerticalFlightPhase.Descent,
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0,
                displayAltitude1AsFlightLevel: false,
                displayAltitude2AsFlightLevel: false,
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS,
            },
            userData: {}
        };
        if (segmentLegIndex === undefined) {
            segment.legs.push(legDefinition);
            segmentLegIndex = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(segmentLegIndex, 0, legDefinition);
        }
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition, this.getBatchStack());
        return legDefinition;
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (segmentLegIndex === undefined) {
            legDefinition = segment.legs.pop();
            segmentLegIndex = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(segmentLegIndex, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition, this.getBatchStack());
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao, this.getBatchStack());
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao, this.getBatchStack());
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao, this.getBatchStack());
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalRunway = undefined;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao, this.getBatchStack());
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral, this.getBatchStack());
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical, this.getBatchStack());
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating, this.getBatchStack());
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        // We iterate of the keys of `details` because we need to be able to set fields to undefined
        // and we only want to overwrite fields that were in the `details` object
        for (const key of Object.keys(details)) {
            this.procedureDetails[key] = details[key];
        }
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails, this.getBatchStack());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            const globalLegIndex = arg1;
            if (globalLegIndex >= 0) {
                segmentIndex = this.getSegmentIndex(globalLegIndex);
                if (segmentIndex >= 0) {
                    segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData, this.getBatchStack());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
        let notify = true;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let verticalData;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            verticalData = arg2;
            notify = arg3 !== undefined ? arg3 : notify;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            verticalData = arg3;
            notify = arg4 !== undefined ? arg4 : notify;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            Object.assign(leg.verticalData, verticalData);
            notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg, this.getBatchStack());
        }
        else {
            console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment, this.getBatchStack());
    }
    /**
     * Sets a global key-value user data pair for this flight plan. Setting a key's user data to `undefined` will delete
     * the key instead.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers. Defaults to true.
     */
    setUserData(key, data, notify = true) {
        if (data === undefined) {
            this.deleteUserData(key, notify);
            return;
        }
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data, this.getBatchStack());
    }
    /**
     * Deletes a global key-value user data pair for this flight plan.
     * @param key The key to delete.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key, this.getBatchStack());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegUserData(arg1, arg2, arg3, arg4, arg5) {
        let notify;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let key;
        let data;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            key = arg2;
            data = arg3;
            notify = arg4 === undefined ? true : arg4;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            key = arg3;
            data = arg4;
            notify = arg5 === undefined ? true : arg5;
        }
        if (data === undefined) {
            this.deleteLegUserData(segmentIndex, segmentLegIndex, key, notify);
            return;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            leg.userData[key] = data;
            notify && this.events.onLegUserDataSet && this.events.onLegUserDataSet(segmentIndex, segmentLegIndex, leg, key, data, this.getBatchStack());
        }
        else {
            console.warn(`FlightPlan: failed to set leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    deleteLegUserData(arg1, arg2, arg3, arg4) {
        let notify;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let key;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            key = arg2;
            notify = arg3 === undefined ? true : arg3;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            key = arg3;
            notify = arg4 === undefined ? true : arg4;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            delete leg.userData[key];
            notify && this.events.onLegUserDataDelete && this.events.onLegUserDataDelete(segmentIndex, segmentLegIndex, leg, key, this.getBatchStack());
        }
        else {
            console.warn(`FlightPlan: failed to delete leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = undefined, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        this.procedureDetails.arrivalRunway = arrivalRunway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
        const batchStack = this.getBatchStack();
        const batchEntry = this.batchEntryStack[this.batchEntryStack.length - 1];
        let currentBatchEntry = batchEntry;
        while (currentBatchEntry) {
            currentBatchEntry.pendingCalculateCount++;
            currentBatchEntry = currentBatchEntry.parent;
        }
        notify && this.events.onCalculatePended && this.events.onCalculatePended(globalLegIndex, batchStack);
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
        notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex, batchStack);
        currentBatchEntry = batchEntry;
        while (currentBatchEntry) {
            currentBatchEntry.pendingCalculateCount--;
            if (currentBatchEntry.isClosed && currentBatchEntry.pendingCalculateCount === 0) {
                this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(currentBatchEntry.batch);
            }
            currentBatchEntry = currentBatchEntry.parent;
        }
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex, copyCalcs = false) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        newPlan.copyFrom(this, copyCalcs);
        return newPlan;
    }
    /**
     * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
     * @param sourcePlan The plan to copy from.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     */
    copyFrom(sourcePlan, copyCalcs = false) {
        if (sourcePlan._originAirport !== undefined) {
            this.setOriginAirport(sourcePlan._originAirport, false);
        }
        else {
            this.removeOriginAirport(false);
        }
        if (sourcePlan._destinationAirport !== undefined) {
            this.setDestinationAirport(sourcePlan._destinationAirport, false);
        }
        else {
            this.removeDestinationAirport(false);
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        this.setProcedureDetails(Object.assign(new ProcedureDetails(), sourcePlan.procedureDetails), false);
        const targetPlanSegmentsCount = this.planSegments.length;
        for (let i = 0; i < targetPlanSegmentsCount; i++) {
            this.removeSegment(0, false);
        }
        for (let i = 0; i < sourcePlan.planSegments.length; i++) {
            const segment = sourcePlan.planSegments[i];
            if (segment !== undefined) {
                this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
                for (const leg of segment.legs) {
                    const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
                    const legIndex = this.getLegIndexFromLeg(newLeg);
                    this.setLegVerticalData(legIndex, leg.verticalData, false);
                    for (const key in leg.userData) {
                        this.setLegUserData(legIndex, key, leg.userData[key], false);
                    }
                    copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
                }
            }
        }
        this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex, false);
        // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
        this.setLateralLeg(sourcePlan._activeLateralLeg, false);
        this.setVerticalLeg(sourcePlan._activeVerticalLeg, false);
        this.setCalculatingLeg(sourcePlan._activeCalculatingLeg, false);
        for (const key in this.userData) {
            this.deleteUserData(key, false);
        }
        for (const key in sourcePlan.userData) {
            this.setUserData(key, sourcePlan.userData[key], false);
        }
    }
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    static copyLegCalculations(existingLeg, newLeg) {
        if (existingLeg.calculated !== undefined) {
            newLeg.calculated = {
                courseMagVar: existingLeg.calculated.courseMagVar,
                initialDtk: existingLeg.calculated.initialDtk,
                distance: existingLeg.calculated.distance,
                cumulativeDistance: existingLeg.calculated.cumulativeDistance,
                distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
                cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
                startLat: existingLeg.calculated.startLat,
                startLon: existingLeg.calculated.startLon,
                endLat: existingLeg.calculated.endLat,
                endLon: existingLeg.calculated.endLon,
                flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
                ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
                ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
                ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
                egressJoinIndex: existingLeg.calculated.egressJoinIndex,
                egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
                endsInFallback: existingLeg.calculated.endsInFallback
            };
        }
        return newLeg;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0,
    verticalAngle: 0,
}, partial);

/**
 * An implementation of {@link SubEventInterface}.
 */
class SubEvent {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    on(handler, paused = false) {
        const sub = new HandlerSubscription(handler, undefined, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /** @inheritdoc */
    clear() {
        this.notifyDepth++;
        for (let i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
        }
        this.notifyDepth--;
        if (this.notifyDepth === 0) {
            this.subs.length = 0;
        }
    }
    /** @inheritdoc */
    notify(sender, data) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(sender, data);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`SubEvent: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(bus, calculator, onLegNameRequested = FlightPlanner.buildDefaultLegName) {
        this.bus = bus;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        this.syncedBatchEntries = [];
        /** Invoked when we receive a flight plan response event. */
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(data => !this.ignoreSync && this.onFlightPlanRequest(data));
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplLegUserDataSet').handle(data => !this.ignoreSync && this.onLegUserDataSet(data));
        subscriber.on('fplsync_fplLegUserDataDelete').handle(data => !this.ignoreSync && this.onLegUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
        subscriber.on('fplsync_fplCalculatePended').handle(data => !this.ignoreSync && this.onCalculatePended(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplBatchOpened').handle(data => !this.ignoreSync && this.onBatchOpened(data));
        subscriber.on('fplsync_fplBatchClosed').handle(data => !this.ignoreSync && this.onBatchClosed(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    onFlightPlanRequest(data) {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            uid: data.uid,
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', { uid: this.lastRequestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER) }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        if (data.uid !== this.lastRequestUid) {
            return;
        }
        this.lastRequestUid = undefined;
        for (let i = 0; i < data.flightPlans.length; i++) {
            // ignore bogus flight plans
            if (data.flightPlans[i].segmentCount === 0) {
                continue;
            }
            const newPlan = new FlightPlan(i, this.calculator, this.onLegNameRequested);
            newPlan.copyFrom(data.flightPlans[i], true);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
            // Make sure the newly loaded plans are calculated at least once from the beginning
            newPlan.calculate(0);
        }
        // Only process a plan index changed event if the plan actually exists.
        if (this.flightPlans[data.planIndex]) {
            this.onPlanIndexChanged(data);
        }
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            this.syncedBatchEntries[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: this.sendLegChanged.bind(this, planIndex),
            onSegmentChanged: this.sendSegmentChanged.bind(this, planIndex),
            onActiveLegChanged: this.sendActiveLegChange.bind(this, planIndex),
            onOriginDestChanged: this.sendOriginDestChanged.bind(this, planIndex),
            onProcedureDetailsChanged: this.sendProcedureDetailsChanged.bind(this, planIndex),
            onUserDataSet: this.sendUserDataSet.bind(this, planIndex),
            onUserDataDelete: this.sendUserDataDelete.bind(this, planIndex),
            onLegUserDataSet: this.sendLegUserDataSet.bind(this, planIndex),
            onLegUserDataDelete: this.sendLegUserDataDelete.bind(this, planIndex),
            onDirectDataChanged: this.sendDirectToData.bind(this, planIndex),
            onCalculatePended: this.sendCalculatePended.bind(this, planIndex),
            onCalculated: this.sendCalculated.bind(this, planIndex),
            onBatchOpened: this.sendBatchOpened.bind(this, planIndex),
            onBatchClosed: this.sendBatchClosed.bind(this, planIndex),
            onBatchAsyncClosed: this.sendBatchAsyncClosed.bind(this, planIndex),
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, copyCalcs = false, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        if (this.flightPlans[targetPlanIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.flightPlans[targetPlanIndex].copyFrom(sourcePlan, copyCalcs);
        }
        else {
            const newPlan = sourcePlan.copy(targetPlanIndex, copyCalcs);
            newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
            this.flightPlans[targetPlanIndex] = newPlan;
        }
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex, copyCalcs);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, data.copyCalcs, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    sendPlanCopied(planIndex, targetPlanIndex, copyCalcs) {
        var _a;
        const data = { planIndex, targetPlanIndex, copyCalcs, batch: (_a = this.flightPlans[targetPlanIndex]) === null || _a === void 0 ? void 0 : _a.getBatchStack() };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        let localLeg;
        switch (data.type) {
            case LegEventType.Added: {
                localLeg = plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
                break;
            }
            case LegEventType.Removed: {
                const leg = plan.removeLeg(data.segmentIndex, data.legIndex, false);
                // We don't want to send the event locally if we didn't find a leg
                if (!leg) {
                    return;
                }
                localLeg = leg;
                break;
            }
            case LegEventType.Changed: {
                try {
                    localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
                }
                catch (_a) {
                    // We don't want to send the event locally if we didn't find a leg
                    return;
                }
                plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
                break;
            }
        }
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg,
            batch: data.batch
        };
        this.sendEvent('fplLegChange', localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg, batch) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg, batch
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        var _a, _b;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        let localSegment = undefined;
        switch (data.type) {
            case SegmentEventType.Added:
                localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Inserted:
                localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Removed:
                localSegment = (_a = plan.tryGetSegment(data.segmentIndex)) !== null && _a !== void 0 ? _a : undefined;
                plan.removeSegment(data.segmentIndex, false);
                break;
            case SegmentEventType.Changed:
                localSegment = data.segment === undefined ? undefined : (_b = plan.tryGetSegment(data.segmentIndex)) !== null && _b !== void 0 ? _b : undefined;
                if (localSegment === undefined) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the segment with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            segment: localSegment,
            batch: data.batch
        };
        this.sendEvent('fplSegmentChange', localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendSegmentChanged(planIndex, index, type, segment, batch) {
        const data = {
            planIndex, segmentIndex: index, type, segment, batch
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type, batch) {
        const data = {
            planIndex,
            index,
            segmentIndex, legIndex,
            previousSegmentIndex, previousLegIndex,
            type,
            batch
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendOriginDestChanged(planIndex, type, airport, batch) {
        const data = { planIndex, type, airport, batch };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        plan.setProcedureDetails(Object.assign(new ProcedureDetails(), data.details), false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendProcedureDetailsChanged(planIndex, details, batch) {
        const data = { planIndex, details, batch };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to global user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to global user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a global user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     * @param batch The modification batch to which the change was assigned.
     */
    sendUserDataSet(planIndex, key, userData, batch) {
        const data = { planIndex, key, data: userData, batch };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a global user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param batch The modification batch to which the change was assigned.
     */
    sendUserDataDelete(planIndex, key, batch) {
        const data = { planIndex, key, batch };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to flight plan leg user data set sync events.
     * @param data The event data.
     */
    onLegUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const localLeg = plan.tryGetLeg(data.segmentIndex, data.segmentIndex);
        if (!localLeg) {
            return;
        }
        plan.setLegUserData(data.segmentIndex, data.legIndex, data.key, data.data, false);
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg,
            key: data.key,
            data: data.data,
            batch: data.batch
        };
        this.sendEvent('fplLegUserDataSet', localData, false);
    }
    /**
     * A callback which is called in response to flight plan leg user data delete sync events.
     * @param data The event data.
     */
    onLegUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const localLeg = plan.tryGetLeg(data.segmentIndex, data.segmentIndex);
        if (!localLeg) {
            return;
        }
        plan.deleteLegUserData(data.segmentIndex, data.legIndex, data.key, false);
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg,
            key: data.key,
            batch: data.batch
        };
        this.sendEvent('fplLegUserDataDelete', localData, false);
    }
    /**
     * Sends a flight plan leg user data set event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment containing the user data's flight plan leg.
     * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
     * @param leg The user data's flight plan leg.
     * @param key The key of the user data.
     * @param userData The data that was set.
     * @param batch The modification batch to which the change was assigned.
     */
    sendLegUserDataSet(planIndex, segmentIndex, segmentLegIndex, leg, key, userData, batch) {
        const data = { planIndex, segmentIndex, legIndex: segmentLegIndex, leg, key, data: userData, batch };
        this.sendEvent('fplLegUserDataSet', data, true);
    }
    /**
     * Sends a flight plan leg user data delete event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment containing the user data's flight plan leg.
     * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
     * @param leg The user data's flight plan leg.
     * @param key The key of the user data that was deleted.
     * @param batch The modification batch to which the change was assigned.
     */
    sendLegUserDataDelete(planIndex, segmentIndex, segmentLegIndex, leg, key, batch) {
        const data = { planIndex, segmentIndex, legIndex: segmentLegIndex, leg, key, batch };
        this.sendEvent('fplLegUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     * @param batch The modification batch to which the change was assigned.
     */
    sendDirectToData(planIndex, directToData, batch) {
        const data = { planIndex, directToData: directToData, batch };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * A callback which is called in response to calculation pended sync events.
     * @param data The event data.
     */
    async onCalculatePended(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const syncedBatchEntries = this.syncedBatchEntries[data.planIndex];
        if (syncedBatchEntries && data.batch) {
            for (let i = data.batch.length - 1; i >= 0; i--) {
                const batch = data.batch[i];
                const entry = syncedBatchEntries.get(batch.uuid);
                if (entry) {
                    entry.pendingCalculateCount++;
                }
            }
        }
        this.sendEvent('fplCalculatePended', data, false);
        await plan.calculate(data.index, false);
        if (this.flightPlans[data.planIndex] !== plan) {
            return;
        }
        this.sendEvent('fplCalculated', data, false);
        if (syncedBatchEntries && data.batch) {
            for (let i = data.batch.length - 1; i >= 0; i--) {
                const batch = data.batch[i];
                const entry = syncedBatchEntries.get(batch.uuid);
                if (entry) {
                    entry.pendingCalculateCount--;
                    if (entry.isClosed && entry.pendingCalculateCount === 0) {
                        this.sendEvent('fplBatchAsyncClosed', entry.eventData, false);
                        syncedBatchEntries.delete(batch.uuid);
                    }
                }
            }
        }
    }
    /**
     * Sends a calculate pended event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the flight plan leg that the path is to be generated from.
     * @param batch The modification batch to which the calculation was assigned.
     */
    sendCalculatePended(planIndex, index, batch) {
        const data = { planIndex, index, batch };
        this.sendEvent('fplCalculatePended', data, true);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the flight plan leg that the path was generated from.
     * @param batch The modification batch to which the calculation was assigned.
     */
    sendCalculated(planIndex, index, batch) {
        const data = { planIndex, index, batch };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to modification batch opened sync events.
     * @param data The event data.
     */
    onBatchOpened(data) {
        var _a;
        var _b, _c;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const localData = { planIndex: data.planIndex, isSynced: true, batch: data.batch };
        const entries = (_a = (_b = this.syncedBatchEntries)[_c = data.planIndex]) !== null && _a !== void 0 ? _a : (_b[_c] = new Map());
        entries.set(data.batch.uuid, { batch: data.batch, isClosed: false, pendingCalculateCount: 0, eventData: localData });
        this.sendEvent('fplBatchOpened', localData, false);
    }
    /**
     * Sends a modification batch opened event.
     * @param planIndex The index of the flight plan.
     * @param batch The modification batch that was opened.
     */
    sendBatchOpened(planIndex, batch) {
        const data = { planIndex, isSynced: false, batch };
        this.sendEvent('fplBatchOpened', data, true);
    }
    /**
     * A callback which is called in response to modification batch closed sync events.
     * @param data The event data.
     */
    onBatchClosed(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const entries = this.syncedBatchEntries[data.planIndex];
        const entry = entries === null || entries === void 0 ? void 0 : entries.get(data.batch.uuid);
        if (entry) {
            entry.isClosed = true;
            this.sendEvent('fplBatchClosed', entry.eventData, false);
            if (entry.pendingCalculateCount === 0) {
                this.sendEvent('fplBatchAsyncClosed', entry.eventData, false);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                entries.delete(data.batch.uuid);
            }
        }
    }
    /**
     * Sends a modification batch closed event.
     * @param planIndex The index of the flight plan.
     * @param batch The modification batch that was closed.
     */
    sendBatchClosed(planIndex, batch) {
        const data = { planIndex, isSynced: false, batch };
        this.sendEvent('fplBatchClosed', data, true);
    }
    /**
     * Sends a modification batch async closed event.
     * @param planIndex The index of the flight plan.
     * @param batch The modification batch that was closed.
     */
    sendBatchAsyncClosed(planIndex, batch) {
        const data = { planIndex, isSynced: false, batch };
        this.sendEvent('fplBatchAsyncClosed', data, false);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator, onLegNameRequested) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator, onLegNameRequested));
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
}

/**
 * Types of changes made to {@link SubscribableMap}.
 */
var SubscribableMapEventType;
(function (SubscribableMapEventType) {
    /** A key was added. */
    SubscribableMapEventType["Added"] = "Added";
    /** A key's entry was changed. */
    SubscribableMapEventType["Changed"] = "Changed";
    /** A key was deleted. */
    SubscribableMapEventType["Deleted"] = "Deleted";
})(SubscribableMapEventType || (SubscribableMapEventType = {}));

/**
 * A pipe from an input subscribable map to an output mutable subscribable map. Each key-value pair
 * added/changed/removed notification received by the pipe is used to add/change/remove key-value pairs in the output
 * map.
 */
class SubscribableMapPipe extends HandlerSubscription {
    /**
     * Constructor.
     * @param from The input subscribable map.
     * @param to The output mutable subscribable map.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from, to, onDestroy) {
        const handler = (map, type, key, value) => {
            if (type === SubscribableMapEventType.Deleted) {
                to.delete(key);
            }
            else {
                to.setValue(key, value);
            }
        };
        const initialNotifyFunc = () => {
            const fromMap = from.get();
            for (const key of to.get().keys()) {
                if (!fromMap.has(key)) {
                    to.delete(key);
                }
            }
            for (const [key, value] of fromMap) {
                to.setValue(key, value);
            }
        };
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableMap {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableMap = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this map.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    getValue(key) {
        return this.get().get(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this map.
     * @param type The type of change.
     * @param key The key related to the change.
     * @param value The value related to the change.
     */
    notify(type, key, value) {
        const map = this.get();
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(map, type, key, value);
                }
            }
            catch (error) {
                console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(map, type, key, value);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this map's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const map = this.get();
        for (const [key, value] of map) {
            sub.handler(map, SubscribableMapEventType.Added, key, value);
        }
    }
    /**
     * Responds to when a subscription to this map is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableMap' in to) {
                sub = new SubscribableMapPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
var SubscribableSetEventType;
(function (SubscribableSetEventType) {
    /** A key was added. */
    SubscribableSetEventType["Added"] = "Added";
    /** A key was deleted. */
    SubscribableSetEventType["Deleted"] = "Deleted";
})(SubscribableSetEventType || (SubscribableSetEventType = {}));

/**
 * A pipe from an input subscribable set to an output mutable subscribable set. Each key added/removed notification
 * received by the pipe is used to add/remove keys to/from the output set.
 */
class SubscribableSetPipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let initialNotifyFunc;
        let onDestroy;
        if (typeof arg4 === 'function') {
            const toCast = to;
            const map = arg3;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(map(key));
                }
                else {
                    const mappedKey = map(key);
                    // Only delete the mapped key if no other key in the input set maps to the same key
                    for (const inputKey of set) {
                        if (map(inputKey) === mappedKey) {
                            return;
                        }
                    }
                    toCast.delete(mappedKey);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set();
                for (const key of fromSet) {
                    toAdd.add(map(key));
                }
                for (const key of toCast.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg4;
        }
        else {
            const toCast = to;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(key);
                }
                else {
                    toCast.delete(key);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set(fromSet);
                for (const key of to.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg3;
        }
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableSet {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableSet = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this set.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    notify(type, key) {
        const set = this.get();
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(set, type, key);
                }
            }
            catch (error) {
                console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(set, type, key);
                    }
                    needCleanUpSubs || (needCleanUpSubs = canCleanUpSubs && !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const set = this.get();
        for (const key of set) {
            sub.handler(set, SubscribableSetEventType.Added, key);
        }
    }
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
        this.rawValue = value;
        this.value = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this.rawValue = value;
        const compValue = this.computeFn(value);
        if (compValue !== this.value) {
            this.value = compValue;
            this.notify();
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this.value;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this.rawValue;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ComputedSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.value, this.rawValue);
    }
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
class SetSubject extends AbstractSubscribableSet {
    /**
     * Constructor.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     */
    constructor(initialKeys) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableSet = true;
        this.backingSet = new Set(initialKeys);
    }
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     * @returns A new SetSubject instance.
     */
    static create(initialKeys) {
        return new SetSubject(initialKeys);
    }
    /** @inheritdoc */
    get() {
        return this.backingSet;
    }
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys) {
        const toAdd = new Set(keys);
        for (const key of this.backingSet) {
            if (!toAdd.delete(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd) {
            this.add(key);
        }
    }
    /** @inheritdoc */
    add(key) {
        const oldSize = this.backingSet.size;
        this.backingSet.add(key);
        if (oldSize !== this.backingSet.size) {
            this.notify(SubscribableSetEventType.Added, key);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const wasDeleted = this.backingSet.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableSetEventType.Deleted, key);
        }
        return wasDeleted;
    }
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set. If not defined, the key will be added to this set if it is not already present and
     * removed if it is already present.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key, force) {
        const shouldAdd = force !== null && force !== void 0 ? force : !this.backingSet.has(key);
        if (shouldAdd) {
            this.add(key);
        }
        else {
            this.delete(key);
        }
        // Explicitly query the set again instead of just returning shouldAdd in case the key was manipulated in a handler
        // triggered by its addition/removal
        return this.backingSet.has(key);
    }
    /**
     * Removes all keys from this set.
     */
    clear() {
        for (const key of this.backingSet) {
            this.backingSet.delete(key);
            this.notify(SubscribableSetEventType.Deleted, key);
        }
    }
}

/**
 * A subscribable map whose key-value pairs can be freely added and removed.
 */
class MapSubject extends AbstractSubscribableMap {
    /**
     * Constructor.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     */
    constructor(initialEntries) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableMap = true;
        this.backingMap = new Map(initialEntries);
    }
    /**
     * Creates and returns a new MapSubject.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     * @returns A new MapSubject instance.
     */
    static create(initialEntries) {
        return new MapSubject(initialEntries);
    }
    /** @inheritdoc */
    get() {
        return this.backingMap;
    }
    /**
     * Sets the key-value pairs contained in this map.
     * @param entries The key-value pairs to set.
     */
    set(entries) {
        const toAdd = entries instanceof Map ? entries : new Map(entries);
        for (const key of this.backingMap.keys()) {
            if (!toAdd.has(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd.keys()) {
            this.setValue(key, toAdd.get(key));
        }
    }
    /** @inheritdoc */
    setValue(key, value) {
        const hasKey = this.backingMap.has(key);
        const shouldNotify = !hasKey || this.backingMap.get(key) !== value;
        this.backingMap.set(key, value);
        if (shouldNotify) {
            this.notify(hasKey ? SubscribableMapEventType.Changed : SubscribableMapEventType.Added, key, value);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const value = this.backingMap.get(key);
        const wasDeleted = this.backingMap.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
        return wasDeleted;
    }
    /** @inheritdoc */
    clear() {
        for (const [key, value] of this.backingMap) {
            this.backingMap.delete(key);
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
    }
}

/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
class ObjectSubject {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
        this.obj = obj;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.initialNotify.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
        return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
        return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
        if (typeof arg1 === 'object') {
            for (const prop in arg1) {
                if (prop in this.obj) {
                    this.set(prop, arg1[prop]);
                }
            }
        }
        else {
            const oldValue = this.obj[arg1];
            if (value !== oldValue) {
                this.obj[arg1] = value;
                this.notify(arg1, oldValue);
            }
        }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(this.obj, key, this.obj[key], oldValue);
                }
            }
            catch (error) {
                console.error(`ObjectSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(this.obj, key, this.obj[key], oldValue);
                    }
                    needCleanUpSubs || (needCleanUpSubs = canCleanUpSubs && !sub.isAlive);
                }
                catch (error) {
                    console.error(`ObjectSubject: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        for (const key in this.obj) {
            const v = this.obj[key];
            sub.handler(this.obj, key, v, v);
        }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for electrical information.
 */
class ElectricalPublisher extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ElectricalPublisher.simvars, bus, pacer);
        this.flightStarted = false;
        this.avBusList = ['elec_av1_bus', 'elec_av2_bus'];
        for (const topic of this.avBusList) {
            if (bus.getTopicSubscriberCount(topic)) {
                this.subscribed.add(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.avBusList.includes(event)) {
                this.subscribed.add(event);
            }
        });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.flightStarted = true;
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.flightStarted) {
            super.onUpdate();
            if (this.av1BusLogic && this.subscribed.has('elec_av1_bus')) {
                this.publish('elec_av1_bus', this.av1BusLogic.getValue() !== 0);
            }
            if (this.av2BusLogic && this.subscribed.has('elec_av2_bus')) {
                this.publish('elec_av2_bus', this.av2BusLogic.getValue() !== 0);
            }
        }
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
        this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
        this.av2BusLogic = logicElement;
    }
}
ElectricalPublisher.simvars = new Map([
    ['elec_master_battery', { name: 'ELECTRICAL MASTER BATTERY:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_avionics_on', { name: 'CIRCUIT AVIONICS ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_navcom1_on', { name: 'CIRCUIT NAVCOM1 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom2_on', { name: 'CIRCUIT NAVCOM2 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom3_on', { name: 'CIRCUIT NAVCOM3 ON', type: SimVarValueType.Bool }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE:#index#', type: SimVarValueType.Volts, indexed: true }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_2_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:2', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_3_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:3', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_4_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:4', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_5_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:5', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_6_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:6', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_2_a', { name: 'ELECTRICAL GENALT BUS AMPS:2', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_3_a', { name: 'ELECTRICAL GENALT BUS AMPS:3', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_4_a', { name: 'ELECTRICAL GENALT BUS AMPS:4', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_5_a', { name: 'ELECTRICAL GENALT BUS AMPS:5', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_6_a', { name: 'ELECTRICAL GENALT BUS AMPS:6', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_ext_power_available', { name: 'EXTERNAL POWER AVAILABLE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_ext_power_on', { name: 'EXTERNAL POWER ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_switch', { name: 'APU GENERATOR SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_active', { name: 'APU GENERATOR ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_eng_gen_switch', { name: 'GENERAL ENG MASTER ALTERNATOR:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_on', { name: 'CIRCUIT ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_switch_on', { name: 'CIRCUIT SWITCH ON:#index#', type: SimVarValueType.Bool, indexed: true }],
]);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/** A publisher for Engine information. */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const isUsingAdvancedFuelSystem = SimVar.GetSimVarValue('NEW FUEL SYSTEM', SimVarValueType.Bool) !== 0;
        const totalUnusableFuelGal = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.GAL);
        const totalUnusableFuelLb = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.LBS);
        const nonIndexedSimVars = [
            ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
            ['fuel_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_usable_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelGal, 0) }],
            ['fuel_usable_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelLb, 0) }],
            ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main', { name: 'FUEL TANK LEFT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main_pct', { name: 'FUEL TANK LEFT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_right_main', { name: 'FUEL TANK RIGHT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right_main_pct', { name: 'FUEL TANK RIGHT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_center', { name: 'FUEL TANK CENTER QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_weight_per_gallon', { name: 'FUEL WEIGHT PER GALLON', type: SimVarValueType.LBS }],
            ['fuel_tank_selector_state_1', { name: 'FUEL TANK SELECTOR:1', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_2', { name: 'FUEL TANK SELECTOR:2', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_3', { name: 'FUEL TANK SELECTOR:3', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_4', { name: 'FUEL TANK SELECTOR:4', type: SimVarValueType.Number }],
            ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
            ['apu_pct', { name: 'APU PCT RPM', type: SimVarValueType.Percent }],
            ['apu_pct_starter', { name: 'APU PCT STARTER', type: SimVarValueType.Percent }],
            ['apu_switch', { name: 'APU SWITCH', type: SimVarValueType.Bool }],
            ['eng_starter_active', { name: 'GENERAL ENG STARTER ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
        ];
        const engineIndexedSimVars = [
            ['rpm', { name: 'GENERAL ENG RPM', type: SimVarValueType.RPM }],
            ['prop_rpm', { name: 'PROP RPM', type: SimVarValueType.RPM }],
            ['n1', { name: 'TURB ENG CORRECTED N1', type: SimVarValueType.Percent }],
            ['n1_uncorrected', { name: 'TURB ENG N1', type: SimVarValueType.Percent }],
            ['n2', { name: 'TURB ENG CORRECTED N2', type: SimVarValueType.Percent }],
            ['n2_uncorrected', { name: 'TURB ENG N2', type: SimVarValueType.Percent }],
            ['torque', { name: 'TURB ENG MAX TORQUE PERCENT', type: SimVarValueType.Percent }],
            ['fuel_flow', { name: 'ENG FUEL FLOW GPH', type: SimVarValueType.GPH }],
            ['recip_ff', { name: 'RECIP ENG FUEL FLOW', type: SimVarValueType.PPH }],
            ['oil_press', { name: 'ENG OIL PRESSURE', type: SimVarValueType.PSI }],
            ['oil_temp', { name: 'ENG OIL TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['itt', { name: 'TURB ENG ITT', type: SimVarValueType.Celsius }],
            ['egt', { name: 'ENG EXHAUST GAS TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['eng_hyd_press', { name: 'ENG HYDRAULIC PRESSURE', type: SimVarValueType.PSI }],
            ['eng_starter_on', { name: 'GENERAL ENG STARTER', type: SimVarValueType.Bool }],
            ['eng_combustion', { name: 'GENERAL ENG COMBUSTION', type: SimVarValueType.Bool }],
            ['eng_ignition_switch_state', { name: 'TURB ENG IGNITION SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_igniting', { name: 'TURB ENG IS IGNITING', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_on', { name: 'GENERAL ENG FUEL PUMP ON', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_switch_state', { name: 'GENERAL ENG FUEL PUMP SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_vibration', { name: 'ENG VIBRATION', type: SimVarValueType.Number }],
            ['fuel_flow_pph', { name: 'ENG FUEL FLOW PPH', type: SimVarValueType.PPH }],
        ];
        const simvars = new Map(nonIndexedSimVars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (const [topic, simvar] of [...engineIndexedSimVars]) {
            // describe the indexed engine topics
            for (let i = 1; i <= engineCount; i++) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
        this.engineCount = engineCount;
        this.subscribed.add('fuel_flow_total');
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('fuel_flow_total')) {
            let totalFuelFlow = 0;
            for (let i = 1; i <= this.engineCount; i++) {
                totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
            }
            this.publish('fuel_flow_total', totalFuelFlow);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Engine information.
 */
class WeightBalanceSimvarPublisher extends SimVarPublisher {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['cg_percent', { name: 'CG PERCENT', type: SimVarValueType.Percent }],
            ['total_weight', { name: 'TOTAL WEIGHT', type: SimVarValueType.Pounds }],
            ['payload_station_weight', { name: 'PAYLOAD STATION WEIGHT:#index#', type: SimVarValueType.Pounds, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * Flight timer modes.
 */
var FlightTimerMode;
(function (FlightTimerMode) {
    FlightTimerMode[FlightTimerMode["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode[FlightTimerMode["CountingUp"] = 1] = "CountingUp";
})(FlightTimerMode || (FlightTimerMode = {}));
/**
 * A publisher for flight timer information.
 */
class FlightTimerPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, timerCount, pacer) {
        const simVars = new Map();
        const baseSimVars = [
            ['timer_mode', { name: 'L:WTFltTimer_Mode', type: SimVarValueType.Number }],
            ['timer_is_running', { name: 'L:WTFltTimer_Running', type: SimVarValueType.Bool }],
            ['timer_initial_value_ms', { name: 'L:WTFltTimer_Initial_Value', type: SimVarValueType.Number }],
            ['timer_value_ms', { name: 'L:WTFltTimer_Value', type: SimVarValueType.Number }]
        ];
        timerCount = Math.max(timerCount, 0);
        for (let i = 1; i <= timerCount; i++) {
            for (const [topic, simvar] of baseSimVars) {
                simVars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type
                });
            }
        }
        super(simVars, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * A publisher for global positioning and inertial data.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['zulu_time', { name: 'E:ZULU TIME', type: SimVarValueType.Seconds }],
            ['time_of_day', { name: 'E:TIME OF DAY', type: SimVarValueType.Number }],
            ['ground_speed', { name: 'GROUND VELOCITY', type: SimVarValueType.Knots }],
            ['inertial_vertical_speed', { name: 'VELOCITY WORLD Y', type: SimVarValueType.FPM }]
        ]), this.bus, this.pacer);
        this.needPublish = {
            'gps-position': false,
            'track_deg_true': false,
            'track_deg_magnetic': false,
            'magvar': false,
            'inertial_speed': false,
            'inertial_acceleration': false,
            'inertial_track_acceleration': false
        };
        for (const topic in this.needPublish) {
            this.needPublish[topic] = bus.getTopicSubscriberCount(topic) > 0;
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle(this.onTopicSubscribed.bind(this));
    }
    /**
     * Responds to when a topic is first subscribed to on the event bus.
     * @param topic The subscribed topic.
     */
    onTopicSubscribed(topic) {
        if (topic in this.needPublish) {
            this.needPublish[topic] = true;
            if (this.publishActive) {
                switch (topic) {
                    case 'gps-position':
                        this.publishPosition();
                        break;
                    case 'track_deg_true':
                        this.publishTrack(true, false, false);
                        break;
                    case 'track_deg_magnetic':
                        this.publishTrack(false, true, false);
                        break;
                    case 'magvar':
                        this.publishTrack(false, false, true);
                        break;
                    case 'inertial_speed':
                        this.publishInertialData(true, false, false);
                        break;
                    case 'inertial_acceleration':
                        this.publishInertialData(false, true, false);
                        break;
                    case 'inertial_track_acceleration':
                        this.publishInertialData(false, false, true);
                        break;
                }
            }
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        this.needPublish['gps-position'] && this.publishPosition();
        this.publishTrack(this.needPublish['track_deg_true'], this.needPublish['track_deg_magnetic'], this.needPublish['magvar']);
        this.publishInertialData(this.needPublish['inertial_speed'], this.needPublish['inertial_acceleration'], this.needPublish['inertial_track_acceleration']);
        this.simVarPublisher.onUpdate();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the `track_deg_true`, `track_deg_magnetic`, and `magvar` topics.
     * @param publishTrue Whether to publish the `track_deg_true` topic.
     * @param publishMagnetic Whether to publish the `track_deg_magnetic` topic.
     * @param publishMagvar Whether to publish the `magvar` topic.
     */
    publishTrack(publishTrue, publishMagnetic, publishMagvar) {
        let trueTrack = 0;
        let magneticTrack = 0;
        let magvar = 0;
        if (publishTrue || publishMagnetic) {
            const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
            trueTrack = GNSSPublisher.getInstantaneousTrack(headingTrue);
        }
        if (publishMagvar || publishMagnetic) {
            magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
            if (publishMagnetic) {
                magneticTrack = NavMath.normalizeHeading(trueTrack - magvar);
            }
        }
        publishTrue && this.publish('track_deg_true', trueTrack);
        publishMagnetic && this.publish('track_deg_magnetic', magneticTrack);
        publishMagvar && this.publish('magvar', magvar);
    }
    /**
     * Publishes the `inertial_speed`, `inertial_acceleration`, and `inertial_track_acceleration` topics.
     * @param publishSpeed Whether to publish the `inertial_speed` topic.
     * @param publishAcceleration Whether to publish the `inertial_acceleration` topic.
     * @param publishTrackAcceleration Whether to publish the `inertial_track_acceleration` topic.
     */
    publishInertialData(publishSpeed, publishAcceleration, publishTrackAcceleration) {
        const velocityVec = this.vec3Cache[0];
        const accelerationVec = this.vec3Cache[1];
        let speed = 0;
        let acceleration = 0;
        if (publishSpeed || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('VELOCITY BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Z', SimVarValueType.MetersPerSecond), velocityVec);
            speed = Vec3Math.abs(velocityVec);
        }
        if (publishAcceleration || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('ACCELERATION BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Z', SimVarValueType.MetersPerSecond), accelerationVec);
            acceleration = Vec3Math.abs(accelerationVec);
        }
        publishSpeed && this.publish('inertial_speed', speed);
        publishAcceleration && this.publish('inertial_acceleration', acceleration);
        publishTrackAcceleration && this.publish('inertial_track_acceleration', speed === 0 ? acceleration : Vec3Math.dot(accelerationVec, velocityVec) / speed);
    }
    /**
     * Gets the instantaneous true track.
     * @param headingTrue The true heading, in degrees.
     * @returns The true track, in degrees.
     */
    static getInstantaneousTrack(headingTrue = 0) {
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(Math.atan2(velocityEW, velocityNS) * Avionics.Utils.RAD2DEG);
        }
        return track;
    }
}

/**
 * A heap which allocates instances of a resource.
 */
class ResourceHeap {
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory, destructor, onAllocated, onFreed, initialSize = 0, maxSize = Number.MAX_SAFE_INTEGER, autoShrinkThreshold = Number.MAX_SAFE_INTEGER) {
        this.factory = factory;
        this.destructor = destructor;
        this.onAllocated = onAllocated;
        this.onFreed = onFreed;
        this.maxSize = maxSize;
        this.autoShrinkThreshold = autoShrinkThreshold;
        this.cache = [];
        this.numAllocated = 0;
        for (let i = 0; i < Math.min(initialSize, maxSize); i++) {
            this.cache.push(factory());
        }
    }
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate() {
        if (this.numAllocated >= this.maxSize) {
            throw new Error(`ResourceHeap: maximum number of allocations (${this.maxSize}) reached`);
        }
        let resource;
        if (this.numAllocated < this.cache.length) {
            resource = this.cache[this.numAllocated];
        }
        else {
            this.cache.push(resource = this.factory());
        }
        this.numAllocated++;
        if (this.onAllocated !== undefined) {
            this.onAllocated(resource);
        }
        return resource;
    }
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource) {
        const index = this.cache.indexOf(resource);
        if (index < 0 || index >= this.numAllocated) {
            return;
        }
        const freed = this.cache[index];
        this.numAllocated--;
        this.cache[index] = this.cache[this.numAllocated];
        this.cache[this.numAllocated] = freed;
        // If the heap size is over the auto-shrink threshold and the number of allocated instances drops to less than or
        // equal to half of the heap size, then reduce the size of the heap to the threshold, or 125% of the number of
        // allocated instances, whichever is greater.
        if (this.cache.length > this.autoShrinkThreshold && this.numAllocated <= this.cache.length / 2) {
            const newLength = Math.max(this.autoShrinkThreshold, this.numAllocated * 1.25);
            for (let i = newLength; i < this.cache.length; i++) {
                this.destructor(this.cache[i]);
            }
            this.cache.length = newLength;
        }
        if (this.onFreed !== undefined) {
            this.onFreed(resource);
        }
    }
}

/**
 * SBAS group names.
 */
var SBASGroupName;
(function (SBASGroupName) {
    /** Wide Area Augmentation System (USA). */
    SBASGroupName["WAAS"] = "WAAS";
    /** European Geostationary Navigation Overlay Service (EU). */
    SBASGroupName["EGNOS"] = "EGNOS";
    /** GPS Aided Geo Augmented Navigation System (India). */
    SBASGroupName["GAGAN"] = "GAGAN";
    /** Multi-functional Satellite Augmentation System (Japan). */
    SBASGroupName["MSAS"] = "MSAS";
})(SBASGroupName || (SBASGroupName = {}));
/**
 * An instrument that computes GPS satellite information.
 */
class GPSSatComputer {
    /**
     * Creates an instance of GPSSat.
     * @param index The index of this GPSSat.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled.
     * @param syncRole This system's sync role. A `primary` system will broadcast sync events through the event bus when
     * satellite positions are calculated, satellite states change, or the system is reset. A `replica` system will
     * listen for the aforementioned sync events on the event bus and set its state accordingly. A system with a sync
     * role of `none` does neither; it maintains its own independent state and does not sync it to other systems.
     */
    constructor(index, bus, ephemerisFile, sbasFile, updateInterval, enabledSBASGroups, syncRole = 'none') {
        this.index = index;
        this.bus = bus;
        this.ephemerisFile = ephemerisFile;
        this.sbasFile = sbasFile;
        this.updateInterval = updateInterval;
        this.syncRole = syncRole;
        this.publisher = this.bus.getPublisher();
        this.syncPublisher = this.bus.getPublisher();
        this.stateChangedTopic = `gps_system_state_changed_${this.index}`;
        this.satStateChangedTopic = `gps_sat_state_changed_${this.index}`;
        this.satPosCalcTopic = `gps_sat_pos_calculated_${this.index}`;
        this.sbasStateChangedTopic = `gps_system_sbas_state_changed_${this.index}`;
        this.pdopTopic = `gps_system_pdop_${this.index}`;
        this.hdopTopic = `gps_system_hdop_${this.index}`;
        this.vdopTopic = `gps_system_vdop_${this.index}`;
        this.satCalcSyncTopic = `gps_system_sync_sat_calc_${this.index}`;
        this.satStateSyncTopic = `gps_system_sync_sat_state_changed_${this.index}`;
        this.resetSyncTopic = `gps_system_sync_reset_${this.index}`;
        this.satStateRequestSyncTopic = `gps_system_sync_sat_state_request_${this.index}`;
        this.satStateResponseSyncTopic = `gps_system_sync_sat_state_response_${this.index}`;
        this.ephemerisData = {};
        this.sbasData = [];
        this.sbasServiceAreas = new Map();
        this.currentSbasGroupsInView = new Set();
        this.satellites = [];
        this.ppos = new GeoPoint(0, 0);
        this.pposVec = new Float64Array(2);
        this.vecHeap = new ResourceHeap(() => Vec3Math.create(), () => { });
        this.altitude = 0;
        this.previousSimTime = 0;
        this.previousUpdate = 0;
        this.simTime = 0;
        this._state = GPSSystemState.Searching;
        this._sbasState = GPSSystemSBASState.Disabled;
        this.dops = Vec3Math.create();
        this._pdop = -1;
        this._hdop = -1;
        this._vdop = -1;
        this.isInit = false;
        this.needAcquireAndUse = false;
        this.needSatCalc = false;
        this.pendingSatStateUpdates = new Map();
        this.enabledSBASGroups = 'isSubscribableSet' in enabledSBASGroups ? enabledSBASGroups : SetSubject.create(enabledSBASGroups);
        this.bus.getSubscriber().on('gps-position').handle(pos => {
            this.ppos.set(pos.lat, pos.long);
            Vec2Math.set(pos.lat, pos.long, this.pposVec);
            this.altitude = pos.alt;
        });
        this.bus.getSubscriber().on('simTime').handle(time => this.simTime = time);
    }
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state() {
        return this._state;
    }
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState() {
        return this._sbasState;
    }
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop() {
        return this._pdop;
    }
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop() {
        return this._hdop;
    }
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop() {
        return this._vdop;
    }
    /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    addSbasSatellites() {
        const tempVec = new Float64Array(3);
        const tempGeoPoint = new GeoPoint(0, 0);
        const orbitHeight = UnitType.KILOMETER.convertTo(35785, UnitType.GA_RADIAN);
        for (let i = 0; i < this.sbasData.length; i++) {
            const sbasDef = this.sbasData[i];
            this.sbasServiceAreas.set(sbasDef.group, sbasDef.coverage);
            for (const satDef of sbasDef.constellation) {
                const sat = new GPSSatellite(satDef.prn, sbasDef.group);
                tempGeoPoint.set(0, satDef.lon);
                const positionCartesian = Vec3Math.multScalar(tempGeoPoint.toCartesian(tempVec), orbitHeight, tempVec);
                sat.positionCartesian.set(positionCartesian);
                this.satellites.push(sat);
            }
        }
    }
    /** @inheritdoc */
    init() {
        // Publish initial state.
        this.publisher.pub(this.stateChangedTopic, this._state, false, true);
        this.publisher.pub(this.sbasStateChangedTopic, this._sbasState, false, true);
        this.publisher.pub(this.pdopTopic, this._pdop, false, true);
        this.publisher.pub(this.hdopTopic, this._hdop, false, true);
        this.publisher.pub(this.vdopTopic, this._vdop, false, true);
        this.loadEphemerisData().then(() => this.loadSbasData()).then(() => {
            this.isInit = true;
            // Setup sync logic.
            if (this.syncRole === 'replica') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satCalcSyncTopic).handle(() => { this.needSatCalc = true; });
                sub.on(this.satStateSyncTopic).handle(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                sub.on(this.resetSyncTopic).handle(() => { this.reset(); });
                sub.on(this.satStateResponseSyncTopic).handle(response => {
                    this.needSatCalc = true;
                    response.forEach(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                });
                // Request initial state.
                this.syncPublisher.pub(this.satStateRequestSyncTopic, undefined, true, false);
            }
            else if (this.syncRole === 'primary') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satStateRequestSyncTopic).handle(() => {
                    this.syncPublisher.pub(this.satStateResponseSyncTopic, this.satellites.map(sat => { return { prn: sat.prn, state: sat.state.get() }; }), true, false);
                });
            }
            if (this.needAcquireAndUse) {
                this.needAcquireAndUse = false;
                this.acquireAndUseSatellites();
            }
            else {
                this.reset();
            }
        });
    }
    /**
     * Loads the GPS ephemeris data file.
     */
    loadEphemerisData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.ephemerisData = JSON.parse(request.responseText);
                        for (const prn in this.ephemerisData) {
                            this.satellites.push(new GPSSatellite(parseInt(prn), undefined, this.ephemerisData[prn]));
                        }
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with ephemeris data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.ephemerisFile);
            request.send();
        });
    }
    /**
     * Loads the GPS SBAS data file.
     */
    loadSbasData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.sbasData = JSON.parse(request.responseText);
                        this.addSbasSatellites();
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with sbas data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.sbasFile);
            request.send();
        });
    }
    /**
     * Instantly acquires and starts using all satellites with sufficient signal strength. If signal strength allows,
     * SBAS satellites are instantly promoted to the {@link GPSSatelliteState.Acquired} state, and GPS satellites are
     * instantly promoted to the {@link GPSSatelliteState.InUse}/{@link GPSSatelliteState.InUseDiffApplied} state.
     *
     * If this system is not initialized, the operation will be delayed until just after initialization, unless `reset()`
     * is called between now and then.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites() {
        if (this.syncRole === 'replica') {
            return;
        }
        if (this.isInit) {
            this.updateSatellites(0, true, true);
        }
        else {
            this.needAcquireAndUse = true;
        }
    }
    /**
     * Resets the GPSSatComputer system. This will set the of the system to {@link GPSSystemState.Searching} and the
     * state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset() {
        this.needAcquireAndUse = false;
        if (!this.isInit) {
            return;
        }
        this.satellites.forEach(sat => {
            const currentState = sat.state.get();
            sat.state.set(GPSSatelliteState.None);
            if (currentState !== GPSSatelliteState.None) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
            }
        });
        const currentState = this._state;
        this._state = GPSSystemState.Searching;
        if (currentState !== GPSSystemState.Searching) {
            this.publisher.pub(this.stateChangedTopic, GPSSystemState.Searching, false, true);
        }
        this.setDop(-1, -1, -1);
        if (this.syncRole === 'primary') {
            this.syncPublisher.pub(this.resetSyncTopic, undefined, true, false);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isInit) {
            return;
        }
        const deltaTime = this.simTime - this.previousSimTime;
        if (this.syncRole !== 'replica') {
            if (deltaTime < 0 || deltaTime > (this.updateInterval * 2)) {
                this.previousSimTime = this.simTime;
                this.previousUpdate = this.simTime;
                return;
            }
        }
        const shouldUpdatePositions = this.syncRole === 'replica'
            ? this.needSatCalc
            : this.simTime >= this.previousUpdate + this.updateInterval;
        this.needSatCalc = false;
        this.updateSatellites(deltaTime, shouldUpdatePositions, false);
    }
    /**
     * Updates the states and optionally the orbital positions of all satellites.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately force satellites to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} for SBAS satellites and {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} for GPS satellites) if signal strength is sufficient.
     */
    updateSatellites(deltaTime, shouldUpdatePositions, forceAcquireAndUse) {
        var _a, _b, _c, _d;
        let numAcquiring = 0;
        let numActiveSbas = 0;
        let shouldUpdateDop = shouldUpdatePositions;
        if (shouldUpdatePositions && this.syncRole === 'primary') {
            (_a = this.syncPublisher) === null || _a === void 0 ? void 0 : _a.pub(this.satCalcSyncTopic, undefined, true, false);
        }
        this.currentSbasGroupsInView.clear();
        const enabledSBASGroups = this.enabledSBASGroups.get();
        for (let i = 0; i < this.satellites.length; i++) {
            const sat = this.satellites[i];
            if (shouldUpdatePositions) {
                sat.computeSatellitePositions(this.simTime);
                sat.applyProjection(this.ppos, this.altitude);
            }
            sat.calculateSignalStrength(this.altitude);
            const updatedState = this.syncRole === 'replica'
                ? sat.forceUpdateState((_c = (_b = this.pendingSatStateUpdates.get(sat.prn)) === null || _b === void 0 ? void 0 : _b.state) !== null && _c !== void 0 ? _c : sat.state.get())
                : sat.updateState(deltaTime, this._state === GPSSystemState.DiffSolutionAcquired, forceAcquireAndUse);
            if (updatedState) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
                if (this.syncRole === 'primary') {
                    this.syncPublisher.pub(this.satStateSyncTopic, { prn: sat.prn, state: sat.state.get() }, true, false);
                }
                shouldUpdateDop = true;
            }
            const satState = sat.state.get();
            if (satState === GPSSatelliteState.Acquired || satState === GPSSatelliteState.DataCollected) {
                numAcquiring++;
                if (sat.sbasGroup !== undefined && enabledSBASGroups.has(sat.sbasGroup)) {
                    numActiveSbas++;
                    this.currentSbasGroupsInView.add(sat.sbasGroup);
                }
            }
        }
        this.pendingSatStateUpdates.clear();
        let withinSbasArea = false;
        for (const group of this.currentSbasGroupsInView) {
            const coverage = this.sbasServiceAreas.get(group);
            if (coverage !== undefined) {
                withinSbasArea = (_d = Vec2Math.pointWithinPolygon(coverage, this.pposVec)) !== null && _d !== void 0 ? _d : false;
            }
            if (withinSbasArea) {
                break;
            }
        }
        const newSBASState = withinSbasArea
            ? GPSSystemSBASState.Active
            : enabledSBASGroups.size === 0 ? GPSSystemSBASState.Disabled : GPSSystemSBASState.Inactive;
        let newSystemState = GPSSystemState.Searching;
        if (numAcquiring > 0) {
            newSystemState = GPSSystemState.Acquiring;
        }
        let pdop = this._pdop, hdop = this._hdop, vdop = this._vdop;
        if (shouldUpdateDop) {
            [pdop, hdop, vdop] = this.calculateDop(this.dops);
        }
        const is3dSolutionPossible = pdop >= 0;
        if (is3dSolutionPossible) {
            newSystemState = numActiveSbas > 0 && withinSbasArea ? GPSSystemState.DiffSolutionAcquired : GPSSystemState.SolutionAcquired;
        }
        if (this._state !== newSystemState) {
            this._state = newSystemState;
            this.publisher.pub(this.stateChangedTopic, newSystemState, false, true);
        }
        if (this._sbasState !== newSBASState) {
            this._sbasState = newSBASState;
            this.publisher.pub(this.sbasStateChangedTopic, newSBASState, false, true);
        }
        if (shouldUpdatePositions) {
            this.previousUpdate = this.simTime;
            this.publisher.pub(this.satPosCalcTopic, undefined, false, false);
        }
        this.setDop(pdop, hdop, vdop);
        this.previousSimTime = this.simTime;
    }
    /**
     * Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats() {
        return this.satellites;
    }
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle() {
        return Math.acos(6378100 / (6378100 + this.altitude));
    }
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the current satellite constellation.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current satellite constellation, as `[PDOP, HDOP, VDOP]`.
     */
    calculateDop(out) {
        Vec3Math.set(-1, -1, -1, out);
        const satsInUse = this.satellites.filter(sat => {
            const state = sat.state.get();
            return state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
        });
        if (satsInUse.length < 4) {
            return out;
        }
        // Get unit line-of-sight vectors for each satellite
        for (let i = 0; i < satsInUse.length; i++) {
            const [zenith, hour] = satsInUse[i].position.get();
            satsInUse[i] = Vec3Math.setFromSpherical(1, zenith, hour, this.vecHeap.allocate());
        }
        const satVecs = satsInUse;
        // First define line-of-sight matrix L composed of row vectors Si = [xi, yi, zi, 1], where xi, yi, zi are the
        // components of the unit line-of-sight vector for satellite i. Then compute the covariance matrix as C = (LᵀL)⁻¹.
        // P = LᵀL is guaranteed to be symmetric, so we need only compute the upper triangular part of the product.
        const P11 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[0], 0);
        const P12 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[1], 0);
        const P13 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[2], 0);
        const P14 = satVecs.reduce((sum, vec) => sum + vec[0], 0);
        const P22 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[1], 0);
        const P23 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[2], 0);
        const P24 = satVecs.reduce((sum, vec) => sum + vec[1], 0);
        const P33 = satVecs.reduce((sum, vec) => sum + vec[2] * vec[2], 0);
        const P34 = satVecs.reduce((sum, vec) => sum + vec[2], 0);
        const P44 = satVecs.length;
        for (let i = 0; i < satVecs.length; i++) {
            this.vecHeap.free(satVecs[i]);
        }
        // Perform block-wise inversion of LᵀL (which is 4x4, so neatly decomposes into four 2x2 matrices) with optimizations
        // presented in Ingemarsson, C and Gustafsson O, 2015.
        // P = [A  B]
        //     [Bᵀ D]
        // C = P⁻¹ = [E  F]
        //           [Fᵀ H]
        // Since we only care about the variance terms along the diagonal of C, we can skip calculating F.
        // V = A⁻¹ (A is symmetric, therefore V is also symmetric, so we only need to compute the upper triangular part)
        const detA = 1 / (P11 * P22 - P12 * P12);
        const V11 = P22 * detA;
        const V12 = -P12 * detA;
        const V22 = P11 * detA;
        // X = VB
        const X11 = V11 * P13 + V12 * P23;
        const X12 = V11 * P14 + V12 * P24;
        const X21 = V12 * P13 + V22 * P23;
        const X22 = V12 * P14 + V22 * P24;
        // H = (D - BᵀX)⁻¹ (H and D are symmetric, which means BᵀX is also symmetric)
        const Hi11 = P33 - (P13 * X11 + P23 * X21);
        const Hi12 = P34 - (P13 * X12 + P23 * X22);
        const Hi22 = P44 - (P14 * X12 + P24 * X22);
        const detHi = 1 / (Hi11 * Hi22 - Hi12 * Hi12);
        const H11 = Hi22 * detHi;
        const H12 = -Hi12 * detHi;
        const H22 = Hi11 * detHi;
        // Z = XH
        const Z11 = X11 * H11 + X12 * H12;
        const Z12 = X11 * H12 + X12 * H22;
        const Z21 = X21 * H11 + X22 * H12;
        const Z22 = X21 * H12 + X22 * H22;
        // E = V + ZXᵀ (We can skip calculating E12 and E21 since we only care about the diagonal)
        const E11 = V11 + Z11 * X11 + Z12 * X12;
        const E22 = V22 + Z21 * X21 + Z22 * X22;
        // Grab the variance terms var(x), var(y), var(z) along the diagonal of C
        const varX = E11;
        const varY = E22;
        const varZ = H11;
        if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
            return out;
        }
        const horizSumVar = varX + varY;
        const pdop = Math.sqrt(horizSumVar + varZ);
        const hdop = Math.sqrt(horizSumVar);
        const vdop = Math.sqrt(varZ);
        return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP valu to set.
     */
    setDop(pdop, hdop, vdop) {
        if (this._pdop !== pdop) {
            this._pdop = pdop;
            this.publisher.pub(this.pdopTopic, pdop, false, true);
        }
        if (this._hdop !== hdop) {
            this._hdop = hdop;
            this.publisher.pub(this.hdopTopic, hdop, false, true);
        }
        if (this._vdop !== vdop) {
            this._vdop = vdop;
            this.publisher.pub(this.vdopTopic, vdop, false, true);
        }
    }
}
/**
 * A tracked GPS satellite.
 */
class GPSSatellite {
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
     */
    constructor(prn, sbasGroup, ephemeris) {
        this.prn = prn;
        this.sbasGroup = sbasGroup;
        this.ephemeris = ephemeris;
        this.stateChangeTime = (5 + (10 * Math.random())) * 1000;
        this.stateChangeTimeRemaining = 0;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        /** The current satellite state. */
        this.state = Subject.create(GPSSatelliteState.None);
        /** The current satellite position, in zenith angle radians and hour angle radians. */
        this.position = Vec2Subject.create(new Float64Array(2));
        /** The current satellite position, in cartesian coordinates. */
        this.positionCartesian = Vec3Subject.create(new Float64Array(3));
        /** The current satellite signal strength. */
        this.signalStrength = Subject.create(0);
        this.isApplyingDiffCorrections = false;
        this.hasComputedPosition = false;
    }
    /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime) {
        const record = this.ephemeris;
        if (record !== undefined) {
            const mu = 3.986005e14; //WGS84 gravitational constant for GPS user (meters3/sec2)
            const omegae_dot = 7.2921151467e-5; //WGS84 earth rotation rate (rad/sec)
            // Restore semi-major axis
            const a = record.sqrtA * record.sqrtA;
            // Computed mean motion
            const n0 = Math.sqrt(mu / (a * a * a));
            // Time from ephemeris reference epoch
            const now = simTime / 1000;
            const t = (now - (86400 * 3) + 1735) % 604800;
            let tk = t - record.toeTimeEphemeris;
            if (tk > 302400) {
                tk -= 604800;
            }
            else if (tk < -302400) {
                tk += 604800;
            }
            // Corrected mean motion
            const n = n0 + record.deltaN;
            // Mean anomaly
            const M = record.m0 + n * tk;
            // Initial guess of eccentric anomaly
            let E = M;
            let E_old;
            let dE;
            // Iterative computation of eccentric anomaly
            for (let i = 1; i < 20; i++) {
                E_old = E;
                E = M + record.eEccentricity * Math.sin(E);
                dE = E - E_old % (2.0 * Math.PI);
                if (Math.abs(dE) < 1e-12) {
                    // Necessary precision is reached, exit from the loop
                    break;
                }
            }
            const sek = Math.sin(E);
            const cek = Math.cos(E);
            const OneMinusecosE = 1.0 - record.eEccentricity * cek;
            const sq1e2 = Math.sqrt(1.0 - record.eEccentricity * record.eEccentricity);
            // Compute the true anomaly
            const tmp_Y = sq1e2 * sek;
            const tmp_X = cek - record.eEccentricity;
            const nu = Math.atan2(tmp_Y, tmp_X);
            // Compute angle phi (argument of Latitude)
            const phi = nu + record.omegaS;
            // Reduce phi to between 0 and 2*pi rad
            const s2pk = Math.sin(2.0 * phi);
            const c2pk = Math.cos(2.0 * phi);
            // Correct argument of latitude
            const u = phi + record.cuc * c2pk + record.cus * s2pk;
            const suk = Math.sin(u);
            const cuk = Math.cos(u);
            // Correct radius
            const r = a * OneMinusecosE + record.crc * c2pk + record.crs * s2pk;
            // Correct inclination
            const i = record.i0 + record.idot * tk + record.cic * c2pk + record.cis * s2pk;
            const sik = Math.sin(i);
            const cik = Math.cos(i);
            // Compute the angle between the ascending node and the Greenwich meridian
            const Omega_dot = record.omegaLDot - omegae_dot;
            const Omega = record.omegaL + Omega_dot * tk - omegae_dot * record.toeTimeEphemeris;
            const sok = Math.sin(Omega);
            const cok = Math.cos(Omega);
            //Compute satellite coordinates in Earth-fixed coordinates
            const xprime = r * cuk;
            const yprime = r * suk;
            const x = xprime * cok - yprime * cik * sok;
            const y = xprime * sok + yprime * cik * cok;
            const z = yprime * sik;
            this.positionCartesian.set(UnitType.METER.convertTo(x, UnitType.GA_RADIAN), UnitType.METER.convertTo(y, UnitType.GA_RADIAN), UnitType.METER.convertTo(z, UnitType.GA_RADIAN));
        }
    }
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos, altitude) {
        const satPos = this.positionCartesian.get();
        const altRadians = UnitType.METER.convertTo(altitude, UnitType.GA_RADIAN);
        const pposCartesian = Vec3Math.multScalar(ppos.toCartesian(this.vec3Cache[0]), 1 + altRadians, this.vec3Cache[0]);
        const delta = Vec3Math.normalize(Vec3Math.sub(satPos, pposCartesian, this.vec3Cache[1]), this.vec3Cache[1]);
        const zenithAngle = Math.acos(Vec3Math.dot(delta, Vec3Math.normalize(pposCartesian, this.vec3Cache[2])));
        const satPos0 = Vec3Math.normalize(satPos, this.vec3Cache[1]);
        const northPole = Vec3Math.set(0, 0, 1, this.vec3Cache[2]);
        if (Math.abs(zenithAngle) < 1e-8 || Math.abs(zenithAngle - 180) < 1e-8) {
            this.position.set(zenithAngle, 0);
        }
        else {
            const A = Vec3Math.normalize(Vec3Math.cross(pposCartesian, northPole, this.vec3Cache[3]), this.vec3Cache[3]);
            const B = Vec3Math.normalize(Vec3Math.cross(pposCartesian, satPos0, this.vec3Cache[4]), this.vec3Cache[4]);
            const signBz = B[2] >= 0 ? 1 : -1;
            const hourAngle = Math.acos(Vec3Math.dot(A, B)) * signBz;
            this.position.set(zenithAngle, -hourAngle);
        }
        this.hasComputedPosition = true;
    }
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude) {
        if (this.hasComputedPosition) {
            const maxZenithAngle = GPSSatellite.calcHorizonAngle(altitude) + (Math.PI / 2);
            const signalStrength = Math.max(0, 1 - (this.position.get()[0] / maxZenithAngle));
            this.signalStrength.set(signalStrength);
        }
    }
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude) {
        return Math.acos(6378100 / (6378100 + Math.max(altitude, 0)));
    }
    /**
     * Updates the state of the satellite.
     * @param deltaTime The amount of sim time that has passed, in milliseconds.
     * @param applyDiffCorrections Whether or not to apply differential corrections to this GPS satellite.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} if this is an SBAS satellite or {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} if this is a GPS satellite) if signal strength is sufficient.
     * @returns True if the satellite state changed, false otherwise.
     */
    updateState(deltaTime, applyDiffCorrections, forceAcquireAndUse) {
        const reachable = this.signalStrength.get() > 0.05;
        if (this.stateChangeTimeRemaining >= 0) {
            this.stateChangeTimeRemaining -= deltaTime;
        }
        if (forceAcquireAndUse) {
            this.isApplyingDiffCorrections = applyDiffCorrections;
            const state = this.state.get();
            if (reachable) {
                const targetState = this.sbasGroup === undefined
                    ? applyDiffCorrections ? GPSSatelliteState.InUseDiffApplied : GPSSatelliteState.InUse
                    : GPSSatelliteState.Acquired;
                if (state !== targetState) {
                    this.state.set(targetState);
                    return true;
                }
            }
            else {
                if (state !== GPSSatelliteState.Unreachable) {
                    this.state.set(GPSSatelliteState.Unreachable);
                    return true;
                }
            }
        }
        else {
            switch (this.state.get()) {
                case GPSSatelliteState.None:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    else {
                        this.state.set(GPSSatelliteState.Unreachable);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                case GPSSatelliteState.Unreachable:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.Acquired:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0 && this.sbasGroup === undefined) {
                        this.state.set(GPSSatelliteState.DataCollected);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.DataCollected:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0) {
                        this.state.set(GPSSatelliteState.InUse);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.InUse:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (applyDiffCorrections) {
                        if (this.isApplyingDiffCorrections && this.stateChangeTimeRemaining <= 0) {
                            this.state.set(GPSSatelliteState.InUseDiffApplied);
                            return true;
                        }
                        else if (!this.isApplyingDiffCorrections) {
                            this.isApplyingDiffCorrections = true;
                            this.stateChangeTimeRemaining = this.stateChangeTime;
                        }
                    }
                    break;
                case GPSSatelliteState.InUseDiffApplied:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (!applyDiffCorrections) {
                        this.isApplyingDiffCorrections = false;
                        this.state.set(GPSSatelliteState.InUse);
                        return true;
                    }
                    break;
            }
        }
        return false;
    }
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param state The state to which to update this satellite.
     * @returns Whether the satellite's state was changed as a result of the forced update.
     */
    forceUpdateState(state) {
        this.stateChangeTimeRemaining = 0;
        this.isApplyingDiffCorrections = state === GPSSatelliteState.InUseDiffApplied;
        if (this.state.get() !== state) {
            this.state.set(state);
            return true;
        }
        else {
            return false;
        }
    }
}
/**
 * Possible state on GPS satellites.
 */
var GPSSatelliteState;
(function (GPSSatelliteState) {
    /** There is no current valid state. */
    GPSSatelliteState["None"] = "None";
    /** The satellite is out of view and cannot be reached. */
    GPSSatelliteState["Unreachable"] = "Unreachable";
    /** The satellite has been found and data is being downloaded. */
    GPSSatelliteState["Acquired"] = "Acquired";
    /** The satellite is faulty. */
    GPSSatelliteState["Faulty"] = "Faulty";
    /** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */
    GPSSatelliteState["DataCollected"] = "DataCollected";
    /** The satellite is being active used in the GPS solution. */
    GPSSatelliteState["InUse"] = "InUse";
    /** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */
    GPSSatelliteState["InUseDiffApplied"] = "InUseDiffApplied";
})(GPSSatelliteState || (GPSSatelliteState = {}));
/**
 * Possible {@link GPSSatComputer} states.
 */
var GPSSystemState;
(function (GPSSystemState) {
    /** The GPS receiver is trying to locate satellites. */
    GPSSystemState["Searching"] = "Searching";
    /** The GPS receiver has found satellites and is acquiring a solution. */
    GPSSystemState["Acquiring"] = "Acquiring";
    /** A 3D solution has been acquired. */
    GPSSystemState["SolutionAcquired"] = "SolutionAcquired";
    /** A 3D solution using differential computations has been acquired. */
    GPSSystemState["DiffSolutionAcquired"] = "DiffSolutionAcquired";
})(GPSSystemState || (GPSSystemState = {}));
/**
 * Possible SBAS connection states.
 */
var GPSSystemSBASState;
(function (GPSSystemSBASState) {
    /** SBAS is disabled. */
    GPSSystemSBASState["Disabled"] = "Disabled";
    /** SBAS is enabled but not receiving differential corrections. */
    GPSSystemSBASState["Inactive"] = "Inactive";
    /** SBAS is enabled and is receiving differential corrections. */
    GPSSystemSBASState["Active"] = "Active";
})(GPSSystemSBASState || (GPSSystemSBASState = {}));

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
/**
 * A publisher for VCockpit BaseInstrument events.
 */
class BaseInstrumentPublisher extends BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument, bus, pacer = undefined) {
        super(bus, pacer);
        this.instrument = instrument;
        this.lastGameState = undefined;
        this.lastIsPowered = undefined;
        this.lastScreenState = undefined;
        this.hasFlightStarted = false;
        instrument.addEventListener('mouseleave', (e) => {
            this.publish('vc_mouse_leave', e, false, false);
        });
        instrument.addEventListener('mouseenter', (e) => {
            this.publish('vc_mouse_enter', e, false, false);
        });
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        this.updateFromGameState(this.instrument.getGameState());
        this.updateFromPowered(this.instrument.isStarted); // Big hack here since there is no other way to get the isStarted state from BaseInstrument
        this.updateFromScreenState(this.instrument.screenState); // Another big hack
    }
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    updateFromGameState(gameState) {
        if (this.lastGameState === gameState) {
            return;
        }
        this.lastGameState = gameState;
        this.publish('vc_game_state', gameState);
        if (!this.hasFlightStarted && gameState === GameState.ingame) {
            this.publish('vc_flight_start', true);
        }
    }
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    updateFromPowered(isPowered) {
        if (this.lastIsPowered === isPowered) {
            return;
        }
        this.lastIsPowered = isPowered;
        this.publish('vc_powered', isPowered);
    }
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    updateFromScreenState(screenState) {
        if (this.lastScreenState === screenState) {
            return;
        }
        const lastScreenState = this.lastScreenState;
        this.lastScreenState = screenState;
        this.publish('vc_screen_state', { current: screenState, previous: lastScreenState });
    }
}

/** Minimums Modes */
var MinimumsMode;
(function (MinimumsMode) {
    MinimumsMode[MinimumsMode["OFF"] = 0] = "OFF";
    MinimumsMode[MinimumsMode["BARO"] = 1] = "BARO";
    MinimumsMode[MinimumsMode["RA"] = 2] = "RA";
    MinimumsMode[MinimumsMode["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
})(MinimumsMode || (MinimumsMode = {}));
/** A publisher for minimums simvar events. */
class MinimumsSimVarPublisher extends SimVarPublisher {
    /**
     * @inheritdoc
     */
    constructor(bus) {
        super(MinimumsSimVarPublisher.simvars, bus);
    }
}
MinimumsSimVarPublisher.simvars = new Map([
    ['decision_height_feet', { name: 'DECISION HEIGHT', type: SimVarValueType.Feet }],
    ['decision_altitude_feet', { name: 'DECISION ALTITUDE MSL', type: SimVarValueType.Feet }],
    ['minimums_mode', { name: 'L:WT_MINIMUMS_MODE', type: SimVarValueType.Number }]
]);
/**
 * A class that manages decision height and altitude data and events.
 */
class MinimumsManager {
    /**
     * Create a MinimumsManager
     * @param bus The event bus
     */
    constructor(bus) {
        this.currentDH = 0;
        this.currentDA = 0;
        this.daDistanceUnit = UnitType.FOOT;
        this.dhDistanceUnit = UnitType.FOOT;
        this.bus = bus;
        this.controlSubscriber = bus.getSubscriber();
        // Initialize both simvars to 0.
        SimVar.SetSimVarValue('K:SET_DECISION_HEIGHT', 'number', 0);
        SimVar.SetSimVarValue('K:SET_DECISION_ALTITUDE_MSL', 'number', 0);
        KeyEventManager.getManager(bus).then(manager => {
            manager.interceptKey('INCREASE_DECISION_HEIGHT', false);
            manager.interceptKey('DECREASE_DECISION_HEIGHT', false);
            manager.interceptKey('INCREASE_DECISION_ALTITUDE_MSL', false);
            manager.interceptKey('DECREASE_DECISION_ALTITUDE_MSL', false);
        });
        this.controlSubscriber.on('set_decision_height_feet').handle((dh) => {
            SimVar.SetSimVarValue('K:SET_DECISION_HEIGHT', SimVarValueType.Number, dh);
        });
        this.controlSubscriber.on('set_decision_altitude_feet').handle((da) => {
            SimVar.SetSimVarValue('K:SET_DECISION_ALTITUDE_MSL', SimVarValueType.Number, da);
        });
        this.controlSubscriber.on('set_minimums_mode').handle((mode) => {
            SimVar.SetSimVarValue('L:WT_MINIMUMS_MODE', SimVarValueType.Number, mode);
        });
        this.controlSubscriber.on('set_dh_distance_unit').handle((unit) => {
            this.dhDistanceUnit = unit == 'meters' ? UnitType.METER : UnitType.FOOT;
        });
        this.controlSubscriber.on('set_da_distance_unit').handle((unit) => {
            this.daDistanceUnit = unit == 'meters' ? UnitType.METER : UnitType.FOOT;
        });
        const sub = this.bus.getSubscriber();
        sub.on('key_intercept').handle((evt) => {
            let simvar;
            let curVal;
            let direction = 'up';
            let unit;
            if (evt.value0 !== undefined) {
                switch (evt.key) {
                    case 'DECREASE_DECISION_HEIGHT':
                        direction = 'down';
                    // eslint-disable-next-line no-fallthrough
                    case 'INCREASE_DECISION_HEIGHT':
                        simvar = 'K:SET_DECISION_HEIGHT';
                        unit = this.dhDistanceUnit;
                        curVal = this.currentDH;
                        break;
                    case 'DECREASE_DECISION_ALTITUDE_MSL':
                        direction = 'down';
                    // eslint-disable-next-line no-fallthrough
                    case 'INCREASE_DECISION_ALTITUDE_MSL':
                        simvar = 'K:SET_DECISION_ALTITUDE_MSL';
                        unit = this.daDistanceUnit;
                        curVal = this.currentDA;
                        break;
                }
                if (simvar !== undefined && curVal !== undefined && unit !== undefined) {
                    // There is one flaw in this logic, but I'm not sure what can be done about
                    // it.  You can set the inc/dec amount via the K event in feet or meters.
                    // If your user preference unit is one, but the simvar call uses the other,
                    // we have now way of knowing  about it so will force a conversion that's not
                    // needed.This is a fairly minor flaw, but worth acknowledging until a
                    // workaround can be found.
                    const increment = unit.convertTo(evt.value0, UnitType.FOOT) * (direction == 'down' ? -1 : 1);
                    SimVar.SetSimVarValue(simvar, 'number', curVal + increment);
                }
            }
        });
    }
}

/**
 * A simple timer for handling debounce.
 */
class DebounceTimer {
    constructor() {
        this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
        return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
        this.clear();
        this.timer = setTimeout(() => {
            this.timer = null;
            action();
        }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
        if (this.timer === null) {
            return;
        }
        clearTimeout(this.timer);
        this.timer = null;
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus, pacer = undefined, transponderCount = 1) {
        const vars = [];
        for (let i = 0; i < transponderCount; i++) {
            vars.push([`xpdr_mode_${i + 1}`, { name: `TRANSPONDER STATE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_code_${i + 1}`, { name: `TRANSPONDER CODE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_ident_${i + 1}`, { name: `TRANSPONDER IDENT:${i + 1}`, type: SimVarValueType.Bool }]);
        }
        super(new Map(vars), bus, pacer);
    }
}
/** A transponder. */
class XPDRInstrument {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus, transponderCount = 1) {
        this.bus = bus;
        this.transponderCount = transponderCount;
        this.identDebounceTimers = Array.from({ length: this.transponderCount }, () => new DebounceTimer());
        this.bus = bus;
        this.simVarPublisher = new XPDRSimVarPublisher(bus);
        this.controlSubscriber = bus.getSubscriber();
    }
    /** Initialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        for (let i = 0; i < this.transponderCount; i++) {
            this.controlSubscriber.on(`publish_xpdr_code_${i + 1}`).handle(this.setXpdrCode.bind(this, i + 1));
            this.controlSubscriber.on(`publish_xpdr_mode_${i + 1}`).handle(this.setXpdrMode.bind(this, i + 1));
            this.controlSubscriber.on(`xpdr_send_ident_${i + 1}`).handle(this.sendIdent.bind(this, i + 1));
            // force standby on plane load when off
            if (this.getXpdrMode(i + 1) === XPDRMode.OFF) {
                this.setXpdrMode(i + 1, XPDRMode.STBY);
            }
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    setXpdrCode(index, code) {
        const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
        SimVar.SetSimVarValue(`K:${index}:XPNDR_SET`, 'Frequency BCD16', bcdCode);
    }
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    setXpdrMode(index, mode) {
        SimVar.SetSimVarValue(`TRANSPONDER STATE:${index}`, 'number', mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    getXpdrMode(index) {
        return SimVar.GetSimVarValue(`TRANSPONDER STATE:${index}`, 'number');
    }
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    sendIdent(index) {
        if (this.getXpdrMode(index) > XPDRMode.STBY) {
            SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_ON`, 'number', 1);
            this.identDebounceTimers[index - 1].schedule(() => {
                SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_OFF`, 'number', 0);
            }, 18000);
        }
    }
}

/**
 * A utility class for generating Promises that wait for certain conditions before they are fulfilled.
 */
class Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    /**
     * Waits for a certain number of frames to elapse.
     * @param count The number of frames to wait.
     * @param glassCockpitRefresh Whether to wait for glass cockpit refresh frames instead of CoherentGT frames. Defaults
     * to `false`.
     */
    static awaitFrames(count, glassCockpitRefresh = false) {
        let elapsedFrameCount = 0;
        if (glassCockpitRefresh) {
            return new Promise(resolve => {
                const callback = () => {
                    if (++elapsedFrameCount > count) {
                        resolve();
                    }
                    else {
                        requestAnimationFrame(callback);
                    }
                };
                requestAnimationFrame(callback);
            });
        }
        else {
            return new Promise(resolve => {
                const id = setInterval(() => {
                    if (++elapsedFrameCount > count) {
                        clearInterval(id);
                        resolve();
                    }
                }, 0);
            });
        }
    }
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = subscribable.sub(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, false, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = consumer.handle(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent(event, predicate, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = event.on((sender, data) => {
                if (predicate === undefined || predicate(data, sender)) {
                    sub.destroy();
                    resolve(data);
                }
            }, true);
            sub.resume();
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
}

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** The acceptable priority types for a given annunciation. */
var AnnunciationType;
(function (AnnunciationType) {
    AnnunciationType[AnnunciationType["Warning"] = 0] = "Warning";
    AnnunciationType[AnnunciationType["Caution"] = 1] = "Caution";
    AnnunciationType[AnnunciationType["Advisory"] = 2] = "Advisory";
    AnnunciationType[AnnunciationType["SafeOp"] = 3] = "SafeOp";
})(AnnunciationType || (AnnunciationType = {}));

/**
 * A manager for registering aural alerts. Alerts can be registered with an {@link AuralAlertSystem} through the
 * manager, which also handles registration requests from the alert system.
 */
class AuralAlertRegistrationManager {
    /**
     * Creates a new instance of AuralAlertRegistrationManager.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.registrations = new Map();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        this.requestSub = subscriber.on('aural_alert_request_all_registrations').handle(this.publishAllRegistrations.bind(this));
    }
    /**
     * Registers an aural alert.
     * @param definition The definition of the alert to register.
     */
    register(definition) {
        this.registrations.set(definition.uuid, definition);
        this.publishRegistration(definition);
    }
    /**
     * Publishes a registration event for an alert.
     * @param definition The definition of the alert to register.
     */
    publishRegistration(definition) {
        this.publisher.pub('aural_alert_register', definition, true, false);
    }
    /**
     * Publishes registration events for all currently registered alerts.
     */
    publishAllRegistrations() {
        for (const definition of this.registrations.values()) {
            this.publishRegistration(definition);
        }
    }
    /**
     * Destroys this manager.
     */
    destroy() {
        this.requestSub.destroy();
    }
}

/**
 * A controller which provides a convenient interface with which to send commands to {@link SoundServer}.
 */
class SoundServerController {
    /**
     * Creates a new instance of SoundServerController.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.publisher = bus.getPublisher();
        this.subscriber = bus.getSubscriber();
    }
    /**
     * Waits for the sound server to finish initialization.
     * @returns A Promise which fulfills with a value of `true` when the sound server finishes initialization.
     */
    awaitInitialized() {
        return Wait.awaitConsumer(this.subscriber.on('sound_server_initialized'), init => init, true);
    }
    /**
     * Requests a sound packet to be played if there is no existing packet with the same key currently being played.
     * @param packet The sound packet to play.
     */
    play(packet) {
        this.publisher.pub('sound_server_play', packet, true, false);
    }
    /**
     * Requests a sound packet to be queued. If there is no existing packet with the same key currently being played, the
     * packet will begin playing immediately. Otherwise, the new packet will begin playing after the existing packet and
     * any other queued packets with the same key are finished playing.
     * @param packet The sound packet to queue.
     */
    queue(packet) {
        this.publisher.pub('sound_server_queue', packet, true, false);
    }
    /**
     * Requests a sound packet to be played at the earliest opportunity. If there is no existing packet with the same key
     * currently being played, the packet will begin playing immediately. Otherwise, the existing packet will be stopped
     * the next time one of its sound atoms finishes playing, any queued packets with the same key will be discarded, and
     * the new packet will begin playing at that time.
     * @param packet The sound packet to play.
     */
    interrupt(packet) {
        this.publisher.pub('sound_server_interrupt', packet, true, false);
    }
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. This
     * also prevents any queued packets with the same key from
     * playing.
     * @param key The key of the sound packet to stop.
     */
    stop(key) {
        this.publisher.pub('sound_server_stop', key, true, false);
    }
    /**
     * Requests that a sound packet stop playing at the earliest opportunity (the next time one of its sound atoms
     * finishes playing). This also prevents any queued packets with the same key from playing.
     * @param key The key of the sound packet to kill.
     */
    kill(key) {
        this.publisher.pub('sound_server_kill', key, true, false);
    }
    /**
     * Requests that all currently playing continuous sound packets stop playing instead of looping the next time their
     * sequences finish. This also clears all queued packets.
     */
    stopAll() {
        this.publisher.pub('sound_server_stop_all', undefined, true, false);
    }
    /**
     * Requests that all currently playing sound packets stop playing at the earliest opportunity (the next time one of
     * their sound atoms finishes playing). This also clears all queued packets.
     */
    killAll() {
        this.publisher.pub('sound_server_kill_all', undefined, true, false);
    }
    /**
     * Requests a single sound atom to be played non-continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: false })`.
     * @param id The ID of the sound atom to play.
     */
    playSound(id) {
        this.publisher.pub('sound_server_play_sound', id, true, false);
    }
    /**
     * Requests a single sound atom to be played continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: true })`.
     * @param id The ID of the sound atom to play.
     */
    startSound(id) {
        this.publisher.pub('sound_server_start_sound', id, true, false);
    }
}

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        /** The context on this component, if any. */
        this.context = undefined;
        /** The type of context for this component, if any. */
        this.contextType = undefined;
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
        if (this.context !== undefined && this.contextType !== undefined) {
            const index = this.contextType.indexOf(context);
            return this.context[index];
        }
        throw new Error('Could not find the provided context type.');
    }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
class Context {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
        this.defaultValue = defaultValue;
        /**
         * The provider component that can be set to a specific context value.
         * @param props The props of the provider component.
         * @returns A new context provider.
         */
        this.Provider = (props) => new ContextProvider(props, this);
    }
}
/**
 * A provider component that can be set to a specific context value.
 */
class ContextProvider extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
        super(props);
        this.parent = parent;
    }
    /** @inheritdoc */
    render() {
        var _a;
        const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
        return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props) {
        return props.children;
    }
    FSComponent.Fragment = Fragment;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (key === 'class' && typeof prop === 'object' && 'isSubscribableSet' in prop) {
                            // Bind CSS classes to a subscribable set
                            prop.sub((set, eventType, modifiedKey) => {
                                if (eventType === SubscribableSetEventType.Added) {
                                    element.classList.add(modifiedKey);
                                }
                                else {
                                    element.classList.remove(modifiedKey);
                                }
                            }, true);
                        }
                        else if (key === 'style' && typeof prop === 'object' && 'isSubscribableMap' in prop) {
                            // Bind CSS styles to a subscribable map.
                            prop.sub((map, eventType, modifiedKey, modifiedValue) => {
                                switch (eventType) {
                                    case SubscribableMapEventType.Added:
                                    case SubscribableMapEventType.Changed:
                                        element.style.setProperty(modifiedKey, modifiedValue);
                                        break;
                                    case SubscribableMapEventType.Deleted:
                                        element.style.setProperty(modifiedKey, null);
                                        break;
                                }
                            }, true);
                        }
                        else if (typeof prop === 'object' && 'isSubscribable' in prop) {
                            if (key === 'style' && prop instanceof ObjectSubject) {
                                // Bind CSS styles to an object subject.
                                prop.sub((v, style, newValue) => {
                                    element.style.setProperty(style.toString(), newValue);
                                }, true);
                            }
                            else {
                                // Bind an attribute to a subscribable.
                                prop.sub((v) => {
                                    element.setAttribute(key, v);
                                }, true);
                            }
                        }
                        else if (key === 'class' && typeof prop === 'object') {
                            // Bind CSS classes to an object of key value pairs where the values can be boolean | Subscribable<boolean>
                            for (const className in prop) {
                                if (className.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[className];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub((showClass) => {
                                        element.classList.toggle(className, !!showClass);
                                    }, true);
                                }
                                else {
                                    element.classList.toggle(className, !!value);
                                }
                            }
                        }
                        else if (key === 'style' && typeof prop === 'object') {
                            // Bind styles to an object of key value pairs
                            for (const style in prop) {
                                if (style.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[style];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub(newValue => {
                                        element.style.setProperty(style, newValue !== null && newValue !== void 0 ? newValue : '');
                                    }, true);
                                }
                                else {
                                    element.style.setProperty(style, value !== null && value !== void 0 ? value : '');
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            if (typeof type === 'function' && type.name === Fragment.name) {
                let fragmentChildren = type(props);
                //Handle the case where the single fragment children is an array of nodes passsed down from above
                while (fragmentChildren && fragmentChildren.length === 1 && Array.isArray(fragmentChildren[0])) {
                    fragmentChildren = fragmentChildren[0];
                }
                vnode = {
                    instance: null,
                    props,
                    children: null
                };
                if (fragmentChildren) {
                    vnode.children = createChildNodes(vnode, fragmentChildren);
                }
            }
            else {
                let instance;
                const pluginSystem = (window._pluginSystem);
                try {
                    instance = type(props);
                }
                catch (_a) {
                    let pluginInstance = undefined;
                    if (pluginSystem !== undefined) {
                        pluginInstance = pluginSystem.onComponentCreating(type, props);
                    }
                    if (pluginInstance !== undefined) {
                        instance = pluginInstance;
                    }
                    else {
                        instance = new type(props);
                    }
                }
                if (props !== null && props.ref !== null && props.ref !== undefined) {
                    props.ref.instance = instance;
                }
                if (instance.contextType !== undefined) {
                    instance.context = instance.contextType.map(c => Subject.create(c.defaultValue));
                }
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentCreated(instance);
                }
                vnode = {
                    instance,
                    props,
                    children: [instance.render()]
                };
            }
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'object') {
                        if ('isSubscribable' in child) {
                            const node = {
                                instance: child,
                                children: null,
                                props: null,
                                root: undefined,
                            };
                            child.sub((v) => {
                                if (node.root !== undefined) {
                                    // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                    node.root.nodeValue = (v === '' || v === null || v === undefined)
                                        ? ' '
                                        : v.toString();
                                }
                            });
                            vnodes.push(node);
                        }
                        else {
                            vnodes.push(child);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            if (element !== null) {
                insertNode(node, position, element);
            }
        }
        else if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance !== null && componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (position === RenderPosition.After) {
                for (let i = node.children.length - 1; i >= 0; i--) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            else {
                for (let i = 0; i < node.children.length; i++) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            const instance = node.instance;
            if (instance instanceof ContextProvider) {
                visitNodes(node, (n) => {
                    if (n === undefined || n === null) {
                        return false;
                    }
                    const nodeInstance = n.instance;
                    if (nodeInstance !== null && nodeInstance.contextType !== undefined) {
                        const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
                        if (contextSlot >= 0) {
                            if (nodeInstance.context === undefined) {
                                nodeInstance.context = [];
                            }
                            nodeInstance.context[contextSlot].set(instance.props.value);
                        }
                        if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            if (componentInstance !== null && componentInstance.onAfterRender !== undefined) {
                const pluginSystem = (window._pluginSystem);
                componentInstance.onAfterRender(node);
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentRendered(node);
                }
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string'
            || (typeof node.instance === 'object'
                && node.instance !== null &&
                'isSubscribable' in node.instance)) {
            let toRender;
            if (typeof node.instance === 'string') {
                toRender = node.instance;
            }
            else {
                toRender = node.instance.get();
                if (toRender === '') {
                    toRender = ' '; // prevent disappearing text node
                }
            }
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', toRender);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', toRender);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', toRender);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else if (Array.isArray(node)) {
            if (position === RenderPosition.After) {
                for (let i = node.length - 1; i >= 0; i--) {
                    render(node[i], element, position);
                }
            }
            else {
                for (let i = 0; i < node.length; i++) {
                    render(node[i], element, position);
                }
            }
        }
        else {
            render(node, element, position);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext(defaultValue) {
        return new Context(defaultValue);
    }
    FSComponent.createContext = createContext;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     */
    function visitNodes(node, visitor) {
        if (node === undefined || node === null) {
            return;
        }
        const stopVisitation = visitor(node);
        if (!stopVisitation && node.children !== undefined && node.children !== null) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (Array.isArray(child)) {
                    for (let childIndex = 0; childIndex < child.length; childIndex++) {
                        visitNodes(child[childIndex], visitor);
                    }
                }
                else {
                    visitNodes(child, visitor);
                }
            }
        }
        return;
    }
    FSComponent.visitNodes = visitNodes;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
     * class should be included in the output array and `false` otherwise.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString, filter) {
        return classString.split(' ').filter(str => str !== '' && (filter === undefined || filter(str)));
    }
    FSComponent.parseCssClassesFromString = parseCssClassesFromString;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
        const reservedClassSet = new Set(reservedClasses);
        if (classesToSubscribe.isSubscribableSet === true) {
            return bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet);
        }
        else {
            return bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet);
        }
    }
    FSComponent.bindCssClassSet = bindCssClassSet;
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet) {
        if (reservedClassSet.size === 0) {
            return classesToSubscribe.sub((set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
        else {
            return classesToSubscribe.sub((set, type, key) => {
                if (reservedClassSet.has(key)) {
                    return;
                }
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableSet} to a record of CSS classes. CSS classes toggled in the record will also be
     * added to and removed from the bound set, with the exception of a set of reserved classes. The presence or absence
     * of any of the reserved classes in the bound set is not affected by the subscribed record.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A record of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscriptions to the CSS class record.
     */
    function bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet) {
        const subs = [];
        for (const cssClass in classesToSubscribe) {
            if (reservedClassSet.has(cssClass)) {
                continue;
            }
            const value = classesToSubscribe[cssClass];
            if (typeof value === 'object') {
                subs.push(value.sub(setToBind.toggle.bind(setToBind, cssClass), true));
            }
            else if (value === true) {
                setToBind.add(cssClass);
            }
            else {
                setToBind.delete(cssClass);
            }
        }
        return subs;
    }
    /**
     * Adds CSS classes to a {@link ToggleableClassNameRecord}.
     * @param record The CSS class record to which to add the new classes. The record will be mutated as classes are
     * added.
     * @param classesToAdd The CSS classes to add to the record, as a space-delimited class string, an iterable of
     * individual class names, or a {@link ToggleableClassNameRecord}.
     * @param allowOverwrite Whether to allow the new classes to overwrite existing entries in the CSS class record.
     * Defaults to `true`.
     * @param filter A function which filters the classes to add. For each class, the function should return `true` if
     * the class should be included in the record and `false` otherwise.
     * @returns The mutated CSS class record, after the new classes have been added.
     */
    function addCssClassesToRecord(record, classesToAdd, allowOverwrite = true, filter) {
        if (classesToAdd === '') {
            return record;
        }
        if (typeof classesToAdd === 'string') {
            classesToAdd = FSComponent.parseCssClassesFromString(classesToAdd, filter);
            filter = undefined;
        }
        if (typeof classesToAdd[Symbol.iterator] === 'function') {
            for (const cssClass of classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = true;
                }
            }
        }
        else {
            for (const cssClass in classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = classesToAdd[cssClass];
                }
            }
        }
        return record;
    }
    FSComponent.addCssClassesToRecord = addCssClassesToRecord;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindStyleMap(mapToBind, stylesToSubscribe, reservedStyles) {
        const reservedStyleSet = new Set(reservedStyles);
        if (stylesToSubscribe.isSubscribableMap === true) {
            return bindStyleMapToSubscribableMap(mapToBind, stylesToSubscribe, reservedStyleSet);
        }
        else if (stylesToSubscribe instanceof ObjectSubject) {
            return bindStyleMapToObjectSubject(mapToBind, stylesToSubscribe, reservedStyleSet);
        }
        else {
            return bindStyleMapToRecord(mapToBind, stylesToSubscribe, reservedStyleSet);
        }
    }
    FSComponent.bindStyleMap = bindStyleMap;
    /**
     * Binds a {@link MutableSubscribableMap} to a subscribable map of CSS styles. Modifications to the CSS styles in the
     * subscribed map will be reflected in the bound map, with the exception of a set of reserved styles. The values of
     * any of the reserved styles in the bound map is not affected by the subscribed map.
     * @param mapToBind The map to bind.
     * @param stylesToSubscribe A key-value map of CSS styles to which to subscribe.
     * @param reservedStyleSet A set of reserved styles.
     * @returns The newly created subscription to the subscribed CSS style map.
     */
    function bindStyleMapToSubscribableMap(mapToBind, stylesToSubscribe, reservedStyleSet) {
        if (reservedStyleSet.size === 0) {
            return stylesToSubscribe.pipe(mapToBind);
        }
        else {
            return stylesToSubscribe.sub((set, type, key, value) => {
                if (reservedStyleSet.has(key)) {
                    return;
                }
                switch (type) {
                    case SubscribableMapEventType.Added:
                    case SubscribableMapEventType.Changed:
                        mapToBind.setValue(key, value);
                        break;
                    case SubscribableMapEventType.Deleted:
                        mapToBind.delete(key);
                        break;
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableMap} to an {@link ObjectSubject} of CSS styles. Modifications to the CSS styles
     * in the subject will be reflected in the bound map, with the exception of a set of reserved styles. The values of
     * any of the reserved styles in the bound map is not affected by the subscribed subject.
     * @param mapToBind The map to bind.
     * @param stylesToSubscribe An ObjectSubject of CSS styles to which to subscribe.
     * @param reservedStyleSet A set of reserved styles.
     * @returns The newly created subscription to the CSS style ObjectSubject.
     */
    function bindStyleMapToObjectSubject(mapToBind, stylesToSubscribe, reservedStyleSet) {
        return stylesToSubscribe.sub((obj, style, value) => {
            if (reservedStyleSet.has(style)) {
                return;
            }
            if (value) {
                mapToBind.setValue(style, value);
            }
            else {
                mapToBind.delete(style);
            }
        }, true);
    }
    /**
     * Binds a {@link MutableSubscribableMap} to a record of CSS styles. Modifications to the CSS styles in the record
     * will be reflected in the bound map, with the exception of a set of reserved styles. The values of any of the
     * reserved styles in the bound map is not affected by the subscribed record.
     * @param mapToBind The map to bind.
     * @param stylesToSubscribe A record of CSS styles to which to subscribe.
     * @param reservedStyleSet A set of reserved styles.
     * @returns The newly created subscriptions to the CSS style record.
     */
    function bindStyleMapToRecord(mapToBind, stylesToSubscribe, reservedStyleSet) {
        const subs = [];
        for (const style in stylesToSubscribe) {
            if (reservedStyleSet.has(style)) {
                continue;
            }
            const value = stylesToSubscribe[style];
            if (typeof value === 'object') {
                subs.push(value.sub(styleValue => {
                    if (styleValue) {
                        mapToBind.setValue(style, styleValue);
                    }
                    else {
                        mapToBind.delete(style);
                    }
                }, true));
            }
            else if (value) {
                mapToBind.setValue(style, value);
            }
            else {
                mapToBind.delete(style);
            }
        }
        return subs;
    }
    /**
     * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
     * branch of the tree.
     * @param root The root of the tree to traverse.
     */
    function shallowDestroy(root) {
        FSComponent.visitNodes(root, node => {
            if (node !== root && node.instance instanceof DisplayComponent) {
                node.instance.destroy();
                return true;
            }
            return false;
        });
    }
    FSComponent.shallowDestroy = shallowDestroy;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));
FSComponent.Fragment;

/**
 * A scrolling digit display. The display supports number bases greater than or equal to 3. The display renders a
 * one digit for each of the following values:
 * ```
 * -(base + 2), -(base + 1), -(base), ... , -1, 0, 1, ... , base, base + 1, base + 2`
 * ```
 * The total number of rendered digits equals `(base + 2) * 2 + 1`. The display will scroll between the rendered
 * digits based on a bound value.
 *
 * When styling the scroller with CSS, select the `digit-scroller-digit` class to style all rendered digits. Each
 * individual digit can also be selected with the `digit-scroller-digit-[index]` classes, where `[index]` is replaced
 * with `0, 1, 2, ...`, starting with the lowest-valued digit. Select the `digit-scroller-nan` class to style the text
 * rendered for `NaN` values. The `--digit-scroller-line-height` variable is used to control the vertical spacing
 * between each digit (defaults to `1em`). The `--digit-scroller-line-offset-y` variable is used to control the
 * vertical offset of each digit (defaults to `0px`).
 */
class DigitScroller extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.digitCount = (this.props.base + 2) * 2 + 1;
        this.translationPerDigit = 100 / this.digitCount;
        this.tapeStyle = ObjectSubject.create({
            display: '',
            position: 'absolute',
            left: '0',
            top: `calc(50% - var(--digit-scroller-line-height, 1em) * ${this.digitCount / 2})`,
            width: '100%',
            height: `calc(var(--digit-scroller-line-height, 1em) * ${this.digitCount})`,
            transform: 'translate3d(0, 0, 0)'
        });
        this.nanTextStyle = ObjectSubject.create({
            display: 'none',
            position: 'absolute',
            left: '0%',
            top: '50%',
            width: '100%',
            transform: 'translateY(-50%)'
        });
        this.digitPlaceFactor = this.props.factor;
        this.scrollThreshold = (_a = this.props.scrollThreshold) !== null && _a !== void 0 ? _a : 0;
        this.translateY = Subject.create(0);
        if (props.base < 3 || Math.floor(props.base) !== props.base) {
            throw new Error(`DigitScroller: invalid number base (${this.props.base})`);
        }
        if (props.factor === 0) {
            throw new Error(`DigitScroller: invalid factor (${props.factor})`);
        }
    }
    /** @inheritdoc */
    onAfterRender() {
        this.translateY.sub(translateY => {
            this.tapeStyle.set('transform', `translate3d(0, ${translateY}%, 0)`);
        });
        this.valueSub = this.props.value.sub(this.update.bind(this), true);
    }
    /**
     * Updates this display.
     * @param value This display's value.
     */
    update(value) {
        if (isNaN(value)) {
            this.nanTextStyle.set('display', '');
            this.tapeStyle.set('display', 'none');
            return;
        }
        this.nanTextStyle.set('display', 'none');
        this.tapeStyle.set('display', '');
        const base = this.props.base;
        const valueSign = value < 0 ? -1 : 1;
        const valueAbs = Math.abs(value);
        let pivot = Math.floor(valueAbs / this.digitPlaceFactor) * this.digitPlaceFactor;
        let digit = Math.floor(pivot / this.digitPlaceFactor) % base;
        let digitTranslate = (valueAbs - pivot) / this.digitPlaceFactor;
        const threshold = this.scrollThreshold / this.digitPlaceFactor;
        digitTranslate = (digitTranslate > threshold) ? (digitTranslate - threshold) / (1 - threshold) : 0;
        if (digitTranslate >= 0.5) {
            pivot += this.digitPlaceFactor;
            digit = (digit + 1) % base;
            digitTranslate -= 1;
        }
        let tapeTranslate = 0;
        if (pivot <= this.digitPlaceFactor) {
            tapeTranslate = (digit + digitTranslate) * valueSign * this.translationPerDigit;
        }
        else {
            tapeTranslate = (((digit + base - 2) % base + 2) + digitTranslate) * valueSign * this.translationPerDigit;
        }
        this.translateY.set(MathUtils.round(tapeTranslate, 0.1));
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        let cssClass;
        if (this.props.class !== undefined && typeof this.props.class === 'object') {
            cssClass = SetSubject.create(['digit-scroller']);
            this.cssClassSub = FSComponent.bindCssClassSet(cssClass, this.props.class, ['digit-scroller']);
        }
        else {
            cssClass = `digit-scroller ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`;
        }
        return (FSComponent.buildComponent("div", { class: cssClass, style: 'overflow: hidden' },
            FSComponent.buildComponent("div", { class: 'digit-scroller-digit-tape', style: this.tapeStyle }, this.renderDigits()),
            FSComponent.buildComponent("div", { class: 'digit-scroller-nan', style: this.nanTextStyle }, (_b = this.props.nanString) !== null && _b !== void 0 ? _b : '–')));
    }
    /**
     * Renders text for each of this display's individual digits.
     * @returns This display's individual digit text, as an array of VNodes.
     */
    renderDigits() {
        var _a;
        const base = this.props.base;
        const renderFunc = (_a = this.props.renderDigit) !== null && _a !== void 0 ? _a : ((digit) => (Math.abs(digit) % base).toString());
        // Digits to render: -(base + 2), -(base + 1), -(base), -(base - 1), ... -1, 0, 1, ... , base - 1, base, base + 1, base + 2
        const zeroIndexOffset = base + 2;
        return Array.from({ length: this.digitCount }, (v, index) => {
            const digit = zeroIndexOffset - index;
            return (FSComponent.buildComponent("div", { style: `position: absolute; left: 0; top: calc(var(--digit-scroller-line-offset-y, 0px) + ${50 + (index - zeroIndexOffset - 0.5) * this.translationPerDigit}%); width: 100%; height: ${this.translationPerDigit}%; line-height: var(--digit-scroller-line-height, 1em);` },
                FSComponent.buildComponent("span", { class: `digit-scroller-digit digit-scroller-digit-${index}`, style: 'vertical-align: baseline;' }, renderFunc(digit))));
        });
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/**
 * A base component for horizon layers.
 */
class HorizonLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isAttached = false;
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is attached to a horizon component.
     * @returns Whether this layer is attached to a horizon component.
     */
    isAttached() {
        return this._isAttached;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        if (this._isAttached) {
            this.onVisibilityChanged(val);
        }
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent horizon component.
     */
    onAttached() {
        this._isAttached = true;
        if (!this._isVisible) {
            this.onVisibilityChanged(this._isVisible);
        }
    }
    /**
     * This method is called when this layer's parent horizon component is awakened.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent horizon component is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when this layer's horizon projection changes.
     * @param projection This layer's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onProjectionChanged(projection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent horizon component.
     */
    onDetached() {
        this._isAttached = false;
    }
}

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class HorizonCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    /** @inheritdoc */
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class HorizonCanvasLayer extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
        if (!this._display) {
            throw new Error('HorizonCanvasLayer: attempted to access display before it was initialized');
        }
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
        if (!this._buffer) {
            throw new Error('HorizonCanvasLayer: attempted to access buffer before it was initialized');
        }
        return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
        return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    /** @inheritdoc */
    onVisibilityChanged() {
        if (this.isInit) {
            this.updateCanvasVisibility();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.initCanvasInstances();
        this.isInit = true;
        this.updateCanvasVisibility();
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new HorizonCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this.display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }, " "));
    }
}

/**
 * The different types of horizon projection changes.
 */
var HorizonProjectionChangeType;
(function (HorizonProjectionChangeType) {
    HorizonProjectionChangeType[HorizonProjectionChangeType["Position"] = 1] = "Position";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Altitude"] = 2] = "Altitude";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Heading"] = 4] = "Heading";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Pitch"] = 8] = "Pitch";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Roll"] = 16] = "Roll";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Offset"] = 32] = "Offset";
    HorizonProjectionChangeType[HorizonProjectionChangeType["ProjectedSize"] = 64] = "ProjectedSize";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Fov"] = 128] = "Fov";
    HorizonProjectionChangeType[HorizonProjectionChangeType["FovEndpoints"] = 256] = "FovEndpoints";
    HorizonProjectionChangeType[HorizonProjectionChangeType["PitchScaleFactor"] = 512] = "PitchScaleFactor";
    HorizonProjectionChangeType[HorizonProjectionChangeType["HeadingScaleFactor"] = 1024] = "HeadingScaleFactor";
    HorizonProjectionChangeType[HorizonProjectionChangeType["ScaleFactor"] = 2048] = "ScaleFactor";
    HorizonProjectionChangeType[HorizonProjectionChangeType["ProjectedOffset"] = 4096] = "ProjectedOffset";
    HorizonProjectionChangeType[HorizonProjectionChangeType["OffsetCenterProjected"] = 8192] = "OffsetCenterProjected";
})(HorizonProjectionChangeType || (HorizonProjectionChangeType = {}));
/**
 * A perspective projection from the point of view of an airplane.
 */
class HorizonProjection {
    /**
     * Constructor.
     * @param projectedWidth The initial projected width of the projection, in pixels.
     * @param projectedHeight The initial projected height of the projection, in pixels.
     * @param fov The initial field of view of the projection, in degrees.
     */
    constructor(projectedWidth, projectedHeight, fov) {
        this.position = new GeoPoint(0, 0);
        this.altitude = 0;
        this.heading = 0;
        this.roll = 0;
        this.pitch = 0;
        this.offset = Vec3Math.create();
        this.fovEndpoints = VecNMath.create(4, 0.5, 0, 0.5, 1);
        this.scaleFactor = 1;
        this.projectedOffset = Vec2Math.create();
        this.offsetCenterProjected = Vec2Math.create();
        this.positionAngleTransforms = [new Transform3D(), new Transform3D()];
        this.altitudeTransform = new Transform3D();
        this.positionAltitudeTransforms = [...this.positionAngleTransforms, this.altitudeTransform];
        this.positionTransform = new Transform3D();
        this.planeAngles = Vec3Math.create();
        this.planeAngleTransforms = [new Transform3D(), new Transform3D(), new Transform3D()];
        this.planeTransform = new Transform3D();
        this.cameraPos = Vec3Math.create();
        this.surfacePos = Vec3Math.create();
        this.perspectiveTransform = new TransformPerspective();
        this.oldParameters = {
            position: new GeoPoint(0, 0),
            altitude: 0,
            heading: 0,
            pitch: 0,
            roll: 0,
            offset: Vec3Math.create(),
            projectedSize: Vec2Math.create(),
            fov: 0,
            fovEndpoints: VecNMath.create(4),
            pitchScaleFactor: 1,
            headingScaleFactor: 1,
            scaleFactor: 1,
            projectedOffset: Vec2Math.create(),
            offsetCenterProjected: Vec2Math.create()
        };
        this.queuedParameters = {};
        this.updateQueued = false;
        this.changeEvent = new SubEvent();
        this.projectedSize = Vec2Math.create(projectedWidth, projectedHeight);
        this.fov = fov;
        this.pitchScaleFactor = 1;
        this.headingScaleFactor = 1;
        this.recompute();
    }
    /**
     * Gets the position of this projection.
     * @returns The position of this projection.
     */
    getPosition() {
        return this.position.readonly;
    }
    /**
     * Gets the altitude of this projection, in meters above mean sea level.
     * @returns The altitude of this projection, in meters above mean sea level.
     */
    getAltitude() {
        return this.altitude;
    }
    /**
     * Gets the true heading of this projection, in degrees.
     * @returns The true heading of this projection, in degrees.
     */
    getHeading() {
        return this.heading;
    }
    /**
     * Gets the pitch of this projection, in degrees.
     * @returns The pitch of this projection, in degrees.
     */
    getPitch() {
        return this.pitch;
    }
    /**
     * Gets the roll of this projection, in degrees.
     * @returns The roll of this projection, in degrees.
     */
    getRoll() {
        return this.roll;
    }
    /**
     * Gets the size of the projected window, as `[width, height]` in pixels.
     * @returns The size of the projected window, as `[width, height]` in pixels.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the field of view of this projection, in degrees.
     * @returns The field of view of this projection, in degrees.
     */
    getFov() {
        return this.fov;
    }
    /**
     * Gets the projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     * @returns The projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each
     * component expressed relative to the width or height of the projected window.
     */
    getFovEndpoints() {
        return this.fovEndpoints;
    }
    /**
     * Gets the focal length of this projection, in meters. The focal length is set such that one meter at a distance
     * from the camera equal to the focal length subtends an angle equal to the field of view.
     * @returns The focal length of this projection, in meters.
     */
    getFocalLength() {
        return this.surfacePos[2];
    }
    /**
     * Gets the pitch angle scale factor of this projection. When a point is projected, its relative zero-roll pitch
     * angle is scaled by this value before projection. The relative zero-roll pitch angle of a point is the pitch angle
     * of the point relative to the camera if the airplane had zero degrees of roll. A scaling factor of 1 leaves points
     * unchanged. Factors less than 1 cause points to be projected closer to the pitch line corresponding to the
     * airplane's pitch. Factors greater than 1 cause points to be projected farther from the pitch line corresponding
     * to the airplane's pitch.
     * @returns The pitch angle scale factor of this projection.
     */
    getPitchScaleFactor() {
        return this.pitchScaleFactor;
    }
    /**
     * Gets the heading angle scale factor of this projection. When a point is projected, its relative heading angle is
     * scaled by this value before projection. The relative heading angle of a point is the difference between the
     * bearing of the point from the airplane and the airplane's heading. A scaling factor of 1 leaves points unchanged.
     * Factors less than 1 cause points to be projected closer to the lubber line. Factors greater than 1 cause points to
     * be projected farther from the lubber line.
     * @returns The heading angle scale factor of this projection.
     */
    getHeadingScaleFactor() {
        return this.headingScaleFactor;
    }
    /**
     * Gets the nominal scale factor of this projection. At a distance from the camera equal to the focal length, one
     * meter will be projected to a number of pixels equal to the nominal scale factor.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /**
     * Gets the projected offset of this projection's center, as `[x, y]` in pixels.
     * @returns The projected offset of this projection's center, as `[x, y]` in pixels.
     */
    getProjectedOffset() {
        return this.projectedOffset;
    }
    /**
     * Gets the projected center of this projection, including offset, as `[x, y]` in pixels.
     * @returns The projected center of this projection, including offset, as `[x, y]` in pixels.
     */
    getOffsetCenterProjected() {
        return this.offsetCenterProjected;
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        Vec2Math.set(this.projectedSize[0] / 2 + this.projectedOffset[0], this.projectedSize[1] / 2 + this.projectedOffset[1], this.offsetCenterProjected);
        // Compute the transformation required to bring the position of the plane to [0, 0, 0]. After applying this
        // transformation, with a heading/roll/pitch of 0, the positive z axis points in the direction of the plane, the
        // positive x axis points directly upward (away from the ground), and the positive y axis points to the right.
        this.positionAngleTransforms[0].toRotationZ(-this.position.lon * Avionics.Utils.DEG2RAD);
        this.positionAngleTransforms[1].toRotationY(this.position.lat * Avionics.Utils.DEG2RAD);
        this.altitudeTransform.toTranslation(-(UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + this.altitude), 0, 0);
        Transform3D.concat(this.positionTransform, this.positionAltitudeTransforms);
        this.planeAngles[0] = -this.heading * Avionics.Utils.DEG2RAD;
        this.planeAngles[1] = this.pitch * Avionics.Utils.DEG2RAD;
        this.planeAngles[2] = this.roll * Avionics.Utils.DEG2RAD;
        this.planeAngleTransforms[0].toRotationZ(this.planeAngles[2]);
        this.planeAngleTransforms[1].toRotationY(this.planeAngles[1]);
        this.planeAngleTransforms[2].toRotationX(this.planeAngles[0]);
        Transform3D.concat(this.planeTransform, this.planeAngleTransforms);
        // Convert camera offset to world coordinates
        this.planeTransform.apply(this.offset, this.cameraPos);
        this.scaleFactor = Math.hypot(this.fovEndpoints[2] * this.projectedSize[0] - this.fovEndpoints[0] * this.projectedSize[0], this.fovEndpoints[3] * this.projectedSize[1] - this.fovEndpoints[1] * this.projectedSize[1]);
        this.surfacePos[2] = 1 / (2 * Math.tan(this.fov * 0.5 * Avionics.Utils.DEG2RAD));
        this.perspectiveTransform
            .setCameraRotation(this.planeTransform)
            .setSurfacePosition(this.surfacePos);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        var _a, _b, _c, _d, _e, _f, _g;
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.position !== undefined && this.position.set(parameters.position);
        this.altitude = (_a = parameters.altitude) !== null && _a !== void 0 ? _a : this.altitude;
        this.heading = (_b = parameters.heading) !== null && _b !== void 0 ? _b : this.heading;
        this.pitch = (_c = parameters.pitch) !== null && _c !== void 0 ? _c : this.pitch;
        this.roll = (_d = parameters.roll) !== null && _d !== void 0 ? _d : this.roll;
        parameters.offset !== undefined && this.offset.set(parameters.offset);
        parameters.projectedSize !== undefined && this.projectedSize.set(parameters.projectedSize);
        this.fov = (_e = parameters.fov) !== null && _e !== void 0 ? _e : this.fov;
        parameters.fovEndpoints !== undefined && this.fovEndpoints.set(parameters.fovEndpoints);
        this.pitchScaleFactor = (_f = parameters.pitchScaleFactor) !== null && _f !== void 0 ? _f : this.pitchScaleFactor;
        this.headingScaleFactor = (_g = parameters.headingScaleFactor) !== null && _g !== void 0 ? _g : this.headingScaleFactor;
        parameters.projectedOffset !== undefined && this.projectedOffset.set(parameters.projectedOffset);
        let changeFlags = this.computeChangeFlags(this.oldParameters);
        if ((changeFlags & HorizonProjection.RECOMPUTE_MASK) !== 0) {
            this.recompute();
            changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        }
        if (changeFlags !== 0) {
            this.changeEvent.notify(this, changeFlags);
        }
    }
    /**
     * Sets the projection parameters to be applied when `applyQueued()` is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
        Object.assign(this.queuedParameters, parameters);
        this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
        if (this.updateQueued) {
            this.updateQueued = false;
            this.set(this.queuedParameters);
            for (const key in this.queuedParameters) {
                delete this.queuedParameters[key];
            }
        }
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.position.set(this.position);
        record.altitude = this.altitude;
        record.heading = this.heading;
        record.pitch = this.pitch;
        record.roll = this.roll;
        record.offset.set(this.offset);
        record.projectedSize.set(this.projectedSize);
        record.fov = this.fov;
        record.fovEndpoints.set(this.fovEndpoints);
        record.pitchScaleFactor = this.pitchScaleFactor;
        record.headingScaleFactor = this.headingScaleFactor;
        record.scaleFactor = this.scaleFactor;
        record.projectedOffset.set(this.projectedOffset);
        record.offsetCenterProjected.set(this.offsetCenterProjected);
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return (oldParameters.position.equals(this.position) ? 0 : HorizonProjectionChangeType.Position)
            | (oldParameters.altitude === this.altitude ? 0 : HorizonProjectionChangeType.Altitude)
            | (oldParameters.heading === this.heading ? 0 : HorizonProjectionChangeType.Heading)
            | (oldParameters.pitch === this.pitch ? 0 : HorizonProjectionChangeType.Pitch)
            | (oldParameters.roll === this.roll ? 0 : HorizonProjectionChangeType.Roll)
            | (Vec3Math.equals(oldParameters.offset, this.offset) ? 0 : HorizonProjectionChangeType.Offset)
            | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : HorizonProjectionChangeType.ProjectedSize)
            | (oldParameters.fov === this.fov ? 0 : HorizonProjectionChangeType.Fov)
            | (VecNMath.equals(oldParameters.fovEndpoints, this.fovEndpoints) ? 0 : HorizonProjectionChangeType.FovEndpoints)
            | (oldParameters.pitchScaleFactor === this.pitchScaleFactor ? 0 : HorizonProjectionChangeType.PitchScaleFactor)
            | (oldParameters.headingScaleFactor === this.headingScaleFactor ? 0 : HorizonProjectionChangeType.HeadingScaleFactor)
            | (Vec2Math.equals(oldParameters.projectedOffset, this.projectedOffset) ? 0 : HorizonProjectionChangeType.ProjectedOffset);
    }
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    computeDerivedChangeFlags(oldParameters) {
        return (oldParameters.scaleFactor === this.scaleFactor ? 0 : HorizonProjectionChangeType.ScaleFactor)
            | (Vec2Math.equals(oldParameters.offsetCenterProjected, this.offsetCenterProjected) ? 0 : HorizonProjectionChangeType.OffsetCenterProjected);
    }
    /**
     * Subscribes a change listener to this projection. The listener will be called every time this projection changes.
     * A listener can be subscribed multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to subscribe.
     * @returns The new subscription.
     */
    onChange(listener) {
        return this.changeEvent.on(listener);
    }
    /**
     * Projects a point represented by a set of lat/lon coordinates and altitude.
     * @param position The lat/lon coordinates of the point to project.
     * @param altitude The altitude of the point to project, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    project(position, altitude, out) {
        const vec = GeoPoint.sphericalToCartesian(position, HorizonProjection.vec3Cache[0]);
        Vec3Math.multScalar(vec, UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + altitude, vec);
        this.positionTransform.apply(vec, vec);
        return this.projectRelativeVec(vec, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    projectRelativeCoordinates(arg1, arg2, arg3, arg4) {
        if (typeof arg1 === 'number') {
            return this.projectRelativeVec(Vec3Math.set(arg1, arg2, arg3, HorizonProjection.vec3Cache[0]), arg4);
        }
        else {
            return this.projectRelativeVec(arg1, arg2);
        }
    }
    /**
     * Projects a point relative to the position of the airplane in spherical space.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The geodetic horizontal distance from the point to project to the airplane, in meters.
     * @param height The geodetic height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeSpherical(bearing, distance, height, out) {
        return this.project(this.position.offset(bearing, UnitType.METER.convertTo(distance, UnitType.GA_RADIAN), HorizonProjection.geoPointCache[0]), this.altitude + height, out);
    }
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The point ot project is expressed
     * in terms of bearing, horizontal distance, and height. The coordinate system is defined at the position of the
     * airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel to
     * the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the airplane, in meters.
     * @param height The Euclidean height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeEuclidean(bearing, distance, height, out) {
        const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = height;
        const y = vec[1];
        const z = vec[0];
        return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The point to project is expressed
     * in terms of distance, relative bearing and pitch. The coordinate system is defined at the position of the
     * airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel to
     * the Earth's surface at the point directly underneath the airplane.
     * @param distance The Euclidean distance from the point to project to the airplane, in meters.
     * @param bearing The relative bearing from the airplane to the point to project, in degrees. The relative bearing is
     * measured relative to the airplane's heading, with positive angles sweeping clockwise when viewed from above.
     * @param pitch The pitch angle from the airplane to the point to project, in degrees. The pitch angle is measured
     * relative to the horizontal plane, with positive angles sweeping above the plane.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeAngular(distance, bearing, pitch, out) {
        const trueBearing = this.heading + bearing;
        const vec = Vec3Math.setFromSpherical(distance, (90 - pitch) * Avionics.Utils.DEG2RAD, trueBearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = vec[2];
        const y = vec[1];
        const z = vec[0];
        return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a 3D vector defined relative to the airplane, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    projectRelativeVec(vec, out) {
        const vecToProject = Vec3Math.sub(vec, this.cameraPos, HorizonProjection.relativeVec3Cache[0]);
        if (this.pitchScaleFactor !== 1 || this.headingScaleFactor !== 1) {
            this.applyPitchHeadingScale(vecToProject, this.pitchScaleFactor, this.headingScaleFactor, vecToProject);
        }
        this.perspectiveTransform.apply(vecToProject, out);
        return Vec2Math.set(out[1] * this.scaleFactor + this.offsetCenterProjected[0], -out[0] * this.scaleFactor + this.offsetCenterProjected[1], out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    projectCameraRelativeCoordinates(arg1, arg2, arg3, arg4) {
        if (typeof arg1 === 'number') {
            return this.projectCameraRelativeVec(Vec3Math.set(arg1, arg2, arg3, HorizonProjection.vec3Cache[0]), arg4);
        }
        else {
            return this.projectCameraRelativeVec(arg1, arg2);
        }
    }
    /**
     * Projects a point relative to the position of the projection camera in Euclidean space. The point to project is
     * expressed in terms of bearing, horizontal distance, and height. The coordinate system is defined at the position
     * of the camera, with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel
     * to the Earth's surface at the point directly underneath the camera.
     * @param bearing The true bearing from the camera to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the camera, in meters.
     * @param height The Euclidean height of the point to project relative to the camera, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectCameraRelativeEuclidean(bearing, distance, height, out) {
        const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = height;
        const y = vec[1];
        const z = vec[0];
        return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a point relative to the position of the projection camera in Euclidean space. The point to project is
     * expressed in terms of distance, bearing and pitch. The coordinate system is defined at the position of the camera,
     * with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel to the Earth's
     * surface at the point directly underneath the camera.
     * @param distance The Euclidean distance from the point to project to the camera, in meters.
     * @param bearing The true bearing from the camera to the point to project, in degrees.
     * @param pitch The pitch angle from the camera to the point to project, in degrees. The pitch angle is measured
     * relative to the horizontal plane, with positive angles sweeping above the plane.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectCameraRelativeAngular(distance, bearing, pitch, out) {
        const vec = Vec3Math.setFromSpherical(distance, (90 - pitch) * Avionics.Utils.DEG2RAD, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = vec[2];
        const y = vec[1];
        const z = vec[0];
        return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a 3D vector defined relative to the camera, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    projectCameraRelativeVec(vec, out) {
        if (this.pitchScaleFactor !== 1 || this.headingScaleFactor !== 1) {
            vec = this.applyPitchHeadingScale(vec, this.pitchScaleFactor, this.headingScaleFactor, HorizonProjection.cameraRelativeVec3Cache[0]);
        }
        this.perspectiveTransform.apply(vec, out);
        return Vec2Math.set(out[1] * this.scaleFactor + this.offsetCenterProjected[0], -out[0] * this.scaleFactor + this.offsetCenterProjected[1], out);
    }
    /**
     * Inverts a pair of projected coordinates to calculate the pitch angle and true bearing (both relative to the
     * horizontal plane with origin at the camera) of the set of points in 3D space that are projected to those
     * coordinates.
     * @param x The projected x coordinate to invert.
     * @param y The projected y coordinate to invert.
     * @param out The 2D vector to which to write the result.
     * @returns The pitch angle and true bearing (both relative to the horizontal plane with origin at the camera) of the
     * set of points in 3D space that are projected to the specified coordinates, as `[pitch angle, true bearing]` in
     * degrees.
     */
    invertToCameraRelativeAngles(x, y, out) {
        // We need to invert the perspective transformation. Since we are only calculating the pitch and bearing angles
        // referenced to the camera (and not also the distance), we can achieve this by choosing an arbitrary z-value for
        // the inverted position vector. If we choose the z-value to be equal to the camera's focal length, then the x and
        // y values of the inverted position vector will be exactly the x and y values of its projection.
        const perspectiveX = (this.offsetCenterProjected[1] - y) / this.scaleFactor;
        const perspectiveY = (x - this.offsetCenterProjected[0]) / this.scaleFactor;
        const cameraRelativeVec = Vec3Math.set(perspectiveX, perspectiveY, this.surfacePos[2], HorizonProjection.vec3Cache[0]);
        this.planeTransform.apply(cameraRelativeVec, cameraRelativeVec);
        if (this.pitchScaleFactor !== 1 || this.headingScaleFactor !== 1) {
            this.applyPitchHeadingScale(cameraRelativeVec, 1 / this.pitchScaleFactor, 1 / this.headingScaleFactor, cameraRelativeVec);
        }
        // Rotate the coordinate system such that z is the vertical axis and x/y form the horizontal plane so that we can
        // use standard theta/phi angles.
        Vec3Math.set(cameraRelativeVec[1], cameraRelativeVec[2], cameraRelativeVec[0], cameraRelativeVec);
        return Vec2Math.set(((90 - Vec3Math.theta(cameraRelativeVec) * Avionics.Utils.RAD2DEG) + 180) % 360 - 180, // -180 to 180
        ((90 - Vec3Math.phi(cameraRelativeVec) * Avionics.Utils.RAD2DEG) + 360) % 360, // 0 to 360
        out);
    }
    /**
     * Applies pitch and heading angle scaling to a 3D vector defined relative to the camera, as `[x, y, z]` in meters
     * with the coordinate system defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param pitchScaleFactor The pitch angle scale factor to use.
     * @param headingScaleFactor The heading angle scale factor to use.
     * @param out The 3D vector to which to write the result.
     * @returns The scaled vector.
     */
    applyPitchHeadingScale(vec, pitchScaleFactor, headingScaleFactor, out) {
        if (pitchScaleFactor !== 1 || headingScaleFactor !== 1) {
            // Rotate the coordinate system such that z is the vertical axis and x/y form the horizontal plane so that we can
            // use standard theta/phi angles.
            Vec3Math.set(vec[1], vec[2], vec[0], out);
            const length = Vec3Math.abs(out);
            if (length > 0) {
                let theta;
                let phi;
                if (pitchScaleFactor !== 1) {
                    theta = Vec3Math.theta(out);
                    const planePitchRad = this.planeAngles[1];
                    const relativePitchAngle = ((MathUtils.HALF_PI - theta) - planePitchRad + Math.PI) % MathUtils.TWO_PI - Math.PI; // range -pi to +pi
                    if (relativePitchAngle !== 0) {
                        theta = MathUtils.HALF_PI - (relativePitchAngle * pitchScaleFactor + planePitchRad);
                        phi = Vec3Math.phi(out);
                        Vec3Math.setFromSpherical(length, theta, phi, out);
                    }
                }
                if (headingScaleFactor !== 1) {
                    phi !== null && phi !== void 0 ? phi : (phi = Vec3Math.phi(out));
                    const planeHeadingRad = -this.planeAngles[0];
                    const relativeHeadingAngle = ((MathUtils.HALF_PI - phi) - planeHeadingRad + Math.PI) % MathUtils.TWO_PI - Math.PI; // range -pi to +pi
                    if (relativeHeadingAngle !== 0) {
                        phi = MathUtils.HALF_PI - (relativeHeadingAngle * headingScaleFactor + planeHeadingRad);
                        theta !== null && theta !== void 0 ? theta : (theta = Vec3Math.theta(out));
                        Vec3Math.setFromSpherical(length, theta, phi, out);
                    }
                }
                // Rotate back to the original coordinate system.
                return Vec3Math.set(out[2], out[0], out[1], out);
            }
        }
        return Vec3Math.copy(vec, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isInProjectedBounds(point, arg2, arg3) {
        let bounds;
        if (point instanceof Float64Array) {
            bounds = arg2;
        }
        else {
            point = this.project(point, arg2, HorizonProjection.vec2Cache[0]);
            bounds = arg3;
        }
        const x = point[0];
        const y = point[1];
        if (!isFinite(x) || !isFinite(y)) {
            return false;
        }
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        return x >= left && x <= right && y >= top && y <= bottom;
    }
}
HorizonProjection.RECOMPUTE_MASK = ~(HorizonProjectionChangeType.PitchScaleFactor | HorizonProjectionChangeType.HeadingScaleFactor);
HorizonProjection.vec2Cache = [Vec2Math.create()];
HorizonProjection.vec3Cache = [Vec3Math.create()];
HorizonProjection.geoPointCache = [new GeoPoint(0, 0)];
HorizonProjection.relativeVec3Cache = [Vec3Math.create()];
HorizonProjection.cameraRelativeVec3Cache = [Vec3Math.create()];

/**
 * A canvas horizon layer whose size and position is synced with the horizon projection window.
 */
class HorizonSyncedCanvasLayer extends HorizonCanvasLayer {
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.projection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the horizon projected window.
     * @param projectedSize The size of the horizon projected window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(projection.getProjectedSize());
        }
    }
}

/**
 * A component which displays an artificial horizon. A horizon tracks the position, altitude, heading, pitch, and roll
 * of an airplane and uses a persepctive projection to project points in space to a planar pixel grid. Each horizon
 * component maintains a {@link HorizonComponent} instance which handles the details of the projection.
 * {@link HorizonLayer} objects added to the horizon as children determine what is drawn in the horizon window.
 */
class HorizonComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.layerEntries = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.projectedSize = SubscribableUtils.toSubscribable(this.props.projectedSize, true);
        this.fov = SubscribableUtils.toSubscribable(this.props.fov, true);
        if (this.props.fovEndpoints !== undefined) {
            this.fovEndpoints = SubscribableUtils.toSubscribable(this.props.fovEndpoints, true);
        }
        if (this.props.projectedOffset !== undefined) {
            this.projectedOffset = SubscribableUtils.toSubscribable(this.props.projectedOffset, true);
        }
        const initialSize = this.projectedSize.get();
        const initialFov = this.fov.get();
        if (this.props.projection !== undefined) {
            this.props.projection.set({ projectedSize: initialSize, fov: initialFov });
        }
        this.projection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new HorizonProjection(initialSize[0], initialSize[1], initialFov);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
        return this.projection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this horizon is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this horizon to sleep. While asleep, this horizon will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this horizon, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this horizon's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this horizon's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        var _a, _b;
        this.projection.onChange(this.onProjectionChanged.bind(this));
        this.projectedSizeSub = this.projectedSize.sub(size => {
            this.projection.set({ projectedSize: size });
        }, true);
        this.fovSub = this.fov.sub(fov => {
            this.projection.set({ fov });
        }, true);
        this.fovEndpointsSub = (_a = this.fovEndpoints) === null || _a === void 0 ? void 0 : _a.sub(fovEndpoints => {
            this.projection.set({ fovEndpoints });
        }, true);
        this.projectedOffsetSub = (_b = this.projectedOffset) === null || _b === void 0 ? void 0 : _b.sub(projectedOffset => {
            this.projection.set({ projectedOffset });
        }, true);
        this.attachLayers(thisNode);
        if (!this._isAwake) {
            this.sleepLayers();
        }
    }
    /**
     * Scans this component's VNode sub-tree for HorizonLayer components and attaches them when found. Only the top-most
     * level of HorizonLayer components are attached; layers that are themselves children of other layers are not
     * attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
        FSComponent.visitNodes(thisNode, node => {
            if (node.instance instanceof HorizonLayer) {
                this.attachLayer(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * This method is called when this horizon is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this horizon's layers.
     */
    wakeLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onWake();
        }
    }
    /**
     * This method is called when this horizon is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this horizon's layers.
     */
    sleepLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onSleep();
        }
    }
    /**
     * This method is called when this horizon's projection changes.
     * @param projection This horizon's projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onProjectionChanged(projection, changeFlags);
        }
    }
    /**
     * This method is called when the size of this horizon's projected window changes.
     */
    onProjectedSizeChanged() {
        // noop
    }
    /**
     * Attaches a layer to this horizon component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layerEntries.findIndex(entry => entry.layer === layer) >= 0) {
            return;
        }
        const entry = new LayerEntry(layer);
        this.layerEntries.push(entry);
        entry.attach();
    }
    /**
     * Detaches a layer from this horizon component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layerEntries.findIndex(entry => entry.layer === layer);
        if (index >= 0) {
            const entry = this.layerEntries[index];
            entry.detach();
            this.layerEntries.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Updates this horizon.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this horizon's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].update(time);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        super.destroy();
        (_a = this.projectedSizeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.fovSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.fovEndpointsSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.projectedOffsetSub) === null || _d === void 0 ? void 0 : _d.destroy();
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].destroy();
        }
    }
}
/**
 * An entry for a horizon layer.
 */
class LayerEntry {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
        this.layer = layer;
        this.updatePeriod = 0;
        this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
        var _a, _b;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
            const clamped = Math.max(0, freq);
            this.updatePeriod = clamped === 0 ? 0 : 1000 / clamped;
        }, true);
        this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
        if (currentTime - this.lastUpdated >= this.updatePeriod) {
            this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
            this.lastUpdated = currentTime;
        }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
        var _a;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
        this.detach();
        this.layer.destroy();
    }
}

/**
 * A path stream which does nothing on any input.
 */
/**
 * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
 * stream.
 */
class AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer) {
        this.consumer = consumer;
    }
    /** @inheritdoc */
    getConsumer() {
        return this.consumer;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.consumer = consumer;
    }
}

/**
 * A {@link TransformingPathStream} which applies an affine transformation to its input.
 *
 * The types of transformation supported by this class are:
 * * Translation.
 * * Uniform scaling.
 * * Rotation.
 */
class AffineTransformPathStream extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.transform = new Transform2D();
        this.concatCache = [];
        this.scale = 1;
        this.rotation = 0;
    }
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x, y, order = 'after') {
        const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
        if (order === 'before') {
            this.concatCache[0] = translation;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = translation;
        }
        Transform2D.concat(this.transform, this.concatCache);
        return this;
    }
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor, order = 'after') {
        const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
        if (order === 'before') {
            this.concatCache[0] = scale;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = scale;
        }
        Transform2D.concat(this.transform, this.concatCache);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle, order = 'after') {
        const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
        if (order === 'before') {
            this.concatCache[0] = rotation;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = rotation;
        }
        Transform2D.concat(this.transform, this.concatCache);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform() {
        this.transform.toIdentity();
        this.updateScaleRotation();
        return this;
    }
    /** @inheritdoc */
    beginPath() {
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.moveTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.lineTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const cp1Transformed = this.applyTransform(cp1x, cp1y);
        cp1x = cp1Transformed[0];
        cp1y = cp1Transformed[1];
        const cp2Transformed = this.applyTransform(cp2x, cp2y);
        cp2x = cp2Transformed[0];
        cp2y = cp2Transformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        const cpTransformed = this.applyTransform(cpx, cpy);
        cpx = cpTransformed[0];
        cpy = cpTransformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        const transformed = this.applyTransform(x, y);
        this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.consumer.closePath();
    }
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    updateScaleRotation() {
        const params = this.transform.getParameters();
        this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
        this.rotation = Math.atan2(params[3], params[0]);
    }
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    applyTransform(x, y) {
        const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
        return this.transform.apply(vec, vec);
    }
}
AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
AffineTransformPathStream.transformCache = [new Transform2D()];

/**
 * An abstract implementation of {@link CssTransform}
 */
class AbstractCssTransform {
    /**
     * Constructor.
     * @param initialParams The transform's initial parameters.
     */
    constructor(initialParams) {
        this.params = new Float64Array(initialParams);
        this.cachedParams = new Float64Array(initialParams);
    }
    /** @inheritdoc */
    resolve() {
        if (this.stringValue !== undefined && VecNMath.equals(this.params, this.cachedParams)) {
            return this.stringValue;
        }
        VecNMath.copy(this.params, this.cachedParams);
        this.stringValue = this.buildString(this.params);
        return this.stringValue;
    }
}
/**
 * A CSS `matrix` transform.
 */
class CssMatrixTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    constructor() {
        super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
        let scaleX;
        if (typeof arg1 === 'number') {
            scaleX = arg1;
        }
        else {
            [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
        }
        this.params[0] = scaleX;
        this.params[1] = skewY;
        this.params[2] = skewX;
        this.params[3] = scaleY;
        this.params[4] = translateX;
        this.params[5] = translateY;
    }
    /** @inheritdoc */
    buildString(params) {
        return `matrix(${params.join(', ')})`;
    }
}
CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
/**
 * A CSS `rotate` transform.
 */
class CssRotateTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
        super(CssRotateTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's rotation angle.
     * @param angle The angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(angle, precision = 0) {
        this.params[0] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `rotate(${params[0]}${this.unit})`;
    }
}
CssRotateTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `rotate3d` transform.
 */
class CssRotate3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
        super(CssRotate3dTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's rotation.
     * @param x The x component of the rotation axis vector.
     * @param y The y component of the rotation axis vector.
     * @param z The z component of the rotation axis vector.
     * @param angle The rotation angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, y, z, angle, precision = 0) {
        this.params[0] = x;
        this.params[1] = y;
        this.params[2] = z;
        this.params[3] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
}
CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
/**
 * A CSS `translateX` transform.
 */
class CssTranslateXTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateXTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param x The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(x, precision = 0) {
        this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateX(${params[0]}${this.unit})`;
    }
}
CssTranslateXTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translateY` transform.
 */
class CssTranslateYTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateYTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param y The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(y, precision = 0) {
        this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateY(${params[0]}${this.unit})`;
    }
}
CssTranslateYTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translateZ` transform.
 */
class CssTranslateZTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateZTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param z The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(z, precision = 0) {
        this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateZ(${params[0]}${this.unit})`;
    }
}
CssTranslateZTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translate` transform.
 */
class CssTranslateTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX) {
        super(CssTranslateTransform.DEFAULT_PARAMS);
        this.unitX = unitX;
        this.unitY = unitY;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
}
CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
/**
 * A CSS `translate3d` transform.
 */
class CssTranslate3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     * @param unitZ The unit to use for this transform's z translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX, unitZ = unitX) {
        super(CssTranslate3dTransform.DEFAULT_PARAMS);
        this.unitX = unitX;
        this.unitY = unitY;
        this.unitZ = unitZ;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param z The z translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     * @param precisionZ The precision with which to set the z translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
        this.params[2] = precisionZ === 0 ? z : MathUtils.round(z, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
}
CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
/**
 * A CSS `scaleX` transform.
 */
class CssScaleXTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, precision = 0) {
        this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleX(${params[0]})`;
    }
}
CssScaleXTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scaleY` transform.
 */
class CssScaleYTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param y The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(y, precision = 0) {
        this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleY(${params[0]})`;
    }
}
CssScaleYTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scaleZ` transform.
 */
class CssScaleZTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param z The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(z, precision = 0) {
        this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleZ(${params[0]})`;
    }
}
CssScaleZTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scale` transform.
 */
class CssScaleTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scale(${params[0]}, ${params[1]})`;
    }
}
CssScaleTransform.DEFAULT_PARAMS = [1, 1];
/**
 * A CSS `scale3d` transform.
 */
class CssScale3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param z The z scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     * @param precisionZ The precision with which to set the z scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
        this.params[2] = precisionZ === 0 ? z : MathUtils.round(y, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
}
CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
/**
 * A concatenated chain of CSS transforms.
 */
class CssTransformChain {
    /**
     * Creates a new chain of CSS transforms.
     * @param transforms The individual child transforms that will constitute the new transform chain. The order of
     * the children passed to the constructor determines the order of concatenation. Concatenation follows the standard
     * CSS transform convention: for a concatenation of transforms `[A, B, C]`, the resulting transformation is
     * equivalent to the one produced by multiplying the transformation matrices in the order `(A * B) * C`.
     */
    constructor(...transforms) {
        this.stringValues = [];
        this.transforms = transforms;
    }
    /**
     * Gets one of this chain's child transforms.
     * @param index The index of the child to get.
     * @returns The child transform at the specified index in this chain.
     * @throws RangeError if `index` is out of bounds.
     */
    getChild(index) {
        if (index < 0 || index >= this.transforms.length) {
            throw new RangeError();
        }
        return this.transforms[index];
    }
    /** @inheritdoc */
    resolve() {
        let needRebuildString = false;
        for (let i = 0; i < this.transforms.length; i++) {
            const stringValue = this.transforms[i].resolve();
            if (this.stringValues[i] !== stringValue) {
                this.stringValues[i] = stringValue;
                needRebuildString = true;
            }
        }
        if (needRebuildString || this.chainedStringValue === undefined) {
            this.chainedStringValue = this.stringValues.join(' ');
        }
        return this.chainedStringValue;
    }
}
/**
 * A subscribable subject whose value is a CSS transform string resolved from a {@link CssTransform}.
 */
class CssTransformSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param transform The new subject's CSS transform.
     */
    constructor(transform) {
        super();
        this._transform = transform;
        this.stringValue = transform.resolve();
        this.transform = transform;
    }
    /** @inheritdoc */
    get() {
        return this.stringValue;
    }
    /**
     * Resolves this subject's CSS transform to a CSS transform string, and sets this subject's value to the resolved
     * string. If this changes this subject's value, subscribers will be notified.
     */
    resolve() {
        const stringValue = this._transform.resolve();
        if (stringValue !== this.stringValue) {
            this.stringValue = stringValue;
            this.notify();
        }
    }
    /**
     * Creates a new instance of {@link CssTransformSubject} whose value is resolved from a CSS transform.
     * @param transform A CSS transform.
     * @returns A new instance of {@link CssTransformSubject} whose value is resolved from the specified CSS transform.
     */
    static create(transform) {
        return new CssTransformSubject(transform);
    }
}
/**
 * A utility class for building CSS transforms.
 */
class CssTransformBuilder {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     * @returns A new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    static matrix() {
        return new CssMatrixTransform();
    }
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate` transform, initialized to zero rotation.
     */
    static rotate(unit) {
        return new CssRotateTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     */
    static rotate3d(unit) {
        return new CssRotate3dTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateX` transform, initialized to zero translation.
     */
    static translateX(unit) {
        return new CssTranslateXTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateY` transform, initialized to zero translation.
     */
    static translateY(unit) {
        return new CssTranslateYTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateZ` transform, initialized to zero translation.
     */
    static translateZ(unit) {
        return new CssTranslateZTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @returns A new instance of a CSS `translate` transform, initialized to zero translation.
     */
    static translate(unitX, unitY) {
        return new CssTranslateTransform(unitX, unitY);
    }
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @param unitZ The unit to use for the new transform's z translation.
     * @returns A new instance of a CSS `translate3d` transform, initialized to zero translation.
     */
    static translate3d(unitX, unitY, unitZ) {
        return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    static scaleX() {
        return new CssScaleXTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    static scaleY() {
        return new CssScaleYTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    static scaleZ() {
        return new CssScaleZTransform();
    }
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    static scale() {
        return new CssScaleTransform();
    }
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    static scale3d() {
        return new CssScale3dTransform();
    }
    /**
     * Concatenates zero or more CSS transformations.
     * @param transforms The individual transforms to concatentate. The order of the transforms passed to the function
     * determines the order of concatenation. Concatenation follows the standard CSS transform convention: for a
     * concatenation of transforms `[A, B, C]`, the resulting transformation is equivalent to the one produced by
     * multiplying the transformation matrices in the order `(A * B) * C`.
     * @returns A new {@link CssTransformChain} object representing the concatenation of the specified transforms.
     */
    static concat(...transforms) {
        return new CssTransformChain(...transforms);
    }
}

/**
 * A utility class for creating number formatters.
 *
 * Each number formatter is a function which generates output strings from input numeric values. The formatting
 * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
 * documentation for more information on each individual option.
 */
class NumberFormatter {
    /**
     * Formats a number to a string.
     * @param number The number to format.
     * @param opts Options describing how to format the number.
     * @returns The formatted string representation of the specified number.
     */
    static formatNumber(number, opts) {
        if (isNaN(number)) {
            return opts.nanString;
        }
        const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
        const sign = number < 0 ? -1 : 1;
        const abs = Math.abs(number);
        let rounded = abs;
        if (precision !== 0) {
            rounded = roundFunc(abs / precision) * precision;
        }
        if (cache) {
            if (opts.cachedString !== undefined && opts.cachedNumber === rounded) {
                return opts.cachedString;
            }
            opts.cachedNumber = rounded;
        }
        const signText = sign === -1
            ? useMinusSign ? '−' : '-'
            : '+';
        let formatted;
        if (precision != 0) {
            const precisionString = `${precision}`;
            const decimalIndex = precisionString.indexOf('.');
            if (decimalIndex >= 0) {
                formatted = rounded.toFixed(precisionString.length - decimalIndex - 1);
            }
            else {
                formatted = `${rounded}`;
            }
        }
        else {
            formatted = `${abs}`;
        }
        let decimalIndex = formatted.indexOf('.');
        if (!forceDecimalZeroes && decimalIndex >= 0) {
            formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, '');
            if (formatted.indexOf('.') == formatted.length - 1) {
                formatted = formatted.substring(0, formatted.length - 1);
            }
        }
        decimalIndex = formatted.indexOf('.');
        if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
            const shift = Math.max(maxDigits - decimalIndex, 0);
            const shiftPrecision = Math.pow(0.1, shift);
            formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
        }
        if (pad === 0) {
            formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, '.');
        }
        else if (pad > 1) {
            decimalIndex = formatted.indexOf('.');
            if (decimalIndex < 0) {
                decimalIndex = formatted.length;
            }
            formatted = formatted.padStart(pad + formatted.length - decimalIndex, '0');
        }
        if (showCommas) {
            const parts = formatted.split('.');
            parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ',');
            formatted = parts.join('.');
        }
        formatted = ((forceSign || signText !== '+') ? signText : '') + formatted;
        if (cache) {
            opts.cachedString = formatted;
        }
        return formatted;
    }
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * * `cache = false`
     * @returns A function which formats numeric values to strings.
     */
    static create(options) {
        const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
        optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
        return (number) => {
            return NumberFormatter.formatNumber(number, optsToUse);
        };
    }
}
NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: 'NaN',
    cache: false
};
NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
};
NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;

/**
 * A path stream which builds SVG path strings from its input path commands.
 */
class SvgPathStream {
    /**
     * Constructor.
     * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
     * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
     */
    constructor(precision = 0) {
        this.svgPath = '';
        this.firstPoint = new Float64Array([NaN, NaN]);
        this.prevPoint = new Float64Array([NaN, NaN]);
        this.precision = precision;
        this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    /**
     * Gets the SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     * @returns The SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     */
    getSvgPath() {
        return this.svgPath.trim();
    }
    /**
     * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @returns The precision of this stream.
     */
    getPrecision() {
        return this.precision;
    }
    /**
     * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
     */
    setPrecision(precision) {
        this.precision = Math.abs(precision);
        this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (isNaN(this.firstPoint[0])) {
            Vec2Math.set(x, y, this.firstPoint);
        }
        this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
            // Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
            // doesn't match the counterClockwise flag.
            const angleDiff = counterClockwise ? MathUtils.diffAngle(endAngle, startAngle) : MathUtils.diffAngle(startAngle, endAngle);
            endAngle = startAngle + angleDiff * directionSign;
        }
        // Clamp to 2pi because we don't need to draw anything past a full circle.
        const angularWidth = Math.min(MathUtils.TWO_PI, (endAngle - startAngle) * directionSign);
        if (angularWidth === MathUtils.TWO_PI) {
            // SVG arc commands cannot draw a full circle, so we need to split the circle into two half circles
            const midAngle = startAngle + Math.PI * directionSign;
            this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
            this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
            return;
        }
        const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(startPoint[0], startPoint[1]);
        }
        else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
            this.lineTo(startPoint[0], startPoint[1]);
        }
        const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
        const radiusString = this.formatter(radius);
        this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
        Vec2Math.copy(endPoint, this.prevPoint);
    }
    /** @inheritdoc */
    closePath() {
        if (!isNaN(this.firstPoint[0])) {
            this.lineTo(this.firstPoint[0], this.firstPoint[1]);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        Vec2Math.set(NaN, NaN, this.firstPoint);
        Vec2Math.set(NaN, NaN, this.prevPoint);
        this.svgPath = '';
    }
}
SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];

/**
 * TCAS operating modes.
 */
var TcasOperatingMode;
(function (TcasOperatingMode) {
    TcasOperatingMode["Off"] = "Off";
    TcasOperatingMode["Standby"] = "Standby";
    TcasOperatingMode["TAOnly"] = "TAOnly";
    TcasOperatingMode["TA_RA"] = "TA/RA";
    TcasOperatingMode["Test"] = "Test";
    TcasOperatingMode["Failed"] = "Failed";
})(TcasOperatingMode || (TcasOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TcasAlertLevel;
(function (TcasAlertLevel) {
    TcasAlertLevel[TcasAlertLevel["None"] = 0] = "None";
    TcasAlertLevel[TcasAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel[TcasAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel[TcasAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TcasAlertLevel || (TcasAlertLevel = {}));
/**
 * Bit flags describing TCAS resolution advisories.
 */
var TcasResolutionAdvisoryFlags;
(function (TcasResolutionAdvisoryFlags) {
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Corrective"] = 1] = "Corrective";
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["UpSense"] = 2] = "UpSense";
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DownSense"] = 4] = "DownSense";
    /** A resolution advisory which crosses an intruder's altitude. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Crossing"] = 8] = "Crossing";
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Climb"] = 16] = "Climb";
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Descend"] = 32] = "Descend";
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Increase"] = 64] = "Increase";
    /** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Reversal"] = 128] = "Reversal";
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceClimb"] = 256] = "ReduceClimb";
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceDescent"] = 512] = "ReduceDescent";
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotClimb"] = 1024] = "DoNotClimb";
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotDescend"] = 2048] = "DoNotDescend";
})(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
/**
 * Types of TCAS resolution advisories.
 */
var TcasResolutionAdvisoryType;
(function (TcasResolutionAdvisoryType) {
    /** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["Climb"] = "Climb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingClimb"] = "CrossingClimb";
    /** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */
    TcasResolutionAdvisoryType["MaintainClimb"] = "MaintainClimb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    /** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseClimb"] = "IncreaseClimb";
    /** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["ReversalClimb"] = "ReversalClimb";
    /** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceDescent"] = "ReduceDescent";
    /** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend0"] = "DoNotDescend0";
    /** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend500"] = "DoNotDescend500";
    /** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1000"] = "DoNotDescend1000";
    /** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1500"] = "DoNotDescend1500";
    /** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend2000"] = "DoNotDescend2000";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["Descend"] = "Descend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["CrossingDescend"] = "CrossingDescend";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["MaintainDescend"] = "MaintainDescend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    /** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseDescend"] = "IncreaseDescend";
    /** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["ReversalDescend"] = "ReversalDescend";
    /** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceClimb"] = "ReduceClimb";
    /** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb0"] = "DoNotClimb0";
    /** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb500"] = "DoNotClimb500";
    /** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1000"] = "DoNotClimb1000";
    /** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1500"] = "DoNotClimb1500";
    /** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb2000"] = "DoNotClimb2000";
    /** Clear of conflict. */
    TcasResolutionAdvisoryType["Clear"] = "Clear";
})(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
/**
 * A TCAS-II-like system.
 */
class Tcas {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.intrudersRA = new Set();
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.create(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            groundTrack: ConsumerSubject.create(null, 0),
            groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
            radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            isOnGround: ConsumerSubject.create(null, false)
        };
        this.simTime = ConsumerSubject.create(null, 0);
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelSubs = new Map();
        this.eventPublisher = this.bus.getPublisher();
        this.eventSubscriber = this.bus.getSubscriber();
        this.paSeparationCache = {
            horizontal: UnitType.NMILE.createNumber(0),
            vertical: UnitType.FOOT.createNumber(0)
        };
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
        const fullRAOptions = {
            initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
            initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
            subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
            subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
            allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : (() => true),
            allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : (() => true),
            allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100),
            allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450)
        };
        this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost() {
        return this.resolutionAdvisoryHost;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // init own airplane subjects
        sub.on('gps-position').atFrequency(this.realTimeUpdateFreq).handle(lla => {
            this.ownAirplaneSubs.position.set(lla.lat, lla.long);
            this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
        });
        sub.on('ground_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); });
        sub.on('vertical_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); });
        sub.on('radio_alt').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(alt => { this.ownAirplaneSubs.radarAltitude.set(alt); });
        this.ownAirplaneSubs.groundTrack.setConsumer(sub.on('track_deg_true'));
        this.ownAirplaneSubs.isOnGround.setConsumer(sub.on('on_ground'));
        // init sim time subject
        this.simTime.setConsumer(sub.on('simTime'));
        // init operating mode notifier
        this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
        // init update loop
        sub.on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    onOperatingModeChanged(mode) {
        this.bus.pub('tcas_operating_mode', mode, false, true);
        if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
            // We are in a mode where TCAS is not operating normally.
            // Cancel any active resolution advisories.
            this.resolutionAdvisoryHost.cancel(this.simTime.get());
            // Clean up all intruders.
            for (let i = 0; i < this.intrudersFiltered.length; i++) {
                this.cleanUpIntruder(this.intrudersFiltered[i]);
            }
            this.intrudersFiltered = [];
        }
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            let tcaPredictionA, tcaPredictionB;
            // Always sort intruders predicted to violate RA protected volume first (or for whom an RA has been issued), then
            // TA protected volume (or for whom a TA has been issued)
            const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (a.tcaRA.isValid && a.tcaRA.isThreat);
            const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (b.tcaRA.isValid && b.tcaRA.isThreat);
            if (aRA && !bRA) {
                return -1;
            }
            else if (!aRA && bRA) {
                return 1;
            }
            else if (aRA && bRA) {
                tcaPredictionA = a.tcaRA;
                tcaPredictionB = b.tcaRA;
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (a.tcaTA.isValid && a.tcaTA.isThreat);
                const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (b.tcaTA.isValid && b.tcaTA.isThreat);
                if (aTA && !bTA) {
                    return -1;
                }
                else if (!aTA && bTA) {
                    return 1;
                }
                else if (aTA && bTA) {
                    tcaPredictionA = a.tcaTA;
                    tcaPredictionB = b.tcaTA;
                }
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
                    return -1;
                }
                else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            // If both are predicted to violate the RA or TA protected volume, sort by time to CPA.
            // Otherwise sort by how close they approach the protected volume at CPA.
            const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
            const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
            let firstComparison;
            let secondComparison;
            if (tcaPredictionA.isThreat) {
                firstComparison = tcaComparison;
                secondComparison = normComparison;
            }
            else {
                firstComparison = normComparison;
                secondComparison = tcaComparison;
            }
            if (firstComparison === 0) {
                return secondComparison;
            }
            else {
                return firstComparison;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        switch (this.operatingModeSub.get()) {
            case TcasOperatingMode.Off:
            case TcasOperatingMode.Standby:
            case TcasOperatingMode.Failed:
            case TcasOperatingMode.Test: // TODO: support TEST mode
                return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
        this.updateResolutionAdvisory(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            const sensitivity = this.sensitivity.selectParameters(intruder);
            intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
            const intruder = this.intrudersSorted[i];
            if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterIntruder(intruder) {
        return true;
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        let taCount = 0, raCount = 0;
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersFiltered[i];
            this.updateIntruderAlertLevel(simTime, intruder);
            switch (intruder.alertLevel.get()) {
                case TcasAlertLevel.TrafficAdvisory:
                    taCount++;
                    break;
                case TcasAlertLevel.ResolutionAdvisory:
                    raCount++;
                    break;
            }
        }
        this.eventPublisher.pub('tcas_ta_intruder_count', taCount, false, true);
        this.eventPublisher.pub('tcas_ra_intruder_count', raCount, false, true);
    }
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    updateIntruderAlertLevel(simTime, intruder) {
        const currentAlertLevel = intruder.alertLevel.get();
        if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
            if (this.canIssueResolutionAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory
            && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat)
            && !this.canCancelResolutionAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
            if (this.canIssueTrafficAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory
            && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat)
            && !this.canCancelTrafficAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.isPredictionValid) {
            const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
            const radius = parametersPA.protectedRadius;
            const height = parametersPA.protectedHeight;
            if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
                intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
                if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0
                    && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
                    intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
                    return;
                }
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
            return;
        }
        intruder.alertLevel.set(TcasAlertLevel.None);
    }
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() === TcasOperatingMode.TA_RA
            && intruder.tcaRA.isValid
            && intruder.tcaRA.tcpa.number > 0
            && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA
            || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateResolutionAdvisory(simTime) {
        if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
            this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
        }
        else {
            this.resolutionAdvisoryHost.cancel(simTime);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
        this.eventPublisher.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        var _a;
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.delete(intruder);
        }
        (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
        this.eventPublisher.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.add(intruder);
        }
        else {
            this.intrudersRA.delete(intruder);
        }
        this.eventPublisher.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
};
/**
 * An airplane managed by TCAS.
 */
class TcasAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TcasAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
        /** The radar altitude of this airplane at the time of the most recent update. */
        this._radarAltitude = UnitType.FOOT.createNumber(0);
        this.radarAltitude = this._radarAltitude.readonly;
        this._isOnGround = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this airplane is on the ground. */
    get isOnGround() {
        return this._isOnGround;
    }
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime, out) {
        const dt = (simTime - this.lastUpdateTime) / 1000;
        return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
        this._radarAltitude.set(this.subs.radarAltitude.get());
        this._isOnGround = this.subs.isOnGround.get();
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
class AbstractTcasIntruder extends TcasAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TcasAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        /** @inheritdoc */
        this.tcaTA = new TcasTcaPredictionClass(this);
        /** @inheritdoc */
        this.tcaRA = new TcasTcaPredictionClass(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    /** @inheritdoc */
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    /** @inheritdoc */
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
        AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime, ownAirplane, sensitivity) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            const taParams = sensitivity.parametersTA;
            const raParams = sensitivity.parametersRA;
            this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
            this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
        }
        else {
            this.invalidatePredictions();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity(ownAirplane);
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
        Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    updateVelocity(ownAirplane) {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
        Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePredictions() {
        this.tcaTA.invalidate();
        this.tcaRA.invalidate();
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
/**
 * An default implementation of {@link TcasIntruder}.
 */
class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
class TcasTcaPredictionClass {
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder) {
        this.intruder = intruder;
        this._isValid = false;
        this._time = NaN;
        this._tcpa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcpa = this._tcpa.readonly;
        this._tcoa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcoa = this._tcoa.readonly;
        this._isThreat = false;
        /** @inheritdoc */
        this.cpaDisplacement = new Float64Array(3);
        this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** @inheritdoc */
        this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
        this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
        /** @inheritdoc */
        this.cpaVerticalSep = this._cpaVerticalSep.readonly;
        this._cpaNorm = NaN;
    }
    /** @inheritdoc */
    get isValid() {
        return this._isValid;
    }
    /** @inheritdoc */
    get time() {
        return this._time;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get isThreat() {
        return this._isThreat;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get cpaNorm() {
        return this._cpaNorm;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime, tau, dmod, zthr, hmd) {
        var _a;
        this._time = simTime;
        if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
            this.invalidate();
            return;
        }
        // Source: Munoz, CA and Narkawicz, AJ. "A TCAS-II Resolution Advisory Detection Algorithm."
        // https://ntrs.nasa.gov/api/citations/20140002736/downloads/20140002736.pdf
        const tauSeconds = tau.asUnit(UnitType.SECOND);
        const s = this.intruder.relativePositionVec;
        const v = this.intruder.relativeVelocityVec;
        const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
        const h = zthr.asUnit(UnitType.METER);
        const r = dmod.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
        const rSquared = r * r;
        // Time to closest horizontal approach
        const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
        // Modified tau
        const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
        // Time to co-altitude
        const tcoa = -s[2] / v[2];
        const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
        const isVerticalThreat = Math.abs(s[2]) <= h || (tcoa >= 0 && tcoa <= tauSeconds);
        let passHmdFilter = true;
        if (hmd !== undefined && isHorizontalThreat && isVerticalThreat) {
            const d = hmd.asUnit(UnitType.METER);
            const dSquared = d * d;
            if (vHorizSquared === 0) {
                passHmdFilter = sHorizSquared <= dSquared;
            }
            else {
                const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
                if (delta < 0) {
                    passHmdFilter = false;
                }
                else {
                    const a = vHorizSquared;
                    const b = 2 * dotSHorizVHoriz;
                    const c = sHorizSquared - dSquared;
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant < 0) {
                        passHmdFilter = false;
                    }
                    else {
                        passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
                    }
                }
            }
        }
        this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
        this._tcpa.set(tcpa);
        this._tcoa.set(tcoa);
        TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
        AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
        AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
        this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
        this._isValid = true;
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate() {
        this._isValid = false;
        this._isThreat = false;
        this._tcpa.set(NaN);
        this._tcoa.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
        this._cpaHorizontalSep.set(NaN);
        this._cpaVerticalSep.set(NaN);
        this._cpaNorm = NaN;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
}
TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * An implementation of {@link TcasResolutionAdvisoryHost}.
 */
class TcasResolutionAdvisoryHostClass {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus, options, ownAirplane) {
        this.options = options;
        this.ownAirplane = ownAirplane;
        this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
        this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
        this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.intruders = new Set();
        this.intruderArray = [];
        this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
        this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.minVerticalSpeed = this._minVerticalSpeed.readonly;
        this._flags = 0;
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._secondaryType = null;
        this._primaryFlags = 0;
        this._secondaryFlags = 0;
        this.vsConstraints = [];
        this.lastStateChangeTime = 0;
        this.stateChangeDelay = 0;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    get flags() {
        return this._flags;
    }
    /** @inheritdoc */
    get primaryType() {
        return this._primaryType;
    }
    /** @inheritdoc */
    get secondaryType() {
        return this._secondaryType;
    }
    /** @inheritdoc */
    get primaryFlags() {
        return this._primaryFlags;
    }
    /** @inheritdoc */
    get secondaryFlags() {
        return this._secondaryFlags;
    }
    /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime, intruder) {
        // Inhibit resolution advisories for intruders whose time to closest horizontal approach is less than or equal to
        // zero (indicating the closest point of approach has already been passed) and whose horizontal separation from the
        // own airplane is increasing.
        if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
            return false;
        }
        if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime, alim, intruders) {
        if (this.intruderArray.length === 0 && intruders.size === 0) {
            return;
        }
        if (simTime < this.lastStateChangeTime) {
            this.lastStateChangeTime = simTime;
        }
        if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
            return;
        }
        if (intruders.size === 0) {
            this.cancel(simTime);
        }
        else {
            const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
            const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
            const alimMeters = alim.asUnit(UnitType.METER);
            const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
            const responseTimeSecondsRemaining = isInitial
                ? responseTimeSeconds
                : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1000, 0, responseTimeSeconds);
            const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
            this.updateIntruders(intruders);
            this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
            if (isInitial) {
                this.selectInitialState(simTime, ownAirplaneVsMps);
            }
            else {
                if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                    this.updatePositive(simTime);
                }
                else if (this._secondaryType === null) {
                    this.updateNegative(simTime, ownAirplaneVsMps);
                }
                else {
                    this.updateComposite(simTime, ownAirplaneVsMps);
                }
            }
        }
    }
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    updateIntruders(intruders) {
        // Remove one sense reversal used for every intruder that was removed from the RA.
        for (let i = 0; i < this.intruderArray.length; i++) {
            if (!intruders.has(this.intruderArray[i])) {
                this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
            }
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        for (const intruder of intruders) {
            this.intruders.add(intruder);
            this.intruderArray.push(intruder);
        }
        this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
        var _a;
        var _b;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        for (let i = 0; i < this.intruderArray.length; i++) {
            const intruder = this.intruderArray[i];
            let above = -Infinity;
            let below = Infinity;
            if (intruder.tcaRA.isValid) {
                const t0 = intruder.tcaRA.time;
                const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
                const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1000;
                const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
                const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                // The altitude own airplane needs to be above in order to pass above the intruder with ALIM vertical separation at CPA.
                const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
                // The altitude own airplane needs to be below in order to pass below the intruder with ALIM vertical separation at CPA.
                const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
                const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
                const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
                if (aboveAlimSense === 1) {
                    // Own airplane needs to adjust vertical speed in the positive direction in order to pass above the intruder with
                    // ALIM vertical separation at CPA.
                    above = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters)
                        : NaN;
                    if (isNaN(above)) {
                        above = Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass above the intruder with ALIM vertical separation at CPA.
                    above = tcpaSeconds > 0
                        ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : -Infinity;
                }
                if (belowAlimSense === -1) {
                    // Own airplane needs to adjust vertical speed in the negative direction in order to pass below the intruder with
                    // ALIM vertical separation at CPA
                    below = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters)
                        : NaN;
                    if (isNaN(below)) {
                        below = -Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass below the intruder with ALIM vertical separation at CPA.
                    below = tcpaSeconds > 0
                        ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : Infinity;
                }
            }
            const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : (_b[i] = { above: 0, below: 0 });
            constraint.above = above;
            constraint.below = below;
        }
        this.vsConstraints.length = this.intruderArray.length;
    }
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    selectInitialState(simTime, ownAirplaneVsMps) {
        // We need to first select either upward or downward sense.
        // The minimum vertical speed own airplane can target while still achieving ALIM separation ABOVE all intruders
        let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
        // The maximum vertical speed own airplane can target while still achieving ALIM separation BELOW all intruders
        let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
        // The strongest initial upward and downward sense RAs are CLIMB and DESCEND, respectively (or their crossing/maintain
        // variants, but all have the same vertical speed target).
        let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
        const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
        const canClimb = this.options.allowClimb(simTime);
        const canDescend = this.options.allowDescend(simTime);
        const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
        const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
        minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
        maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
        let sense;
        let senseIsCrossing = false;
        let doesSenseAchieveAlim = false;
        let senseRequiredVs = 0;
        // If one sense RA achieves ALIM separation and the other does not, choose the one that achieves ALIM separation.
        if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
            sense = 1;
        }
        else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
            sense = -1;
        }
        else {
            // If both or neither sense RA achieves ALIM separation, choose the non-crossing sense. Only the closest intruder
            // is evaluated, since in a multi-intruder RA there is the opportunity to reverse sense with each intruder.
            const closestIntruder = this.intruderArray[0];
            const t0 = closestIntruder.tcaRA.time;
            const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
            const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
            const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
            const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
            if (crossingSense === -1 && !isUpSenseInhibited) {
                sense = 1;
            }
            else if (crossingSense === 1 && !isDownSenseInhibited) {
                sense = -1;
            }
            else {
                // If neither sense is crossing or the non-crossing sense is inhibited, choose the one that is not inhibited.
                if (!isUpSenseInhibited && isDownSenseInhibited) {
                    sense = 1;
                }
                else if (isUpSenseInhibited && !isDownSenseInhibited) {
                    sense = -1;
                }
                else {
                    // If neither or both senses are inhibited, choose the one that gives the greatest potential separation at
                    // CPA (i.e. the one that requires the least change in vertical speed). Again, only the closest intruder is evaluated.
                    if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
                        sense = 1;
                    }
                    else {
                        sense = -1;
                    }
                }
                senseIsCrossing = sense === crossingSense;
            }
        }
        doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
        doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
        doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
        senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
        // For multi-intruder RAs, there is the option to choose an initial composite RA which combines two negative RAs of
        // opposite senses.
        if (this.intruderArray.length > 1) {
            // Because the composite RA always includes a vertical speed of 0 within its vertical speed target range, it
            // achieves ALIM separation from all intruders if and only if a vertical speed of 0 does.
            const doesCompositeAchieveAlim = this.vsConstraints.every(constraint => constraint.above <= 0 || constraint.below >= 0);
            // If the composite RA achieves ALIM separation from all intruders and the selected up/down sense RA does not,
            // choose the composite RA.
            if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
                sense = 0;
                doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
            else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
                // If both or neither the composite RA or the selected up/down sense RA achieves ALIM separation from all
                // intruders, choose the composite RA if the up/down sense RA is crossing.
                if (senseIsCrossing) {
                    sense = 0;
                    doesSenseAchieveAlim = doesCompositeAchieveAlim;
                }
                else {
                    // If both or neither the composite RA or the selected up/down sense RA is crossing, choose the one that
                    // provides the greatest potential vertical separation at CPA. Again, only the closest intruder is
                    // evaluated.
                    if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
                        sense = 0;
                        doesSenseAchieveAlim = doesCompositeAchieveAlim;
                    }
                }
            }
        }
        // Now that we have selected the sense, we need to choose the appropriate initial RA type.
        let primaryType;
        let secondaryType = null;
        switch (sense) {
            case 0: // Composite RA
                if (doesSenseAchieveAlim) {
                    // Find the vertical speed limits required to achieve ALIM separation.
                    const maxVsMps = this.getCompositeRequiredMaxVs();
                    const minVsMps = this.getCompositeRequiredMinVs();
                    if (ownAirplaneVsMps > maxVsMps) {
                        // Downward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                    }
                    else if (ownAirplaneVsMps < minVsMps) {
                        // Upward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                    else {
                        // Preventative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                }
                else {
                    primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
                }
                break;
            case 1: // Upward sense single RA
                if (ownAirplaneVsMps < minUpSenseVsMps) {
                    // Corrective
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    }
                }
                else {
                    // Preventative
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
                    }
                }
                break;
            case -1: // Downward sense single RA
                if (ownAirplaneVsMps > maxDownSenseVsMps) {
                    // Corrective
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                    }
                }
                else {
                    // Preventative
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
                    }
                }
                break;
        }
        this.setState(simTime, primaryType, secondaryType, true);
    }
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updatePositive(simTime) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
        // Check if we are inhibited, if so -> convert the current RA to its negative preventative counterpart.
        const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        if (isInhibited) {
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
            return;
        }
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, attempt to
        // weaken the RA. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            // If weakening to a REDUCE CLIMB/DESCENT RA would still provide ALIM separation, do so.
            if (requiredVsMps * sense <= 0) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
            }
        }
        else {
            // Check if strengthening to an INCREASE CLIMB/DESCENT RA would provide ALIM separation
            const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
            let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
            }
        }
    }
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    updateNegative(simTime, ownAirplaneVsMps) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, we do nothing since
        // negative RAs cannot be weakened. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            return;
        }
        const requirePositive = requiredVsMps * sense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // negative RA we can.
        }
        if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
            // We need to issue a corrective negative RA.
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            this.setState(simTime, sense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
        }
    }
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    updateComposite(simTime, ownAirplaneVsMps) {
        if (this._secondaryType === null) {
            throw new Error('TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active');
        }
        const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
        const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredMinVsMps = this.getCompositeRequiredMinVs();
        const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
        const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
        if (primarySense === 1) {
            primaryCurrentVsMps = currentMinVsMps;
            primaryRequiredVsMps = requiredMinVsMps;
            secondaryCurrentVsMps = currentMaxVsMps;
            secondaryRequiredVsMps = requiredMaxVsMps;
        }
        else {
            primaryCurrentVsMps = currentMaxVsMps;
            primaryRequiredVsMps = requiredMaxVsMps;
            secondaryCurrentVsMps = currentMinVsMps;
            secondaryRequiredVsMps = requiredMinVsMps;
        }
        const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
        const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
        const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0
            || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // pair of negative RAs we can.
        }
        let primaryType;
        if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
            // We need to issue a corrective negative RA.
            primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            primaryType = primarySense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
        }
        const secondaryType = primarySense === 1
            ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps)
            : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
        this.setState(simTime, primaryType, secondaryType);
    }
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    setState(simTime, primaryType, secondaryType, isInitial = false) {
        if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
            return;
        }
        let minSpeed, maxSpeed;
        const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
        this._primaryType = primaryType;
        this._primaryFlags = primaryTypeDef.flags;
        this._secondaryType = secondaryType;
        if (secondaryType !== null) {
            const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
            this._secondaryFlags = secondaryTypeDef.flags;
            minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
            maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
        }
        else {
            this._secondaryFlags = 0;
            minSpeed = primaryTypeDef.minVerticalSpeed;
            maxSpeed = primaryTypeDef.maxVerticalSpeed;
        }
        this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
        this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
        this.isInitial = isInitial;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE
            + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1000;
        if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
            this.senseReversalCount++;
        }
        if (isInitial) {
            this.publisher.pub('tcas_ra_issued', this, false, false);
        }
        else {
            this.publisher.pub('tcas_ra_updated', this, false, false);
        }
    }
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
            return;
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        this._maxVerticalSpeed.set(NaN);
        this._minVerticalSpeed.set(NaN);
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._primaryFlags = 0;
        this._secondaryType = null;
        this._secondaryFlags = 0;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher.pub('tcas_ra_canceled', undefined, false, false);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    getUpSenseRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    getDownSenseRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
        const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
        if (signedAccel === 0) {
            return vs;
        }
        const y0 = currentAlt + vs * responseTime;
        const tc = tcpa - responseTime;
        const a = signedAccel / 2;
        const b = -signedAccel * tc;
        const c = targetAlt - y0 - vs * tc;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            return NaN;
        }
        const sqrtDiscr = Math.sqrt(discriminant);
        const t1 = (-b + sqrtDiscr) / (2 * a);
        const t2 = (-b - sqrtDiscr) / (2 * a);
        if (t1 <= tc && t1 >= 0) {
            return vs + signedAccel * t1;
        }
        if (t2 <= tc && t2 >= 0) {
            return vs + signedAccel * t2;
        }
        return NaN;
    }
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    static getDoNotDescendType(minVsMps) {
        if (minVsMps > -500) {
            return TcasResolutionAdvisoryType.DoNotDescend0;
        }
        else if (minVsMps > -1000) {
            return TcasResolutionAdvisoryType.DoNotDescend500;
        }
        else if (minVsMps > -1500) {
            return TcasResolutionAdvisoryType.DoNotDescend1000;
        }
        else if (minVsMps > -2000) {
            return TcasResolutionAdvisoryType.DoNotDescend1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotDescend2000;
        }
    }
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    static getDoNotClimbType(maxVsMps) {
        if (maxVsMps < 500) {
            return TcasResolutionAdvisoryType.DoNotClimb0;
        }
        else if (maxVsMps < 1000) {
            return TcasResolutionAdvisoryType.DoNotClimb500;
        }
        else if (maxVsMps < 1500) {
            return TcasResolutionAdvisoryType.DoNotClimb1000;
        }
        else if (maxVsMps < 2000) {
            return TcasResolutionAdvisoryType.DoNotClimb1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotClimb2000;
        }
    }
}
/** The base amount of delay between state changes, in milliseconds, before predicted response time is taken into account. */
TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5000;
TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
        return -1;
    }
    else if (tcpaComparison > 0) {
        return 1;
    }
    else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
        return -1;
    }
    else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
        return 1;
    }
    else {
        return 0;
    }
};
TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
        flags: 0,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 2500,
        maxVerticalSpeed: 3000
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -3000,
        maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1000
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 2000
    },
};
TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];

/**
 * Standard TCAS-II sensitivity parameters.
 */
class TcasIISensitivityParameters {
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
        let level;
        if (radarAltFeet > 2350) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (radarAltFeet > 1000) {
            level = 1;
        }
        else {
            level = 0;
        }
        return level;
    }
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    altitude, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    radarAltitude) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPA(level) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level) {
        return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
}
TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
};
TcasIISensitivityParameters.TA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.33),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.48),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(40),
        protectedRadius: UnitType.NMILE.createNumber(0.75),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(45),
        protectedRadius: UnitType.NMILE.createNumber(1),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(1200)
    }
];
TcasIISensitivityParameters.RA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.35),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.55),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(350),
        hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.8),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(400),
        hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(700),
        alim: UnitType.FOOT.createNumber(600),
        hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(800),
        alim: UnitType.FOOT.createNumber(700),
        hmd: UnitType.NMILE.createNumber(0.98)
    }
];
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
class TcasIISensitivity {
    constructor() {
        this.sensitivity = new TcasIISensitivityParameters();
        this.level = 0;
        this.params = {
            parametersPA: this.sensitivity.getPA(0),
            parametersTA: this.sensitivity.getTA(0),
            parametersRA: this.sensitivity.getRA(0)
        };
    }
    /** @inheritdoc */
    selectParameters() {
        return this.params;
    }
    /** @inheritdoc */
    selectRAAlim() {
        return this.sensitivity.getRAAlim(this.level);
    }
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude, radarAltitude) {
        this.level = this.sensitivity.selectLevel(altitude, radarAltitude);
        this.params.parametersPA = this.sensitivity.getPA(this.level);
        this.params.parametersTA = this.sensitivity.getTA(this.level);
        this.params.parametersRA = this.sensitivity.getRA(this.level);
    }
}

/** The acceptable priority types for a given warning. */
var WarningType;
(function (WarningType) {
    WarningType[WarningType["Warning"] = 0] = "Warning";
    WarningType[WarningType["Caution"] = 1] = "Caution";
    WarningType[WarningType["Test"] = 2] = "Test";
    WarningType[WarningType["SoundOnly"] = 3] = "SoundOnly";
})(WarningType || (WarningType = {}));
/** The main logic for a system warning. */
class Warning {
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type, condition, shortText, longText, soundId, once) {
        this.type = type;
        this.shortText = shortText;
        this.longText = longText;
        this.soundId = soundId;
        this.condition = condition;
        this.once = once;
        this._triggered = false;
        if (this.soundId) {
            this._soundEventId = new Name_Z(this.soundId);
        }
    }
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText() {
        return this.shortText || this.longText ? true : false;
    }
    /**
     * The alert is being fired, take action.
     */
    trigger() {
        this._triggered = true;
    }
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description() {
        return `<${this.shortText}|${this.longText}|${this.soundId}>`;
    }
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered() {
        return this._triggered;
    }
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger() {
        return !this.once || !this._triggered;
    }
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId() {
        return this._soundEventId;
    }
}
/** The basic component for handling warning logic. */
class WarningManager {
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings, logicHost, textCb, soundCb) {
        this.warnings = warnings;
        this.logicHost = logicHost;
        this.textCb = textCb;
        this.soundCb = soundCb;
        this.curSndIdx = null;
        this.curTxtIdx = null;
        this.warnActiveStates = new Array();
        for (let i = 0; i < warnings.length; i++) {
            this.logicHost.addLogicAsNumber(warnings[i].condition, this.handleWarning.bind(this, i), 0);
            this.warnActiveStates.push(false);
        }
    }
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    handleWarning(warnIndex, active) {
        const warning = this.warnings[warnIndex];
        // Handle a warning that is going active.
        if (active && warning.canTrigger) {
            this.warnActiveStates[warnIndex] = true;
            warning.trigger();
            // Only worry about text if the warning has text.
            if (warning.hasText) {
                // If there is no existing text displayed, or text of a lower priority, replace it.
                if ((this.curTxtIdx == undefined || this.curTxtIdx > warnIndex)) {
                    // First, if the prior warning was a one-shot, force it to inactive so it won't be restored later.
                    if (this.curTxtIdx && this.warnings[this.curTxtIdx].once) {
                        this.warnActiveStates[this.curTxtIdx] = false;
                    }
                    this.textCb(warning);
                    this.curTxtIdx = warnIndex;
                }
            }
            // Now check for sound.
            if (this.soundCb !== undefined && warning.soundId) {
                // Make sure we have the right to play our sound.
                if (this.curSndIdx == undefined || this.curSndIdx > warnIndex) {
                    // Disable a prior sound, if one was playing.
                    if (this.curSndIdx && this.curSndIdx > warnIndex) {
                        this.soundCb(this.warnings[this.curSndIdx], false);
                        // If the prior warning was a one-shot, force it to inactive so it won't be restored.
                        if (this.warnings[this.curSndIdx].once) {
                            this.warnActiveStates[this.curSndIdx] = false;
                        }
                    }
                    this.soundCb(warning, true);
                    this.curSndIdx = warnIndex;
                }
            }
            // If that was a one-time alert, turn it off, too.
            if (warning.once) {
                this.handleWarning(warnIndex, 0);
            }
        }
        else if (!active) {
            this.warnActiveStates[warnIndex] = false;
            let isCurSnd = this.curSndIdx == warnIndex ? true : false;
            let isCurTxt = this.curTxtIdx == warnIndex ? true : false;
            // If this warning is the current active text or sound, we need to disable it.
            if (isCurSnd && this.soundCb) {
                this.soundCb(warning, false);
            }
            if (isCurTxt) {
                this.textCb(undefined);
            }
            // If either of those were true, let's see if there's anything else
            // of lower prirority that should be made active.
            if (isCurSnd || isCurTxt) {
                // We know there was no higher-priority warning, so we step through
                // everything lower than us.
                let i = warnIndex + 1;
                while ((isCurSnd || isCurTxt) && i < this.warnings.length) {
                    // Only continue this iteration if the next potential warning
                    // is active.
                    if (this.warnActiveStates[i]) {
                        const nextWarning = this.warnings[i];
                        // Make sure we can trigger the warning.   This will be false if
                        // it's a one-shot that's already triggered.  If so, just fall
                        // through to the next iteration.
                        if (nextWarning.canTrigger) {
                            // See if the lower priority warning has sound.  If so, activate.
                            if (isCurSnd && nextWarning.soundId && this.soundCb) {
                                this.soundCb(this.warnings[i], true);
                                this.curSndIdx = i;
                                // We can stop looking for another sound.
                                isCurSnd = false;
                            }
                            // Now do the same sort of thing for text.
                            if (isCurTxt && this.warnings[i].hasText) {
                                this.textCb(this.warnings[i]);
                                this.curTxtIdx = i;
                                // We can stop looking for another text.
                                isCurTxt = false;
                            }
                        }
                    }
                    // Move to the next warning on the list.
                    i++;
                }
            }
            // If we haven't yet set new sound or text, just nullify them.
            if (isCurSnd && this.soundCb) {
                this.curSndIdx = null;
            }
            if (isCurTxt) {
                this.curTxtIdx = null;
            }
        }
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** Create a list of system warnings. */
class XMLWarningFactory {
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument) {
        this.instrument = instrument;
    }
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document) {
        const warnings = new Array();
        const configs = document.getElementsByTagName('VoicesAlerts');
        if (configs.length == 0) {
            return warnings;
        }
        const config = configs[0];
        for (const warn of config.children) {
            let type;
            const typeElem = warn.getElementsByTagName('Type');
            if (typeElem.length == 0) {
                continue;
            }
            switch (typeElem[0].textContent) {
                case 'Warning':
                    type = WarningType.Warning;
                    break;
                case 'Caution':
                    type = WarningType.Caution;
                    break;
                case 'Test':
                    type = WarningType.Test;
                    break;
                case 'SoundOnly':
                    type = WarningType.SoundOnly;
                    break;
                default:
                    continue;
            }
            let textElem = warn.getElementsByTagName('Condition');
            if (textElem.length == 0) {
                continue;
            }
            const condition = new CompositeLogicXMLElement(this.instrument, textElem[0]);
            textElem = warn.getElementsByTagName('ShortText');
            let shortText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                shortText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('LongText');
            let longText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                longText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('SoundEvent');
            let soundEvent = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                soundEvent = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('Once');
            let once = false;
            if (textElem.length > 0 && textElem[0].textContent == 'True') {
                once = true;
            }
            warnings.push(new Warning(type, condition, shortText, longText, soundEvent, once));
        }
        return warnings;
    }
}

var APVerticalModes;
(function (APVerticalModes) {
    APVerticalModes[APVerticalModes["NONE"] = 0] = "NONE";
    APVerticalModes[APVerticalModes["PITCH"] = 1] = "PITCH";
    APVerticalModes[APVerticalModes["VS"] = 2] = "VS";
    APVerticalModes[APVerticalModes["FLC"] = 3] = "FLC";
    APVerticalModes[APVerticalModes["ALT"] = 4] = "ALT";
    APVerticalModes[APVerticalModes["PATH"] = 5] = "PATH";
    APVerticalModes[APVerticalModes["GP"] = 6] = "GP";
    APVerticalModes[APVerticalModes["GS"] = 7] = "GS";
    APVerticalModes[APVerticalModes["CAP"] = 8] = "CAP";
    APVerticalModes[APVerticalModes["TO"] = 9] = "TO";
    APVerticalModes[APVerticalModes["GA"] = 10] = "GA";
    APVerticalModes[APVerticalModes["FPA"] = 11] = "FPA";
    APVerticalModes[APVerticalModes["FLARE"] = 12] = "FLARE";
})(APVerticalModes || (APVerticalModes = {}));
var APLateralModes;
(function (APLateralModes) {
    APLateralModes[APLateralModes["NONE"] = 0] = "NONE";
    APLateralModes[APLateralModes["ROLL"] = 1] = "ROLL";
    APLateralModes[APLateralModes["LEVEL"] = 2] = "LEVEL";
    APLateralModes[APLateralModes["GPSS"] = 3] = "GPSS";
    APLateralModes[APLateralModes["HEADING"] = 4] = "HEADING";
    APLateralModes[APLateralModes["VOR"] = 5] = "VOR";
    APLateralModes[APLateralModes["LOC"] = 6] = "LOC";
    APLateralModes[APLateralModes["BC"] = 7] = "BC";
    APLateralModes[APLateralModes["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes[APLateralModes["NAV"] = 9] = "NAV";
    APLateralModes[APLateralModes["TO"] = 10] = "TO";
    APLateralModes[APLateralModes["GA"] = 11] = "GA";
    APLateralModes[APLateralModes["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes[APLateralModes["TRACK"] = 13] = "TRACK";
    APLateralModes[APLateralModes["TRACK_HOLD"] = 14] = "TRACK_HOLD";
    APLateralModes[APLateralModes["FMS_LOC"] = 15] = "FMS_LOC";
    APLateralModes[APLateralModes["TO_LOC"] = 16] = "TO_LOC";
})(APLateralModes || (APLateralModes = {}));
var APAltitudeModes;
(function (APAltitudeModes) {
    APAltitudeModes[APAltitudeModes["NONE"] = 0] = "NONE";
    APAltitudeModes[APAltitudeModes["ALTS"] = 1] = "ALTS";
    APAltitudeModes[APAltitudeModes["ALTV"] = 2] = "ALTV";
})(APAltitudeModes || (APAltitudeModes = {}));

/**
 * A Utility Class for VNAV
 */
class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg) {
        if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc
            || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1
            || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
            return true;
        }
        return false;
    }
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
        const delta = targetAltitude - currentAltitude;
        const minutesToConstraint = distance / groundSpeed * 60;
        return delta / minutesToConstraint;
    }
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
        return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs, groundspeed) {
        return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets the flight path angle required to travel a given lateral distance and altitude. Positive flight path angles
     * represent an ascending flight path. By convention, the flight path angle required to travel zero altitude equals
     * zero degrees for all distances.
     * @param distance The lateral distance to travel, in the same units as `altitude`.
     * @param altitude The altitude to travel, in the same units as `distance`.
     * @returns The flight path angle, in degrees, required to travel the specified altitude and distance.
     */
    static getFpa(distance, altitude) {
        if (altitude === 0) {
            return 0;
        }
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance traveled.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance traveled.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance traveled,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa, distance) {
        return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets the lateral distance traveled along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance traveled along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa, altitude) {
        return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    return l;
                }
            }
        }
        return Math.max(0, plan.length - 1);
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan, iterator) {
        let fafIndex = -1;
        iterator.iterateReverse(lateralPlan, cursor => {
            if (fafIndex === -1 && cursor.legDefinition && (cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF)) {
                fafIndex = cursor.legIndex + cursor.segment.offset;
            }
        });
        fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
        return fafIndex;
    }
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
            if (verticalPlan.constraints[c].index >= globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            if (verticalPlan.constraints[c].index < globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan, globalLegIndex) {
        const constraintIndex = verticalPlan.constraints.findIndex(c => c.index === globalLegIndex);
        if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
            return true;
        }
        return false;
    }
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint) {
        let distance = 0;
        for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
            distance += constraint.legs[legIndex].distance;
        }
        return distance;
    }
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
        let distance = 0;
        const startGlobalIndex = previousConstraint !== undefined ? previousConstraint.index + 1 : 0;
        for (let i = startGlobalIndex; i <= constraint.index; i++) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
            distance += verticalLeg.distance;
        }
        return distance;
    }
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
        if (activeLegIndex > constraint.index) {
            return 0;
        }
        let distance = 0;
        let index = activeLegIndex;
        for (const leg of lateralPlan.legs(false, activeLegIndex)) {
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
                return Number.POSITIVE_INFINITY;
            }
            else if (leg.calculated !== undefined) {
                distance += leg.calculated.distanceWithTransitions;
            }
            if (++index > constraint.index) {
                break;
            }
        }
        distance -= distanceAlongLeg;
        return distance;
    }
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint, out) {
        if (constraint.maxAltitude === constraint.minAltitude) {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
            switch (constraint.type) {
                case 'climb':
                case 'missed':
                    if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    break;
                default:
                    if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
            }
        }
        else {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        return out;
    }
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
        if (verticalPlan.constraints.length > 0) {
            if (selectedGlobalLegIndex < activeLegIndex) {
                return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
            }
            for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
                const constraint = verticalPlan.constraints[c];
                if (constraint.index === selectedGlobalLegIndex || (c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index)) {
                    return constraint;
                }
                else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
                    return verticalPlan.constraints[c + 1];
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the index of the next descent constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next descent constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextDescentConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next climb constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next climb constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextClimbConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'climb') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next missed approach constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next missed approach constraint at or after the specified flight plan leg, or `-1` if
     * one could not be found.
     */
    static getNextMaprConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if ((constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.minAltitude : undefined;
    }
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint) {
            if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return currentConstraint;
            }
            else if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
                const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== undefined ?
                    VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
                for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
                    const constraint = verticalPlan.constraints[c];
                    if (constraint.type === 'climb' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        return constraint;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the current climb constraint, if one exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The current climb constraint, or `undefined` if no such constraint exists.
     */
    static getCurrentClimbConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.type === 'climb') {
            return currentConstraint;
        }
        return undefined;
    }
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.targetAltitude;
        }
        const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan) {
        if (verticalPlan.fafLegIndex !== undefined) {
            return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
        }
        return undefined;
    }
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
        var _a;
        out.todLegIndex = -1;
        out.bodLegIndex = -1;
        out.todLegDistance = 0;
        out.distanceFromTod = 0;
        out.distanceFromBod = 0;
        out.currentConstraintLegIndex = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no TOD/BOD if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active constraint contains a VNAV-ineligible leg after the active leg.
            || ((activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== undefined && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex)) {
            return out;
        }
        out.currentConstraintLegIndex = activeConstraint.index;
        // Find the next BOD, which will be at the end of the earliest non-flat descent constraint subsequent to and
        // including the active constraint that ends in a level-off at a lower altitude than the aircraft's current
        // altitude. Note that we are guaranteed to not go through a VNAV discontinuity, since all constraints that end in
        // a discontinuity also end in a level-off.
        // lag altitude by ~3 seconds so that we aren't continuously pushing TOD in front of the plane while descending.
        const altitude = currentAltitude - currentVS / 20;
        let bodConstraintIndex, bodConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a climb constraint, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
                bodConstraintIndex = i;
                bodConstraint = constraint;
                break;
            }
        }
        if (!bodConstraint) {
            return out;
        }
        out.bodLegIndex = bodConstraint.index;
        // Find the TOD associated with the BOD. To do this, we need to first find the earliest non-flat descent constraint
        // between the active constraint and the BOD constraint (inclusive) that is connected to the BOD constraint with no
        // intervening flat constraints or VNAV path discontinuities and whose target altitude less than the aircraft's
        // current altitude.
        let todConstraintIndex = bodConstraintIndex;
        for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const prevConstraint = verticalPlan.constraints[i + 1];
            if (!prevConstraint
                || prevConstraint.index < activeLegIndex
                || prevConstraint.type === 'climb'
                || prevConstraint.type === 'missed'
                || prevConstraint.targetAltitude > altitude
                || prevConstraint.fpa <= 0
                || prevConstraint.isPathEnd) {
                todConstraintIndex = i;
                break;
            }
        }
        const todConstraint = verticalPlan.constraints[todConstraintIndex];
        // Now that we have found the TOD constraint, we need to find the TOD leg: the leg on which the TOD actually lies.
        // To do this, we calculate the along-track distance from the end of the TOD constraint to the TOD, then iterate
        // through the legs in the constraint backwards while keeping track of the total along-track distance covered by
        // each leg.
        let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
        let constraintIndex = todConstraintIndex;
        let todLegIndex = todConstraint.index;
        let todLegDistance = 0;
        let todLeg = todConstraint.legs[0];
        while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
            const constraint = verticalPlan.constraints[constraintIndex];
            // Remember that flight plan legs in a VNAV constraint appear in reverse order relative to how they are ordered
            // in the flight plan.
            for (let i = 0; i < constraint.legs.length; i++) {
                if (!constraint.legs[i].isEligible) {
                    // We've encounted a VNAV-ineligible leg. Since we cannot calculate a vertical path through this leg, we have
                    // to stop iterating now so that the TOD gets set to the most recent VNAV-eligible leg.
                    constraintIndex = verticalPlan.constraints.length;
                    break;
                }
                todLeg = constraint.legs[i];
                distance -= todLeg.distance;
                if (distance <= 0) {
                    todLegIndex = constraint.index - i;
                    todLegDistance = todLeg.distance + distance;
                    break;
                }
            }
            constraintIndex++;
        }
        if (distance > 0) {
            // If we still haven't found the TOD yet, set it to the beginning of the earliest VNAV leg that was iterated.
            todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
            todLegDistance = todLeg.distance;
        }
        out.todLegIndex = todLegIndex;
        out.todLegDistance = todLegDistance;
        // calculate distance to TOD/BOD
        let globalLegIndex = bodConstraint.index;
        let distanceToBOD = 0, distanceToTOD = 0;
        let hasReachedTOD = false;
        let isDone = false;
        for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const constraint = verticalPlan.constraints[i];
            for (let j = 0; j < constraint.legs.length; j++) {
                const leg = constraint.legs[j];
                if (globalLegIndex === todLegIndex) {
                    distanceToTOD -= todLegDistance;
                    hasReachedTOD = true;
                }
                if (globalLegIndex > activeLegIndex) {
                    distanceToBOD += leg.distance;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance;
                    }
                }
                else if (globalLegIndex === activeLegIndex) {
                    distanceToBOD += leg.distance - distanceAlongLeg;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance - distanceAlongLeg;
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= distanceAlongLeg;
                    }
                }
                else {
                    if (hasReachedTOD) {
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= leg.distance;
                    }
                }
                if (isDone) {
                    break;
                }
                else {
                    globalLegIndex--;
                }
            }
            if (isDone) {
                break;
            }
        }
        out.distanceFromBod = distanceToBOD;
        out.distanceFromTod = distanceToTOD;
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
        var _a, _b;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no BOC/TOC if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active VNAV constraint is not a climb-type constraint.
            || (activeConstraint.type !== 'climb' && activeConstraint.type !== 'missed')) {
            return out;
        }
        // Find the TOC. To do this, we need to first find the earliest climb constraint subsequent to and including the
        // active constraint that has a maximum altitude (i.e. is an AT, AT OR BELOW, or BETWEEN constraint). Additionally,
        // the TOC must not be separated from the active constraint by a descent-type constraint.
        let tocConstraintIndex, tocConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (isFinite(constraint.maxAltitude)) {
                tocConstraintIndex = i;
                tocConstraint = constraint;
                break;
            }
        }
        // If there is no next TOC, there also can be no next BOC since the next BOC must follow the next TOC.
        if (!tocConstraint) {
            return out;
        }
        out.tocConstraintIndex = tocConstraintIndex;
        out.tocAltitude = tocConstraint.maxAltitude;
        // Calculate distance to TOC.
        const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies.
        const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
        let tocLegIndex;
        let currentConstraintIndex = activeConstraintIndex;
        let currentConstraint;
        let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
        let currentLeg = activeLeg;
        const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
        if (distanceRemaining > activeLegDistanceRemaining) {
            distanceRemaining -= activeLegDistanceRemaining;
            if (currentConstraintLegIndex <= 0) {
                --currentConstraintIndex;
            }
            else {
                currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
            }
            while (currentConstraintIndex >= tocConstraintIndex) {
                currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                currentLeg = currentConstraint.legs[currentConstraintLegIndex];
                if (currentLeg !== undefined) {
                    if (distanceRemaining > currentLeg.distance) {
                        out.distanceFromToc += currentLeg.distance;
                        distanceRemaining -= currentLeg.distance;
                    }
                    else {
                        out.distanceFromToc += distanceRemaining;
                        tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
                        distanceRemaining -= currentLeg.distance;
                        break;
                    }
                }
                if (currentConstraintLegIndex <= 0) {
                    --currentConstraintIndex;
                }
                else {
                    currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
                }
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last leg of the TOC constraint.
            out.tocLegIndex = tocConstraint.index;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        // Find the next BOC, which is located at the beginning of the earliest climb constraint subsequent to (and not
        // including) the TOC constraint with a maximum altitude greater than the TOC constraint. Additionally, the BOC
        // must not be separated from the TOC constraint by a descent-type constraint.
        let lastClimbConstraintIndex = tocConstraintIndex;
        let bocConstraintIndex, bocConstraint;
        for (let i = tocConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (constraint.maxAltitude > tocConstraint.maxAltitude) {
                bocConstraintIndex = i;
                bocConstraint = constraint;
                break;
            }
            lastClimbConstraintIndex = i;
        }
        let bocDistanceStopConstraintIndex = undefined;
        if (bocConstraint) {
            out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
            bocDistanceStopConstraintIndex = bocConstraintIndex;
        }
        else {
            // If we did not find a climb constraint subsequent to the TOC constraint with a maximum altitude greater than the
            // the TOC constraint, then the BOC will be located at the last climb constraint.
            const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
            if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
                out.bocLegIndex = lastClimbConstraint.index + 1;
                bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
            }
        }
        // Calculate distance to BOC
        if (bocDistanceStopConstraintIndex !== undefined) {
            let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
            for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
                distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
            }
            out.distanceFromBoc = distanceToEndOfActiveConstraint;
            for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
                out.distanceFromBoc += verticalPlan.constraints[i].distance;
            }
        }
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        // Find the last climb constraint
        const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // If the active leg is past the first descent constraint, both cruise BOC and cruise TOC are undefined.
        if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
            return out;
        }
        const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
        const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        // Cruise BOC will always be located at the beginning of the first leg after the last climb constraint. If there
        // are no climb constraints in the plan, then cruise BOC is undefined.
        if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
            const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
            out.bocLegIndex = lastClimbConstraint.index + 1;
            out.distanceFromBoc = activeLegDistanceRemaining
                + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
        // Calculate distance to TOC.
        const deltaAltitude = cruiseAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies. The TOC is restricted to legs prior to the first descent constraint.
        let tocLegIndex;
        const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
        if (distanceRemaining > activeLegDistanceRemaining) {
            let legIndex = activeLegIndex + 1;
            for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
                const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                if (distanceRemaining > legDistance) {
                    out.distanceFromToc += legDistance;
                    distanceRemaining -= legDistance;
                }
                else {
                    out.distanceFromToc += distanceRemaining;
                    tocLegIndex = legIndex;
                    distanceRemaining -= legDistance;
                    break;
                }
                legIndex++;
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last viable leg.
            out.tocLegIndex = lastLegIndex;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        out.tocAltitude = cruiseAltitude;
        return out;
    }
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset] !== undefined;
            }
        }
        return false;
    }
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset];
            }
        }
        throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
        const segment = verticalPlan.segments[segmentIndex];
        const leg = segment.legs[legIndex];
        if (segment && leg) {
            return leg;
        }
        else {
            throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
        }
    }
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
        return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan) {
        return verticalPlan.segments;
    }
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
        if (lateralLeg.leg !== undefined) {
            switch (lateralLeg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    return true;
            }
        }
        return false;
    }
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index, minAltitude, maxAltitude, name, type = 'descent') {
        return {
            index,
            minAltitude,
            maxAltitude,
            targetAltitude: 0,
            name,
            isTarget: false,
            isPathEnd: false,
            distance: 0,
            fpa: 0,
            legs: [],
            type,
            isBeyondFaf: false
        };
    }
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
        return {
            segmentIndex,
            legIndex,
            fpa: 0,
            altitude: 0,
            isUserDefined: false,
            isDirectToTarget: false,
            distance: distance,
            isEligible: true,
            isBod: false,
            isAdvisory: true,
            name
        };
    }
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan) {
        let index = -1;
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            const type = verticalPlan.constraints[c].type;
            if (type === 'descent' || type === 'manual') {
                index = c;
            }
            if (type === 'direct') {
                return c;
            }
        }
        return index;
    }
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            const type = verticalPlan.constraints[i].type;
            if (type === 'descent' || type === 'direct' || type === 'manual') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a, b) {
        return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a, b) {
        return a.type === b.type && a.altitude === b.altitude;
    }
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a, b) {
        return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint
            && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint)
            && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed) {
        if (groundSpeed <= 190) {
            return 100;
        }
        else if (groundSpeed >= 210) {
            return 250;
        }
        else {
            return 100 + (((groundSpeed - 190) / 20) * 150);
        }
    }
}

/**
 * LNAV transition modes.
 */
var LNavTransitionMode;
(function (LNavTransitionMode) {
    /** LNAV is attempting to track a non-transition vector. */
    LNavTransitionMode[LNavTransitionMode["None"] = 0] = "None";
    /** LNAV is attempting to track an ingress vector. */
    LNavTransitionMode[LNavTransitionMode["Ingress"] = 1] = "Ingress";
    /** LNAV is attempting to track an egress vector. */
    LNavTransitionMode[LNavTransitionMode["Egress"] = 2] = "Egress";
    /**
     * LNAV is attempting to track a non-transition vector prior to where the ingress transition joins the base flight
     * path after deactivating suspend mode.
     */
    LNavTransitionMode[LNavTransitionMode["Unsuspend"] = 3] = "Unsuspend";
})(LNavTransitionMode || (LNavTransitionMode = {}));
/**
 * Sim var names for LNAV data.
 */
var LNavVars;
(function (LNavVars) {
    /** The current desired track, in degrees true. */
    LNavVars["DTK"] = "L:WTAP_LNav_DTK";
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavVars["XTK"] = "L:WTAP_LNav_XTK";
    /** Whether LNAV is tracking a path. */
    LNavVars["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    LNavVars["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    /** The currently active LNAV transition mode. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    LNavVars["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    /** The index of the vector LNAV is currently tracking. */
    LNavVars["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    /** The current course LNAV is attempting to steer, in degrees true. */
    LNavVars["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    /** Whether LNAV sequencing is suspended. */
    LNavVars["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LNavVars["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LNavVars["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    LNavVars["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    LNavVars["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    LNavVars["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    /** The current along-track ground speed of the airplane. */
    LNavVars["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
})(LNavVars || (LNavVars = {}));
/**
 * A publisher for LNAV sim var events.
 */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavSimVarPublisher.simvars, bus);
    }
}
LNavSimVarPublisher.simvars = new Map([
    ['lnav_dtk', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ['lnav_xtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ['lnav_is_tracking', { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ['lnav_tracked_leg_index', { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ['lnav_transition_mode', { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ['lnav_tracked_vector_index', { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ['lnav_course_to_steer', { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ['lnav_is_suspended', { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ['lnav_leg_distance_along', { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_leg_distance_remaining', { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_distance_along', { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_vector_distance_remaining', { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_anticipation_distance', { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ['lnav_along_track_speed', { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
]);

/**
 * Sim var names for VNAV data.
 */
var VNavVars;
(function (VNavVars) {
    /** The vertical deviation in feet. */
    VNavVars["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    /** The VNAV target altitude in feet. */
    VNavVars["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavVars["PathMode"] = "L:WTAP_VNav_Path_Mode";
    /** The VNAV State. */
    VNavVars["VNAVState"] = "L:WTAP_VNav_State";
    /** Whether a VNAV Path Exists for the current leg. */
    VNavVars["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    /** The VNAV current altitude capture type. */
    VNavVars["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    VNavVars["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    /** The distance to the next BOD in meters, or -1 if one does not exist. */
    VNavVars["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    /** The index of the leg for the next TOD. */
    VNavVars["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    VNavVars["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavVars["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    /** The distance to the next TOC in meters, or -1 if one does not exist. */
    VNavVars["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    /** The distance to the next BOC in meters, or -1 if one does not exist. */
    VNavVars["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    /** The index of the leg for the next TOC. */
    VNavVars["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    /** The distance from the end of the TOC leg that the TOC is, in meters. */
    VNavVars["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    /** The index of the leg for the next BOC. */
    VNavVars["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavVars["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    /** The current constraint altitude, in feet. */
    VNavVars["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    /** The next constraint altitude, in feet. */
    VNavVars["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    /** The current required flight path angle, in degrees. */
    VNavVars["FPA"] = "L:WTAP_VNav_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    /** The VNAV approach guidance mode. */
    VNavVars["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    /** The current LPV vertical deviation in feet. */
    VNavVars["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    /** The current remaining LPV distance in meters. */
    VNavVars["GPDistance"] = "L:WTAP_GP_Distance";
    /** The current LPV FPA, in degrees. */
    VNavVars["GPFpa"] = "L:WTAP_GP_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    /** The approach glidepath service level. */
    VNavVars["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
})(VNavVars || (VNavVars = {}));
/** A publisher for VNAV sim var events. */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(VNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
VNavSimVarPublisher.simvars = new Map([
    ['vnav_vertical_deviation', { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnav_target_altitude', { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnav_path_mode', { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ['vnav_path_available', { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ['vnav_state', { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ['vnav_altitude_capture_type', { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ['vnav_tod_distance', { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_leg_distance', { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_bod_distance', { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_global_leg_index', { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnav_bod_global_leg_index', { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnav_toc_distance', { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_leg_distance', { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_boc_distance', { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_global_leg_index', { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_boc_global_leg_index', { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_global_leg_index', { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_altitude', { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_next_constraint_altitude', { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_fpa', { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ['vnav_required_vs', { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ['gp_approach_mode', { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ['gp_vertical_deviation', { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ['gp_distance', { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ['gp_fpa', { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ['gp_required_vs', { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ['gp_service_level', { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
]);

/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
class SmoothingPathCalculator {
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        /** The Vertical Flight Plans managed by this Path Calculator */
        this.verticalFlightPlans = [];
        /** @inheritdoc */
        this.planBuilt = new SubEvent();
        /** @inheritdoc */
        this.vnavCalculated = new SubEvent();
        this.legAltitudes = [0, 0];
        this.applyPathValuesResult = [undefined, 0];
        this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
        this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
        this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
        this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
        this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
        this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
        this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : (() => true);
        this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
        this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
        const fpl = this.bus.getSubscriber();
        fpl.on('fplCreated').handle(e => this.createVerticalPlan(e.planIndex));
        fpl.on('fplCopied').handle(e => this.onPlanChanged(e.targetPlanIndex));
        fpl.on('fplLoaded').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplLegChange').handle(e => this.onPlanChanged(e.planIndex, e));
        fpl.on('fplSegmentChange').handle(e => this.onPlanChanged(e.planIndex, undefined, e));
        fpl.on('fplIndexChanged').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplCalculated').handle(e => this.onPlanCalculated(e));
        bus.getSubscriber().on('vnav_set_default_fpa').handle(this.setDefaultFpa.bind(this));
        bus.getSubscriber().on('vnav_set_vnav_direct_to').handle(data => {
            if (data.globalLegIndex < 0) {
                this.cancelVerticalDirect(data.planIndex);
            }
            else {
                this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
            }
        });
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
        var _a;
        var _b;
        return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : (_b[planIndex] = this.createVerticalPlan(planIndex));
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /** @inheritdoc */
    requestPathCompute(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== undefined) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            this.computePathAndNotify(lateralPlan, verticalPlan);
            return true;
        }
        return false;
    }
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== undefined && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
                const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
                if (priorConstraint && priorConstraint.type !== 'climb' && priorConstraint.type !== 'missed') {
                    return priorConstraintIndex;
                }
                else {
                    return -1;
                }
            }
            let i = verticalPlan.constraints.length - 1;
            while (i >= 0) {
                const constraint = verticalPlan.constraints[i];
                if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== 'climb' && constraint.type !== 'missed') {
                    return i;
                }
                i--;
            }
        }
        else {
            const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraintIndex >= 0) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isMissed = currentConstraint.type === 'missed';
                for (let i = currentConstraintIndex; i >= 0; i--) {
                    const constraint = verticalPlan.constraints[i];
                    if (constraint.type === 'climb' || (isMissed && constraint.type === 'missed')) {
                        if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                            return i;
                        }
                    }
                    else {
                        return -1;
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
        var _a, _b;
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
        }
        else {
            return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
        }
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex)) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
            if (globalLegIndex > -1) {
                const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
                switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
                    case 'climb':
                    case 'missed':
                        return VerticalFlightPhase.Climb;
                }
            }
        }
        return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return undefined;
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
        }
        else {
            return currentConstraint.targetAltitude;
        }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            if (priorConstraint) {
                return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
            }
            else {
                return { type: AltitudeRestrictionType.Unused, altitude: 0 };
            }
        }
        else {
            return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        // added check for climb or descent for smoothing path calc
        if (currentConstraint !== undefined) {
            if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    return currentConstraint.maxAltitude;
                }
                else {
                    return currentConstraint.minAltitude;
                }
            }
            else {
                if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
                    return currentConstraint.minAltitude;
                }
                else {
                    return currentConstraint.maxAltitude;
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
        if (currentConstraint) {
            const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
            if (currentConstraintIndex > -1) {
                if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'climb' || constraint.type === 'missed') {
                            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                else {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
        if (constraintGlobalLegIndex < 0) {
            return;
        }
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
        verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex === undefined) {
            return;
        }
        verticalPlan.verticalDirectIndex = undefined;
        verticalPlan.verticalDirectFpa = undefined;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    setDefaultFpa(fpa) {
        const newFpa = Math.max(0, fpa);
        if (newFpa !== this.flightPathAngle) {
            this.flightPathAngle = newFpa;
            for (let i = 0; i < this.verticalFlightPlans.length; i++) {
                const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : undefined;
                const verticalPlan = this.verticalFlightPlans[i];
                if (lateralPlan && verticalPlan) {
                    this.computePathAndNotify(lateralPlan, verticalPlan);
                }
            }
        }
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex !== undefined) {
            if (legChangeEvent !== undefined) {
                const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
                if (globalIndex <= verticalPlan.verticalDirectIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
            else if (segmentChangeEvent !== undefined) {
                const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
                if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
        }
        verticalPlan.planChanged = true;
        verticalPlan.currentAlongLegDistance = undefined;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
        this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
    }
    /**
     * Builds a vertical flight plan if its corresponding lateral flight plan has been changed since the last rebuild,
     * then computes the vertical path sends events notifying subscribers that the plan was built and calculated.
     * @param planIndex The index of the plan to build and compute.
     */
    buildVerticalFlightPlanAndComputeAndNotify(planIndex) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.planChanged) {
            this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        }
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
        this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
        this.vnavCalculated.notify(this, planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
        this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.notifyBuilt(verticalPlan.planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
        SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
        verticalPlan.planChanged = false;
    }
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e, _f, _g;
        // Reset the constraints array.
        verticalPlan.constraints.length = 0;
        // Reset the segments array.
        verticalPlan.segments.length = 0;
        verticalPlan.destLegIndex = undefined;
        verticalPlan.firstDescentConstraintLegIndex = undefined;
        verticalPlan.lastDescentConstraintLegIndex = undefined;
        verticalPlan.missedApproachStartIndex = undefined;
        // Find the FAF in the lateral plan, if any.
        verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
        const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
        let firstApproachGlobalLegIndex;
        // Iterate forward through the lateral plan to build the constraints
        for (const segment of lateralPlan.segments()) {
            // Add the plan segments to the VNav Path Calculator Segments
            verticalPlan.segments[segment.segmentIndex] = {
                offset: segment.offset,
                legs: []
            };
            if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === undefined) {
                firstApproachGlobalLegIndex = segment.offset;
            }
            for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                const globalLegIndex = segment.offset + segmentLegIndex;
                const lateralLeg = segment.legs[segmentLegIndex];
                const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '', (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : undefined);
                // Check if the leg is part of the missed approach, and set the missed approach start index.
                if (verticalPlan.missedApproachStartIndex === undefined
                    && segment.segmentType === FlightPlanSegmentType.Approach
                    && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
                    verticalPlan.missedApproachStartIndex = globalLegIndex;
                }
                // Check if the leg contains a constraint
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
                verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                // Check if the leg precedes a defined vertical direct for this vertical flight plan.
                const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== undefined && globalLegIndex < verticalPlan.verticalDirectIndex;
                const legPrecedesDirectTo = directToTargetLegIndex !== undefined && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
                if (constraintAltitudes !== undefined
                    && !legPrecedesVerticalDirectIndex
                    && !legPrecedesDirectTo
                    && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
                    verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
                    const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    // Add the new vertical constraint to the array of constraints in reverse order.
                    verticalPlan.constraints.unshift(verticalConstraint);
                }
                // Add the new vertical leg to the vertical flight plan
                verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
            }
        }
        verticalPlan.length = lateralPlan.length;
        if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== undefined) {
            const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
            if (firstApproachConstraint && firstApproachConstraint.type !== 'climb' && firstApproachConstraint.type !== 'missed') {
                SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
            }
        }
        verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
        verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
        var _a;
        const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? 'missed' : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? 'descent' : 'climb');
        constraint.isBeyondFaf = verticalPlan.fafLegIndex === undefined ? false : globalLegIndex > verticalPlan.fafLegIndex;
        // Check if this constraint is a vertical direct.
        if (verticalPlan.verticalDirectIndex === globalLegIndex) {
            constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
            constraint.type = 'direct';
        }
        const userFpa = lateralLeg.verticalData.fpa;
        if (userFpa !== undefined && constraint.type !== 'climb' && constraint.type !== 'missed') {
            constraint.fpa = userFpa;
            constraint.type = 'manual';
        }
        return constraint;
    }
    /**
     * Computes the vertical path for a flight plan and sends an event notifying subscribers that the plan was
     * calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePathAndNotify(lateralPlan, verticalPlan) {
        this.computePath(lateralPlan, verticalPlan);
        this.notifyCalculated(lateralPlan.planIndex);
    }
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePath(lateralPlan, verticalPlan) {
        this.computeDescentPath(lateralPlan, verticalPlan);
    }
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computeDescentPath(lateralPlan, verticalPlan) {
        this.fillLegDistances(lateralPlan, verticalPlan);
        // Updated leg distances could cause some invalidated constraints to become valid, so we will re-insert all
        // invalidated constraints and filter them again.
        this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
        this.findAndRemoveInvalidConstraints(verticalPlan);
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        this.populateConstraints(verticalPlan);
        if (this.computeFlightPathAngles(verticalPlan)) {
            for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
                const constraint = verticalPlan.constraints[constraintIndex];
                if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                    let altitude = constraint.targetAltitude;
                    let constraintIsBod = true;
                    if (constraintIndex > 0) {
                        const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
                        if (nextConstraint !== undefined && nextConstraint.type !== 'climb') {
                            const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                            if ((nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25) || constraint.fpa === 0) {
                                constraintIsBod = false;
                            }
                        }
                    }
                    if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
                        constraint.isPathEnd = true;
                        constraint.isTarget = true;
                        constraintIsBod = true;
                    }
                    for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                        const leg = constraint.legs[legIndex];
                        leg.fpa = constraint.fpa;
                        leg.altitude = altitude;
                        altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
                        if (legIndex === 0) {
                            leg.isAdvisory = false;
                        }
                        else {
                            leg.isAdvisory = true;
                        }
                        if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                            leg.isBod = true;
                        }
                        else {
                            leg.isBod = false;
                        }
                    }
                }
            }
        }
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    fillLegDistances(lateralPlan, verticalPlan) {
        var _a, _b, _c;
        if (lateralPlan.length > 0) {
            for (const segment of lateralPlan.segments()) {
                if (segment) {
                    const vnavSegment = verticalPlan.segments[segment.segmentIndex];
                    for (let l = 0; l < segment.legs.length; l++) {
                        const leg = segment.legs[l];
                        if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                            vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
                        }
                        else if (leg && leg.calculated && leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                            let prevLeg;
                            for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                                if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
                                    prevLeg = checkLeg;
                                    break;
                                }
                            }
                            if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                                vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                            }
                        }
                        else {
                            vnavSegment.legs[l].distance = 0;
                        }
                    }
                }
            }
        }
    }
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    findAndRemoveInvalidConstraints(verticalPlan) {
        var _a, _b, _c;
        let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all constraints prior to the
        // direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? firstDescentConstraintIndex
            : verticalPlan.constraints.length - 1;
        let phase = 'climb';
        let priorMinAltitude = -Infinity;
        let priorMaxAltitude = Infinity;
        let distanceFromPriorMinAltitude = 0;
        let requiredFpa = 0;
        for (let i = startIndex; i >= 0; i--) {
            const currentConstraint = verticalPlan.constraints[i];
            const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
            let currentPhase;
            switch (currentConstraint.type) {
                case 'climb':
                case 'missed':
                    currentPhase = currentConstraint.type;
                    break;
                default:
                    currentPhase = 'descent';
            }
            if (currentPhase !== phase) {
                // Reset prior altitudes when switching phases.
                phase = currentPhase;
                priorMinAltitude = -Infinity;
                priorMaxAltitude = Infinity;
                distanceFromPriorMinAltitude = currentConstraintDistance;
            }
            else {
                distanceFromPriorMinAltitude += currentConstraintDistance;
            }
            let isDescentConstraint;
            let shouldInvalidate;
            switch (phase) {
                case 'climb':
                case 'missed':
                    isDescentConstraint = false;
                    shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
                    break;
                default:
                    isDescentConstraint = true;
                    if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
                        requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
                    }
                    else {
                        requiredFpa = 0;
                    }
                    shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
            }
            const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
            if (shouldInvalidate) {
                constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
                verticalPlan.constraints.splice(i, 1);
                // Need to subtract current constraint distance because it will get added again at the beginning of the next iteration.
                // (The next constraint inherits the legs that belonged to the current constraint after it is removed.)
                distanceFromPriorMinAltitude -= currentConstraintDistance;
                // If we invalidated the first descent constraint, we need to find the new one.
                if (isDescentConstraint && i === firstDescentConstraintIndex) {
                    firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
                    verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
                }
            }
            else {
                constraintLeg.invalidConstraintAltitude = undefined;
                if (isFinite(currentConstraint.minAltitude)) {
                    priorMinAltitude = currentConstraint.minAltitude;
                    distanceFromPriorMinAltitude = 0;
                }
                if (isFinite(currentConstraint.maxAltitude)) {
                    priorMaxAltitude = currentConstraint.maxAltitude;
                }
            }
        }
        // Update last descent leg in case we invalidated some descent constraints
        verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
        var _a;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all legs prior to and including
        // the direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? (verticalPlan.firstDescentConstraintLegIndex + 1)
            : 0;
        let globalLegIndex = startIndex;
        for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
            if (verticalLeg.invalidConstraintAltitude !== undefined) {
                const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                if (constraintAltitudes !== undefined) {
                    const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
                    // If we re-validated a descent constraint, we need to update the first/last descent constraint when appropriate.
                    if (proposedConstraint.type === 'descent'
                        || proposedConstraint.type === 'manual'
                        || proposedConstraint.type === 'direct'
                        || proposedConstraint.type === 'dest') {
                        if (verticalPlan.firstDescentConstraintLegIndex === undefined || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
                        }
                        if (verticalPlan.lastDescentConstraintLegIndex === undefined || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                            verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
                        }
                    }
                }
            }
            globalLegIndex++;
        }
    }
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    populateConstraints(verticalPlan) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
            const constraint = verticalPlan.constraints[constraintIndex];
            const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
            constraint.legs.length = 0;
            constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
            let eligibleLegIndex;
            let ineligibleLegIndex;
            for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== undefined ? previousConstraint.index : -1); globalLegIndex--) {
                const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
                constraint.legs.push(verticalLeg);
                if (ineligibleLegIndex === undefined && verticalLeg.isEligible) {
                    eligibleLegIndex = globalLegIndex;
                }
                if (ineligibleLegIndex === undefined && !verticalLeg.isEligible) {
                    ineligibleLegIndex = globalLegIndex;
                }
            }
            if (ineligibleLegIndex !== undefined && eligibleLegIndex !== undefined) {
                constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
            }
        }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
        // Iterate through all descent constraints in reverse flight plan order and attempt to assign one as a "target"
        // constraint, which is a constraint that anchors a constant FPA path connecting it to one or more prior
        // constraints.
        // Once a target constraint is found, the iteration continues as we attempt to build a constant FPA path backwards
        // from the target constraint that meets all the iterated constraints. Once we reach a constraint that cannot be
        // met with a constant FPA path from the target constraint that also meets all intermediate constraints, we assign
        // a new target constraint at the point where the FPA must change. Certain constraints must also be designated as
        // target constraints regardless of whether a constant FPA path through them is possible. In any case, once we
        // designate a new target constraint, the process is repeated until we run out of descent constraints.
        let currentTargetConstraint;
        let currentPathSegmentDistance = 0;
        let currentPathSegmentMinFpa = this.minFlightPathAngle;
        let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        let currentTargetConstraintHasFixedFpa = false;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
            // There are no descent constraints, so no FPAs to be calculated
            return false;
        }
        for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
            const constraint = verticalPlan.constraints[targetConstraintIndex];
            // If the current constraint is climb or missed, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            // If we haven't found a target constraint yet, attempt to make the current constraint the target constraint,
            // if it defines either a minimum or maximum altitude. The target altitude is preferentially set to the minimum
            // altitude, if it exists. If the current constraint has neither a minimum nor maximum altitude (which should
            // technically never happen), skip it.
            if (!currentTargetConstraint) {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    currentTargetConstraint = constraint;
                    currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
                    currentTargetConstraint.isTarget = true;
                }
                else {
                    continue;
                }
            }
            // Reset the method variables
            currentPathSegmentMinFpa = this.minFlightPathAngle;
            currentPathSegmentMaxFpa = this.maxFlightPathAngle;
            currentPathSegmentDistance = currentTargetConstraint.distance;
            const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
            if (currentTargetConstraintIsFirstDescentConstraint) {
                if (currentTargetConstraint.type === 'descent') {
                    // If this is the first descent constraint and it is not a direct or manual, set the FPA to the default value.
                    currentTargetConstraint.fpa = this.flightPathAngle;
                }
                // If currentTargetConstraintIsFirstDescentConstraint is true, then after this logic, we're done with this method.
                return true;
            }
            // If the current target constraint is a manual or direct type, then honor the FPA by not allowing any other FPAs.
            if (currentTargetConstraint.type === 'manual') {
                currentPathSegmentMinFpa = currentTargetConstraint.fpa;
                currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
                currentTargetConstraintHasFixedFpa = true;
            }
            else {
                currentTargetConstraintHasFixedFpa = false;
            }
            let pathSegmentIsFlat = false;
            for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
                const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
                const isCurrentConstraintClimb = currentConstraint.type === 'climb' || currentConstraint.type === 'missed';
                const isCurrentConstraintManual = currentConstraint.type === 'manual';
                const isCurrentConstraintDirect = currentConstraint.type === 'direct';
                if (isCurrentConstraintClimb) {
                    // We have reached a climb constraint.
                    if (currentConstraintIndex - 1 > targetConstraintIndex) {
                        // There is at least one constraint between the existing target constraint and the current climb
                        // constraint. Attempt to extend the constant-FPA path through the constraint immediately following the
                        // current climb constraint (which is guaranteed to be a descent constraint).
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                        const maxAltitude = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
                        const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude, false);
                        if (terminatedIndex < currentConstraintIndex) {
                            // The path was terminated early, which means there is a new target constraint.
                            targetConstraintIndex = terminatedIndex - 1; // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                            break;
                        }
                    }
                    else {
                        // The existing target constraint immediately follows the current climb constraint. Treat the target
                        // constraint as if it were the first descent constraint and apply the default FPA. Note that we are
                        // guaranteed the target constraint is not a direct constraint.
                        currentTargetConstraint.fpa = this.flightPathAngle;
                    }
                    // Do not designate a new target constraint in order to allow the outer loop to find the new one.
                    targetConstraintIndex = currentConstraintIndex;
                    currentTargetConstraint = undefined;
                    break;
                }
                const minAltitude = currentConstraint.minAltitude;
                const maxAltitude = currentConstraint.maxAltitude;
                if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
                    // We are in a flat segment (all constraints with FPA = 0) and the current constraint would allow a
                    // non-zero FPA to the constraint immediately following it. Therefore, we set the new target constraint
                    // to the constraint immediately following the current one (because it is at the end of that constraint
                    // where the FPA can potentially change from non-zero to zero). Note that we are guaranteed that the
                    // new target constraint lies prior to the existing target constraint.
                    const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                    const newTargetConstraintIndex = currentConstraintIndex - 1;
                    SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, 
                    // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                    // constraints are equal to the flat segment altitude.
                    Infinity, this.applyPathValuesResult);
                    // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                    targetConstraintIndex = newTargetConstraintIndex - 1;
                    currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
                    currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                    currentTargetConstraint.isTarget = true;
                    break;
                }
                else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
                    // The current constraint does not allow a non-zero FPA to the target constraint, and the target constraint
                    // does not have a fixed FPA. We will mark the current segment as flat and set the target constraint FPA to 0.
                    pathSegmentIsFlat = true;
                    currentTargetConstraint.fpa = 0;
                    if (isCurrentConstraintFirstDescent) {
                        // If the current constraint is the first descent constraint, then we need to make it the new target
                        // constraint because the first descent constraint is never flat.
                        const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                        SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, 
                        // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                        // constraints are equal to the flat segment altitude.
                        Infinity, this.applyPathValuesResult);
                        // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                        targetConstraintIndex = currentConstraintIndex - 1;
                        currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
                        currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                        currentTargetConstraint.isTarget = true;
                        break;
                    }
                    continue;
                }
                // Get the min and max FPA from the current target constraint to the current constraint.
                const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
                const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
                const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
                // A new target constraint needs to be created under the following conditions:
                // - The current constraint cannot be met with a constant FPA path from the current target constraint within
                //   this calculator's FPA limits.
                // - The current constraint is the final approach fix.
                // - The current constraint is a vertical direct constraint.
                // - The current constraint is a manual constraint.
                if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
                    // We need to choose a FPA for the constant-FPA smoothed path.
                    if (isFpaOutOfBounds) {
                        // If we are creating a new target constraint because the current constraint can't be met with a
                        // constant-FPA path, then we set the FPA of the smoothed path to the value that brings the new
                        // target constraint's target altitude as close to meeting the current constraint as possible.
                        if (minFpa > currentPathSegmentMaxFpa) {
                            currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
                        }
                        else {
                            currentTargetConstraint.fpa = currentPathSegmentMinFpa;
                        }
                    }
                    else {
                        // If the new target constraint can be met with a constant-FPA path, then we choose a valid FPA that is
                        // as close to the calculator's default FPA as possible.
                        currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                        currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    }
                    // Find the next constraint with a max altitude
                    const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
                    // Attempt to extend a constant-FPA path from the existing target constraint to the current constraint and
                    // make the current constraint the new target constraint.
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
                    targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                    currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                    break;
                }
                else if (isCurrentConstraintFirstDescent) {
                    // We have reached the first descent constraint without needing to create a new target constraint, so
                    // attempt to extend the constant-FPA path from the existing target constraint through the first descent
                    // constraint.
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
                    if (terminatedIndex < currentConstraintIndex + 1) {
                        // The path was terminated early, which means there is a new target constraint.
                        targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                        currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                        break;
                    }
                    else {
                        // The path was not terminated early, so we are done.
                        return true;
                    }
                }
                else {
                    // Extend the current constant-FPA path and update the FPA limits
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentPathSegmentDistance += currentConstraint.distance;
                }
            }
        }
        return true;
    }
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
        const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
        if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== undefined) {
            // A constant-FPA path was not able to be extended from the existing target constraint to the first descent
            // constraint, so we need to designate a new target constraint where the path terminated.
            const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
            // Establish the proposed next target constraint target altitude
            const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
            const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
            // Set the new target constraint values
            const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            newTargetConstraint.isTarget = true;
            newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
        }
        return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.constraints.length > 0) {
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                const constraint = verticalPlan.constraints[i];
                if (constraint.type !== 'climb') {
                    return constraint.targetAltitude;
                }
            }
        }
        return undefined;
    }
    // Start of buildVerticalFlightPlan helper methods
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    static getConstraintAltitudes(leg, out) {
        if (leg.verticalData !== undefined) {
            switch (leg.verticalData.altDesc) {
                case AltitudeRestrictionType.At:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.AtOrAbove:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = Number.POSITIVE_INFINITY;
                    return out;
                case AltitudeRestrictionType.AtOrBelow:
                    out[0] = Number.NEGATIVE_INFINITY;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.Between:
                    out[0] = leg.verticalData.altitude2;
                    out[1] = leg.verticalData.altitude1;
                    return out;
            }
        }
        return undefined;
    }
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    static forceAtConstraint(constraint) {
        if (constraint.minAltitude !== constraint.maxAltitude) {
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                constraint.maxAltitude = constraint.minAltitude;
            }
            else {
                constraint.minAltitude = constraint.maxAltitude;
            }
        }
    }
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    static getDirectToTargetLegIndex(lateralPlan) {
        const directToData = lateralPlan.directToData;
        if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
            const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
            if (segment !== null) {
                return segment.offset + directToData.segmentLegIndex;
            }
        }
        return undefined;
    }
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
        // Check for a direct to in the lateral plan
        if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
            const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
            if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
                const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
                directVerticalLeg.isDirectToTarget = true;
                const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
                if (segment !== undefined) {
                    const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
                    for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type !== 'climb' && constraint.type !== 'missed' && constraint.index >= globalLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                            return;
                        }
                    }
                    verticalPlan.firstDescentConstraintLegIndex = undefined;
                }
            }
        }
    }
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
        if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
        const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
        const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
        if (currentMinWithPrecision > priorMaxWithPrecision) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
        if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
            const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
            const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
            if (minFpaTempValue > maxFpa) {
                return true;
            }
        }
        return false;
    }
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg) {
        switch (lateralLeg.leg.type) {
            case LegType.VM:
            case LegType.FM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint() {
        return false;
    }
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
        return (isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10)) || requiredFpa > maxFpa;
    }
    // Start of computeFlightPathAngles helper methods
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
        for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.maxAltitude < Infinity) {
                return constraint.maxAltitude;
            }
            if (i === firstDescentConstraintIndex && constraint.type === 'direct') {
                if (constraint.minAltitude > -Infinity) {
                    return constraint.minAltitude;
                }
            }
        }
        return Infinity;
    }
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        let distance = currentTargetConstraint.distance;
        for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
            const smoothedConstraint = verticalPlan.constraints[i];
            const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
            // The path can continue past the current constraint if the target altitude at the current constraint is less
            // than the maximum altitude.
            if (targetAltitude < maxAltitude) {
                smoothedConstraint.fpa = currentTargetConstraint.fpa;
                smoothedConstraint.targetAltitude = targetAltitude;
                distance += smoothedConstraint.distance;
            }
            else {
                out[0] = i;
                out[1] = distance;
                return out;
            }
        }
        out[0] = undefined;
        out[1] = distance;
        return out;
    }
}
SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;

/**
 * Sim var names for LNAV-related data.
 */
var LNavDataVars;
(function (LNavDataVars) {
    /** The current nominal desired track, in degrees true. */
    LNavDataVars["DTKTrue"] = "L:WT_LNavData_DTK_True";
    /** The current nominal desired track, in degrees magnetic. */
    LNavDataVars["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavDataVars["XTK"] = "L:WT_LNavData_XTK";
    /** The current CDI scale. */
    LNavDataVars["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    LNavDataVars["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    LNavDataVars["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    LNavDataVars["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    /** The nominal distance remaining to the destination. */
    LNavDataVars["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
})(LNavDataVars || (LNavDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class LNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavDataSimVarPublisher.simvars, bus);
    }
}
LNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
]);

/**
 * Transports an alert state to the CAS via the event bus.
 */
class CasAlertTransporter {
    /**
     * Creates an instance of a CasAlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     */
    constructor(bus, uuid, priority, suffix) {
        this.bus = bus;
        this.uuid = uuid;
        this.priority = priority;
        this.suffix = suffix;
        this.currentValue = false;
        this.subs = [];
        this.updateEntries = [];
        this.isAlive = true;
        this.isPaused = false;
    }
    /**
     * Sets whether or not the alert is active.
     * @param active Whether or not the alert is active.
     * @throws Error if this transporter has been destroyed.
     */
    set(active) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot change an alert with a dead transporter');
        }
        if (this.currentValue !== active) {
            if (active) {
                this.bus.getPublisher().pub('cas_activate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            else {
                this.bus.getPublisher().pub('cas_deactivate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            this.currentValue = active;
        }
    }
    /**
     * Binds an alert state to a subscribable value.
     * @param toWatch The subscribable value to watch.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bind(toWatch, predicate) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        this.subs.push(toWatch.sub(v => this.set(predicate(v)), true, this.isPaused));
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindUpdate(predicate) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: false,
            func: (deltaTime) => this.set(predicate(deltaTime))
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @param state The optional state to pass into the predicate.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindStateUpdate(predicate, state) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: true,
            func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
            state
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Resumes this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also resumed. On resumption, the values of bound subscribables are evaluated
     * immediately, while the values of bound update loops will be evaluated during the next update cycle.
     * @returns This transporter, after it has been resumed.
     * @throws Error if this transporter has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot resume a dead transporter');
        }
        if (!this.isPaused) {
            return this;
        }
        this.isPaused = false;
        this.subs.forEach(sub => { sub.resume(true); });
        this.updateEntries.forEach(entry => { entry.isPaused = false; });
        return this;
    }
    /**
     * Pauses this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also paused.
     * @returns This transporter, after it has been paused.
     * @throws Error if this transporter has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot pause a dead transporter');
        }
        if (this.isPaused) {
            return this;
        }
        this.isPaused = true;
        this.subs.forEach(sub => { sub.pause(); });
        if (CasAlertTransporter.updateEntries) {
            this.updateEntries.forEach(entry => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const index = CasAlertTransporter.updateEntries.indexOf(entry);
                if (index >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    CasAlertTransporter.updateEntries.splice(index, 1);
                }
            });
        }
        return this;
    }
    /**
     * Destroys this transporter. This will destroy any subscribables or update loops used to bind the state of this
     * transporter's alert. Once this transporter has been destroyed, it cannot be used to change the state of its alert,
     * bind the state of its alert, or be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        this.subs.forEach(sub => { sub.destroy(); });
        this.updateEntries.forEach(entry => { entry.isPaused = true; });
    }
    /**
     * Creates an instance of an AlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     * @returns The created AlertTransporter.
     */
    static create(bus, uuid, priority, suffix) {
        return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    /**
     * Initializes the update functions.
     */
    initUpdateFuncs() {
        if (CasAlertTransporter.updateEntries === undefined) {
            CasAlertTransporter.updateEntries = [];
            this.bus.getSubscriber().on('simTime').handle((timestamp) => {
                if (CasAlertTransporter.previousTimestamp === -1) {
                    CasAlertTransporter.previousTimestamp = timestamp;
                }
                const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 10000);
                if (CasAlertTransporter.updateEntries !== undefined) {
                    for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
                        const entry = CasAlertTransporter.updateEntries[i];
                        if (entry.isPaused) {
                            continue;
                        }
                        if (entry.hasState) {
                            entry.func(deltaTime, entry.state);
                        }
                        else {
                            entry.func(deltaTime);
                        }
                    }
                }
                CasAlertTransporter.previousTimestamp = timestamp;
            });
        }
    }
}
CasAlertTransporter.previousTimestamp = -1;

/**
 * This is a convenience tool for publishing and republishing CAS alert registrations.  Code
 * that wants to implement its own alert publishing system can use the CasRegistrationManager
 * to avoid having to subscribe to and handle requests on the bus for republication of alert
 * registrations.
 */
class CasRegistrationManager {
    /**
     * Create a CasRegistrationManager
     * @param bus The event bus
     */
    constructor(bus) {
        this.registrations = new Map();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('cas_publish_registration').handle(uuid => this.publishRegistration(uuid));
        subscriber.on('cas_publish_all_registrations').handle(() => this.publishAllRegistrations());
    }
    /**
     * Register an alert for management.
     * @param definition The CasAlertDefinition for this alert.
     */
    register(definition) {
        this.registrations.set(definition.uuid, definition);
        this.publishRegistration(definition.uuid);
    }
    /**
     * Handle publishing information for a single alert.
     * @param uuid The UUID of the registation to publish.
     */
    publishRegistration(uuid) {
        const definition = this.registrations.get(uuid);
        if (definition) {
            this.publisher.pub('cas_register_alert', definition, true, false);
        }
    }
    /**
     * Publish all current registrations.
     */
    publishAllRegistrations() {
        for (const uuid of this.registrations.keys()) {
            this.publishRegistration(uuid);
        }
    }
}

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus, settingDefs, keepLocal = false) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.subscriber = this.bus.getSubscriber();
        this.syncPublisher = this.bus.getPublisher();
        this.syncSubscriber = this.bus.getSubscriber();
        this.keepLocal = keepLocal;
        this.settings = new Map(settingDefs.map(def => {
            const initTopic = `usersetting_init_${def.name}`;
            const syncTopic = `usersetting_sync_${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0,
                initUid: Math.round(Math.random() * Number.MAX_SAFE_INTEGER)
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            entry.initSub = this.syncSubscriber.on(initTopic).handle(data => {
                // Do not respond to our own initialization sync.
                if (data.uid === entry.initUid) {
                    return;
                }
                // If we receive an initialization sync event for a setting, that means a manager on another instrument tried
                // to initialize the same setting to its default value. However, since the setting already exists here, we will
                // send a response to override the initialized value with the existing value.
                this.syncPublisher.pub(entry.syncTopic, { value: entry.setting.value, syncTime: entry.syncTime, initUid: data.uid }, !this.keepLocal, true);
            }, true);
            // Because sync events are cached, the initial subscriptions to the sync topic below will grab the synced value
            // of the new setting if it exists on the local instrument (e.g. if the value was synced from another instrument
            // after the local instrument was created but before this manager and local setting were created).
            this.syncSubscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            if (entry.syncTime === 0) {
                // If the new setting has no synced value on the local instrument, we will try to grab an initialization value
                // instead. If one exists, we will use it, but keep the local sync time at 0. If there is a pending response
                // to this initialization value, we want to be ready to accept the response when it arrives, which we can't do
                // if the local sync time is non-zero).
                const sub = this.syncSubscriber.on(initTopic).handle(data => {
                    this.onSettingValueSynced(entry, { value: data.value, syncTime: 0 });
                });
                sub.destroy();
            }
            if (entry.syncTime === 0) {
                // An existing synced value does not exist for the new setting on the local instrument, so we will go ahead
                // and initialize the new setting value to its default and send an initialization sync event. If the setting
                // exists on other instruments, their managers will send an initialization response to override our initialized
                // value.
                this.syncPublisher.pub(initTopic, { value: entry.setting.value, syncTime: Date.now(), uid: entry.initUid }, !this.keepLocal, true);
                this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
            }
            entry.initSub.resume();
            return [def.name, entry];
        }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.syncPublisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, !this.keepLocal, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // If the sync event is an initialization response, ignore it if the local setting value has already been synced.
        // Otherwise, protect against race conditions by not responding to sync events older than the last time this
        // manager synced the setting.
        if ((data.initUid !== undefined && entry.syncTime !== 0)
            || (data.initUid === undefined && data.syncTime < entry.syncTime)) {
            return;
        }
        this.syncSettingFromEvent(entry, data);
    }
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    syncSettingFromEvent(entry, data) {
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // Publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
    }
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
        return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        super();
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isMutableSubscribable = true;
        this._value = definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.valueChangedCallback(v);
        this.notify();
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        if (this._value === value) {
            return;
        }
        this._value = value;
        this.notify();
    }
    /** @inheritdoc */
    get() {
        return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * The state of an avionics system.
 */
var AvionicsSystemState;
(function (AvionicsSystemState) {
    AvionicsSystemState["Off"] = "Off";
    AvionicsSystemState["Initializing"] = "Initializing";
    AvionicsSystemState["On"] = "On";
    AvionicsSystemState["Failed"] = "Failed";
})(AvionicsSystemState || (AvionicsSystemState = {}));

/**
 * A basic avionics system with a fixed initialization time and logic.
 */
class BasicAvionicsSystem {
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index, bus, stateEvent) {
        this.index = index;
        this.bus = bus;
        this.stateEvent = stateEvent;
        /** The time it takes in milliseconds for the system to initialize. */
        this.initializationTime = 0;
        /** A timeout after which initialization will be complete. */
        this.initializationTimer = new DebounceTimer();
        this.publisher = this.bus.getPublisher();
        /** Whether power data consumed by this system is valid. */
        this.isPowerValid = false;
        this.bus.pub(this.stateEvent, { previous: undefined, current: undefined });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.isPowerValid = true;
                this.onPowerValid();
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    get state() {
        return this._state;
    }
    /**
     * Responds to when power data becomes valid.
     */
    onPowerValid() {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic, electricity logic element, or
     * {@link Subscribable}.
     * @param source The source to which to connect this system's power state.
     */
    connectToPower(source) {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.electricalPowerSub = undefined;
        this.electricalPowerLogic = undefined;
        if (typeof source === 'string') {
            this.electricalPowerSub = this.bus.getSubscriber()
                .on(source)
                .whenChanged()
                .handle(this.onPowerChanged.bind(this), !this.isPowerValid);
        }
        else if (SubscribableUtils.isSubscribable(source)) {
            this.electricalPowerSub = source.sub(this.onPowerChanged.bind(this), true, !this.isPowerValid);
        }
        else {
            this.electricalPowerLogic = source;
            this.updatePowerFromLogic();
        }
    }
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    setState(state) {
        if (this._state !== state) {
            const previous = this._state;
            this._state = state;
            this.onStateChanged(previous, state);
            this.bus.pub(this.stateEvent, { previous, current: state });
        }
    }
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        // noop
    }
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Off);
            }
        }
        else {
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(() => this.setState(AvionicsSystemState.On), this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        this.updatePowerFromLogic();
    }
    /**
     * Updates this system's power state from an electricity logic element.
     */
    updatePowerFromLogic() {
        if (!this.isPowerValid || this.electricalPowerLogic === undefined) {
            return;
        }
        const isPowered = this.electricalPowerLogic.getValue() !== 0;
        if (isPowered !== this.isPowered) {
            this.onPowerChanged(isPowered);
        }
    }
}

/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
class FsBaseInstrument extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
        super.Update();
        if (this.fsInstrument) {
            this.fsInstrument.Update();
        }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
        if (this.fsInstrument) {
            this.fsInstrument.onInteractionEvent(_args);
        }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
        super.onGameStateChanged(oldState, newState);
        if (this.fsInstrument) {
            this.fsInstrument.onGameStateChanged(oldState, newState);
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
        if (this.fsInstrument) {
            this.fsInstrument.onFlightStart();
        }
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
        super.onSoundEnd(soundEventId);
        if (this.fsInstrument) {
            this.fsInstrument.onSoundEnd(soundEventId);
        }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return false;
    }
}

/**
 * A configuration object which defines options related to various aircraft sensors.
 */
class SensorsConfig {
    /**
     * Creates a new SensorsConfig from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     */
    constructor(baseInstrument, element) {
        if (element === undefined) {
            this.adcCount = 1;
            this.ahrsCount = 1;
            this.radarAltimeterCount = 1;
            this.gpsCount = 1;
            this.adcDefinitions = [undefined, { altimeterIndex: 1, airspeedIndicatorIndex: 1 }];
            this.ahrsDefinitions = [undefined, { attitudeIndicatorIndex: 1, directionIndicatorIndex: 1 }];
            this.radarAltimeterDefinitions = [undefined, {}];
            this.gpsDefinitions = [undefined, {}];
        }
        else {
            if (element.tagName !== 'Sensors') {
                throw new Error(`Invalid SensorsConfig definition: expected tag name 'Sensors' but was '${element.tagName}'`);
            }
            const adcCount = Number(element.getAttribute('adc-count'));
            if (!Number.isInteger(adcCount) || adcCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC count (must be a positive integer)');
                this.adcCount = 1;
            }
            else {
                this.adcCount = adcCount;
            }
            const ahrsCount = Number(element.getAttribute('ahrs-count'));
            if (!Number.isInteger(ahrsCount) || ahrsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS count (must be a positive integer)');
                this.ahrsCount = 1;
            }
            else {
                this.ahrsCount = ahrsCount;
            }
            const radarAltimeterCount = Number(element.getAttribute('radar-altimeter-count'));
            if (!Number.isInteger(radarAltimeterCount) || radarAltimeterCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized RA count (must be a positive integer)');
                this.radarAltimeterCount = 1;
            }
            else {
                this.radarAltimeterCount = radarAltimeterCount;
            }
            const gpsCount = Number(element.getAttribute('gps-count'));
            if (!Number.isInteger(gpsCount) || gpsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS count (must be a positive integer)');
                this.gpsCount = 1;
            }
            else {
                this.gpsCount = gpsCount;
            }
            this.adcDefinitions = this.parseAdcDefinitions(baseInstrument, element);
            this.ahrsDefinitions = this.parseAhrsDefinitions(baseInstrument, element);
            this.radarAltimeterDefinitions = this.parseRadarAltimeterDefinitions(baseInstrument, element);
            this.gpsDefinitions = this.parseGpsDefinitions(baseInstrument, element);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this configuration defines a radar altimeter. */
    get hasRadarAltimeter() {
        return this.radarAltimeterDefinitions.length > 1;
    }
    /**
     * Parses ADC definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of ADC definitions defined by the configuration document element.
     */
    parseAdcDefinitions(baseInstrument, element) {
        const adcElements = element.querySelectorAll(':scope>Adc');
        const defs = [];
        for (const adcElement of adcElements) {
            const index = Number(adcElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.adcCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC index (must be an integer between 1 and the number of supported ADCs)');
                continue;
            }
            const altimeterIndex = Number(adcElement.getAttribute('altimeter'));
            if (!Number.isInteger(altimeterIndex) || altimeterIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized altimeter index (must be a positive integer)');
                continue;
            }
            const airspeedIndicatorIndex = Number(adcElement.getAttribute('airspeed-indicator'));
            if (!Number.isInteger(airspeedIndicatorIndex) || airspeedIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized airspeed indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = adcElement.querySelector(':scope>Electric');
            defs[index] = {
                altimeterIndex,
                airspeedIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    altimeterIndex: i,
                    airspeedIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses AHRS definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of AHRS definitions defined by the configuration document element.
     */
    parseAhrsDefinitions(baseInstrument, element) {
        const ahrsElements = element.querySelectorAll(':scope>Ahrs');
        const defs = [];
        for (const ahrsElement of ahrsElements) {
            const index = Number(ahrsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.ahrsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const attitudeIndicatorIndex = Number(ahrsElement.getAttribute('attitude-indicator'));
            if (!Number.isInteger(attitudeIndicatorIndex) || attitudeIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized attitude indicator index (must be a positive integer)');
                continue;
            }
            const directionIndicatorIndex = Number(ahrsElement.getAttribute('direction-indicator'));
            if (!Number.isInteger(directionIndicatorIndex) || directionIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized direction indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = ahrsElement.querySelector(':scope>Electric');
            defs[index] = {
                attitudeIndicatorIndex,
                directionIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    attitudeIndicatorIndex: i,
                    directionIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses a radar altimeter definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of RA definitions defined by the configuration document element.
     */
    parseRadarAltimeterDefinitions(baseInstrument, element) {
        const radarAltimeterElements = element.querySelectorAll(':scope>RadarAltimeter');
        const defs = [];
        for (const radarAltimeterElement of radarAltimeterElements) {
            const index = Number(radarAltimeterElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.radarAltimeterCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const electricLogicElement = radarAltimeterElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.radarAltimeterCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
    /**
     * Parses a GPS receiver definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of GPS definitions defined by the configuration document element.
     */
    parseGpsDefinitions(baseInstrument, element) {
        const gpsElements = element.querySelectorAll(':scope>Gps');
        const defs = [];
        for (const gpsElement of gpsElements) {
            const index = Number(gpsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.gpsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS index (must be an integer between 1 and the number of supported GPS)');
                continue;
            }
            const electricLogicElement = gpsElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.gpsCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
}

/**
 * A configuration object which defines options for G3000/5000 avionics systems.
 */
class AvionicsConfig {
    /**
     * Creates an AvionicsConfig from an XML configuration document.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param xmlConfig An XML configuration document.
     */
    constructor(baseInstrument, xmlConfig) {
        const root = xmlConfig.getElementsByTagName('PlaneHTMLConfig')[0];
        this.sensors = this.parseSensorsConfig(baseInstrument, root.querySelector(':scope>Sensors'));
    }
    /**
     * Parses a sensors configuration object from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns The sensors configuration defined by the configuration document element.
     */
    parseSensorsConfig(baseInstrument, element) {
        if (element !== null) {
            try {
                return new SensorsConfig(baseInstrument, element);
            }
            catch (e) {
                console.warn(e);
            }
        }
        return new SensorsConfig(baseInstrument, undefined);
    }
}

/** The state of the altitude alerter. */
var AltAlertState;
(function (AltAlertState) {
    /** Disabled Mode */
    AltAlertState[AltAlertState["DISABLED"] = 0] = "DISABLED";
    /** Armed Mode. */
    AltAlertState[AltAlertState["ARMED"] = 1] = "ARMED";
    /** Within 900 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_900"] = 2] = "WITHIN_900";
    /** Within 300 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_300"] = 3] = "WITHIN_300";
    /** Within 200 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_200"] = 4] = "WITHIN_200";
    /** Captured the preselected altitude. */
    AltAlertState[AltAlertState["CAPTURED"] = 5] = "CAPTURED";
    /** Outside of the 200ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_200"] = 6] = "DEVIATION_200";
    /** Outside of the 300ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_300"] = 7] = "DEVIATION_300";
    /** Outside of the 900ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_900"] = 8] = "DEVIATION_900";
})(AltAlertState || (AltAlertState = {}));
/** Navigation sources for lateral and vertical guidance */
var NavigationSource;
(function (NavigationSource) {
    NavigationSource[NavigationSource["NONE"] = 0] = "NONE";
    /** FMC/non-precision source i.e. LNAV or VNAV */
    NavigationSource[NavigationSource["NPS"] = 1] = "NPS";
    NavigationSource[NavigationSource["IAN"] = 2] = "IAN";
    NavigationSource[NavigationSource["ILS"] = 3] = "ILS";
    NavigationSource[NavigationSource["GLS"] = 4] = "GLS";
})(NavigationSource || (NavigationSource = {}));
/** Approach frequency tuning mode for the ILS radio */
var ApproachTuningMode;
(function (ApproachTuningMode) {
    ApproachTuningMode[ApproachTuningMode["Park"] = 0] = "Park";
    ApproachTuningMode[ApproachTuningMode["ParkTuned"] = 1] = "ParkTuned";
    ApproachTuningMode[ApproachTuningMode["Autotuned"] = 2] = "Autotuned";
    ApproachTuningMode[ApproachTuningMode["ManuallyTuned"] = 3] = "ManuallyTuned";
})(ApproachTuningMode || (ApproachTuningMode = {}));
var VorTuningMode;
(function (VorTuningMode) {
    /** The FMC isn't currently tuning a VOR */
    VorTuningMode[VorTuningMode["None"] = 0] = "None";
    /** The FMC is tuning the VOR manually entered on the CDU by the pilots */
    VorTuningMode[VorTuningMode["ManuallyTuned"] = 1] = "ManuallyTuned";
    /** The FMC is tuning a VOR required by the current procedure */
    VorTuningMode[VorTuningMode["ProcedureTuned"] = 2] = "ProcedureTuned";
    /** The FMC is tuning a VOR that features as a waypoint on the current route */
    VorTuningMode[VorTuningMode["RouteTuned"] = 3] = "RouteTuned";
    /** The FMC is tuning a suitable nearby VOR */
    VorTuningMode[VorTuningMode["AutoTuned"] = 4] = "AutoTuned";
})(VorTuningMode || (VorTuningMode = {}));
var AutolandCapability;
(function (AutolandCapability) {
    AutolandCapability[AutolandCapability["None"] = 0] = "None";
    AutolandCapability[AutolandCapability["FailPassive"] = 1] = "FailPassive";
    AutolandCapability[AutolandCapability["FailOperational"] = 2] = "FailOperational";
})(AutolandCapability || (AutolandCapability = {}));

/** Type for whether ND is in HDG up or TRK up mode. */
var BoeingNdHdgTrkUpMode;
(function (BoeingNdHdgTrkUpMode) {
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["HDG"] = 0] = "HDG";
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["TRK"] = 1] = "TRK";
})(BoeingNdHdgTrkUpMode || (BoeingNdHdgTrkUpMode = {}));
/**
 * IRS alignment time modes.
 */
var BoeingIrsAlignTimeMode;
(function (BoeingIrsAlignTimeMode) {
    /** IRS aligns instantly. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Instant"] = 0] = "Instant";
    /** IRS attitude alignment finishes in 30 seconds and full alignment finishes in 60 seconds. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Accelerated"] = 1] = "Accelerated";
    /**
     * IRS attitude alignment finishes in 30 seconds and full alignment finishes in an amount of time approximating the
     * real unit (5 minutes at the equator to 17 minutes near the poles).
     */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Realistic"] = 2] = "Realistic";
})(BoeingIrsAlignTimeMode || (BoeingIrsAlignTimeMode = {}));
/**
 * Auto fuel management modes
 */
var BoeingAutoFuelMode;
(function (BoeingAutoFuelMode) {
    /** Auto fuel management on */
    BoeingAutoFuelMode[BoeingAutoFuelMode["ON"] = 0] = "ON";
    /** Auto fuel management off */
    BoeingAutoFuelMode[BoeingAutoFuelMode["OFF"] = 1] = "OFF";
})(BoeingAutoFuelMode || (BoeingAutoFuelMode = {}));
const boeingMsfsUserSettings = [
    {
        name: 'boeingMsfsNdHdgTrkUpMode',
        defaultValue: BoeingNdHdgTrkUpMode.TRK,
    },
    {
        name: 'boeingMsfsIrsAlignTime',
        defaultValue: BoeingIrsAlignTimeMode.Accelerated,
    },
    {
        name: 'boeingMsfsSelcal',
        defaultValue: 'DM-ES',
    },
    {
        name: 'boeingMsfsAutoFuelManagement',
        defaultValue: BoeingAutoFuelMode.OFF,
    },
    {
        name: 'boeingMsfsSimbriefUserID',
        defaultValue: -1,
    },
    {
        name: 'boeingMsfsSimbriefUsername',
        defaultValue: '',
    },
];
/**
 * Utility class for retrieving boeing msfs user setting managers.
 * These are user settings for Boeing aircraft and are meant to be persistent.
 */
class BoeingMsfsUserSettings {
    /**
     * Retrieves a manager for boeing msfs user settings.
     * @param bus The event bus.
     * @returns a manager for boeing msfs user settings.
     */
    static getManager(bus) {
        if (BoeingMsfsUserSettings.INSTANCE === undefined) {
            BoeingMsfsUserSettings.INSTANCE = new DefaultUserSettingManager(bus, boeingMsfsUserSettings);
        }
        return BoeingMsfsUserSettings.INSTANCE;
    }
}

const refsSettings = [
    {
        name: 'minimumsMode',
        defaultValue: MinimumsMode.OFF,
    },
    {
        name: 'decisionHeightFeet',
        defaultValue: 0,
    },
    {
        name: 'decisionAltitudeFeet',
        defaultValue: 0,
    },
    {
        name: 'metricAltitudeDisplay',
        defaultValue: false,
    },
    {
        name: 'fltNumber',
        defaultValue: '',
    },
    {
        name: 'fpvActive',
        defaultValue: false,
    },
    /** The EICAS page secondary engine indicators display state. */
    {
        name: 'eicasSecondaryEngineIndicatorsOn',
        defaultValue: false,
    }
];
/** Utility class for retrieving Refs user setting managers. */
class CockpitUserSettings {
    /**
     * Retrieves a manager for Refs user settings.
     * @param bus The event bus.
     * @returns a manager for Refs user settings.
     */
    static getManager(bus) {
        if (CockpitUserSettings.INSTANCE === undefined) {
            CockpitUserSettings.INSTANCE = new DefaultUserSettingManager(bus, refsSettings);
            CockpitUserSettings.wireSettings(CockpitUserSettings.INSTANCE);
        }
        return CockpitUserSettings.INSTANCE;
    }
    /**
     * Wires up any special setttings handlers.
     * @param settingsManager The settings manager.
     */
    static wireSettings(settingsManager) {
        CockpitUserSettings.subs.push(settingsManager.getSetting('fltNumber').sub(fltNumber => {
            // strip the first 1-3 letters from the callsign to get only the numbers to feed to the default ATC
            const justTheNumber = fltNumber.includes('-') || fltNumber.length === 0
                ? '0'
                : fltNumber.replace(/^([A-Z]{1,3})/, '');
            SimVar.SetSimVarValue('ATC FLIGHT NUMBER', SimVarValueType.String, justTheNumber);
        }));
    }
}
CockpitUserSettings.subs = [];

/**
 * TCAS operating mode setting values.
 */
var TcasOperatingModeSetting;
(function (TcasOperatingModeSetting) {
    TcasOperatingModeSetting["TA_RA"] = "TA_RA";
    TcasOperatingModeSetting["TAOnly"] = "TAOnly";
    TcasOperatingModeSetting["Standby"] = "Standby";
})(TcasOperatingModeSetting || (TcasOperatingModeSetting = {}));
const trafficSettings = [
    {
        name: 'trafficOperatingMode',
        defaultValue: TcasOperatingModeSetting.TAOnly
    },
    {
        name: 'trafficShowOther',
        defaultValue: true
    },
    {
        name: 'trafficAltitudeRelative',
        defaultValue: true
    },
    {
        name: 'trafficShowAbove',
        defaultValue: false
    },
    {
        name: 'trafficShowBelow',
        defaultValue: false
    }
];
/**
 * Utility class for retrieving the traffic user setting manager.
 */
class TrafficUserSettings {
    /**
     * Retrieves a setting manager with traffic user settings.
     * @param bus The event bus.
     * @returns A setting manager with traffic user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, trafficSettings));
    }
}

var VSpeedType;
(function (VSpeedType) {
    VSpeedType["V1"] = "V1";
    VSpeedType["Vr"] = "Vr";
    VSpeedType["V2"] = "V2";
    // Venr = 'Venr',
    // Vapp = 'Vapp',
    VSpeedType["Vref"] = "Vref";
})(VSpeedType || (VSpeedType = {}));
/** Utility class for retrieving the vspeeds user setting manager. */
class VSpeedUserSettings {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        const settingDefs = [];
        for (const vspeed in VSpeedType) {
            settingDefs.push({
                name: `vspeed_value_${vspeed}`,
                defaultValue: 0
            });
        }
        this.manager = new DefaultUserSettingManager(bus, settingDefs);
    }
    /**
     * Get an instance of VSpeedUserSettings.
     * @param bus The event bus.
     * @returns An instance of VSpeedUserSettings.
     */
    static getManager(bus) {
        if (VSpeedUserSettings.INSTANCE === undefined) {
            VSpeedUserSettings.INSTANCE = new VSpeedUserSettings(bus);
        }
        return VSpeedUserSettings.INSTANCE;
    }
    /** @inheritdoc */
    getSettings(type) {
        return {
            value: this.manager.getSetting(`vspeed_value_${type}`)
        };
    }
}

/** Takeoff thrust modes. */
var OptimumRequest;
(function (OptimumRequest) {
    OptimumRequest["OPTIMUM"] = "OPTIMUM";
})(OptimumRequest || (OptimumRequest = {}));
/** Takeoff thrust modes. To be used in the FMC */
var TakeoffThrustMode;
(function (TakeoffThrustMode) {
    TakeoffThrustMode["TO"] = "TO";
    TakeoffThrustMode["TO1"] = "TO 1";
    TakeoffThrustMode["TO2"] = "TO 2";
    TakeoffThrustMode["DTO"] = "D-TO";
    TakeoffThrustMode["DTO1"] = "D-TO 1";
    TakeoffThrustMode["DTO2"] = "D-TO 2";
})(TakeoffThrustMode || (TakeoffThrustMode = {}));
/** Possible takeoff thrust ratings for selection in the EFB. */
var EFBTakeoffThrustMode;
(function (EFBTakeoffThrustMode) {
    EFBTakeoffThrustMode["OPTIMUM"] = "OPTIMUM";
    EFBTakeoffThrustMode["TO"] = "TO";
    EFBTakeoffThrustMode["TO1"] = "TO 1 -10";
    EFBTakeoffThrustMode["TO2"] = "TO 2 -20";
    EFBTakeoffThrustMode["WINDSHEAR"] = "WINDSHEAR";
})(EFBTakeoffThrustMode || (EFBTakeoffThrustMode = {}));
/** Climb thrust modes. */
var ClimbThrustMode;
(function (ClimbThrustMode) {
    ClimbThrustMode["CLB"] = "CLB";
    ClimbThrustMode["CLB1"] = "CLB 1";
    ClimbThrustMode["CLB2"] = "CLB 2";
})(ClimbThrustMode || (ClimbThrustMode = {}));
/** Airborne thrust modes. */
var AirborneThrustMode;
(function (AirborneThrustMode) {
    /** Go-around thrust limit. */
    AirborneThrustMode["GA"] = "GA";
    /** Maximum continuous thrust limit. */
    AirborneThrustMode["CON"] = "CON";
    /** Cruise thrust limit. */
    AirborneThrustMode["CRZ"] = "CRZ";
})(AirborneThrustMode || (AirborneThrustMode = {}));
var GlideslopeStatus;
(function (GlideslopeStatus) {
    GlideslopeStatus[GlideslopeStatus["ON"] = 0] = "ON";
    GlideslopeStatus[GlideslopeStatus["OFF"] = 1] = "OFF";
})(GlideslopeStatus || (GlideslopeStatus = {}));
/** Speed modes. */
var SpeedMode;
(function (SpeedMode) {
    /** Economy speed. */
    SpeedMode["ECON"] = "ECON SPD";
    /** Select speed. Manually entered speed on the CDU or the VNAV speed target is the maneuvering speed for flaps zero. */
    SpeedMode["SEL"] = "SEL SPD";
    /** Long-range cruise speed. */
    SpeedMode["LRC"] = "LRC SPD";
    /** Engine-out long-range cruise speed. */
    SpeedMode["EOLRC"] = "EO LRC";
    /** Engine-out speed. */
    SpeedMode["EO"] = "EO SPD";
    /** Engine-out operations at airline specified engine out company speed. */
    SpeedMode["CO"] = "CO SPD";
    /** Speed is limited by VMO, MMO, flap limit, or buffet limit. */
    SpeedMode["LIM"] = "LIM SPD";
    /** Speed intervention entered on the MCP IAS/MACH indicator. */
    SpeedMode["MCP"] = "MCP SPD";
    /** Required time of arrival speed. */
    SpeedMode["RTA"] = "RTA";
})(SpeedMode || (SpeedMode = {}));
/** Runway conditions, the short list is for the FMC */
var RunwayCondition;
(function (RunwayCondition) {
    /** Dry */
    RunwayCondition["DRY"] = "DRY";
    /** Wet */
    RunwayCondition["WET"] = "WET";
    /** Wet, skid resistant */
    RunwayCondition["WET_SKID_RES"] = "WET SK-R";
})(RunwayCondition || (RunwayCondition = {}));
/** Runway conditions, longer list for the EFB takeoff performance calculation */
var EfbRunwayCondition;
(function (EfbRunwayCondition) {
    /** Dry */
    EfbRunwayCondition["DRY"] = "DRY";
    /** Wet */
    EfbRunwayCondition["WET"] = "WET";
    /** Standing water */
    EfbRunwayCondition["STNDNG_WTR"] = "STNDNG WTR";
    /** Slush */
    EfbRunwayCondition["SLUSH"] = "SLUSH WTR";
    /** Compact snow */
    EfbRunwayCondition["CMPCT_SNOW"] = "CMPCT SNOW";
    /** Dry snow */
    EfbRunwayCondition["DRY_SNOW"] = "DRY SNOW";
    /** Ice */
    EfbRunwayCondition["ICE"] = "Ice";
    /** Breaking action good */
    EfbRunwayCondition["GOOD"] = "GOOD";
    /** Breaking action Medium */
    EfbRunwayCondition["MEDIUM"] = "MEDIUM";
    /** Breaking action Poor */
    EfbRunwayCondition["POOR"] = "POOR";
})(EfbRunwayCondition || (EfbRunwayCondition = {}));
var EFBAntiIceSetting;
(function (EFBAntiIceSetting) {
    /** OFF */
    EFBAntiIceSetting["OFF"] = "OFF";
    /** ENGINE */
    EFBAntiIceSetting["ENGINE"] = "ENGINE";
    /** ENG AUTO */
    EFBAntiIceSetting["ENGINE_AUTO"] = "ENG AUTO";
})(EFBAntiIceSetting || (EFBAntiIceSetting = {}));

// TODO consider getting limits from game vars
// add game var to get slat angles for each handle position => no config needed?
/**
 * Flap Position Computer
 * @deprecated Needs refactored into BoeingFlapSystem
 */
class FlapComputer {
    /**
     * Constructor a new FlapComputer
     * @param bus Event bus
     * @param config Flap Computer configuration
     */
    constructor(bus, config) {
        this.bus = bus;
        this.flapsLeftAngle = ConsumerSubject.create(null, 0);
        this.flapsRightAngle = ConsumerSubject.create(null, 0);
        this.slatsLeftAngle = ConsumerSubject.create(null, 0);
        this.slatsRightAngle = ConsumerSubject.create(null, 0);
        /** total gross weight in lbs */
        this.grossWeight = ConsumerSubject.create(null, 0);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.flapInterpolatedPosition = Subject.create(0);
        this.flapInterpolatedLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapLimitIndex = Subject.create(0);
        this.flapLimitPosition = Subject.create(0);
        this.flapLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapManeuverSpeed = Subject.create(0);
        this.holdingSpeed = Subject.create(0);
        this.needUpdate = true;
        this.flapPositionConfig = [...config.flap_positions].sort((a, b) => a.flapAngle === b.flapAngle ? a.slatAngle - b.slatAngle : a.flapAngle - b.flapAngle);
        this.flapSpeedLimitLookup = new LerpLookupTable(this.flapPositionConfig.filter((c) => isFinite(c.speedLimit)).map((c) => [c.speedLimit, c.label]));
        this.speedData = config.speed_data;
        const pub = this.bus.getPublisher();
        this.flapInterpolatedPosition.sub((pos) => pub.pub('flap_computer_interpolated_position', pos));
        this.flapInterpolatedLimitSpeed.sub((pos) => pub.pub('flap_computer_interpolated_limit_speed', pos));
        this.flapLimitIndex.sub((index) => pub.pub('flap_computer_limit_index', index));
        this.flapLimitPosition.sub((pos) => pub.pub('flap_computer_limit_position', pos));
        this.flapLimitSpeed.sub((speed) => pub.pub('flap_computer_limit_speed', speed));
        this.flapManeuverSpeed.sub((speed) => pub.pub('flap_computer_maneuver_speed', speed));
        this.holdingSpeed.sub((speed) => pub.pub('flap_computer_holding_speed', speed));
        this.listenToEvents();
    }
    /** Update the flap setting from the flap and slat angles */
    updateFlapPosition() {
        if (!this.needUpdate) {
            return;
        }
        this.needUpdate = false;
        // we consider the highest out of the two sides
        const actualFlapAngle = Math.max(this.flapsLeftAngle.get(), this.flapsRightAngle.get());
        const actualSlatAngle = Math.max(this.slatsLeftAngle.get(), this.slatsRightAngle.get());
        // find the flap position used for speed limit calculation (increments just after passing each position)
        let flapLimitIndex = this.flapPositionConfig.findIndex((p) => actualFlapAngle <= p.flapAngle + FlapComputer.ANGLE_TOLERANCE);
        const firstFlapPos = this.flapPositionConfig[flapLimitIndex];
        for (; flapLimitIndex < this.flapPositionConfig.length - 1; flapLimitIndex++) {
            const nextLimitPos = this.flapPositionConfig[flapLimitIndex + 1];
            if (nextLimitPos.flapAngle !== firstFlapPos.flapAngle) {
                break;
            }
            const limitPos = this.flapPositionConfig[flapLimitIndex];
            if (actualSlatAngle <= limitPos.slatAngle + FlapComputer.ANGLE_TOLERANCE) {
                break;
            }
        }
        const flapLimitPosition = this.flapPositionConfig[flapLimitIndex];
        this.flapLimitIndex.set(flapLimitIndex);
        this.flapLimitPosition.set(flapLimitPosition.label);
        this.flapLimitSpeed.set(isFinite(flapLimitPosition.speedLimit) ? flapLimitPosition.speedLimit : -1);
        this.flapManeuverSpeed.set(this.speedData.getFlapManeuverSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        this.holdingSpeed.set(this.speedData.getHoldingSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        // interpolate a position for display on the EICAS
        let interpolatedLabel = 0;
        // if we're clean, no need for interpolation
        if (flapLimitIndex > 0) {
            // choose the next index (lower flap position/angle)
            const nextLowerFlapPosition = this.flapPositionConfig[flapLimitIndex - 1];
            let k;
            if ((flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle) < FlapComputer.ANGLE_TOLERANCE) {
                // flap position doesn't change... interpolate slat angle
                k = (flapLimitPosition.slatAngle - actualSlatAngle) / (flapLimitPosition.slatAngle - nextLowerFlapPosition.slatAngle);
            }
            else {
                k = (flapLimitPosition.flapAngle - actualFlapAngle) / (flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle);
            }
            interpolatedLabel = MathUtils.clamp(Avionics.Utils.lerpAngle(flapLimitPosition.label, nextLowerFlapPosition.label, k), nextLowerFlapPosition.label, flapLimitPosition.label);
        }
        this.flapInterpolatedPosition.set(interpolatedLabel);
        if (interpolatedLabel > 0) {
            this.flapInterpolatedLimitSpeed.set(this.flapSpeedLimitLookup.get(interpolatedLabel));
        }
        else {
            this.flapInterpolatedLimitSpeed.set(-1);
        }
    }
    /** Setup event listeners */
    listenToEvents() {
        const sub = this.bus.getSubscriber();
        this.flapsLeftAngle.setConsumer(sub.on('flaps_left_angle').withPrecision(2));
        this.flapsRightAngle.setConsumer(sub.on('flaps_right_angle').withPrecision(2));
        this.slatsLeftAngle.setConsumer(sub.on('slats_left_angle').withPrecision(2));
        this.slatsRightAngle.setConsumer(sub.on('slats_right_angle').withPrecision(2));
        this.grossWeight.setConsumer(sub.on('total_weight').withPrecision(-3));
        this.pressureAlt.setConsumer(sub.on('pressure_alt').withPrecision(-3));
        sub.on('realTime').atFrequency(5).handle(this.updateFlapPosition.bind(this));
        MappedSubject.create(() => this.needUpdate = true, this.flapsLeftAngle, this.flapsRightAngle, this.slatsLeftAngle, this.slatsRightAngle, this.grossWeight, this.pressureAlt);
    }
}
FlapComputer.ANGLE_TOLERANCE = 0.25;

/**
 * Standard Boeing 787-10 names for backplane instruments and publishers.
 */
var InstrumentBackplaneNames;
(function (InstrumentBackplaneNames) {
    InstrumentBackplaneNames["Adc"] = "Adc";
    InstrumentBackplaneNames["Ahrs"] = "Ahrs";
    InstrumentBackplaneNames["Ai"] = "AI";
    InstrumentBackplaneNames["Alert"] = "Alert";
    InstrumentBackplaneNames["Ambient"] = "Ambient";
    InstrumentBackplaneNames["AntiIce"] = "AntiIce";
    InstrumentBackplaneNames["Autopilot"] = "Autopilot";
    InstrumentBackplaneNames["AutopilotRadioNav"] = "AutopilotRadioNav";
    InstrumentBackplaneNames["B78Apu"] = "B78Apu";
    InstrumentBackplaneNames["B78Door"] = "B78Door";
    InstrumentBackplaneNames["B78Gear"] = "B78Gear";
    InstrumentBackplaneNames["B78Hydraulics"] = "B78Hydraulics";
    InstrumentBackplaneNames["Base"] = "Base";
    InstrumentBackplaneNames["BoeingAutopilot"] = "BoeingAutopilot";
    InstrumentBackplaneNames["Brakes"] = "Brakes";
    InstrumentBackplaneNames["Clock"] = "Clock";
    InstrumentBackplaneNames["ControlSurfaces"] = "ControlSurfaces";
    InstrumentBackplaneNames["CockpitVars"] = "CockpitVars";
    InstrumentBackplaneNames["Eis"] = "Eis";
    InstrumentBackplaneNames["Electrical"] = "Electrical";
    InstrumentBackplaneNames["Engine"] = "Engine";
    InstrumentBackplaneNames["Fadec"] = "Fadec";
    InstrumentBackplaneNames["FuelSystem"] = "FuelSystem";
    InstrumentBackplaneNames["FuelTotalizer"] = "FuelTotalizer";
    InstrumentBackplaneNames["FmsOperatingPhase"] = "FmsOperatingPhase";
    InstrumentBackplaneNames["Gnss"] = "Gnss";
    InstrumentBackplaneNames["HEvents"] = "HEvents";
    InstrumentBackplaneNames["Hydraulics"] = "Hydraulics";
    InstrumentBackplaneNames["LNav"] = "LNav";
    InstrumentBackplaneNames["LNavData"] = "LNavData";
    InstrumentBackplaneNames["Minimums"] = "Minimums";
    InstrumentBackplaneNames["NavCom"] = "NavCom";
    InstrumentBackplaneNames["NavEvents"] = "NavEvents";
    InstrumentBackplaneNames["NavProc"] = "NavProc";
    InstrumentBackplaneNames["Pressurization"] = "Pressurization";
    InstrumentBackplaneNames["SpeedLimit"] = "SpeedLimit";
    InstrumentBackplaneNames["Sound"] = "Sound";
    InstrumentBackplaneNames["Timer"] = "Timer";
    InstrumentBackplaneNames["Traffic"] = "Traffic";
    InstrumentBackplaneNames["VNav"] = "VNav";
    InstrumentBackplaneNames["BoeingVNav"] = "BoeingVNav";
    InstrumentBackplaneNames["WeightFuel"] = "WeightFuel";
    InstrumentBackplaneNames["Xpdr"] = "Xpdr";
    InstrumentBackplaneNames["WeightAndBalance"] = "WeightAndBalance";
    InstrumentBackplaneNames["Units"] = "Units";
})(InstrumentBackplaneNames || (InstrumentBackplaneNames = {}));

/**
 * A default implementation of {@link MarkerBeaconDataProvider}.
 */
class MarkerBeaconDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param markerBeaconIndex The index of the AoA computer that is the source of this provider's data.
     */
    constructor(bus, markerBeaconIndex) {
        this.bus = bus;
        this._markerBeaconState = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.markerBeaconState = this._markerBeaconState;
        this._isDataFailed = Subject.create(false);
        /** @inheritdoc */
        this.isDataFailed = this._isDataFailed;
        this.markerSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.markerBeaconIndex = SubscribableUtils.toSubscribable(markerBeaconIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultMarkerBeaconDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        this.markerBeaconIndexSub = this.markerBeaconIndex.sub(index => {
            this._markerBeaconState.setConsumer(sub.on(`marker_mkr_bcn_state_${index}`));
            this.markerSystemState.setConsumer(sub.on(`marker_state_${index}`));
        }, true);
        if (paused) {
            this.pause();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultMarkerBeaconDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        this._markerBeaconState.resume();
        this.markerSystemState.resume();
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultMarkerBeaconDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this._markerBeaconState.pause();
        this.markerSystemState.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this._markerBeaconState.destroy();
        this.markerSystemState.destroy();
        (_a = this.markerBeaconIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/**
 * A Garmin marker beacon receiver system.
 */
class MarkerBeaconSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a marker beacon system.
     * @param index The index of the marker beacon system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `marker_state_${index}`);
        const radioAltTopic = `marker_mkr_bcn_state_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's marker beacon state data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `marker_mkr_bcn_state_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.beaconStateSub = this.bus.getSubscriber().on('marker_beacon_state').handle(val => {
            this.publisher.pub(topic, val);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.beaconStateSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.beaconStateSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

const SHORT_LLA_FORMAT_REGEX = /^([NS])(\d{2})([WE])(\d{3})$/;
const LONG_LLA_FORMAT_REGEX = /^([NS])(\d{4}(?:\.\d)?)([WE])(\d{5}(?:\.\d)?)$/;
/**
 * Utilities for parsing coordinates in the WT21 supported formats
 */
class BoeingCoordinatesUtils {
    /**
     * Parses a string according to the LAT LONG format
     *
     * @param str             the string to parse
     * @param acceptShortForm whether to accept the short (XYYZUU/XYYUUZ) formats
     *
     * @returns a {@link LatLongInterface} object if a valid LL definition and `null` otherwise
     */
    static parseLatLong(str, acceptShortForm = true) {
        if (acceptShortForm) {
            const shortMatch = SHORT_LLA_FORMAT_REGEX.exec(str);
            if (shortMatch) {
                const latDir = shortMatch[1];
                const latNum = shortMatch[2];
                const lonDir = shortMatch[3];
                const lonNum = shortMatch[4];
                const parsedLat = this.parseLatitude(latDir, latNum);
                const parsedLon = this.parseLongitude(lonDir, lonNum);
                if (parsedLat === null || parsedLon === null) {
                    return null;
                }
                return new GeoPoint(parsedLat, parsedLon);
            }
        }
        const fullMatch = LONG_LLA_FORMAT_REGEX.exec(str);
        if (!fullMatch) {
            return null;
        }
        const latDir = fullMatch[1];
        const latNum = fullMatch[2];
        const lonDir = fullMatch[3];
        const lonNum = fullMatch[4];
        // if either has a decimal, both must
        if (latNum.includes('.') !== lonNum.includes('.')) {
            return null;
        }
        const parsedLat = this.parseLatitude(latDir, latNum);
        const parsedLon = this.parseLongitude(lonDir, lonNum);
        if (parsedLat === null || parsedLon === null) {
            return null;
        }
        return new GeoPoint(parsedLat, parsedLon);
    }
    /**
     * Parses a latitude string
     *
     * @param dirStr the N or S string part
     * @param numStr the numerical string part
     *
     * @returns the latitude in degrees
     */
    static parseLatitude(dirStr, numStr) {
        let lat;
        const splitLatNum = numStr.split('.');
        const latLeft = splitLatNum[0];
        const latRight = splitLatNum[1];
        // Parse latitude degrees + minutes
        if (latLeft.length > 2) {
            const deg = parseInt(latLeft.substring(0, 2));
            const min = parseInt(latLeft.substring(2));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lat = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lat = parseInt(latLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (latRight) {
            const secs = parseFloat(`0.${latRight}`);
            const add = secs / 60;
            lat += add;
        }
        // If direction is S, negate latitude
        if (dirStr === 'S') {
            lat *= -1;
        }
        if (Math.abs(lat) > 90) {
            return null;
        }
        return lat;
    }
    /**
     * Parses a longitude string
     *
     * @param dirStr the W or E string part
     * @param numStr the numerical string part
     *
     * @returns the longitude in degrees
     */
    static parseLongitude(dirStr, numStr) {
        let lon;
        const splitLonNum = numStr.split('.');
        const lonLeft = splitLonNum[0];
        const lonRight = splitLonNum[1];
        // Parse longitude degrees + minutes
        if (lonLeft.length > 3) {
            const deg = parseInt(lonLeft.substring(0, 3));
            const min = parseInt(lonLeft.substring(3));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lon = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lon = parseInt(lonLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (lonRight) {
            const secs = parseFloat(`0.${lonRight}`);
            const add = secs / 60;
            lon += add;
        }
        // If direction is W, negate longitude
        if (dirStr === 'W') {
            lon *= -1;
        }
        if (Math.abs(lon) > 180) {
            return null;
        }
        return lon;
    }
}

/** Example match would be: `DEN270/22.5` */
const PBD_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
/** Example match would be: `DEN090/DVV180` */
const PBPB_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\w+)(\d{3}(?:\.\d)?)(?:\/(\w+))?$/;
const ATO_REGEX = /^(\w+)\/([+-]?\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
// This should technically be only TF, but that doesn't make much sense and seems like a mistake
const ATO_VALID_PREVIOUS_LEG_TYPES = [LegType.CF, LegType.DF, LegType.IF, LegType.TF, LegType.RF];
const ATO_VALID_NEXT_LEG_TYPES = [LegType.IF, LegType.TF];
/**
 * Error that can occur when creating an ATO waypoint
 */
var AlongTrackOffsetError;
(function (AlongTrackOffsetError) {
    AlongTrackOffsetError[AlongTrackOffsetError["NotAvailable"] = 0] = "NotAvailable";
    AlongTrackOffsetError[AlongTrackOffsetError["DistanceTooLarge"] = 1] = "DistanceTooLarge";
})(AlongTrackOffsetError || (AlongTrackOffsetError = {}));
/**
 * Utilities for Boeing pilot defined waypoints
 */
class BoeingPilotWaypointUtils {
    /**
     * Returns whether the limit number of pilot defined waypoints is reached
     *
     * @param facilities the existing user facilities
     *
     * @returns a boolean
     */
    static isLimitReached(facilities) {
        return facilities.length >= 50; // TODO 50 for RTE 1, 50 for RTE 2
    }
    /**
     * Returns the next available auto-generated name, given existing user facilities and an ident
     *
     * @param facilities the existing user facilities
     * @param ident      the ident of the facility
     *
     * @returns a string to be used as an ident for a user facility
     */
    static nextAutoGeneratedName(facilities, ident) {
        let suffix = 1;
        for (const facility of facilities) {
            const facIdent = ICAO.getIdent(facility.icao);
            if (facIdent.match(`${ident.substring(0, 3)}\\d\\d`)) {
                suffix++;
            }
        }
        return `${ident.substring(0, 3)}${suffix.toString().padStart(2, '0')}`;
    }
    /**
     * Returns the name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(0).padStart(2, '0');
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(0).padStart(3, '0');
        return `${latitudeSign}${latitudeStr}${longitudeSign}${longitudeStr}`;
    }
    /**
     * Returns the internal name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongInternalIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(3);
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(3);
        return `${latitudeSign}${latitudeStr}|${longitudeSign}${longitudeStr}`;
    }
    /**
     * Converts a scratchpad entry to a {@link UserFacility} if applicable
     *
     * @param fms                  the {@link BoeingFms} instance
     * @param selectWptFromIdent   the function called to select a facility
     * @param scratchpadContents   the scratchpad contents
     * @param targetGlobalLegIndex the target global leg index, if applicable
     *
     * @returns a user facility, or null if none is parsed
     */
    static async createFromScratchpadEntry(fms, selectWptFromIdent, scratchpadContents, targetGlobalLegIndex) {
        var _a, _b, _c, _d;
        const pbdMatch = BoeingPilotWaypointUtils.parsePlaceBearingDistance(scratchpadContents);
        if (pbdMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facility = await selectWptFromIdent(pbdMatch.placeIdent, fms.ppos);
            if (facility) {
                const ident = (_a = pbdMatch.newIdent) !== null && _a !== void 0 ? _a : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facility.icao));
                const usrFacility = UserFacilityUtils.createFromRadialDistance(`U      ${ident}`, facility, pbdMatch.bearing, pbdMatch.distance);
                return [usrFacility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const pbpbMatch = BoeingPilotWaypointUtils.parsePlaceBearingPlaceBearing(scratchpadContents);
        if (pbpbMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facilityA = await selectWptFromIdent(pbpbMatch.placeAIdent, fms.ppos);
            const facilityB = await selectWptFromIdent(pbpbMatch.placeBIdent, fms.ppos);
            if (facilityA && facilityB) {
                const ident = (_b = pbpbMatch.newIdent) !== null && _b !== void 0 ? _b : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facilityA.icao));
                const facility = UserFacilityUtils.createFromRadialRadial(`U      ${ident}`, facilityA, pbpbMatch.bearingA, facilityB, pbpbMatch.bearingB);
                if (!facility) {
                    return Promise.reject('NO INTERSECTION');
                }
                return [facility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const atoMatch = BoeingPilotWaypointUtils.parseAlongTrackOffset(scratchpadContents);
        if (atoMatch) {
            if (targetGlobalLegIndex === undefined) {
                throw new Error('Along-track offset can only be created by createFromScratchpadEntry is a target global leg index is specified');
            }
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const plan = fms.getPlanForFmcRender();
            const lnavActiveLegIndex = SimVar.GetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number);
            const lnavActiveLegDistanceAlong = SimVar.GetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM);
            const result = await BoeingPilotWaypointUtils.createAlongTrackOffset(fms.facLoader, plan, targetGlobalLegIndex, lnavActiveLegIndex, lnavActiveLegDistanceAlong, atoMatch.distance);
            if (!Array.isArray(result)) {
                if (result === AlongTrackOffsetError.DistanceTooLarge) {
                    return Promise.reject('DISTANCE TOO LARGE');
                }
                else {
                    return Promise.reject('ALONG TRK WPT N/A');
                }
            }
            const [usrPos, insertAfter] = result;
            const leg = plan.getLeg(targetGlobalLegIndex);
            const ident = (_c = atoMatch.newIdent) !== null && _c !== void 0 ? _c : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, (_d = leg.name) !== null && _d !== void 0 ? _d : 'USR');
            return [UserFacilityUtils.createFromLatLon(`U      ${ident}`, usrPos.lat, usrPos.lon), insertAfter];
        }
        const coordinatesMatch = BoeingCoordinatesUtils.parseLatLong(scratchpadContents);
        if (coordinatesMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
            // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
            // needed - in BoeingFmsUtils.buildBoeingLegName, we extract the values to reconstruct the short name
            const ident = BoeingPilotWaypointUtils.latLongInternalIdent(coordinatesMatch);
            return [UserFacilityUtils.createFromLatLon(`ULL    ${ident}`, coordinatesMatch.lat, coordinatesMatch.lon), false];
        }
        return null;
    }
    /**
     * Parses a string according to the PB/D format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingDistanceInput} object if a valid PBD definition and `null` otherwise
     */
    static parsePlaceBearingDistance(str) {
        const match = str.match(PBD_REGEX);
        if (!match) {
            return null;
        }
        const bearing = parseFloat(match[2]);
        if (bearing < 0 || bearing > 360) {
            return null;
        }
        return {
            placeIdent: match[1],
            bearing,
            distance: parseFloat(match[3]),
            newIdent: match[4],
        };
    }
    /**
     * Parses a string according to the PB/PB format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingPlaceBearingInput} object if a valid PBPB definition and `null` otherwise
     */
    static parsePlaceBearingPlaceBearing(str) {
        const match = str.match(PBPB_REGEX);
        if (!match) {
            return null;
        }
        const bearingA = parseFloat(match[2]);
        const bearingB = parseFloat(match[4]);
        if (bearingA < 0 || bearingA > 360 || bearingA < 0 || bearingB > 360) {
            return null;
        }
        return {
            placeAIdent: match[1],
            bearingA,
            placeBIdent: match[3],
            bearingB,
            newIdent: match[5],
        };
    }
    /**
     * Parses a string according to the along-track offset format
     *
     * @param str the string to parse
     *
     * @returns a {@link AlongTrackOffsetInput} object if a valid ATO definition and `null` otherwise
     */
    static parseAlongTrackOffset(str) {
        const match = str.match(ATO_REGEX);
        if (!match) {
            return null;
        }
        return {
            placeIdent: match[1],
            distance: parseFloat(match[2]),
            newIdent: match[3],
        };
    }
    /**
     * Creates an along-track offset position with input data
     *
     * @param facLoader                  the facility loader
     * @param plan                       the flight plan the ATO is being created from
     * @param globalLegIndex             the global leg index in the plan the ATO is being created from (WT21: LSK position)
     * @param lnavActiveLegIndex         the active lnav leg index (not nominal)
     * @param lnavDistanceAlongActiveLeg the distance flown along the active lnav leg
     * @param distance                   the distance input
     *
     * @returns a {@link GeoPoint}
     */
    static async createAlongTrackOffset(facLoader, plan, globalLegIndex, lnavActiveLegIndex, lnavDistanceAlongActiveLeg, distance) {
        const planLeg = plan.tryGetLeg(globalLegIndex);
        if (planLeg) {
            const distanceNegative = distance < 0;
            // Check for the previous leg type being valid if the distance is negative
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    if (!ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType)) {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
                else {
                    return AlongTrackOffsetError.NotAvailable;
                }
            }
            let fixIcao1 = undefined;
            let fixIcao2 = undefined;
            let facility1 = undefined;
            let facility2 = undefined;
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    const legType = planLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType) && ATO_VALID_NEXT_LEG_TYPES.includes(legType)) {
                        let maxDistance = planLeg.calculated ? UnitType.NMILE.convertFrom(planLeg.calculated.distance, UnitType.METER) : -1;
                        if (lnavActiveLegIndex === globalLegIndex) {
                            maxDistance -= lnavDistanceAlongActiveLeg;
                            maxDistance = Math.max(0, maxDistance);
                        }
                        if (Math.abs(distance) < maxDistance) {
                            fixIcao1 = previousPlanLeg.leg.fixIcao;
                            fixIcao2 = planLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                }
            }
            else {
                const nextPlanLeg = plan.tryGetLeg(globalLegIndex + 1);
                if (nextPlanLeg) {
                    const legType = planLeg.leg.type;
                    const nextLegType = nextPlanLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(legType) && ATO_VALID_NEXT_LEG_TYPES.includes(nextLegType)) {
                        const maxDistance = nextPlanLeg.calculated ? UnitType.NMILE.convertFrom(nextPlanLeg.calculated.distance, UnitType.METER) : -1;
                        let minDistance = 0;
                        if (lnavActiveLegIndex === globalLegIndex + 1) {
                            minDistance = lnavDistanceAlongActiveLeg;
                        }
                        if (distance > minDistance && distance < maxDistance) {
                            fixIcao1 = planLeg.leg.fixIcao;
                            fixIcao2 = nextPlanLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                    else {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
            }
            if (fixIcao1 && fixIcao1 !== ICAO.emptyIcao && fixIcao2 && fixIcao2 !== ICAO.emptyIcao) {
                facility1 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao1), fixIcao1);
                facility2 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao2), fixIcao2);
                if (facility1 && facility2) {
                    const circle = GeoCircle.createGreatCircle(facility1, facility2);
                    const offsetOut = new Float64Array(3);
                    circle.offsetDistanceAlong(distanceNegative ? facility2 : facility1, UnitType.GA_RADIAN.convertFrom(distance, UnitType.NMILE), offsetOut);
                    const geoPoint = new GeoPoint(0, 0);
                    geoPoint.setFromCartesian(offsetOut);
                    return [geoPoint, !distanceNegative];
                }
            }
        }
        return AlongTrackOffsetError.NotAvailable;
    }
}

/**
 * Utility Methods for the Boeing FMS.
 */
class BoeingFmsUtils {
    /**
     * Gets the active segment in the Lateral Flight Plan.
     * @param plan The Lateral Flight Plan.
     * @returns The Active Flight Plan Segment or undefined.
     */
    static getActiveSegment(plan) {
        if (plan.length > 0 && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            return plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
        }
        return undefined;
    }
    /**
     * Checks whether a leg exists in a segment with the specified ICAO and, if so, returns the leg index of that leg.
     * @param segment The segment to check for the icao.
     * @param icao The ICAO to check for in the segment.
     * @returns The segment leg index of the leg with the matching icao, or -1.
     */
    static findIcaoInSegment(segment, icao) {
        if (icao !== undefined) {
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (leg !== undefined && leg.leg !== undefined && leg.leg.fixIcao && leg.leg.fixIcao === icao) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        return FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: isOriginRunway
                ? oneWayRunway.elevation
                : oneWayRunway.elevation + UnitType.METER.convertFrom(50, UnitType.FOOT) // Arrival runway leg altitude should be 50 feet above threshold
        });
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param facRepo is a facility repository in which to store the created faf leg facility
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param finalLegVpa is the vertical path angle selected for the final approach, or undefined if not applicable.
     * @returns an approach procedure.
     */
    static buildVisualApproach(facRepo, airport, runway, finalLegDistance, finalLegVpa) {
        const runwayVec = GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, BoeingFmsUtils.vec3Cache[0]);
        const approachPath = BoeingFmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
        const runwayCode = RunwayUtils.getRunwayCode(runway.direction);
        const runwayLetter = RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
        const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-finalLegDistance, UnitType.GA_RADIAN), BoeingFmsUtils.geoPointCache[0]);
        const runwayIdent = RunwayUtils.getRunwayNameString(runway.direction, runway.runwayDesignator);
        const finalLegIdent = `${finalLegVpa !== undefined ? 'FA' : 'RX'}${runwayIdent}`;
        const icao = `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`;
        // Add facility to facRepo
        const fafFacility = UserFacilityUtils.createFromLatLon(icao, fafLatLon.lat, fafLatLon.lon);
        facRepo.add(fafFacility);
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: icao,
            course: MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + (Math.tan(UnitType.DEGREE.convertTo(finalLegVpa !== null && finalLegVpa !== void 0 ? finalLegVpa : 3, UnitType.RADIAN)) * UnitType.NMILE.convertTo(finalLegDistance, UnitType.METER)),
        });
        const runwayLeg = BoeingFmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.verticalAngle = finalLegVpa !== undefined ? 360 - Math.abs(finalLegVpa) : 0;
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        return {
            name: `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: [],
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approachType The approach type.
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a tunable localizer.
     * @param approachType The approach type.
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets the procedure index and transition index from procedure details of the lateral plan based on segment type.
     * @param segmentType The segment type.
     * @param lateralPlan The lateral flight plan.
     * @returns an array of procedureIndex, transitionIndex.
     */
    static getProcedureIndexAndTransitionIndexFromSegmentType(segmentType, lateralPlan) {
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return [lateralPlan.procedureDetails.departureIndex, lateralPlan.procedureDetails.departureTransitionIndex];
            case FlightPlanSegmentType.Arrival:
                return [lateralPlan.procedureDetails.arrivalIndex, lateralPlan.procedureDetails.arrivalTransitionIndex];
            case FlightPlanSegmentType.Approach:
                return [lateralPlan.procedureDetails.approachIndex, lateralPlan.procedureDetails.approachTransitionIndex];
        }
        return [-1, -1];
    }
    /**
     * Combiner method to get a procedure name as a string for the FPLN Page.
     * @param segmentType The segment type.
     * @param facility The facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The transition index.
     * @returns the name as a string.
     */
    static getProcedureNameAsString(segmentType, facility, procedureIndex, transitionIndex) {
        if (facility === undefined) {
            return 'NO FACILITY';
        }
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return this.getDepartureNameAsString(facility, procedureIndex);
            case FlightPlanSegmentType.Arrival:
                if (transitionIndex !== undefined) {
                    return this.getArrivalNameAsString(facility, procedureIndex, transitionIndex);
                }
                break;
            case FlightPlanSegmentType.Approach:
                if (procedureIndex === -1 && transitionIndex === -1) {
                    // must be visual
                    return 'VISUAL';
                }
                else if (transitionIndex !== undefined) {
                    return this.getApproachNameAsString(facility, procedureIndex, transitionIndex);
                }
        }
        return 'PROC NAME ERROR';
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @returns The name of the departure procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getDepartureNameAsString(facility, procedureIndex) {
        // let name = '';
        const departure = facility.departures[procedureIndex];
        // if (runway) {
        //   name += `RW${runway.designation}.`;
        // }
        // const transition = departure.enRouteTransitions[transitionIndex];
        // if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        // } else if (departure.commonLegs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        // } else {
        //   name += `${departure.name}`;
        // }
        return `${departure.name}`;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param facility The airport to which the arrival belongs.
     * @param procedureIndex An arrival procedure index.
     * @param transitionIndex The index of the arrival enroute transition.
     * @returns The name of the arrival procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getArrivalNameAsString(facility, procedureIndex, transitionIndex) {
        const arrival = facility.arrivals[procedureIndex];
        // TODO We may need to add back the transition name
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            return `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            return `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        // else if (arrival.commonLegs.length > 0) {
        //   name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival?.name}`;
        // }
        // if (runway) {
        //   name += `.RW${runway.designation}`;
        // }
        // return `${arrival?.name}`;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @param transitionIndex The transition index.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc, transitionIndex) {
        let type;
        // let subtype: string | undefined;
        // let rnavType: string | undefined;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNV';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'BCS';
                break; // no idea if this is the real format
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        let transition = undefined;
        if (transitionIndex > -1 && proc.transitions.length > 0) {
            transition = proc.transitions[transitionIndex].name;
        }
        return {
            type: type,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            transition: transition
        };
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    /**
     * Utility method that gets an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param facility The Facility.
     * @param procedureIndex The approach index.
     * @param transitionIndex The index of the approach transition.
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(facility, procedureIndex, transitionIndex) {
        const approach = facility.approaches[procedureIndex];
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, transitionIndex);
        let name = parts.transition ? parts.transition + '.' + parts.type : parts.type;
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        // parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Get the name of an approach in the format used on the EFIS
     * @param facilityOrApproach Either an airport facility (if combined with a procedure as the second arg) or an approach procedure
     * @param procedureIndex Index of the desired approach if the first arg is an airport facility
     * @returns formatted approach name ready for EFIS display
     */
    static getApproachNameAsEfisString(facilityOrApproach, procedureIndex) {
        var _a, _b;
        const approach = 'airportPrivateType' in facilityOrApproach ? facilityOrApproach.approaches[procedureIndex !== null && procedureIndex !== void 0 ? procedureIndex : -1] : facilityOrApproach;
        if (!approach) {
            return '???';
        }
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, -1);
        if (parts.runway) {
            return `${parts.type}${(_a = parts.suffix) !== null && _a !== void 0 ? _a : ''} ${parts.runway}`;
        }
        else {
            return `${parts.type}${(_b = parts.suffix) !== null && _b !== void 0 ? _b : ''}`;
        }
    }
    /**
     * Checks whether an approach has a primary NAV frequency based on its type. Only approaches of the following types
     * have primary NAV frequencies: ILS, LOC (BC), LDA, SDF, VOR(DME).
     * @param approach The approach to check.
     * @returns Whether the specified approach has a primary NAV frequency based on its type.
     */
    static approachHasNavFrequency(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return undefined;
        }
        for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return -1;
        }
        let index = plan.getLegIndexFromLeg(leg);
        for (leg of plan.legs(true, index)) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return index;
            }
            index--;
        }
        return -1;
    }
    /**
     * Gets an altitude for display with padding, Flight Level Handling
     * @param altitudeMeters the altitude IN METERS to evaluate
     * @param transitionAltitudeFeet the transition altitude IN FEET to evaluate
     * @returns A display string
     */
    static parseAltitudeForDisplay(altitudeMeters, transitionAltitudeFeet) {
        const altitudeFeet = Math.round(UnitType.METER.convertTo(altitudeMeters, UnitType.FOOT));
        transitionAltitudeFeet = Math.round(transitionAltitudeFeet);
        if (altitudeFeet >= transitionAltitudeFeet) {
            return 'FL' + (altitudeFeet / 100).toFixed(0).padStart(3, '0');
        }
        return altitudeFeet.toFixed(0).padStart(5, ' ');
    }
    /**
     * Checks if leg type is an "arc" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isArcLeg(legType) {
        return arcLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "heading to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return headingToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "hold at" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "hold at" leg type.
     */
    static isHoldAtLeg(legType) {
        return holdAtLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is an "to altitude" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return altitudeLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "course to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "course to" leg type.
     */
    static isCourseToLeg(legType) {
        return courseToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "discontinuity" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "discontinuity" leg type.
     */
    static isDiscontinuityLeg(legType) {
        return discontinuityLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "vectors" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "vectors" leg type.
     */
    static isVectorsLeg(legType) {
        return vectorsTypes.includes(legType);
    }
    /**
     * Gets the direct to magnetic course from the leg vectors.
     * @param leg The Leg Definition
     * @returns the magnetic course.
     */
    static getDirectToCourse(leg) {
        let course = 360;
        if (leg.leg.type === LegType.DF && leg.calculated !== undefined) {
            const vector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
            if (vector !== undefined) {
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                // If it is a great circle, then it's basically the "straight" part of the path, so we want to get the bearing at the start,
                // otherwise it's the turn, so we want the bearing from the end of the turn.
                const point = circle.isGreatCircle()
                    ? BoeingFmsUtils.geoPointCache[0].set(vector.startLat, vector.startLon)
                    : BoeingFmsUtils.geoPointCache[0].set(vector.endLat, vector.endLon);
                course = circle.bearingAt(point, Math.PI);
                course = MagVar.trueToMagnetic(course, MagVar.get(point));
            }
        }
        else if (leg.leg.type === LegType.CF && leg.calculated !== undefined) {
            course = leg.leg.course;
        }
        return course;
    }
    /**
     * Checks for an airway at a leg and returns the airway or undefined
     * @param facLoader The facility loader.
     * @param icao The icao of the entry to check.
     * @param airwayName The airway to search for.
     * @returns The airway object or undefined
     */
    static async isAirwayAtLeg(facLoader, icao, airwayName) {
        const facility = await facLoader.getFacility(FacilityType.Intersection, icao);
        if (facility) {
            const matchedRoute = facility.routes.find((r) => r.name === airwayName);
            if (matchedRoute) {
                const airway = await facLoader.getAirway(matchedRoute.name, matchedRoute.type, icao);
                return airway;
            }
        }
        return undefined;
    }
    /**
     * Looks for an airway with name {@link airwayBName} crossing one of the fixes of airway {@link airwayA}
     *
     * @param facLoader the facility loader
     * @param airwayA the airway to look for intersections in
     * @param airwayBName the name of the second airway
     *
     * @returns a tuple of the found airway and the fix ICAO where the two airways cross
     */
    static async findAirwayCrossingAirway(facLoader, airwayA, airwayBName) {
        for (const fac of airwayA.waypoints) {
            const airwayBFacRoute = fac.routes.find((it) => it.name === airwayBName);
            if (airwayBFacRoute) {
                const airway = await facLoader.getAirway(airwayBFacRoute.name, airwayBFacRoute.type, fac.icao);
                return [airway, fac.icao];
            }
        }
    }
    /**
     * Checks for an airway exit at a given icao.
     * @param airway The Airway Object.
     * @param icao The icao of the entry to check.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static isLegValidAirwayExit(airway, icao) {
        return airway.waypoints.find((w) => w.icao === icao);
    }
    /**
     * Checks for an airway exit matching an input ident
     * @param airway The AirwayObject.
     * @param ident The Ident to search for.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static matchIdentToAirway(airway, ident) {
        return airway.waypoints.find((w) => ICAO.getIdent(w.icao) === ident);
    }
    /**
     * Checks whether a leg should appear on the Direct To Page based on leg type.
     * @param leg The FlightPlanLeg to evaluate.
     * @returns whether or not the leg should appear on the Direct To page.
     */
    static canLegBeSelectedOnDirectPage(leg) {
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
            case LegType.PI:
            case LegType.CI:
            case LegType.VI:
            case LegType.CR:
            case LegType.VR:
                return false;
            default:
                return true;
        }
    }
    /**
     * Checks whether a leg with a given type being active should cause LNAV to be auto unsuspended
     * @param legType the leg type
     * @returns a boolean
     */
    static canLegBeAutoUnsuspended(legType) {
        switch (legType) {
            case LegType.HM:
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildBoeingLegName(leg) {
        // Name for PPOS hold leg
        if (leg.fixIcao === ICAO.emptyIcao && BoeingFmsUtils.isHoldAtLeg(leg.type)) {
            return 'PPOS';
        }
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `(${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0).padEnd(5, ' ')})`;
            case LegType.FM:
            case LegType.VM:
                return 'VECTORS';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
            case LegType.PI:
                return '(INTC)';
            default:
                if (leg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(leg.fixIcao) === FacilityType.USR) {
                    const regionStr = ICAO.getRegionCode(leg.fixIcao);
                    // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
                    // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
                    // needed - here, we extract the values to reconstruct the short name
                    if (regionStr === 'LL') {
                        const ident = ICAO.getIdent(leg.fixIcao);
                        const [latStr, longStr] = ident.split('|');
                        const lat = parseFloat(latStr.replace('N', '').replace('S', '-'));
                        const long = parseFloat(longStr.replace('E', '').replace('W', '-'));
                        return BoeingPilotWaypointUtils.latLongIdent(BoeingFmsUtils.geoPointCache[1].set(lat, long));
                    }
                }
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.directToData.segmentIndex = i;
                    plan.directToData.segmentLegIndex = j - 1;
                    return;
                }
            }
        }
        plan.directToData.segmentIndex = -1;
        plan.directToData.segmentLegIndex = -1;
    }
    /**
     * Removes all of a flight plan's Direct-To data, but from the DirectToData object and from any legs in the plan.
     * Scans the legs of the flight plan for Direct-To legs and removes them.
     * @param plan A flight plan.
     */
    static removeAllDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
        plan.setDirectToData(-1, true);
    }
    /**
     * Removes all of a flight plan's Displaced Active Legs,
     * which are flagged when a procedure is added and the active leg array is moved to enroute.
     * @param plan A flight plan.
     */
    static removeDisplacedActiveLegs(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = segment.legs.length - 1; j >= 0; j--) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
    }
    /**
     * Writes the calculated end coordinates of a leg to {@link out}, if the necessary calculated data exists
     *
     * @param leg the leg to find the end point for
     * @param out the {@link GeoPoint} to write the result to
     *
     * @returns whether anything was written
     */
    static writeLegCalculatedEndPoint(leg, out) {
        if (leg.calculated && leg.calculated.endLat && leg.calculated.endLon) {
            out.set(leg.calculated.endLat, leg.calculated.endLon);
            return true;
        }
        return false;
    }
    /**
     * Returns true if a leg is a vector of discontinuity.
     * @param leg The FlightPlanLeg
     * @returns Whether the leg is a vector of discontinuity
     */
    static isLegVectOrDisco(leg) {
        switch (leg.type) {
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return true;
            default:
                return false;
        }
    }
    /**
     * Returns hold legs in the flight plan. Used to determine and show appropriate HOLD pages.
     *
     * @param plan     the flight plan in question
     * @param inMissed whether to only include missed approach holds
     *
     * @returns the result
     */
    static getPlanHolds(plan, inMissed = false) {
        var _a;
        const holdLegs = [];
        for (const leg of plan.legs()) {
            const legSegment = (_a = plan.getSegmentFromLeg(leg)) === null || _a === void 0 ? void 0 : _a.segmentType;
            if (!inMissed && legSegment === FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (inMissed && legSegment !== FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (this.isHoldAtLeg(leg.leg.type)) {
                holdLegs.push(leg);
            }
        }
        return holdLegs;
    }
    /**
     * Returns the first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`.
     * @param plan The flight plan.
     * @param fixIcao The fix's ICAO.
     * @returns The first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`, or -1 if not found.
     * */
    static findHoldInPlan(plan, fixIcao) {
        let index = -1;
        for (const leg of plan.legs()) {
            if (leg.leg.type !== LegType.HM) {
                continue;
            }
            if (leg.leg.fixIcao === fixIcao) {
                index = plan.getLegIndexFromLeg(leg);
                break;
            }
        }
        return index;
    }
    /**
     * Calculates time in seconds to fly a certain distance at a ground speed
     *
     * @param distance distance to fly
     * @param groundSpeed GS to predict with
     *
     * @returns time in number of seconds
     */
    static estimateSecondsForDistance(distance, groundSpeed) {
        return (distance / groundSpeed) * 3600;
    }
    /**
     * Calculates distance flown for a number of seconds at a ground speed
     *
     * @param seconds time flown in number of seconds
     * @param groundSpeed GS to predict with
     *
     * @returns distance in nautical miles
     */
    static estimateDistanceForSeconds(seconds, groundSpeed) {
        return (seconds / 3600) * groundSpeed;
    }
    /**
     * Returns the index of the last non-missed approach leg in the flight plan
     *
     * @param plan the plan to use for lookup
     *
     * @returns array of index and ident, or undefined if no approach segment
     */
    static getLastNonMissedApproachLeg(plan) {
        if (plan.length === 0) {
            return -1;
        }
        let legIndex = plan.length - 1;
        while (BitFlags.isAll(plan.getLeg(legIndex).flags, LegDefinitionFlags.MissedApproach)) {
            legIndex--;
        }
        return legIndex;
    }
    /**
     * Returns the distance between the end of a leg before a discontinuity and the start of the leg after that discontinuity
     *
     * @param prevLeg the leg before the discontinuity
     * @param nextLeg the leg after the discontinuity
     *
     * @returns the great circle distance between the end of the previous leg and the start of the next leg, in metres
     */
    static distanceBetweenDiscontinuedLegs(prevLeg, nextLeg) {
        var _a, _b;
        let distance;
        if (prevLeg && nextLeg && ((_a = prevLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && prevLeg.calculated.endLon && ((_b = nextLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLat) && nextLeg.calculated.endLon) {
            const term = new GeoPoint(prevLeg.calculated.endLat, prevLeg.calculated.endLon);
            const start = new GeoPoint(nextLeg.calculated.endLat, nextLeg.calculated.endLon);
            distance = UnitType.GA_RADIAN.convertTo(term.distance(start), UnitType.METER);
        }
        else {
            distance = 0;
        }
        return distance;
    }
    /**
     * Formats a facility frequency's type for display on the FMC
     *
     * @param frequency  the frequency
     * @param noneString (optional) the string to return when the type is "None"
     *
     * @returns a string
     */
    static formatFacilityFrequencyType(frequency, noneString = 'UNKNOWN') {
        switch (frequency.type) {
            case FacilityFrequencyType.ASOS:
                return 'ASOS';
            case FacilityFrequencyType.ATIS:
                return 'ATIS';
            case FacilityFrequencyType.AWOS:
                return 'AWOS';
            case FacilityFrequencyType.Approach:
                return 'APR';
            case FacilityFrequencyType.CPT:
            case FacilityFrequencyType.Clearance:
                return 'CLEARANCE';
            case FacilityFrequencyType.CTAF:
                return 'CTAF';
            case FacilityFrequencyType.Center:
                return 'CTR';
            case FacilityFrequencyType.Departure:
                return 'DEP';
            case FacilityFrequencyType.FSS:
                return 'FSS';
            case FacilityFrequencyType.GCO:
                return 'GCO';
            case FacilityFrequencyType.Ground:
                return 'GND';
            case FacilityFrequencyType.Multicom:
                return 'MULTICOM';
            case FacilityFrequencyType.Tower:
                return 'TWR';
            case FacilityFrequencyType.Unicom:
                return 'UNICOM';
            default:
                return noneString;
        }
    }
    /**
     * Formats a facility type (and, if applicable, VOR type) into a string
     *
     * Used on the SELECT DESIRED XXX page
     *
     * @param facility the facility
     *
     * @returns a string
     */
    static formatFacilityType(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            switch (facility.type) {
                default:
                case VorType.VOR:
                    return 'VOR';
                case VorType.VORDME:
                    return 'VORDME';
                case VorType.VORTAC:
                    return 'VORTAC';
                case VorType.TACAN:
                    return 'TACAN';
                case VorType.ILS:
                    return 'ILS';
                case VorType.DME:
                    return 'DME';
            }
        }
        else {
            switch (ICAO.getFacilityType(facility.icao)) {
                case FacilityType.Airport:
                    return 'APRT';
                case FacilityType.NDB:
                    return 'NDB';
                case FacilityType.Intersection:
                    return 'WAYPOINT';
                case FacilityType.RWY:
                    return 'RUNWAY';
                case FacilityType.USR:
                    return 'PILOT';
                case FacilityType.VIS:
                    return 'VISUAL';
                default:
                    return 'UNKNOWN';
            }
        }
    }
    /**
     * Returns the distance from PPOS to the end of a leg, given a lateral plan and a global leg index
     * @param lateralPlan the lateral plan
     * @param globalLegIndex the global leg index
     * @returns the distance, in metres
     */
    static getDistanceFromPposToLegEnd(lateralPlan, globalLegIndex) {
        var _a, _b;
        const legDistanceRemaining = SimVar.GetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM);
        const legDistanceRemainingMetres = UnitType.METER.convertFrom(legDistanceRemaining, UnitType.NMILE);
        const currentLeg = lateralPlan.getLeg(lateralPlan.activeLateralLeg);
        const targetLeg = lateralPlan.getLeg(globalLegIndex);
        if (currentLeg.calculated && targetLeg.calculated) {
            const cumulativeDistanceToCurrentLeg = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions;
            const cumulativeDistanceToTargetLeg = (_b = targetLeg.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions;
            const distanceBetweenLegs = cumulativeDistanceToTargetLeg - cumulativeDistanceToCurrentLeg;
            return legDistanceRemainingMetres + distanceBetweenLegs;
        }
        return undefined;
    }
    /**
     * Toggle assumed temp takeoff derate.
     * @param mode The takeoff thrust mode.
     * @returns The opposite derate mode of the passed fixed thrust mode.
     */
    static toggleAssumedTempDerate(mode) {
        switch (mode) {
            case TakeoffThrustMode.TO: return TakeoffThrustMode.DTO;
            case TakeoffThrustMode.TO1: return TakeoffThrustMode.DTO1;
            case TakeoffThrustMode.TO2: return TakeoffThrustMode.DTO2;
            case TakeoffThrustMode.DTO: return TakeoffThrustMode.TO;
            case TakeoffThrustMode.DTO1: return TakeoffThrustMode.TO1;
            case TakeoffThrustMode.DTO2: return TakeoffThrustMode.TO2;
        }
    }
    /**
     * Returns whether the passed takeoff thrust mode is an assumed temperature derate mode.
     * @param mode The takeoff thrust mode.
     * @returns Whether the passed takeoff thrust mode is an assumed temperature derate mode.
     */
    static thrustModeIsAssumedTemp(mode) {
        return (mode === TakeoffThrustMode.DTO ||
            mode === TakeoffThrustMode.DTO1 ||
            mode === TakeoffThrustMode.DTO2);
    }
    /**
     * Helper to set an assumed temp de-rate.
     * @param perfPlan The performance plan to set the values on.
     * @param assumedTemp The assumed temp in °C, or null to clear the assumed temp.
     * @param oat The outside air temp in °C.
     * @param mode The thrust mode to use, defaults to the current thrust mode.
     */
    static setAssumedTempDerate(perfPlan, assumedTemp, oat, mode) {
        perfPlan.takeoffAssumedTemp.set(assumedTemp);
        const assumedTempExceedsOAT = assumedTemp !== null && assumedTemp > oat;
        const takeoffThrustMode = mode !== null && mode !== void 0 ? mode : perfPlan.takeoffThrustMode.get();
        if ((assumedTempExceedsOAT && !BoeingFmsUtils.thrustModeIsAssumedTemp(takeoffThrustMode)) ||
            (!assumedTempExceedsOAT && BoeingFmsUtils.thrustModeIsAssumedTemp(takeoffThrustMode))) {
            perfPlan.takeoffThrustMode.set(BoeingFmsUtils.toggleAssumedTempDerate(takeoffThrustMode));
        }
    }
    /**
     * Checks if two VHF frequencies are equal
     * @param frequencyA The first frequency to compare
     * @param frequencyB The second frequency to compare
     * @returns true if the frequencies are equal
     */
    static vhfFrequenciesEqual(frequencyA, frequencyB) {
        return Math.abs(frequencyA - frequencyB) < 0.0025;
    }
    /**
     * Check if a leg can contain wind data
     * @param legType Leg Type
     * @returns true if the leg is eligible for wind data
     */
    static legTypeCanHaveWind(legType) {
        switch (legType) {
            case LegType.AF:
            case LegType.CF:
            case LegType.DF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.IF:
            case LegType.RF:
            case LegType.TF:
                return true;
            default:
                return false;
        }
    }
    /**
     * Get a basic facility with only the properties of {@link Facility} from any facility.
     * @param facility The facility.
     * @returns A facility instance with only the basic subset of properties.
     */
    static getBaseFacility(facility) {
        return {
            icao: facility.icao,
            name: facility.name,
            lat: facility.lat,
            lon: facility.lon,
            region: facility.region,
            city: facility.city,
            magvar: facility.magvar,
        };
    }
}
BoeingFmsUtils.vec3Cache = [new Float64Array(3)];
BoeingFmsUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingFmsUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
BoeingFmsUtils.DTO_LEG_OFFSET = 3;
BoeingFmsUtils.LEG_USER_DATA_KEY_CRUISE_STEP_ALTITUDE = 'wtboeing.cruise-step-altitude';
/**
 * Utility method to return a single RnavTypeFlag from multiple possible flags.
 * @param rnavTypeFlags The input RnavTypeFlags.
 * @returns A single RnavTypeFlag
 */
BoeingFmsUtils.getBestRnavType = ApproachUtils.getBestRnavType;
/**
 * Additional Bitflags describing a leg definition specific to the Boeing FMS
 */
var BoeingExtraLegDefinitionFlags;
(function (BoeingExtraLegDefinitionFlags) {
    /**
     * A leg that was part of the active leg pair in a procedure when the procedure was removed, and was subsequently
     * moved to another segment in the plan.
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DisplacedActiveLeg"] = 536870912] = "DisplacedActiveLeg";
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["ProcedureLeg"] = 1073741824] = "ProcedureLeg";
    /**
     * Applied to the target leg of a direct to
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DirectToTarget"] = -2147483648] = "DirectToTarget";
})(BoeingExtraLegDefinitionFlags || (BoeingExtraLegDefinitionFlags = {}));
/** Array of "arc" leg types. */
const arcLegTypes = [LegType.AF, LegType.RF];
/** Array of "heading to" leg types. */
const headingToLegTypes = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold at" leg types. */
const holdAtLegTypes = [LegType.HA, LegType.HF, LegType.HM];
/** Array of "to altitude" leg types. */
const altitudeLegTypes = [LegType.CA, LegType.FA, LegType.VA, LegType.HA];
/** Array of "course to" leg types. */
const courseToLegTypes = [LegType.CA, LegType.CF, LegType.CI];
/**
 * Array of "discontinuity" leg types
 */
const discontinuityLegTypes = [LegType.Discontinuity, LegType.ThruDiscontinuity];
/** Array of "vectors" leg types */
const vectorsTypes = [LegType.FM, LegType.VM];

/** FMS Operating Phases of flight */
var FmsOperatingPhase;
(function (FmsOperatingPhase) {
    FmsOperatingPhase[FmsOperatingPhase["PREFLIGHT"] = 0] = "PREFLIGHT";
    FmsOperatingPhase[FmsOperatingPhase["TAKEOFF"] = 1] = "TAKEOFF";
    FmsOperatingPhase[FmsOperatingPhase["CLIMB"] = 2] = "CLIMB";
    FmsOperatingPhase[FmsOperatingPhase["CRUISE"] = 3] = "CRUISE";
    FmsOperatingPhase[FmsOperatingPhase["DESCENT"] = 4] = "DESCENT";
    FmsOperatingPhase[FmsOperatingPhase["APPROACH"] = 5] = "APPROACH";
    FmsOperatingPhase[FmsOperatingPhase["COMPLETE"] = 6] = "COMPLETE";
})(FmsOperatingPhase || (FmsOperatingPhase = {}));
/**
 * L Var names for FMS phase-related data.
 */
var FmsOperatingPhaseDataVars;
(function (FmsOperatingPhaseDataVars) {
    /** The current nominal desired track, in degrees true. */
    FmsOperatingPhaseDataVars["FmsOperatingPhaseVar"] = "L:WT_Boeing_Fms_Operating_Phase";
})(FmsOperatingPhaseDataVars || (FmsOperatingPhaseDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class FmsOperatingPhasePublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(FmsOperatingPhasePublisher.simvars, bus);
    }
}
FmsOperatingPhasePublisher.simvars = new Map([
    ['fms_operating_phase', { name: FmsOperatingPhaseDataVars.FmsOperatingPhaseVar, type: SimVarValueType.Enum }],
]);

/**
 * Types of vertical flight path vectors.
 */
var VerticalFlightPathVectorType;
(function (VerticalFlightPathVectorType) {
    VerticalFlightPathVectorType["Climb"] = "Climb";
    VerticalFlightPathVectorType["ClimbLevel"] = "ClimbLevel";
    VerticalFlightPathVectorType["ClimbAcceleration"] = "ClimbAcceleration";
    VerticalFlightPathVectorType["ClimbLevelAcceleration"] = "ClimbLevelAcceleration";
    VerticalFlightPathVectorType["Cruise"] = "Cruise";
    VerticalFlightPathVectorType["CruiseAcceleration"] = "CruiseAcceleration";
    VerticalFlightPathVectorType["CruiseDeceleration"] = "CruiseDeceleration";
    VerticalFlightPathVectorType["CruiseStepClimb"] = "CruiseStepClimb";
    VerticalFlightPathVectorType["CruiseStepClimbAcceleration"] = "CruiseStepClimbAcceleration";
    VerticalFlightPathVectorType["CruiseStepClimbDeceleration"] = "CruiseStepClimbDeceleration";
    VerticalFlightPathVectorType["CruiseStepDescent"] = "CruiseStepDescent";
    VerticalFlightPathVectorType["CruiseStepDescentAcceleration"] = "CruiseStepDescentAcceleration";
    VerticalFlightPathVectorType["CruiseStepDescentDeceleration"] = "CruiseStepDescentDeceleration";
    VerticalFlightPathVectorType["LevelDeceleration"] = "LevelDeceleration";
    VerticalFlightPathVectorType["IdleDescent"] = "IdleDescent";
    VerticalFlightPathVectorType["IdleDescentDeceleration"] = "IdleDescentDeceleration";
    VerticalFlightPathVectorType["GeometricDescent"] = "GeometricDescent";
    VerticalFlightPathVectorType["GeometricDescentDeceleration"] = "GeometricDescentDeceleration";
})(VerticalFlightPathVectorType || (VerticalFlightPathVectorType = {}));
/**
 * Sources from which a flight path vector's target speed is derived.
 */
var VerticalFlightPathVectorSpeedSource;
(function (VerticalFlightPathVectorSpeedSource) {
    VerticalFlightPathVectorSpeedSource["None"] = "None";
    VerticalFlightPathVectorSpeedSource["Schedule"] = "Schedule";
    VerticalFlightPathVectorSpeedSource["FlightPlan"] = "FlightPlan";
    VerticalFlightPathVectorSpeedSource["Transition"] = "Transition";
    VerticalFlightPathVectorSpeedSource["Restriction"] = "Restriction";
})(VerticalFlightPathVectorSpeedSource || (VerticalFlightPathVectorSpeedSource = {}));
/**
 * The current VNAV altitude capture type.
 */
var BoeingVNavAltCaptureType;
(function (BoeingVNavAltCaptureType) {
    /** Altitude capture is not armed. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VNAV target altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["VNAV"] = 2] = "VNAV";
    /** Altitude will capture the cruise altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Cruise"] = 3] = "Cruise";
})(BoeingVNavAltCaptureType || (BoeingVNavAltCaptureType = {}));
/**
 * Boeing VNAV tracking phases.
 */
var BoeingVNavTrackingPhase;
(function (BoeingVNavTrackingPhase) {
    BoeingVNavTrackingPhase["None"] = "None";
    BoeingVNavTrackingPhase["Climb"] = "Climb";
    BoeingVNavTrackingPhase["Cruise"] = "Cruise";
    BoeingVNavTrackingPhase["Descent"] = "Descent";
    BoeingVNavTrackingPhase["MissedApproach"] = "MissedApproach";
})(BoeingVNavTrackingPhase || (BoeingVNavTrackingPhase = {}));
/** This enum begins at 100 so that it can be used in combination with APVerticalModes in BoeingFmaData for display on the FMA. */
var BoeingVNavModes;
(function (BoeingVNavModes) {
    BoeingVNavModes[BoeingVNavModes["NONE"] = 100] = "NONE";
    BoeingVNavModes[BoeingVNavModes["ARMED"] = 101] = "ARMED";
    BoeingVNavModes[BoeingVNavModes["SPD_CLIMB"] = 102] = "SPD_CLIMB";
    BoeingVNavModes[BoeingVNavModes["SPD_DESCENT"] = 103] = "SPD_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_DESCENT"] = 104] = "PATH_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_IDLE"] = 105] = "PATH_IDLE";
    BoeingVNavModes[BoeingVNavModes["PATH_LEVEL"] = 106] = "PATH_LEVEL";
    BoeingVNavModes[BoeingVNavModes["ALT"] = 107] = "ALT";
    BoeingVNavModes[BoeingVNavModes["THR_DESCENT"] = 108] = "THR_DESCENT";
})(BoeingVNavModes || (BoeingVNavModes = {}));
/** Path Deviation Mode for the Boeing Vnav Manager. */
var PathDeviationMode;
(function (PathDeviationMode) {
    PathDeviationMode[PathDeviationMode["NONE"] = 0] = "NONE";
    PathDeviationMode[PathDeviationMode["BELOW"] = 1] = "BELOW";
    PathDeviationMode[PathDeviationMode["ABOVE"] = 2] = "ABOVE";
})(PathDeviationMode || (PathDeviationMode = {}));
var BoeingVnavDescentPendingType;
(function (BoeingVnavDescentPendingType) {
    BoeingVnavDescentPendingType["DesDir"] = "des-dir";
    BoeingVnavDescentPendingType["DesNow"] = "des-now";
})(BoeingVnavDescentPendingType || (BoeingVnavDescentPendingType = {}));

/** Boeing VNAV Utilities */
class BoeingVNavUtils {
    /**
     * Utility method that checks if a mode is a vnav mode.
     * @param mode The BoeingVNavMode or APVerticalMode.
     * @returns True if the mode is an active vnav mode.
     */
    static isModeVnav(mode) {
        return mode === BoeingVNavModes.ALT ||
            mode === BoeingVNavModes.PATH_DESCENT ||
            mode === BoeingVNavModes.PATH_IDLE ||
            mode === BoeingVNavModes.PATH_LEVEL ||
            mode === BoeingVNavModes.SPD_CLIMB ||
            mode === BoeingVNavModes.SPD_DESCENT;
    }
    /**
     * Gets the index of the cruise step in effect at a given query point along a flight plan. The cruise step in effect
     * is defined as the the closest (as measured along the lateral flight path) cruise step in the flight plan at or
     * before the query point.
     * @param verticalPath The flight plan's associated vertical flight path.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance from the query point to the end of its containing leg, in meters.
     * @returns The index of the cruise step in effect at the specified query point.
     */
    static getCurrentCruiseStepIndex(verticalPath, globalLegIndex, distanceToLegEnd) {
        for (let i = verticalPath.cruiseSteps.length - 1; i >= 0; i--) {
            const step = verticalPath.cruiseSteps[i];
            if (step.globalLegIndex < globalLegIndex
                || (step.globalLegIndex === globalLegIndex && step.distanceToLegEnd >= distanceToLegEnd)) {
                return i;
            }
        }
        return -1;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A manager and calculator for vertical flight plans for Boeing avionics systems.
 */
class BoeingPathCalculator extends SmoothingPathCalculator {
    /**
     * Creates an instance of BoeingPathCalculator.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param perfProvider A provider of airplane performance data.
     * @param engineDataProvider A provider of airplane engine data.
     * @param speedProvider A provider of airplane airspeed references.
     * @param perfPlanRepository The performance plan repository.
     * @param windPlanner The wind planner.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, perfProvider, engineDataProvider, speedProvider, perfPlanRepository, windPlanner, options) {
        var _a, _b, _c, _d;
        super(bus, flightPlanner, primaryPlanIndex, options);
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.speedProvider = speedProvider;
        this.perfPlanRepository = perfPlanRepository;
        this.windPlanner = windPlanner;
        this.speedConstraintLists = [];
        this.plannedCruiseStepList = [];
        this.verticalFlightPathEntries = [];
        this.perfPlanSubscriptions = [];
        this.accelerationResult = Vec2Math.create();
        this.enablePathCalc = (_a = options === null || options === void 0 ? void 0 : options.enablePathCalc) !== null && _a !== void 0 ? _a : false;
        this.engineCount = Math.max((_b = options === null || options === void 0 ? void 0 : options.engineCount) !== null && _b !== void 0 ? _b : 2, 1);
        this.performanceDescentIdleN1Offset = Math.max((_c = options === null || options === void 0 ? void 0 : options.performanceDescentIdleN1Offset) !== null && _c !== void 0 ? _c : 10, 0);
        this.cruiseStepCostBias = (_d = options === null || options === void 0 ? void 0 : options.cruiseStepCostBias) !== null && _d !== void 0 ? _d : 0;
        if (this.enablePathCalc) {
            const sub = bus.getSubscriber();
            this.fmsOperatingPhase = ConsumerValue.create(sub.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
            // TODO: Maybe support ADC system?
            this.indicatedAltitude = ConsumerValue.create(sub.on('indicated_alt'), 0);
            this.lnavIsAwaitingCalc = ConsumerSubject.create(sub.on('lnav_is_awaiting_calc'), false);
            this.lnavTrackedLegIndex = ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
            this.lnavLegDistanceRemaining = ConsumerValue.create(sub.on('lnav_leg_distance_remaining'), 0);
            this.fob = ConsumerValue.create(sub.on('fuel_usable_total_weight'), 0);
            const legUserDataHandler = (e) => {
                if (e.key === BoeingFmsUtils.LEG_USER_DATA_KEY_CRUISE_STEP_ALTITUDE) {
                    this.getVerticalFlightPlan(e.planIndex).planChanged = true;
                    this.getVerticalFlightPath(e.planIndex).isPending = true;
                }
            };
            sub.on('fplLegUserDataSet').handle(legUserDataHandler);
            sub.on('fplLegUserDataDelete').handle(legUserDataHandler);
            // TODO: This is a massive hack that relies on LNAV's awaiting calculate logic as well as the fact that the only
            // way the active plan can change in the Boeings is through a plan copy. This needs to be replaced with a more
            // robust solution at some point and **UNDER NO CIRCUMSTANCES SHOULD IT BE REPLICATED ELSEWHERE**.
            const primaryPlanActiveLegIndex = Subject.create(0);
            sub.on('fplActiveLegChange').handle(event => {
                if (event.type === ActiveLegType.Lateral && event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(event.index);
                }
            });
            sub.on('fplCopied').handle(event => {
                if (event.targetPlanIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            sub.on('fplLoaded').handle(event => {
                if (event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            this.canUpdatePrimaryPlan = MappedSubject.create(([isAwaitingCalc, trackedLegIndex, planActiveLegIndex]) => !isAwaitingCalc && trackedLegIndex === planActiveLegIndex, this.lnavIsAwaitingCalc, this.lnavTrackedLegIndex, primaryPlanActiveLegIndex);
            // We need to update pending vertical plans on an update loop in order to guarantee that we don't perform the
            // update using an intermediate state from LNAV (specifically when the tracked leg index has been updated before
            // the remaining leg distance).
            sub.on('realTime').handle(this.update.bind(this));
        }
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /**
     * Gets the speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The speed constraint list for the specified flight plan.
     */
    getSpeedConstraintList(planIndex) {
        var _a;
        return (_a = this.speedConstraintLists[planIndex]) !== null && _a !== void 0 ? _a : this.createSpeedConstraintList(planIndex);
    }
    /**
     * Gets the planned cruise step list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The planned cruise step list for the specified flight plan.
     */
    getPlannedCruiseStepList(planIndex) {
        return this._getPlannedCruiseStepList(planIndex);
    }
    /**
     * Gets the planned cruise step list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The planned cruise step list for the specified flight plan.
     */
    _getPlannedCruiseStepList(planIndex) {
        var _a;
        return (_a = this.plannedCruiseStepList[planIndex]) !== null && _a !== void 0 ? _a : this.createPlannedCruiseStepList(planIndex);
    }
    /**
     * Gets the calculated vertical flight path for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The calculated vertical flight path for the specified flight plan.
     */
    getVerticalFlightPath(planIndex) {
        return this.getVerticalFlightPathEntry(planIndex).path;
    }
    /**
     * Gets the vertical flight path entry for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The vertical flight path entry for the specified flight plan.
     */
    getVerticalFlightPathEntry(planIndex) {
        var _a;
        return (_a = this.verticalFlightPathEntries[planIndex]) !== null && _a !== void 0 ? _a : this.createVerticalFlightPathEntry(planIndex);
    }
    /**
     * Gets the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The speed constraint in effect for the specified flight plan leg and vertical flight phase, or
     * `undefined` if there is no speed constraint in effect.
     */
    getCurrentSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        return speedConstraints[this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach)];
    }
    /**
     * Gets the next speed constraint to take effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The next speed constraint to take effect for the specified flight plan leg and vertical flight phase,
     * or `undefined` if there is no speed constraint in effect.
     */
    getNextSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        const currentIndex = this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach);
        if (currentIndex < 0) {
            if (flightPhase === VerticalFlightPhase.Climb) {
                // If there is no current constraint in effect during climb, there can be no next climb constraint because
                // either we have sequenced all climb constraints or there is at least one non-climb constraint to sequence
                // before the next climb constraint.
                return undefined;
            }
            else {
                // If there is no current constraint in effect during descent, it is still possible that the next upcoming
                // constraint to be sequenced is the next descent constraint. This constraint, if it exists, is located at the
                // index where the current constraint would be located if it existed, so we need to check if the constraint at
                // that index is a descent constraint and has yet to be sequenced.
                const constraint = speedConstraints[-currentIndex - 1];
                if (constraint !== undefined && flightPhase === constraint.flightPhase && constraint.globalLegIndex >= globalLegIndex) {
                    return constraint;
                }
                else {
                    return undefined;
                }
            }
        }
        const isMapr = speedConstraints[currentIndex].isMissedApproach;
        const constraint = speedConstraints[currentIndex + 1];
        if (constraint !== undefined && flightPhase === constraint.flightPhase && isMapr === constraint.isMissedApproach) {
            return constraint;
        }
        return undefined;
    }
    /**
     * Gets the index of the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param speedConstraintList The speed constraint list for the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The index of the speed constraint in effect for the specified flight plan leg and vertical flight phase.
     * If there is no speed constraint in effect, `-(i + 1)` is returned instead, where `i` is the index at which the
     * constraint would be located if it existed.
     */
    getCurrentSpeedConstraintIndex(planIndex, speedConstraintList, globalLegIndex, flightPhase, isMissedApproach) {
        var _a, _b;
        if (flightPhase === VerticalFlightPhase.Climb) {
            const inMissedApproach = isMissedApproach !== null && isMissedApproach !== void 0 ? isMissedApproach : (this.flightPlanner.hasFlightPlan(planIndex)
                && BitFlags.isAll((_b = (_a = this.flightPlanner.getFlightPlan(planIndex).tryGetLeg(globalLegIndex)) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, LegDefinitionFlags.MissedApproach));
            // During climb, the next upcoming climb speed constraint to be sequenced is in effect.
            for (let i = 0; i < speedConstraintList.length; i++) {
                const constraint = speedConstraintList[i];
                // Speed constraints in the missed approach are not active until we are in the missed approach.
                if (constraint.isMissedApproach && !inMissedApproach) {
                    return -(i + 1);
                }
                if (constraint.globalLegIndex >= globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 1);
                }
            }
            return -(speedConstraintList.length + 1);
        }
        else {
            // During descent, the last sequenced descent speed constraint is in effect.
            for (let i = speedConstraintList.length - 1; i >= 0; i--) {
                const constraint = speedConstraintList[i];
                if (constraint.globalLegIndex < globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 2);
                }
            }
            return -1;
        }
    }
    /**
     * Gets the next planned cruise step at or after a given flight plan leg.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the next planned cruise step.
     * @returns The next planned cruise step at or after the specified flight plan leg, or `undefined` if there is no
     * such cruise step.
     */
    getNextPlannedCruiseStep(planIndex, globalLegIndex) {
        const plannedCruiseSteps = this.getPlannedCruiseStepList(planIndex);
        return plannedCruiseSteps[this.getNextPlannedCruiseStepIndex(planIndex, globalLegIndex)];
    }
    /**
     * Gets the index of the next planned cruise step at or after a given flight plan leg.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the next planned cruise step.
     * @returns The index of the next planned cruise step at or after the specified flight plan leg, or `-1` if there is
     * no such cruise step.
     */
    getNextPlannedCruiseStepIndex(planIndex, globalLegIndex) {
        const plannedCruiseSteps = this.getPlannedCruiseStepList(planIndex);
        for (let i = 0; i < plannedCruiseSteps.length; i++) {
            const step = plannedCruiseSteps[i];
            if (step.globalLegIndex >= globalLegIndex) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Creates a new, empty speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created speed constraint list.
     */
    createSpeedConstraintList(planIndex) {
        return this.speedConstraintLists[planIndex] = [];
    }
    /**
     * Creates a new, empty planned cruise step list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created planned cruise step list.
     */
    createPlannedCruiseStepList(planIndex) {
        return this.plannedCruiseStepList[planIndex] = [];
    }
    /**
     * Creates a new vertical path entry for a flight plan. The new entry will be initialized with an empty vertical
     * path.
     * @param planIndex The index of the flight plan.
     * @returns The created vertical path entry.
     */
    createVerticalFlightPathEntry(planIndex) {
        const entry = {
            path: BoeingPathCalculator.createVerticalPath(planIndex),
            lastTocLegIndex: undefined,
            lastTocDistanceToLegEnd: undefined,
            isTocSequenced: false,
            lastCruiseStepStartLegIndex: undefined,
            lastCruiseStepStartDistanceToLegEnd: undefined,
            perfDescentWorkingPath: BoeingPathCalculator.createVerticalPath(planIndex),
            geoDescentCoarsePath: BoeingPathCalculator.createGeometricDescentCoarsePath(),
            needsRebuild: false,
            needsSetLastCruiseStepStart: false
        };
        this.verticalFlightPathEntries[planIndex] = entry;
        return entry;
    }
    /**
     * Request an immediate path computation for a specified flight plan. If this calculator does not support path
     * calculations, then this method does nothing and will always return `false`. If computation is requested for the
     * active flight plan but cannot be carried out when the method is called, then the computation will be pended until
     * the active flight plan path can be computed, and the method will return `false`.
     * @param planIndex The index of the flight plan for which to request a path computation.
     * @returns Whether the requested path computation was executed successfully.
     */
    requestPathCompute(planIndex) {
        if (!this.enablePathCalc || !this.flightPlanner.hasFlightPlan(planIndex) || this.verticalFlightPlans[planIndex] === undefined) {
            return false;
        }
        if (planIndex !== this.primaryPlanIndex || this.canUpdatePrimaryPlan.get()) {
            this.computePathAndNotify(this.flightPlanner.getFlightPlan(planIndex), this.verticalFlightPlans[planIndex]);
            return true;
        }
        else {
            this.getVerticalFlightPath(planIndex).isPending = true;
            return false;
        }
    }
    /** @inheritdoc */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        if (!this.enablePathCalc) {
            return;
        }
        super.onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent);
        this.getVerticalFlightPath(planIndex).isPending = true;
    }
    /** @inheritdoc */
    onPlanCalculated(event) {
        if (!this.enablePathCalc) {
            return;
        }
        if (event.planIndex !== this.primaryPlanIndex || this.canUpdatePrimaryPlan.get()) {
            this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
        }
        else {
            this.getVerticalFlightPath(event.planIndex).isPending = true;
        }
    }
    /**
     * Updates this calculator.
     */
    update() {
        if (this.canUpdatePrimaryPlan.get()
            && this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)
            && this.getVerticalFlightPath(this.primaryPlanIndex).isPending) {
            this.buildVerticalFlightPlanAndComputeAndNotify(this.primaryPlanIndex);
        }
    }
    /** @inheritdoc */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        super.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.buildSpeedConstraints(lateralPlan, this.getSpeedConstraintList(verticalPlan.planIndex));
        this.buildPlannedCruiseSteps(lateralPlan, this._getPlannedCruiseStepList(verticalPlan.planIndex));
        this.buildVerticalFlightPath(lateralPlan, this.getVerticalFlightPathEntry(verticalPlan.planIndex));
    }
    /**
     * Builds a speed constraint list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param speedConstraints The speed constraint list to build.
     */
    buildSpeedConstraints(lateralPlan, speedConstraints) {
        var _a, _b;
        let speedConstraintIndex = 0;
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(lateralPlan.planIndex);
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    const leg = segment.legs[segmentLegIndex];
                    const isDirectToLeg = BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo)
                        && lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex - this.directToLegOffset;
                    const approachSpeed = (_a = perfPlan.approachFlapSpeed.get()) === null || _a === void 0 ? void 0 : _a[1];
                    const windCorrection = perfPlan.approachWindCorrection.get();
                    const hasAutoApproachSpeed = leg.verticalData.speedDesc === SpeedRestrictionType.Unused
                        && BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF)
                        && approachSpeed !== undefined;
                    // If the leg is a direct-to leg with an associated direct-to target leg, skip it since its constraint is
                    // duplicated from that of the target leg.
                    if ((leg.verticalData.speedDesc !== SpeedRestrictionType.Unused || hasAutoApproachSpeed) && !isDirectToLeg) {
                        const isMissedApproach = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
                        const isCursorDepartureOrMissedApproach = segment.segmentType === FlightPlanSegmentType.Departure || isMissedApproach;
                        // If the constraint leg is a direct-to target, shift the leg index to that of the direct-to leg.
                        const isDirectToTarget = lateralPlan.directToData.segmentIndex === segmentIndex
                            && lateralPlan.directToData.segmentLegIndex === segmentLegIndex;
                        const constraint = (_b = speedConstraints[speedConstraintIndex]) !== null && _b !== void 0 ? _b : (speedConstraints[speedConstraintIndex] = BoeingPathCalculator.createSpeedConstraintListItem());
                        constraint.globalLegIndex = segment.offset + segmentLegIndex + (isDirectToTarget ? this.directToLegOffset : 0);
                        constraint.flightPhase = isCursorDepartureOrMissedApproach ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent;
                        constraint.speedConstraint.speedDesc = hasAutoApproachSpeed ? SpeedRestrictionType.At : leg.verticalData.speedDesc;
                        constraint.speedConstraint.speed = hasAutoApproachSpeed ? (approachSpeed + windCorrection) : leg.verticalData.speed;
                        constraint.speedConstraint.speedUnit = hasAutoApproachSpeed ? SpeedUnit.IAS : leg.verticalData.speedUnit;
                        constraint.isMissedApproach = hasAutoApproachSpeed ? false : isMissedApproach;
                        let useMin = false;
                        let useMax = false;
                        switch (constraint.speedConstraint.speedDesc) {
                            case SpeedRestrictionType.At:
                            case SpeedRestrictionType.Between:
                                useMin = true;
                                useMax = true;
                                break;
                            case SpeedRestrictionType.AtOrAbove:
                                useMin = true;
                                break;
                            case SpeedRestrictionType.AtOrBelow:
                                useMax = true;
                                break;
                        }
                        constraint.minCas = -Infinity;
                        constraint.maxCas = Infinity;
                        constraint.minMach = -Infinity;
                        constraint.maxMach = Infinity;
                        if (useMin) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.minMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.minCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        if (useMax) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.maxMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.maxCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        speedConstraintIndex++;
                    }
                }
            }
        }
        speedConstraints.length = speedConstraintIndex;
    }
    /**
     * Builds a planned cruise step list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param plannedCruiseSteps The planned cruise step list to build.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    buildPlannedCruiseSteps(lateralPlan, plannedCruiseSteps) {
        var _a;
        var _b;
        let plannedCruiseStepIndex = 0;
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    // If the leg is a direct-to target leg, skip it since its planned cruise step will be duplicated in the
                    // associated direct-to leg.
                    if (lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex) {
                        continue;
                    }
                    const plannedStepAltitude = segment.legs[segmentLegIndex].userData[BoeingFmsUtils.LEG_USER_DATA_KEY_CRUISE_STEP_ALTITUDE];
                    if (typeof plannedStepAltitude === 'number') {
                        const plannedCruiseStep = (_a = plannedCruiseSteps[_b = plannedCruiseStepIndex++]) !== null && _a !== void 0 ? _a : (plannedCruiseSteps[_b] = BoeingPathCalculator.createPlannedCruiseStep());
                        plannedCruiseStep.globalLegIndex = segment.offset + segmentLegIndex;
                        plannedCruiseStep.toAltitude = plannedStepAltitude;
                        plannedCruiseStep.deferredDistance = 0;
                        plannedCruiseStep.isInvalid = false;
                    }
                }
            }
        }
        plannedCruiseSteps.length = plannedCruiseStepIndex;
    }
    /**
     * Builds an empty vertical flight path from a lateral flight plan. After the path is built, it will contain one
     * leg (containing zero vectors) for each leg in the lateral flight plan, and all TOC/TOD data will be undefined.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to build.
     */
    buildVerticalFlightPath(lateralPlan, verticalPathEntry) {
        verticalPathEntry.needsRebuild = false;
        const verticalPath = verticalPathEntry.path;
        verticalPath.legs.length = lateralPlan.length;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            if (leg) {
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
            else {
                verticalPath.legs[i] = BoeingPathCalculator.createVerticalPathLeg();
            }
        }
        verticalPath.cruiseSteps.length = 0;
        verticalPath.isPending = true;
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocVectorIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.predictedCruiseDistance = undefined;
        verticalPath.predictedCruiseDuration = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todVectorIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        verticalPathEntry.lastTocLegIndex = undefined;
        verticalPathEntry.lastTocDistanceToLegEnd = undefined;
        verticalPathEntry.lastCruiseStepStartLegIndex = undefined;
        verticalPathEntry.lastCruiseStepStartDistanceToLegEnd = undefined;
        if (this.fmsOperatingPhase.get() < FmsOperatingPhase.CLIMB) {
            verticalPathEntry.isTocSequenced = false;
        }
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Initializes performance plan subscriptions for an indexed flight plan. Once these subscriptions are initialized,
     * the vertical path for the flight plan will be flagged to be rebuilt during the next flight plan calculation cycle
     * whenever certain performance plan values change. If subscriptions are already initialized for the specified flight
     * plan, then this method does nothing.
     * @param planIndex The index of the flight plan for which to initialize performance plan subscriptions.
     */
    initPerfPlanSubscriptions(planIndex) {
        if (this.perfPlanSubscriptions[planIndex]) {
            return;
        }
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(planIndex);
        const entry = this.getVerticalFlightPathEntry(planIndex);
        const handler = () => {
            entry.needsRebuild = true;
        };
        const speedHandler = (mode, activeMode) => {
            if (mode.get() === activeMode) {
                entry.needsRebuild = true;
            }
        };
        const approachSpeedHandler = () => {
            const verticalPlan = this.verticalFlightPlans[planIndex];
            verticalPlan && (verticalPlan.planChanged = true);
        };
        const climbSelSpeedHandler = speedHandler.bind(this, perfPlan.speedClimbMode, SpeedMode.SEL);
        const cruiseSelSpeedHandler = speedHandler.bind(this, perfPlan.speedCruiseMode, SpeedMode.SEL);
        const descentSelSpeedHandler = speedHandler.bind(this, perfPlan.speedDescentMode, SpeedMode.SEL);
        const cruiseAltHandler = () => {
            entry.needsRebuild = true;
            entry.needsSetLastCruiseStepStart = true;
        };
        this.perfPlanSubscriptions[planIndex] = [
            perfPlan.speedClimbMode.sub(handler),
            perfPlan.speedClimbSelectCas.sub(climbSelSpeedHandler),
            perfPlan.speedClimbSelectMach.sub(climbSelSpeedHandler),
            perfPlan.speedCruiseMode.sub(handler),
            perfPlan.speedCruiseSelectCas.sub(cruiseSelSpeedHandler),
            perfPlan.speedCruiseSelectMach.sub(cruiseSelSpeedHandler),
            perfPlan.speedDescentMode.sub(handler),
            perfPlan.speedDescentSelectCas.sub(descentSelSpeedHandler),
            perfPlan.speedDescentSelectMach.sub(descentSelSpeedHandler),
            perfPlan.cruiseAltitude.sub(cruiseAltHandler),
            perfPlan.stepSize.sub(handler),
            perfPlan.climbSpeedLimitAltitude.sub(handler),
            perfPlan.climbSpeedLimitCas.sub(handler),
            perfPlan.climbSpeedRestrAltitude.sub(handler),
            perfPlan.climbSpeedRestrCas.sub(handler),
            perfPlan.descentSpeedLimitAltitude.sub(handler),
            perfPlan.descentSpeedLimitCas.sub(handler),
            perfPlan.descentSpeedRestrAltitude.sub(handler),
            perfPlan.descentSpeedRestrCas.sub(handler),
            perfPlan.approachFlapSpeed.sub(approachSpeedHandler),
            perfPlan.approachWindCorrection.sub(approachSpeedHandler)
        ];
    }
    /** @inheritdoc */
    computePath(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e;
        const verticalPathEntry = this.getVerticalFlightPathEntry(verticalPlan.planIndex);
        this.initPerfPlanSubscriptions(verticalPlan.planIndex);
        if (verticalPathEntry.needsRebuild) {
            this.buildVerticalFlightPath(lateralPlan, verticalPathEntry);
        }
        const verticalPath = verticalPathEntry.path;
        verticalPath.isPending = false;
        const activeLegIndex = this.lnavTrackedLegIndex.get();
        const activeDistanceToLegEnd = Math.max(0, UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER));
        // TODO: Support engine-out ops.
        const engineCount = this.engineCount;
        // Compute FPAs for geometric descent segment.
        this.computeDescentPath(lateralPlan, verticalPlan);
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(verticalPlan.planIndex);
        const climbSpeedMode = perfPlan.speedClimbMode.get();
        const cruiseSpeedMode = perfPlan.speedCruiseMode.get();
        const descentSpeedMode = perfPlan.speedDescentMode.get();
        let initialCruiseAltitude = perfPlan.cruiseAltitude.get();
        const zfw = perfPlan.manualZfw.get();
        let climbCas, climbMach;
        let cruiseCas, cruiseMach;
        let descentCas, descentMach;
        if (climbSpeedMode === SpeedMode.SEL) {
            climbCas = perfPlan.speedClimbSelectCas.get();
            climbMach = perfPlan.speedClimbSelectMach.get();
        }
        else {
            climbCas = perfPlan.speedClimbEconCas.get();
            climbMach = perfPlan.speedClimbEconMach.get();
        }
        if (cruiseSpeedMode === SpeedMode.SEL) {
            cruiseCas = perfPlan.speedCruiseSelectCas.get();
            cruiseMach = perfPlan.speedCruiseSelectMach.get();
        }
        else {
            cruiseCas = perfPlan.speedCruiseEconCas.get();
            cruiseMach = perfPlan.speedCruiseEconMach.get();
        }
        if (descentSpeedMode === SpeedMode.SEL) {
            descentCas = perfPlan.speedDescentSelectCas.get();
            descentMach = perfPlan.speedDescentSelectMach.get();
        }
        else {
            descentCas = perfPlan.speedDescentEconCas.get();
            descentMach = perfPlan.speedDescentEconMach.get();
        }
        if (initialCruiseAltitude === null
            || zfw === null
            || (climbCas === null && climbMach === null)
            || (cruiseCas === null && cruiseMach === null)
            || (descentCas === null && descentMach === null)) {
            this.clearVerticalPath(verticalPathEntry);
            return;
        }
        const maprStartLegIndex = (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : -1;
        const firstDescentConstraintLegIndex = (_b = verticalPlan.firstDescentConstraintLegIndex) !== null && _b !== void 0 ? _b : -1;
        const lastSimulatedLegIndex = maprStartLegIndex < 0 ? lateralPlan.length : maprStartLegIndex;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const isPastCalculatedTod = verticalPath.todLegIndex !== undefined && verticalPath.todDistanceToLegEnd !== undefined
            && (activeLegIndex > verticalPath.todLegIndex
                || (activeLegIndex === verticalPath.todLegIndex && activeDistanceToLegEnd <= verticalPath.todDistanceToLegEnd));
        climbCas !== null && climbCas !== void 0 ? climbCas : (climbCas = Infinity);
        climbMach !== null && climbMach !== void 0 ? climbMach : (climbMach = Infinity);
        cruiseCas !== null && cruiseCas !== void 0 ? cruiseCas : (cruiseCas = Infinity);
        cruiseMach !== null && cruiseMach !== void 0 ? cruiseMach : (cruiseMach = Infinity);
        descentCas !== null && descentCas !== void 0 ? descentCas : (descentCas = Infinity);
        descentMach !== null && descentMach !== void 0 ? descentMach : (descentMach = Infinity);
        initialCruiseAltitude = UnitType.FOOT.convertTo(initialCruiseAltitude, UnitType.METER);
        climbCas = UnitType.KNOT.convertTo(climbCas, UnitType.MPS);
        cruiseCas = UnitType.KNOT.convertTo(cruiseCas, UnitType.MPS);
        descentCas = UnitType.KNOT.convertTo(descentCas, UnitType.MPS);
        const climbThrustMode = perfPlan.climbThrustMode.get();
        const currentAltitude = UnitType.FOOT.convertTo(this.indicatedAltitude.get(), UnitType.METER);
        const currentWeight = zfw + this.fob.get();
        const costIndex = (_c = perfPlan.costIndex.get()) !== null && _c !== void 0 ? _c : 180;
        let climbTransitionAltitude = perfPlan.climbSpeedLimitAltitude.get();
        if (climbTransitionAltitude !== null) {
            climbTransitionAltitude = UnitType.FOOT.convertTo(climbTransitionAltitude, UnitType.METER);
        }
        let climbTransitionCas = perfPlan.climbSpeedLimitCas.get();
        if (climbTransitionCas !== null) {
            climbTransitionCas = UnitType.KNOT.convertTo(climbTransitionCas, UnitType.MPS);
        }
        let climbRestrictionAltitude = perfPlan.climbSpeedRestrAltitude.get();
        if (climbRestrictionAltitude !== null) {
            climbRestrictionAltitude = UnitType.FOOT.convertTo(climbRestrictionAltitude, UnitType.METER);
        }
        let climbRestrictionCas = perfPlan.climbSpeedRestrCas.get();
        if (climbRestrictionCas !== null) {
            climbRestrictionCas = UnitType.KNOT.convertTo(climbRestrictionCas, UnitType.MPS);
        }
        let descentTransitionAltitude = perfPlan.descentSpeedLimitAltitude.get();
        if (descentTransitionAltitude !== null) {
            descentTransitionAltitude = UnitType.FOOT.convertTo(descentTransitionAltitude, UnitType.METER);
        }
        let descentTransitionCas = perfPlan.descentSpeedLimitCas.get();
        if (descentTransitionCas !== null) {
            descentTransitionCas = UnitType.KNOT.convertTo(descentTransitionCas, UnitType.MPS);
        }
        let descentRestrictionAltitude = perfPlan.descentSpeedRestrAltitude.get();
        if (descentRestrictionAltitude !== null) {
            descentRestrictionAltitude = UnitType.FOOT.convertTo(descentRestrictionAltitude, UnitType.METER);
        }
        let descentRestrictionCas = perfPlan.descentSpeedRestrCas.get();
        if (descentRestrictionCas !== null) {
            descentRestrictionCas = UnitType.KNOT.convertTo(descentRestrictionCas, UnitType.MPS);
        }
        const stepSize = perfPlan.stepSize.get();
        let stepSizeAltitude;
        switch (stepSize) {
            case 'ICAO':
                stepSizeAltitude = 4000;
                break;
            case 'RVSM':
                stepSizeAltitude = 2000;
                break;
            default:
                stepSizeAltitude = stepSize;
        }
        stepSizeAltitude = UnitType.FOOT.convertTo(stepSizeAltitude, UnitType.METER);
        const lateralLegs = [...lateralPlan.legs()];
        if (!isPastCalculatedTod) {
            const clearEndIndex = Math.min(verticalPath.legs.length, activeLegIndex);
            for (let i = 0; i < clearEndIndex; i++) {
                verticalPath.legs[i].vectors.length = 0;
                verticalPath.legs[i].simDistance = 0;
            }
            verticalPath.tocLegIndex = undefined;
            verticalPath.tocVectorIndex = undefined;
            verticalPath.tocDistanceToLegEnd = undefined;
            verticalPath.tocWeight = undefined;
            // Only simulate the climb if we have not yet sequenced the first descent constraint (if one exists).
            if (firstDescentConstraintLegIndex < 0 || activeLegIndex <= firstDescentConstraintLegIndex) {
                // If we are already past the TOC, then do not simulate climb. Instead, any deviation from the cruise altitude
                // will be treated as a cruise step climb or descent.
                if (!verticalPathEntry.isTocSequenced) {
                    this.simulateClimb(lateralLegs, verticalPlan, verticalPathEntry, climbThrustMode, climbCas, climbMach, climbTransitionAltitude, climbTransitionCas, climbRestrictionAltitude, climbRestrictionCas, initialCruiseAltitude, activeLegIndex, activeDistanceToLegEnd, currentAltitude, currentWeight, lastSimulatedLegIndex, false, engineCount);
                }
                if (verticalPathEntry.lastTocLegIndex === undefined) {
                    // If lastTocLegIndex is not defined, this means that this is the first time the path has been computed since
                    // it was (re)built and we are already at or above the cruise altitude. In this case, we will treat the
                    // airplane's current along-track position as the TOC.
                    verticalPathEntry.lastTocLegIndex = activeLegIndex;
                    verticalPathEntry.lastTocDistanceToLegEnd = activeDistanceToLegEnd;
                    verticalPathEntry.isTocSequenced = true;
                }
                else {
                    // We are considered to be past the TOC if the cruise simulation did not run, which can only happen if we
                    // were already past the TOC or if were not originally past the TOC but we are now at or above the cruise
                    // altitude.
                    verticalPathEntry.isTocSequenced = verticalPath.tocLegIndex === undefined;
                }
            }
            else {
                verticalPathEntry.isTocSequenced = true;
            }
            if (verticalPathEntry.needsSetLastCruiseStepStart) {
                if (verticalPathEntry.isTocSequenced) {
                    verticalPathEntry.lastCruiseStepStartLegIndex = activeLegIndex;
                    verticalPathEntry.lastCruiseStepStartDistanceToLegEnd = activeDistanceToLegEnd;
                }
                verticalPathEntry.needsSetLastCruiseStepStart = false;
            }
            const selCruiseCas = cruiseSpeedMode === SpeedMode.SEL ? cruiseCas : null;
            const selCruiseMach = cruiseSpeedMode === SpeedMode.SEL ? cruiseMach : null;
            this.computeCruiseSteps(lateralLegs, verticalPlan, verticalPathEntry, costIndex, initialCruiseAltitude, stepSizeAltitude, climbThrustMode, selCruiseCas, selCruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
            this.simulateCruise(lateralLegs, verticalPlan, verticalPathEntry, costIndex, initialCruiseAltitude, climbThrustMode, selCruiseCas, selCruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, currentAltitude, activeLegIndex, activeDistanceToLegEnd, currentWeight, lastSimulatedLegIndex, engineCount);
            let needResetComputedDescentData = true;
            // If there exists at least one descent constraint, then we need to simulate the performance descent.
            if (firstDescentConstraintIndex >= 0) {
                const firstDescentConstraintAltitude = firstDescentConstraint.legs[0].altitude;
                if (isFinite(firstDescentConstraintAltitude)) {
                    const finalCruiseAltitude = (_e = (_d = verticalPath.cruiseSteps[verticalPath.cruiseSteps.length - 1]) === null || _d === void 0 ? void 0 : _d.toAltitude) !== null && _e !== void 0 ? _e : initialCruiseAltitude;
                    if (finalCruiseAltitude > firstDescentConstraintAltitude) {
                        // Cruise altitude is above the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist of a level deceleration segment + an idle descent segment that
                        // intercepts the geometric descent path at the first descent constraint.
                        this.computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, finalCruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
                    }
                    else {
                        // Cruise altitude is at or below the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist only of a level deceleration segment that intercepts the geometric
                        // descent path at some point past the first descent constraint. Alternatively, if the geometric descent
                        // path never descends below the cruise altitude, there will be no descent.
                        this.computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, finalCruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
                    }
                    needResetComputedDescentData = false;
                }
            }
            if (needResetComputedDescentData) {
                this.resetVerticalPathComputedDescentData(verticalPathEntry);
            }
            // Compute predicted cruise distance and duration. Both values require a computed TOC and TOD. If the TOD is
            // before the TOC, then clamp the values to zero.
            if (verticalPath.tocLegIndex !== undefined && verticalPath.tocVectorIndex !== undefined
                && verticalPath.todLegIndex !== undefined && verticalPath.todVectorIndex !== undefined) {
                verticalPath.predictedCruiseDistance = 0;
                verticalPath.predictedCruiseDuration = 0;
                for (let i = verticalPath.tocLegIndex; i <= verticalPath.todLegIndex; i++) {
                    const leg = verticalPath.legs[i];
                    const vectorStartIndex = i === verticalPath.tocLegIndex ? verticalPath.tocVectorIndex + 1 : 0;
                    const vectorEndIndex = i === verticalPath.todLegIndex ? verticalPath.todVectorIndex : leg.vectors.length;
                    for (let j = vectorStartIndex; j < vectorEndIndex; j++) {
                        const vector = leg.vectors[j];
                        verticalPath.predictedCruiseDistance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
                        verticalPath.predictedCruiseDuration += vector.duration;
                    }
                }
            }
            else {
                verticalPath.predictedCruiseDistance = undefined;
                verticalPath.predictedCruiseDuration = undefined;
            }
        }
        else {
            // We are past the calculated TOD. In this case, we will not recalculate the TOD. However, if we are still in
            // the performance descent segment, we need to adjust the vertical path vectors to account for any changes in
            // lateral leg distances.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && (activeLegIndex < verticalPath.geoDescentSimInterceptLegIndex
                    || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex
                        && activeDistanceToLegEnd > verticalPath.geoDescentSimInterceptDistanceToLegEnd))) {
                this.adjustPerformanceDescent(lateralLegs, verticalPath);
            }
            // If we are past the TOD, then predicted cruise distance and duration are undefined.
            verticalPath.predictedCruiseDistance = undefined;
            verticalPath.predictedCruiseDuration = undefined;
        }
        if (maprStartLegIndex < 0 || activeLegIndex < maprStartLegIndex) {
            // We are not in the missed approach.
            this.simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
        }
    }
    /**
     * Clears a vertical flight path of all vectors and resets all computed data stored in the path.
     * @param verticalPathEntry The entry for the vertical flight path to clear.
     */
    clearVerticalPath(verticalPathEntry) {
        const verticalPath = verticalPathEntry.path;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            leg.vectors.length = 0;
            leg.simDistance = 0;
        }
        verticalPath.cruiseSteps.length = 0;
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocVectorIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.predictedCruiseDistance = undefined;
        verticalPath.predictedCruiseDuration = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todVectorIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptVectorIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        verticalPathEntry.lastTocLegIndex = undefined;
        verticalPathEntry.lastTocDistanceToLegEnd = undefined;
        verticalPathEntry.isTocSequenced = false;
        verticalPathEntry.lastCruiseStepStartLegIndex = undefined;
        verticalPathEntry.lastCruiseStepStartDistanceToLegEnd = undefined;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Resets stored computed TOD and descent data in a vertical flight path.
     * @param verticalPathEntry The entry for the vertical flight path to reset.
     */
    resetVerticalPathComputedDescentData(verticalPathEntry) {
        const verticalPath = verticalPathEntry.path;
        verticalPath.todLegIndex = undefined;
        verticalPath.todVectorIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptVectorIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
    }
    /**
     * Gets the name of the method in {@link BoeingEngineDataProvider} that provides the target climb N1 for a given
     * climb thrust mode.
     * @param mode The climb thrust mode for which to get the N1 method name.
     * @returns The name of the method in {@link BoeingEngineDataProvider} that provides the target climb N1 for the
     * specified climb thrust mode.
     */
    getClimbN1MethodName(mode) {
        switch (mode) {
            case ClimbThrustMode.CLB1:
                return 'getClb1N1';
            case ClimbThrustMode.CLB2:
                return 'getClb2N1';
            default:
                return 'getClbMaxN1';
        }
    }
    /**
     * Calculates cruise steps for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation.
     * @param costIndex The cost index to use when converting time cost to fuel equivalents, in (dollars per hour) per
     * (cents per pound of fuel).
     * @param cruiseAltitude The initial cruise altitude, in meters above MSL.
     * @param stepSize The cruise step size, in meters.
     * @param climbThrustMode The climb thrust mode to use during step climbs.
     * @param selCruiseCas The selected cruise calibrated airspeed, in meters per second, or `null` if there is no such
     * speed.
     * @param selCruiseMach The selected cruise mach number, or `null` if there is no such speed.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    computeCruiseSteps(lateralLegs, verticalPlan, verticalPathEntry, costIndex, cruiseAltitude, stepSize, climbThrustMode, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        var _x, _y;
        const verticalPath = verticalPathEntry.path;
        const plannedCruiseSteps = this._getPlannedCruiseStepList(verticalPlan.planIndex);
        const activePlannedCruiseStepIndex = this.getNextPlannedCruiseStepIndex(verticalPlan.planIndex, activeLegIndex);
        const cruiseSteps = verticalPath.cruiseSteps;
        let startLegIndex = activeLegIndex;
        let startDistanceToLegEnd = activeDistanceToLegEnd;
        let startWeight = activeWeight;
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight) {
            startLegIndex = verticalPath.tocLegIndex;
            startDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
            startWeight = verticalPath.tocWeight;
        }
        let startLeg = lateralLegs[startLegIndex];
        while (startLegIndex < lateralLegs.length - 1 && startDistanceToLegEnd <= 0) {
            startLegIndex++;
            startLeg = lateralLegs[startLegIndex];
            startDistanceToLegEnd = (_b = (_a = startLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
        }
        let startPlannedCruiseStepIndex = activePlannedCruiseStepIndex;
        // Invalidate all planned cruise steps between the active leg and the starting leg.
        if (activePlannedCruiseStepIndex >= 0) {
            for (let i = activePlannedCruiseStepIndex; i < plannedCruiseSteps.length; i++) {
                const step = plannedCruiseSteps[i];
                if (step.globalLegIndex < startLegIndex) {
                    step.isInvalid = true;
                    step.deferredDistance = 0;
                }
                else {
                    startPlannedCruiseStepIndex = i;
                    break;
                }
            }
        }
        // Remove all cruise steps before the last-calculated TOC (or the airplane's along-track position if the
        // last-calculated TOC is undefined).
        let lastTocLegIndex;
        let lastTocDistanceToLegEnd;
        if (verticalPathEntry.lastTocLegIndex !== undefined && verticalPathEntry.lastTocDistanceToLegEnd !== undefined) {
            lastTocLegIndex = verticalPathEntry.lastTocLegIndex;
            lastTocDistanceToLegEnd = verticalPathEntry.lastTocDistanceToLegEnd;
        }
        else {
            lastTocLegIndex = activeLegIndex;
            lastTocDistanceToLegEnd = activeDistanceToLegEnd;
        }
        let startCruiseStepIndex = cruiseSteps.length;
        for (let i = 0; i < cruiseSteps.length; i++) {
            const step = cruiseSteps[i];
            if (step.globalLegIndex > lastTocLegIndex
                || (step.globalLegIndex === lastTocLegIndex && step.distanceToLegEnd < lastTocDistanceToLegEnd)) {
                startCruiseStepIndex = i;
                break;
            }
        }
        if (startCruiseStepIndex > 0) {
            cruiseSteps.splice(0, startCruiseStepIndex);
        }
        // Find the index at which to start writing cruise steps. We want to preserve all cruise steps between the
        // last-calculated TOC and the starting position.
        startCruiseStepIndex = cruiseSteps.length;
        for (let i = 0; i < cruiseSteps.length; i++) {
            const step = cruiseSteps[i];
            if (step.globalLegIndex > startLegIndex
                || (step.globalLegIndex === startLegIndex && step.distanceToLegEnd < startDistanceToLegEnd)) {
                startCruiseStepIndex = i;
                break;
            }
        }
        const endLegIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? ((_c = verticalPlan.missedApproachStartIndex) !== null && _c !== void 0 ? _c : lateralLegs.length)
            : verticalPlan.firstDescentConstraintLegIndex + 1;
        // If we are already past the last eligible leg to be simulated or there are no potential future cruise steps,
        // then we don't need to proceed any further.
        if (startLegIndex >= endLegIndex || (startPlannedCruiseStepIndex < 0 && stepSize === 0)) {
            // Invalidate all planned cruise steps after the starting leg.
            if (startPlannedCruiseStepIndex >= 0) {
                for (let i = startPlannedCruiseStepIndex; i < plannedCruiseSteps.length; i++) {
                    const step = plannedCruiseSteps[i];
                    step.isInvalid = true;
                    step.deferredDistance = 0;
                }
            }
            // Remove all cruise steps after the starting leg.
            cruiseSteps.length = startCruiseStepIndex;
            return;
        }
        const wingArea = this.perfProvider.getWingArea();
        const climbN1MethodName = this.getClimbN1MethodName(climbThrustMode);
        let distanceToEnd = startDistanceToLegEnd;
        for (let i = startLegIndex + 1; i < endLegIndex; i++) {
            distanceToEnd += (_e = (_d = lateralLegs[i].calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
        }
        let distanceFromLastCruiseStepStart = 0;
        let lastCruiseStepStartLegIndex;
        let lastCruiseStepStartDistanceToLegEnd;
        // Set the position of the start of the last cruise step to (in order of decreasing priority):
        // 1. The most recently sequenced predicted cruise step evaluated from the starting position. Such a cruise step is
        // guaranteed to be at or after the most recently initiated cruise step because initiating a cruise step clears
        // all predicted cruise steps.
        // 2. The point at which the most recent cruise step was initiated.
        // 3. The TOC.
        //
        // Additionally, set the starting cruise altitude to the target altitude of the sequenced predicted cruise step if
        // one exists.
        const lastCruiseStep = cruiseSteps[startCruiseStepIndex - 1];
        if (lastCruiseStep) {
            lastCruiseStepStartLegIndex = lastCruiseStep.globalLegIndex;
            lastCruiseStepStartDistanceToLegEnd = lastCruiseStep.distanceToLegEnd;
            cruiseAltitude = lastCruiseStep.toAltitude;
        }
        else if (verticalPathEntry.lastCruiseStepStartLegIndex !== undefined && verticalPathEntry.lastCruiseStepStartDistanceToLegEnd !== undefined) {
            lastCruiseStepStartLegIndex = verticalPathEntry.lastCruiseStepStartLegIndex;
            lastCruiseStepStartDistanceToLegEnd = verticalPathEntry.lastCruiseStepStartDistanceToLegEnd;
        }
        else {
            lastCruiseStepStartLegIndex = lastTocLegIndex;
            lastCruiseStepStartDistanceToLegEnd = lastTocDistanceToLegEnd;
        }
        if (lastCruiseStepStartLegIndex < startLegIndex) {
            distanceFromLastCruiseStepStart = lastCruiseStepStartDistanceToLegEnd;
            for (let i = lastCruiseStepStartLegIndex + 1; i < startLegIndex; i++) {
                distanceFromLastCruiseStepStart += (_g = (_f = lateralLegs[i].calculated) === null || _f === void 0 ? void 0 : _f.distanceWithTransitions) !== null && _g !== void 0 ? _g : 0;
            }
            distanceFromLastCruiseStepStart += ((_j = (_h = startLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0) - startDistanceToLegEnd;
        }
        else if (lastCruiseStepStartLegIndex === startLegIndex) {
            distanceFromLastCruiseStepStart = Math.max(0, lastCruiseStepStartDistanceToLegEnd - startDistanceToLegEnd);
        }
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        const isSelCruiseSpeed = selCruiseCas !== null || selCruiseMach !== null;
        let currentAltitude = cruiseAltitude;
        let targetAltitude = cruiseAltitude;
        let currentLegIndex = startLegIndex;
        let currentLeg = startLeg;
        let currentLegDistance = (_l = (_k = startLeg.calculated) === null || _k === void 0 ? void 0 : _k.distanceWithTransitions) !== null && _l !== void 0 ? _l : 0;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentWeight = startWeight;
        let nextPlannedCruiseStepIndex = startPlannedCruiseStepIndex;
        let nextPlannedCruiseStep = plannedCruiseSteps[nextPlannedCruiseStepIndex];
        let currentPlannedCruiseStepIndex = -1;
        let currentPlannedCruiseStep = undefined;
        let currentPlannedCruiseStepDeferredDistance = 0;
        let currentCruiseStepIndex = startCruiseStepIndex;
        let hasInitiatedStepDescent = false;
        let distanceToNextEvaluatePoint = Infinity;
        if (!nextPlannedCruiseStep) {
            distanceToNextEvaluatePoint = BoeingPathCalculator.CRUISE_STEP_START_MARGIN - distanceFromLastCruiseStepStart;
            if (distanceToNextEvaluatePoint < 0) {
                distanceToNextEvaluatePoint += Math.ceil(-distanceToNextEvaluatePoint / BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP) * BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP;
            }
        }
        let isLastValidPlannedCruiseStepDescend = false;
        if (startCruiseStepIndex > 0) {
            const lastSequencedCruiseStep = cruiseSteps[startCruiseStepIndex - 1];
            isLastValidPlannedCruiseStepDescend = lastSequencedCruiseStep.plannedStepIndex >= 0 && lastSequencedCruiseStep.toAltitude < lastSequencedCruiseStep.fromAltitude;
        }
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // This is a very rough approximation, but our margins are large enough (hundreds of NM) to cushion the expected
        // error.
        let descentDistance = firstDescentConstraint
            ? VNavUtils.distanceForAltitude(-3, Math.min(firstDescentConstraint.legs[0].altitude, cruiseAltitude) - cruiseAltitude)
            : 0;
        let currentCruiseCas = selCruiseCas !== null && selCruiseCas !== void 0 ? selCruiseCas : Infinity;
        let currentCruiseMach = selCruiseMach !== null && selCruiseMach !== void 0 ? selCruiseMach : Infinity;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let legCourse = undefined;
        let legCourseIndex = undefined;
        let windDirection = undefined;
        let windSpeed = undefined;
        let headwind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        let lastWeatherAltitude = currentAltitude;
        while (distanceToEnd - descentDistance > BoeingPathCalculator.CRUISE_STEP_TOD_MARGIN && currentLegIndex < endLegIndex) {
            // ---- Update planned cruise step ----
            if (nextPlannedCruiseStep && currentLegIndex > nextPlannedCruiseStep.globalLegIndex) {
                if (currentPlannedCruiseStep) {
                    // If we still have not been able to execute the current planned cruise step, then invalidate it.
                    currentPlannedCruiseStep.isInvalid = true;
                    currentPlannedCruiseStep.deferredDistance = 0;
                }
                currentPlannedCruiseStepIndex = nextPlannedCruiseStepIndex;
                currentPlannedCruiseStep = nextPlannedCruiseStep;
                currentPlannedCruiseStepDeferredDistance = 0;
                nextPlannedCruiseStep = plannedCruiseSteps[++nextPlannedCruiseStepIndex];
            }
            // ---- Update speed constraint ----
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (currentLegDistance > 0) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // ---- Update average leg course ----
                if (legCourseIndex !== currentLegIndex) {
                    legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    legCourseIndex = currentLegIndex;
                }
                // ---- Compute ambient conditions ----
                // Check if we need to update winds and delta ISA offset.
                if (currentLegIndex !== lastWeatherLegIndex || Math.abs(currentAltitude - lastWeatherAltitude) > 30.48) {
                    const windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, currentLegDistance - distanceToLegEnd, BoeingPathCalculator.windCache);
                    if (windVector !== null) {
                        [windDirection, windSpeed] = windVector;
                        if (legCourse !== undefined) {
                            headwind = -BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windDirection, windSpeed);
                        }
                        else {
                            headwind = 0;
                        }
                    }
                    else {
                        windDirection = undefined;
                        windSpeed = undefined;
                        headwind = 0;
                    }
                    deltaIsa = (_m = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, currentLegDistance - distanceToLegEnd)) !== null && _m !== void 0 ? _m : 0;
                    lastWeatherLegIndex = currentLegIndex;
                    lastWeatherAltitude = currentAltitude;
                }
                const pressure = AeroMath.isaPressure(currentAltitude);
                const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
                const density = AeroMath.densityAir(pressure, temperature);
                const soundSpeed = AeroMath.soundSpeedAir(temperature);
                // ---- Compute the current simulation step's target speed ----
                if (!isSelCruiseSpeed) {
                    [currentCruiseCas, currentCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, currentAltitudeFeet, currentWeight, headwind, BoeingPathCalculator.econSpeedCache, pressure);
                    currentCruiseCas = UnitType.KNOT.convertTo(currentCruiseCas, UnitType.MPS);
                }
                // Initiating a step descent will remove transition and restriction speed limits if stepping below their
                // respective altitudes, so neither speed limit will ever be in effect after a step descent (unless the pilot
                // takes action to restore them, but for the purposes of the simulation we will assume this doesn't happen).
                const useTransitionCas = canUseTransitionCas && !hasInitiatedStepDescent && currentAltitude < transitionAltitude;
                const useRestrictionCas = canUseRestrictionCas && !hasInitiatedStepDescent && currentAltitude < restrictionAltitude;
                const targetCas = BoeingPathCalculator.getTargetCas(currentCruiseCas, currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined);
                const targetMach = BoeingPathCalculator.getTargetMach(currentCruiseMach, currentSpeedConstraint);
                const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
                let mach = AeroMath.casToMach(casToTarget, pressure);
                let tas = AeroMath.machToTas(mach, soundSpeed);
                const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
                let cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                // ---- Evaluate planned cruise steps ----
                let targetAltitudeFeet;
                let pressureAtTarget;
                let temperatureAtTarget;
                let machAtTarget;
                if (targetAltitude === currentAltitude && currentPlannedCruiseStep) {
                    let executedPlannedStepIndex = -1;
                    if (currentPlannedCruiseStep.toAltitude !== currentAltitude) {
                        if (currentPlannedCruiseStep.toAltitude > currentAltitude) {
                            // If the current planned cruise step steps to a higher altitude, then we need to check if we can climb
                            // to the target altitude.
                            const maxAltitude = this.engineDataProvider.getMaximumAltitude(currentWeight);
                            targetAltitudeFeet = UnitType.METER.convertTo(targetAltitude, UnitType.FOOT);
                            if (targetAltitudeFeet <= maxAltitude) {
                                pressureAtTarget = AeroMath.isaPressure(targetAltitude);
                                temperatureAtTarget = AeroMath.isaTemperature(targetAltitude)
                                    + ((_o = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, targetAltitudeFeet, currentLegDistance - distanceToLegEnd)) !== null && _o !== void 0 ? _o : 0);
                                let targetCruiseCas = currentCruiseCas;
                                let targetCruiseMach = currentCruiseMach;
                                if (!isSelCruiseSpeed) {
                                    [targetCruiseCas, targetCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, targetAltitudeFeet, currentWeight, 0, BoeingPathCalculator.econSpeedCache, pressureAtTarget);
                                    targetCruiseCas = UnitType.KNOT.convertTo(targetCruiseCas, UnitType.MPS);
                                }
                                machAtTarget = Math.min(AeroMath.casToMach(BoeingPathCalculator.getTargetCas(targetCruiseCas, currentSpeedConstraint, canUseRestrictionCas && targetAltitude < restrictionAltitude ? restrictionCas : undefined, canUseTransitionCas && targetAltitude < transitionAltitude ? transitionCas : undefined), pressureAtTarget), BoeingPathCalculator.getTargetMach(targetCruiseMach, currentSpeedConstraint));
                                const residualVs = this.getClimbVerticalSpeed(climbN1MethodName, targetAltitude, wingArea, pressureAtTarget, temperatureAtTarget, machAtTarget, currentWeight, engineCount);
                                if (residualVs >= BoeingPathCalculator.CRUISE_STEP_CLIMB_RESIDUAL_VS_MPS) {
                                    executedPlannedStepIndex = currentPlannedCruiseStepIndex;
                                    currentPlannedCruiseStep.isInvalid = false;
                                    currentPlannedCruiseStep.deferredDistance = currentPlannedCruiseStepDeferredDistance;
                                    targetAltitude = currentPlannedCruiseStep.toAltitude;
                                    currentPlannedCruiseStepIndex = -1;
                                    currentPlannedCruiseStep = undefined;
                                }
                            }
                        }
                        else {
                            executedPlannedStepIndex = currentPlannedCruiseStepIndex;
                            currentPlannedCruiseStep.isInvalid = false;
                            currentPlannedCruiseStep.deferredDistance = currentPlannedCruiseStepDeferredDistance;
                            targetAltitude = currentPlannedCruiseStep.toAltitude;
                            currentPlannedCruiseStepIndex = -1;
                            currentPlannedCruiseStep = undefined;
                        }
                    }
                    else {
                        // If the current planned cruise step steps to the current altitude, then there is nothing to do except
                        // validate the cruise step.
                        currentPlannedCruiseStep.isInvalid = false;
                        currentPlannedCruiseStep.deferredDistance = 0;
                        currentPlannedCruiseStepIndex = -1;
                        currentPlannedCruiseStep = undefined;
                    }
                    if (executedPlannedStepIndex >= 0) {
                        const step = (_p = cruiseSteps[_x = currentCruiseStepIndex++]) !== null && _p !== void 0 ? _p : (cruiseSteps[_x] = BoeingPathCalculator.createCruiseStep());
                        step.globalLegIndex = currentLegIndex;
                        step.distanceToLegEnd = distanceToLegEnd;
                        step.fromAltitude = currentAltitude;
                        step.toAltitude = plannedCruiseSteps[executedPlannedStepIndex].toAltitude;
                        step.plannedStepIndex = executedPlannedStepIndex;
                        isLastValidPlannedCruiseStepDescend = step.toAltitude < step.fromAltitude;
                    }
                }
                // ---- Evaluate computed cruise steps ----
                // Computed cruise steps can only be evaluated after we have sequenced all planned cruise steps.
                if (!nextPlannedCruiseStep && !currentPlannedCruiseStep) {
                    if (stepSize <= 0 || isLastValidPlannedCruiseStepDescend) {
                        // If the step size is zero or the last valid planned cruise step was a step descent, then immediately exit
                        // the loop because we will not be evaluating any computed cruise steps.
                        break;
                    }
                    else if (
                    // To evaluate computed cruise steps...
                    // ... we must not be stepping to a different cruise altitude...
                    targetAltitude === currentAltitude
                        // ... and we must be at or past the next evaluation point.
                        && distanceToNextEvaluatePoint < 1) {
                        const simulateDistance = Math.min(distanceToEnd, BoeingPathCalculator.CRUISE_STEP_EVALUATE_LOOKAHEAD);
                        const currentAltitudeCost = this.evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, currentAltitude, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, currentLegIndex, distanceToLegEnd, currentWeight, endLegIndex, simulateDistance, engineCount);
                        // Evaluate all cruise altitudes we can step to from the current altitude from 9000 below the current
                        // altitude to the maximum cruise altitude.
                        // TODO: Determine if we need to limit the number of evaluated steps to e.g. 2 below + 2 above for perf reasons.
                        let recommendedAltitude = currentAltitude;
                        let recommendedAltitudeCost = currentAltitudeCost;
                        const minAltitude = Math.max(0, currentAltitude - 2743.2);
                        const maxAltitude = UnitType.FOOT.convertTo(this.engineDataProvider.getMaximumAltitude(currentWeight), UnitType.METER);
                        // Step descents.
                        let evaluateAltitude = currentAltitude - stepSize;
                        while (evaluateAltitude >= minAltitude) {
                            const evaluateAltitudeCost = this.evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, evaluateAltitude, selCruiseCas, selCruiseMach, 
                            // Initiating a step descent will remove transition and restriction speed limits if stepping below
                            // their respective altitudes, so neither speed limit will ever be in effect after a step descent
                            // (unless the pilot takes action to restore them, but for the purposes of the simulation we will
                            // assume this doesn't happen).
                            null, null, null, null, currentLegIndex, distanceToLegEnd, currentWeight, endLegIndex, simulateDistance, engineCount) + Math.abs(evaluateAltitude - currentAltitude) * this.cruiseStepCostBias;
                            if (evaluateAltitudeCost < recommendedAltitudeCost) {
                                recommendedAltitude = evaluateAltitude;
                                recommendedAltitudeCost = evaluateAltitudeCost;
                            }
                            evaluateAltitude -= stepSize;
                        }
                        // Step climbs.
                        evaluateAltitude = currentAltitude + stepSize;
                        while (evaluateAltitude <= maxAltitude) {
                            const pressureAtEval = AeroMath.isaPressure(evaluateAltitude);
                            const temperatureAtEval = AeroMath.isaTemperature(evaluateAltitude)
                                + ((_q = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, UnitType.METER.convertTo(evaluateAltitude, UnitType.FOOT), currentLegDistance - distanceToLegEnd)) !== null && _q !== void 0 ? _q : 0);
                            let evalCruiseCas = currentCruiseCas;
                            let evalCruiseMach = currentCruiseMach;
                            if (!isSelCruiseSpeed) {
                                [evalCruiseCas, evalCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, UnitType.METER.convertTo(evaluateAltitude, UnitType.FOOT), currentWeight, 0, BoeingPathCalculator.econSpeedCache, pressureAtEval);
                                evalCruiseCas = UnitType.KNOT.convertTo(evalCruiseCas, UnitType.MPS);
                            }
                            const machAtEval = Math.min(AeroMath.casToMach(BoeingPathCalculator.getTargetCas(evalCruiseCas, currentSpeedConstraint, canUseRestrictionCas && evaluateAltitude < restrictionAltitude ? restrictionCas : undefined, canUseTransitionCas && evaluateAltitude < transitionAltitude ? transitionCas : undefined), pressureAtEval), BoeingPathCalculator.getTargetMach(evalCruiseMach, currentSpeedConstraint));
                            const residualVs = this.getClimbVerticalSpeed(climbN1MethodName, evaluateAltitude, wingArea, pressureAtEval, temperatureAtEval, machAtEval, currentWeight, engineCount);
                            if (residualVs < BoeingPathCalculator.CRUISE_STEP_CLIMB_RESIDUAL_VS_MPS) {
                                break;
                            }
                            const evaluateAltitudeCost = this.evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, evaluateAltitude, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, currentLegIndex, distanceToLegEnd, currentWeight, endLegIndex, simulateDistance, engineCount) + Math.abs(evaluateAltitude - currentAltitude) * this.cruiseStepCostBias;
                            if (evaluateAltitudeCost < recommendedAltitudeCost) {
                                recommendedAltitude = evaluateAltitude;
                                recommendedAltitudeCost = evaluateAltitudeCost;
                            }
                            evaluateAltitude += stepSize;
                        }
                        if (recommendedAltitude !== currentAltitude) {
                            targetAltitude = recommendedAltitude;
                            const step = (_r = cruiseSteps[_y = currentCruiseStepIndex++]) !== null && _r !== void 0 ? _r : (cruiseSteps[_y] = BoeingPathCalculator.createCruiseStep());
                            step.globalLegIndex = currentLegIndex;
                            step.distanceToLegEnd = distanceToLegEnd;
                            step.fromAltitude = currentAltitude;
                            step.toAltitude = recommendedAltitude;
                            step.plannedStepIndex = -1;
                        }
                        else {
                            distanceToNextEvaluatePoint = BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP;
                        }
                    }
                }
                // ---- Compute simulation step deltas ----
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windDirection !== undefined && windSpeed !== undefined && legCourse !== undefined) {
                    wind = Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windDirection, windSpeed, tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                }
                let gs = tas + wind;
                let distanceStep;
                let altitudeStep;
                let engineFuelFlow;
                if (targetAltitude === currentAltitude) {
                    // We are currently holding the current cruise altitude.
                    distanceStep = distanceToNextEvaluatePoint;
                    altitudeStep = 0;
                    const engineGrossThrust = this.perfProvider.getLevelFlightRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, mach, 0, engineCount);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                else {
                    // We are currently climbing or descending to another cruise altitude.
                    let vs;
                    let engineGrossThrust;
                    if (targetAltitude > currentAltitude) {
                        targetAltitudeFeet !== null && targetAltitudeFeet !== void 0 ? targetAltitudeFeet : (targetAltitudeFeet = UnitType.METER.convertTo(targetAltitude, UnitType.FOOT));
                        pressureAtTarget !== null && pressureAtTarget !== void 0 ? pressureAtTarget : (pressureAtTarget = AeroMath.isaPressure(targetAltitude));
                        temperatureAtTarget !== null && temperatureAtTarget !== void 0 ? temperatureAtTarget : (temperatureAtTarget = AeroMath.isaTemperature(targetAltitude)
                            + ((_s = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, targetAltitudeFeet, currentLegDistance - distanceToLegEnd)) !== null && _s !== void 0 ? _s : 0));
                        if (machAtTarget === undefined) {
                            let targetCruiseCas = currentCruiseCas;
                            let targetCruiseMach = currentCruiseMach;
                            if (!isSelCruiseSpeed) {
                                [targetCruiseCas, targetCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, UnitType.METER.convertTo(targetAltitudeFeet, UnitType.FOOT), currentWeight, 0, BoeingPathCalculator.econSpeedCache, pressureAtTarget);
                                targetCruiseCas = UnitType.KNOT.convertTo(targetCruiseCas, UnitType.MPS);
                            }
                            machAtTarget = Math.min(AeroMath.casToMach(BoeingPathCalculator.getTargetCas(targetCruiseCas, currentSpeedConstraint, canUseRestrictionCas && targetAltitude < restrictionAltitude ? restrictionCas : undefined, canUseTransitionCas && targetAltitude < transitionAltitude ? transitionCas : undefined), pressureAtTarget), BoeingPathCalculator.getTargetMach(targetCruiseMach, currentSpeedConstraint));
                        }
                        const temperatureK = temperature + 273.15;
                        const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(currentAltitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                        const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                        engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                        const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                        const currentVs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), 0);
                        const vsAtTarget = this.getClimbVerticalSpeed(climbN1MethodName, targetAltitude, wingArea, pressureAtTarget, temperatureAtTarget, machAtTarget, currentWeight, engineCount);
                        vs = Math.max((currentVs + vsAtTarget) / 2, BoeingPathCalculator.MIN_CLIMB_VS_MPS);
                    }
                    else {
                        hasInitiatedStepDescent = true;
                        // Transition and restriction speed limits are never in effect after a step descent is initiated, so if we
                        // had previously used them, we need to recalculate our speeds.
                        if (useTransitionCas || useRestrictionCas) {
                            const newTargetCas = BoeingPathCalculator.getTargetCas(currentCruiseCas, currentSpeedConstraint);
                            mach = Math.min(targetMach, AeroMath.casToMach(newTargetCas, pressure));
                            tas = AeroMath.machToTas(mach, soundSpeed);
                            cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                            if (windDirection !== undefined && windSpeed !== undefined && legCourse !== undefined) {
                                wind = Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windDirection, windSpeed, tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                            }
                            gs = tas + wind;
                        }
                        vs = BoeingPathCalculator.CRUISE_DESCENT_VS_MPS;
                        engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                    }
                    altitudeStep = targetAltitude - currentAltitude;
                    distanceStep = altitudeStep / vs * gs;
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the simulation step. If so, end the simulation
                // step at the end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                const tolerance = targetAltitude !== currentAltitude ? 1 : BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP_TOL;
                if (distanceStep >= distanceToLegEnd - tolerance) {
                    if (altitudeStep !== 0) {
                        altitudeStep = MathUtils.lerp(distanceToLegEnd, 0, distanceStep, 0, altitudeStep, true, true);
                    }
                    distanceStep = distanceToLegEnd;
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const timeStep = distanceStep / gs;
                distanceToEnd -= distanceStep;
                distanceToLegEnd -= distanceStep;
                distanceToNextEvaluatePoint -= distanceStep;
                currentAltitude += altitudeStep;
                if (altitudeStep !== 0 && Math.abs(targetAltitude - currentAltitude) < 1) {
                    currentAltitude = targetAltitude;
                    if (!currentPlannedCruiseStep && !nextPlannedCruiseStep) {
                        distanceToNextEvaluatePoint = BoeingPathCalculator.CRUISE_STEP_START_MARGIN;
                    }
                    // This is a very rough approximation, but our margins are large enough (hundreds of NM) to cushion the expected
                    // error.
                    descentDistance = firstDescentConstraint
                        ? VNavUtils.distanceForAltitude(-3, Math.min(firstDescentConstraint.legs[0].altitude, currentAltitude) - currentAltitude)
                        : 0;
                }
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                if (currentPlannedCruiseStep) {
                    currentPlannedCruiseStepDeferredDistance += distanceStep;
                }
                if (advanceLegIndexTo !== undefined) {
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[currentLegIndex];
                    currentLegDistance = (_u = (_t = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _t === void 0 ? void 0 : _t.distanceWithTransitions) !== null && _u !== void 0 ? _u : 0;
                    distanceToLegEnd = currentLegDistance;
                }
            }
            else {
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                currentLegDistance = (_w = (_v = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _v === void 0 ? void 0 : _v.distanceWithTransitions) !== null && _w !== void 0 ? _w : 0;
                distanceToLegEnd = currentLegDistance;
            }
        }
        // Invalidate all planned cruise steps after the end.
        if (nextPlannedCruiseStepIndex >= 0) {
            for (let i = nextPlannedCruiseStepIndex; i < plannedCruiseSteps.length; i++) {
                const step = plannedCruiseSteps[i];
                step.isInvalid = true;
                step.deferredDistance = 0;
            }
        }
        cruiseSteps.length = currentCruiseStepIndex;
    }
    /**
     * Gets the estimated vertical speed achievable during a climb, in meters per second.
     * @param climbN1MethodName The name of the method in {@link BoeingEngineDataProvider} which provides the target
     * engine N1 during the climb.
     * @param altitude The altitude of the climb, in meters above MSL.
     * @param wingArea The airplane's wing area, in square meters.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @param mach The mach number during the climb.
     * @param weight The weight of the airplane, in pounds.
     * @param engineCount The number of operational engines.
     * @returns The estimated vertical speed achievable during a climb with the specified parameters, in meters per
     * second.
     */
    getClimbVerticalSpeed(climbN1MethodName, altitude, wingArea, pressure, temperature, mach, weight, engineCount) {
        const tas = AeroMath.machToTas(mach, AeroMath.soundSpeedAir(temperature));
        const cl = AeroMath.liftCoefficient(UnitType.POUND_FORCE.convertTo(weight, UnitType.NEWTON), wingArea, AeroMath.densityAir(pressure, temperature), tas);
        const temperatureK = temperature + 273.15;
        const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(altitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
        const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
        const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
        const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
        return this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, weight, cl, tas, 0);
    }
    /**
     * Evaluates the estimated cost, in pounds of fuel per nautical mile, of cruising at a given altitude.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param costIndex The cost index to use when converting time cost to fuel equivalents, in (dollars per hour) per
     * (cents per pound of fuel).
     * @param cruiseAltitude The cruise altitude to simulate, in meters above MSL.
     * @param selCruiseCas The selected cruise calibrated airspeed, in meters per second, or `null` if there is no such
     * speed.
     * @param selCruiseMach The selected cruise mach number, or `null` if there is no such speed.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param startLegIndex The global index of the flight plan leg containing the point at which to start the
     * simulation.
     * @param startDistanceToLegEnd The along-track distance, in meters, from the simulation start point to the end of
     * its containing leg.
     * @param startWeight The weight of the airplane at the start of the simulation, in pounds.
     * @param endLegIndex The global index of the last flight plan leg eligible for simulation, exclusive.
     * @param distanceToSimulate The total along-track distance to simulate, in meters.
     * @param engineCount The number of operational engines to simulate.
     * @returns The estimated cost, in pounds of fuel per nautical mile, of cruising at the specified altitude with the
     * specified parameters.
     */
    evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, cruiseAltitude, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, distanceToSimulate, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g;
        const verticalPath = verticalPathEntry.path;
        const cruiseAltitudeFeet = UnitType.METER.convertTo(cruiseAltitude, UnitType.FOOT);
        const wingArea = this.perfProvider.getWingArea();
        let distanceToEnd = distanceToSimulate;
        const useTransitionCas = transitionAltitude !== null && transitionCas !== null && cruiseAltitude < transitionAltitude;
        const useRestrictionCas = restrictionAltitude !== null && restrictionCas !== null && cruiseAltitude < restrictionAltitude;
        const isSelCruiseSpeed = selCruiseCas !== null || selCruiseMach !== null;
        let currentLegIndex = startLegIndex;
        let currentLeg = lateralLegs[startLegIndex];
        let currentLegDistance = (_b = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentWeight = startWeight;
        let currentCruiseCas = selCruiseCas !== null && selCruiseCas !== void 0 ? selCruiseCas : Infinity;
        let currentCruiseMach = selCruiseMach !== null && selCruiseMach !== void 0 ? selCruiseMach : Infinity;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let legCourse = undefined;
        let legCourseIndex = undefined;
        let windVector = null;
        let headwind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        let totalFuelBurn = 0;
        let totalDuration = 0;
        while (distanceToEnd > 0 && currentLegIndex < endLegIndex) {
            // ---- Update speed constraint ----
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (currentLegDistance > 0) {
                // ---- Update average leg course ----
                if (legCourseIndex !== currentLegIndex) {
                    legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    legCourseIndex = currentLegIndex;
                }
                // ---- Compute ambient conditions ----
                // Check if we need to update winds and delta ISA offset.
                if (currentLegIndex !== lastWeatherLegIndex) {
                    const distanceAlongLeg = currentLegDistance - distanceToLegEnd;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache);
                    if (windVector !== null && legCourse !== undefined) {
                        headwind = -BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1]);
                    }
                    else {
                        headwind = 0;
                    }
                    deltaIsa = (_c = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg)) !== null && _c !== void 0 ? _c : 0;
                    lastWeatherLegIndex = currentLegIndex;
                }
                const pressure = AeroMath.isaPressure(cruiseAltitude);
                const temperature = AeroMath.isaTemperature(cruiseAltitude) + deltaIsa;
                const density = AeroMath.densityAir(pressure, temperature);
                const soundSpeed = AeroMath.soundSpeedAir(temperature);
                // ---- Compute the current simulation step's target speed ----
                if (!isSelCruiseSpeed) {
                    [currentCruiseCas, currentCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, cruiseAltitudeFeet, currentWeight, headwind, BoeingPathCalculator.econSpeedCache, pressure);
                    currentCruiseCas = UnitType.KNOT.convertTo(currentCruiseCas, UnitType.MPS);
                }
                const targetCas = BoeingPathCalculator.getTargetCas(currentCruiseCas, currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined);
                const targetMach = BoeingPathCalculator.getTargetMach(currentCruiseMach, currentSpeedConstraint);
                const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const wind = legCourse !== undefined && windVector
                    ? Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1], tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas)
                    : 0;
                const gs = tas + wind;
                const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                const engineGrossThrust = this.perfProvider.getLevelFlightRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, mach, 0, engineCount);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                let distanceStep = Math.min(BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP, distanceToEnd);
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd - BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP_TOL) {
                    distanceStep = distanceToLegEnd;
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const timeStep = distanceStep / gs;
                const fuelBurn = timeStep * engineFuelFlow * engineCount;
                distanceToEnd -= distanceStep;
                distanceToLegEnd -= distanceStep;
                totalFuelBurn += fuelBurn;
                totalDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - fuelBurn);
                if (advanceLegIndexTo !== undefined) {
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_e = (_d = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                }
            }
            else {
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                currentLegDistance = (_g = (_f = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _f === void 0 ? void 0 : _f.distanceWithTransitions) !== null && _g !== void 0 ? _g : 0;
                distanceToLegEnd = currentLegDistance;
            }
        }
        // Boeing cost formula: fuel(lb) + CI * 100 * time(hr).
        return (totalFuelBurn + costIndex * totalDuration / 36) / UnitType.METER.convertTo(distanceToSimulate - distanceToEnd, UnitType.NMILE);
    }
    /**
     * Calculates the top of descent and simulates the performance (off-idle) descent phase for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const firstDescentConstraintLegIndex = firstDescentConstraint.index;
        const targetAltitude = firstDescentConstraint.legs[0].altitude;
        // If cruise altitude is below the target altitude, then there is no performance descent path to be calculated (we
        // will transition immediately from cruise to geometric descent).
        if (cruiseAltitude <= targetAltitude) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        // If we have already sequenced the first descent constraint, then we are in the geometric descent segment and
        // there is no performance descent path to be calculated.
        if (activeLegIndex > firstDescentConstraintLegIndex) {
            // Set both the TOD and the geometric descent intercept point to be slightly behind the airplane's current
            // position. This will allow the geometric descent path to be properly calculated.
            const distanceToLegEnd = activeDistanceToLegEnd + 10;
            verticalPath.todLegIndex = activeLegIndex;
            verticalPath.todVectorIndex = 0;
            verticalPath.todDistanceToLegEnd = distanceToLegEnd;
            verticalPath.perfDescentTodDistance = 0;
            verticalPath.perfDescentSimDistance = 0;
            verticalPath.geoDescentInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentInterceptDistanceToLegEnd = distanceToLegEnd;
            verticalPath.geoDescentInterceptWeight = activeWeight;
            verticalPath.geoDescentSimInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentSimInterceptVectorIndex = -1;
            verticalPath.geoDescentSimInterceptDistanceToLegEnd = distanceToLegEnd;
            return;
        }
        const geoInterceptLegIndex = firstDescentConstraintLegIndex + 1;
        const geoInterceptConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, geoInterceptLegIndex);
        const geoInterceptConstraintTargetAltitude = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.targetAltitude;
        const geoInterceptLeg = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.legs[geoInterceptLegIndex - geoInterceptConstraint.index];
        const doesGeoInterceptLegStartLevel = geoInterceptLeg === undefined
            || geoInterceptLeg.fpa === 0
            || firstDescentConstraint.targetAltitude + 1 < geoInterceptLeg.altitude + VNavUtils.altitudeForDistance(geoInterceptLeg.fpa, geoInterceptLeg.distance);
        // Now we will iteratively solve for the TOD. In each iteration, we will choose a TOD along the flight path,
        // then simulate the entire performance descent segment down to the first descent constraint. If the lateral
        // distance covered brings us to within tolerance to the constraint fix, we are done. Otherwise, we adjust
        // the TOD by a lateral distance equal to the difference between the simulated lateral distance and the required
        // lateral distance and run another iteration.
        // If the performance descent was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use a crude estimate based on constant FPA.
        let estimatedTodDistanceFromFirstConstraint;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromFirstConstraint = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromFirstConstraint = VNavUtils.distanceForAltitude(-3, targetAltitude - cruiseAltitude);
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDescentDistance = estimatedTodDistanceFromFirstConstraint;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the first descent constraint fix to find the lateral position of the TOD
            // -----------------------------
            let todLegIndex = -1;
            let todLeg = undefined;
            let legIndex = firstDescentConstraintLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDescentDistance;
            while (legIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[legIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLegIndex = legIndex;
                    todLeg = leg;
                    todDistanceToLegEnd = distanceToGo;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                legIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs with non-zero distance before the first descent constraint.
                this.resetVerticalPathComputedDescentData(verticalPathEntry);
                return;
            }
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, doesGeoInterceptLegStartLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDescentDistance, todLegIndex, todDistanceToLegEnd, firstDescentConstraintLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDescentDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDescentDistance, prevEstimate);
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = firstDescentConstraintLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = 0;
    }
    /**
     * Calculates the top of descent and simulates the level deceleration segment for a flight plan in which the cruise
     * altitude intercepts the geometric descent path after the first descent altitude constraint.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        // Find the constraint that defines the vertical path we will intercept. This must be a non-flat constraint with a
        // target altitude lower than the cruise altitude.
        let constraintToIntercept = undefined;
        for (let i = firstDescentConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                break;
            }
            if (constraint.targetAltitude <= cruiseAltitude && constraint.fpa > 0) {
                constraintToIntercept = constraint;
                break;
            }
        }
        // If there is no constraint to intercept, then we will remain in cruise until the end of the flight plan.
        if (!constraintToIntercept) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        // Find the point along the flight plan at which the cruise altitude intercepts the geometric descent path.
        let distanceToIntercept = VNavUtils.distanceForAltitude(constraintToIntercept.fpa, cruiseAltitude - constraintToIntercept.targetAltitude);
        let interceptLegIndex = constraintToIntercept.index;
        let interceptDistanceToLegEnd = 0;
        let interceptLeg = lateralLegs[interceptLegIndex];
        while (interceptLeg && distanceToIntercept > 0) {
            const legDistance = interceptLeg.calculated ? interceptLeg.calculated.distanceWithTransitions : 0;
            if (legDistance > distanceToIntercept) {
                interceptDistanceToLegEnd = distanceToIntercept;
                break;
            }
            else {
                distanceToIntercept -= legDistance;
                interceptLeg = lateralLegs[--interceptLegIndex];
            }
        }
        // If we have already sequenced the point at which the cruise altitude intercepts the geometric descent path, then
        // we are already in the geometric descent segment and there is no performance descent path to calculate.
        if (activeLegIndex > interceptLegIndex
            || (activeLegIndex === interceptLegIndex
                && activeDistanceToLegEnd < interceptDistanceToLegEnd)) {
            // Set both the TOD and the geometric descent intercept point to be slightly behind the airplane's current
            // position. This will allow the geometric descent path to be properly calculated.
            const distanceToLegEnd = activeDistanceToLegEnd + 10;
            verticalPath.todLegIndex = activeLegIndex;
            verticalPath.todVectorIndex = 0;
            verticalPath.todDistanceToLegEnd = distanceToLegEnd;
            verticalPath.perfDescentTodDistance = 0;
            verticalPath.perfDescentSimDistance = 0;
            verticalPath.geoDescentInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentInterceptDistanceToLegEnd = distanceToLegEnd;
            verticalPath.geoDescentInterceptWeight = activeWeight;
            verticalPath.geoDescentSimInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentSimInterceptVectorIndex = -1;
            verticalPath.geoDescentSimInterceptDistanceToLegEnd = distanceToLegEnd;
            return;
        }
        // Now we will iteratively solve for the TOD, which in this context is the beginning of level deceleration.
        // If the level deceleration was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use an arbitrary estimate of 10km.
        let estimatedTodDistanceFromIntercept;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromIntercept = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromIntercept = 10000;
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDecelerationDistance = estimatedTodDistanceFromIntercept;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the intercept point to find the lateral position of the TOD
            // -----------------------------
            let todLegIndex = -1;
            let todLeg = undefined;
            let legIndex = interceptLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDecelerationDistance + interceptDistanceToLegEnd;
            while (legIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[legIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLegIndex = legIndex;
                    todLeg = leg;
                    todDistanceToLegEnd = distanceToGo;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                legIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs with non-zero distance before the intercept point.
                this.resetVerticalPathComputedDescentData(verticalPathEntry);
                return;
            }
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, cruiseAltitude, constraintToIntercept.targetAltitude, false, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDecelerationDistance, todLegIndex, todDistanceToLegEnd, interceptLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDecelerationDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDecelerationDistance, prevEstimate);
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = interceptLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = interceptDistanceToLegEnd;
    }
    /**
     * Adjusts the vertical flight path vectors in the performance (off-idle) descent to account for changes in lateral
     * flight plan leg distances since the vectors were simulated.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPath The vertical flight path containing the vectors to adjust.
     */
    adjustPerformanceDescent(lateralLegs, verticalPath) {
        var _a, _b, _c;
        if (verticalPath.todLegIndex === undefined
            || verticalPath.todDistanceToLegEnd === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined) {
            return;
        }
        let distanceCovered = verticalPath.todDistanceToLegEnd;
        const endLegIndex = Math.min(verticalPath.legs.length, verticalPath.geoDescentSimInterceptLegIndex + 1);
        for (let i = verticalPath.todLegIndex + 1; i < endLegIndex; i++) {
            const leg = verticalPath.legs[i];
            if (leg.vectors.length === 0) {
                continue;
            }
            const isInterceptLeg = i === verticalPath.geoDescentSimInterceptLegIndex;
            const endDistanceToLegEnd = isInterceptLeg ? verticalPath.geoDescentSimInterceptDistanceToLegEnd : 0;
            const lerpEndDistanceToLegEnd = Math.max(0, endDistanceToLegEnd);
            const newLegDistance = (_c = (_b = (_a = lateralLegs[i]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            for (let j = 0; j < leg.vectors.length; j++) {
                const vector = leg.vectors[j];
                if (isInterceptLeg && vector.simStartDistanceToLegEnd <= endDistanceToLegEnd) {
                    break;
                }
                vector.startDistanceToLegEnd = MathUtils.lerp(vector.simStartDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
                vector.endDistanceToLegEnd = MathUtils.lerp(vector.simEndDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
            }
            distanceCovered += newLegDistance - endDistanceToLegEnd;
        }
        verticalPath.perfDescentTodDistance = distanceCovered;
    }
    /**
     * Simulates the VNAV climb phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The vertical flight path entry to which to write the results of the simulation.
     * @param climbThrustMode The thrust mode to use during the climb phase.
     * @param climbCas The climb calibrated airspeed to use, in meters per second.
     * @param climbMach The climb mach number to use.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param bocLegIndex The global index of the flight plan leg containing the start of the climb.
     * @param bocDistanceToLegEnd The lateral distance, in meters, from the start of the climb to the end of its
     * containing leg.
     * @param bocAltitude The altitude, in meters above MSL, of the start of the climb.
     * @param bocWeight The airplane weight, in pounds, at the start of the climb.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the climb, exclusive. If the
     * climb is simulated to end past the last eligible leg, then the simulation will proceed along the last eligible leg
     * as if it were infinitely extended until the top of climb is reached.
     * @param isMissedApproach Whether the simulated climb is part of the missed approach.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateClimb(lateralLegs, verticalPlan, verticalPathEntry, climbThrustMode, climbCas, climbMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, cruiseAltitude, bocLegIndex, bocDistanceToLegEnd, bocAltitude, bocWeight, endLegIndex, isMissedApproach, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var _k, _l;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        if (bocAltitude >= cruiseAltitude - 100 || bocLegIndex >= endLegIndex) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        const climbN1MethodName = this.getClimbN1MethodName(climbThrustMode);
        const wingArea = this.perfProvider.getWingArea();
        let currentVerticalPathLegIndex = bocLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        // Simulate climb steps. Each step covers the distance to the end of the next lateral leg, the next AT OR BELOW
        // climb altitude restriction to be sequenced, the next speed restriction or speed transition to be sequenced, or
        // 1000 feet of climb, whichever is shorter.
        let currentAltitude = bocAltitude;
        let currentLegIndex = bocLegIndex;
        let currentLeg = lateralLegs[bocLegIndex];
        let distanceToLegEnd = bocDistanceToLegEnd;
        let currentWeight = bocWeight;
        let lastVerticalPathLegIndex = currentVerticalPathLegIndex;
        let lastVerticalPathVectorIndex = currentVerticalPathVectorIndex - 1;
        let lastDistanceToLegEnd = bocDistanceToLegEnd;
        const getNextTargetConstraint = isMissedApproach ? VNavUtils.getNextMaprTargetConstraint : VNavUtils.getNextClimbTargetConstraint;
        let currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, bocLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = climbCas;
        const defaultTargetCasSource = isFinite(climbCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = climbMach;
        const defaultTargetMachSource = isFinite(climbMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let casToUse = Infinity;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude < cruiseAltitude) {
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedClimbWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                deltaIsa = (_a = this.windPlanner.getInterpolatedClimbIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (currentTargetAltitudeConstraint && currentLegIndex > currentTargetAltitudeConstraint.index) {
                // We passed the current target altitude constraint that we were tracking, so we need to get the new current
                // target altitude constraint.
                currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
            }
            // Do not apply flight plan leg altitude restriction if we are past the end of the last eligible leg to be
            // simulated. Otherwise we might get stuck below the cruise altitude forever.
            const targetAltitude = currentTargetAltitudeConstraint && (currentLegIndex < endLegIndex - 1 || distanceToLegEnd > 0)
                ? Math.min(cruiseAltitude, currentTargetAltitudeConstraint.maxAltitude)
                : cruiseAltitude;
            if (currentSpeedConstraint && currentLegIndex > currentSpeedConstraint.globalLegIndex) {
                // We passed the current speed constraint that we were tracking, so we need to get the new current speed
                // constraint.
                currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
                // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed constraint
                // increased our target speed.
                if (!isAccelerating) {
                    isAccelerating = true;
                    accelerationCas = casToUse;
                }
            }
            if (useTransitionCas) {
                if (currentAltitude >= transitionAltitude) {
                    useTransitionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed transition
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            if (useRestrictionCas) {
                if (currentAltitude >= restrictionAltitude) {
                    useRestrictionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed restriction
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
            let distanceStep;
            let timeStep;
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
                altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
                altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = casToTarget);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || casToTarget <= accelerationCas + 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            casToUse = isAccelerating ? accelerationCas : casToTarget;
            // If we are on the last eligible leg to be simulated, we will run the simulation even if the leg does not have
            // a non-zero calculated distance in order to guarantee that the simulation eventually reaches cruise altitude.
            if (currentLegIndex === endLegIndex - 1 || (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0)) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let vs;
                let engineFuelFlow;
                if (altitudeStep <= 0) {
                    // The current altitude is at or above the current target climb altitude (if it were at or above the cruise
                    // altitude we would have exited the while loop already). In this case, we will hold the current altitude
                    // until we sequence the altitude constraint.
                    altitudeStep = 0;
                    vs = 0;
                    const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0);
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                        const targetNetThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl, 0);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(targetNetThrustRequired, currentWeight, cl, tas, 0, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        timeStep = tasStep / acceleration;
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                        timeStep = distanceStep / gs;
                    }
                    const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                }
                else {
                    // The current altitude is below the current target climb altitude, so we will climb using the selected climb
                    // climb thrust rating.
                    const temperatureK = temperature + 273.15;
                    const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(currentAltitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                    const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                    const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                    if (isAccelerating) {
                        vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, vs, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        const accelTimeStep = tasStep / acceleration;
                        const accelAltitudeStep = vs * accelTimeStep;
                        // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the current climb target altitude).
                        if (accelAltitudeStep > altitudeStep) {
                            // vs cannot be 0 here
                            timeStep = altitudeStep / vs;
                        }
                        else {
                            altitudeStep = accelAltitudeStep;
                            timeStep = accelTimeStep;
                        }
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), 1);
                        timeStep = altitudeStep / vs;
                        distanceStep = timeStep * gs;
                    }
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd && currentLegIndex < endLegIndex - 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined || (currentLegIndex === endLegIndex - 1 && distanceToLegEnd > 0 && distanceStep > distanceToLegEnd)) {
                    // We are either advancing legs or we are about to cross the end of the last eligible leg to be simulated.
                    // Either way we need to end the current step at the end of the current leg.
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * vs;
                    if (advanceLegIndexTo !== undefined) {
                        currentLegIndex = advanceLegIndexTo;
                        currentLeg = lateralLegs[currentLegIndex];
                        distanceToLegEnd = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                    }
                    else {
                        distanceToLegEnd = 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentAltitude += altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.ClimbLevelAcceleration;
                    }
                    else {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.Climb : VerticalFlightPathVectorType.ClimbLevel;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from a level acceleration into a climb
                        // acceleration or vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_f = (_k = pathLeg.vectors)[vectorIndex]) !== null && _f !== void 0 ? _f : (_k[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                    lastVerticalPathVectorIndex = currentVerticalPathVectorIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_g = (_l = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_l[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = isAccelerating ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.Climb;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                lastVerticalPathVectorIndex = 0;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
        verticalPath.tocLegIndex = lastVerticalPathLegIndex;
        verticalPath.tocVectorIndex = lastVerticalPathVectorIndex;
        verticalPath.tocDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.tocWeight = currentWeight;
        verticalPathEntry.lastTocLegIndex = verticalPath.tocLegIndex;
        verticalPathEntry.lastTocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
    }
    /**
     * Simulates the VNAV cruise phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param costIndex The cost index to use when converting time cost to fuel equivalents, in (dollars per hour) per
     * (cents per pound of fuel).
     * @param initialCruiseAltitude The initial cruise altitude, in meters above MSL.
     * @param climbThrustMode The climb thrust mode to use during step climbs.
     * @param selCruiseCas The selected cruise calibrated airspeed, in meters per second, or `null` if there is no such
     * speed.
     * @param selCruiseMach The selected cruise mach number, or `null` if there is no such speed.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeAltitude The airplane's current altitude, in meters above MSL.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the cruise, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCruise(lateralLegs, verticalPlan, verticalPathEntry, costIndex, initialCruiseAltitude, climbThrustMode, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeAltitude, activeLegIndex, activeDistanceToLegEnd, activeWeight, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var _p, _q, _r;
        const verticalPath = verticalPathEntry.path;
        endLegIndex = Math.min(endLegIndex, lateralLegs.length);
        let tocLegIndex;
        let tocDistanceToLegEnd;
        let tocWeight = activeWeight;
        let currentVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let tocCasToUse = undefined;
        // If a TOC is defined in the vertical flight path, then we need to make sure we start writing cruise vectors after
        // the TOC. Otherwise, the simulation starts in the cruise phase at the airplane's current along-track position, so
        // we will start writing vectors at index 0 for the active leg.
        if (verticalPath.tocLegIndex !== undefined
            && verticalPath.tocVectorIndex !== undefined
            && verticalPath.tocDistanceToLegEnd !== undefined
            && verticalPath.tocWeight !== undefined) {
            // Check if the TOC lies past the end of its containing leg. If it does, then we need to start our simulation at
            // the beginning of the next leg.
            if (verticalPath.tocDistanceToLegEnd < 0) {
                tocLegIndex = verticalPath.tocLegIndex + 1;
                tocDistanceToLegEnd = (_c = (_b = (_a = lateralLegs[tocLegIndex]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
            }
            else {
                tocLegIndex = verticalPath.tocLegIndex;
                tocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
                tocWeight = verticalPath.tocWeight;
                const tocPathLeg = verticalPath.legs[tocLegIndex];
                const tocPathVector = tocPathLeg.vectors[verticalPath.tocVectorIndex];
                currentVerticalPathLegIndex = tocLegIndex;
                currentVerticalPathVectorIndex = verticalPath.tocVectorIndex + 1;
                tocCasToUse = UnitType.KNOT.convertTo(tocPathVector.endCas, UnitType.MPS);
                for (let i = 0; i < currentVerticalPathVectorIndex; i++) {
                    currentVerticalPathLegDuration += tocPathLeg.vectors[i].duration;
                }
            }
        }
        else {
            tocLegIndex = activeLegIndex;
            tocDistanceToLegEnd = activeDistanceToLegEnd;
            currentVerticalPathLegIndex = tocLegIndex;
        }
        if (tocLegIndex >= endLegIndex) {
            return;
        }
        const climbN1MethodName = this.getClimbN1MethodName(climbThrustMode);
        const wingArea = this.perfProvider.getWingArea();
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        const isSelCruiseSpeed = selCruiseCas !== null || selCruiseMach !== null;
        // Start the simulation at the initial cruise altitude if we have sequenced the first descent constraint, or we
        // have not yet passed the TOC, or we are within 100 meters of the initial cruise altitude. Otherwise, start the
        // simulation at the airplane's current altitude.
        let currentAltitude = ((verticalPlan.firstDescentConstraintLegIndex !== undefined && activeLegIndex > verticalPlan.firstDescentConstraintLegIndex)
            || !verticalPathEntry.isTocSequenced
            || Math.abs(initialCruiseAltitude - activeAltitude) < 100)
            ? initialCruiseAltitude
            : activeAltitude;
        let currentLegIndex = tocLegIndex;
        let currentLeg = lateralLegs[tocLegIndex];
        let currentLegDistance = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
        let distanceToLegEnd = tocDistanceToLegEnd;
        let currentWeight = tocWeight;
        let currentCruiseCas = selCruiseCas !== null && selCruiseCas !== void 0 ? selCruiseCas : Infinity;
        let currentCruiseMach = selCruiseMach !== null && selCruiseMach !== void 0 ? selCruiseMach : Infinity;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let distanceToNextSpeedConstraint = nextSpeedConstraint
            ? BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd)
            : Infinity;
        let useNextSpeedConstraint = false;
        let prevUsedSpeedConstraint = currentSpeedConstraint;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        let currentCruiseStepIndex = BoeingVNavUtils.getCurrentCruiseStepIndex(verticalPath, tocLegIndex, tocDistanceToLegEnd);
        let currentCruiseStep = verticalPath.cruiseSteps[currentCruiseStepIndex];
        let nextCruiseStep = verticalPath.cruiseSteps[currentCruiseStepIndex + 1];
        let distanceToNextCruiseStep = nextCruiseStep
            ? BoeingPathCalculator.getDistanceToCruiseStep(lateralLegs, nextCruiseStep, currentLegIndex, distanceToLegEnd)
            : Infinity;
        let hasInitiatedStepDescent = false;
        let targetAltitude = (_f = currentCruiseStep === null || currentCruiseStep === void 0 ? void 0 : currentCruiseStep.toAltitude) !== null && _f !== void 0 ? _f : initialCruiseAltitude;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let legCourse = undefined;
        let legCourseIndex = undefined;
        let windVector = null;
        let headwind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        let lastWeatherAltitude = currentAltitude;
        while (currentLegIndex < endLegIndex) {
            const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
            const pressure = AeroMath.isaPressure(currentAltitude);
            // ---- Update speed constraint ----
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                distanceToNextSpeedConstraint = nextSpeedConstraint
                    ? BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd)
                    : Infinity;
                useNextSpeedConstraint = false;
            }
            // ---- Update cruise step ----
            if (nextCruiseStep && distanceToNextCruiseStep < 1) {
                currentCruiseStepIndex++;
                currentCruiseStep = nextCruiseStep;
                nextCruiseStep = verticalPath.cruiseSteps[currentCruiseStepIndex + 1];
                distanceToNextCruiseStep = nextCruiseStep
                    ? BoeingPathCalculator.getDistanceToCruiseStep(lateralLegs, nextCruiseStep, currentLegIndex, distanceToLegEnd)
                    : Infinity;
                hasInitiatedStepDescent || (hasInitiatedStepDescent = currentCruiseStep.toAltitude < currentAltitude);
                targetAltitude = currentCruiseStep.toAltitude;
            }
            if (currentLegDistance > 0) {
                // ---- Update average leg course ----
                if (legCourseIndex !== currentLegIndex) {
                    legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    legCourseIndex = currentLegIndex;
                }
                // ---- Compute ambient conditions ----
                // Check if we need to update winds and delta ISA offset.
                if (currentLegIndex !== lastWeatherLegIndex || Math.abs(currentAltitude - lastWeatherAltitude) > 30.48) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache);
                    if (windVector !== null) {
                        if (legCourse !== undefined) {
                            headwind = -BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1]);
                        }
                        else {
                            headwind = 0;
                        }
                    }
                    else {
                        headwind = 0;
                    }
                    deltaIsa = (_g = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _g !== void 0 ? _g : 0;
                    lastWeatherLegIndex = currentLegIndex;
                    lastWeatherAltitude = currentAltitude;
                }
            }
            // ---- Compute the current simulation step's target speed ----
            if (!isSelCruiseSpeed) {
                [currentCruiseCas, currentCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, currentAltitudeFeet, currentWeight, headwind, BoeingPathCalculator.econSpeedCache, pressure);
                currentCruiseCas = UnitType.KNOT.convertTo(currentCruiseCas, UnitType.MPS);
            }
            const prevUsedTransitionCas = useTransitionCas ? transitionCas : undefined;
            const prevUsedRestrictionCas = useRestrictionCas ? restrictionCas : undefined;
            // Initiating a step descent will remove transition and restriction speed limits if stepping below their
            // respective altitudes, so neither speed limit will ever be in effect after a step descent (unless the pilot
            // takes action to restore them, but for the purposes of the simulation we will assume this doesn't happen).
            useTransitionCas = canUseTransitionCas && !hasInitiatedStepDescent && currentAltitude < transitionAltitude;
            useRestrictionCas = canUseRestrictionCas && !hasInitiatedStepDescent && currentAltitude < restrictionAltitude;
            const speedConstraintToUse = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            const { targetCas, targetCasSource, targetMach, targetMachSource } = BoeingPathCalculator.getTargetSpeedData(currentCruiseCas, currentCruiseMach, speedConstraintToUse, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            tocCasToUse !== null && tocCasToUse !== void 0 ? tocCasToUse : (tocCasToUse = casToTarget);
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = tocCasToUse);
            if (!isAccelerating) {
                accelerationCas = casToTarget;
                const { targetCas: prevTargetCas, targetMach: prevTargetMach } = BoeingPathCalculator.getTargetSpeedData(currentCruiseCas, currentCruiseMach, prevUsedSpeedConstraint, prevUsedTransitionCas, prevUsedRestrictionCas, BoeingPathCalculator.targetSpeedDataCache);
                const prevCasToTarget = Math.min(prevTargetCas, AeroMath.machToCas(prevTargetMach, pressure));
                if (Math.abs(casToTarget - prevCasToTarget) > 0.1) {
                    isAccelerating = true;
                }
            }
            else if (!isFinite(accelerationCas) || Math.abs(casToTarget - accelerationCas) <= 0.1) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            prevUsedSpeedConstraint = speedConstraintToUse;
            const casToUse = isAccelerating ? accelerationCas : casToTarget;
            if (currentLegDistance > 0) {
                let maxDistanceStep = Math.min(distanceToLegEnd, distanceToNextCruiseStep);
                if (maxDistanceStep > BoeingPathCalculator.MAX_DISTANCE_STEP + BoeingPathCalculator.MAX_DISTANCE_STEP_TOL) {
                    maxDistanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                }
                let distanceStep;
                let altitudeStep;
                let timeStep;
                let tasStep;
                let deltaTas;
                // ---- Compute additional ambient conditions ----
                const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
                const density = AeroMath.densityAir(pressure, temperature);
                const soundSpeed = AeroMath.soundSpeedAir(temperature);
                // ---- Compute simulation step speeds ----
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windVector !== null && legCourse !== undefined) {
                    wind = Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1], tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                }
                const gs = tas + wind;
                // ---- Handle flight plan speed constraint anticipation ----
                // Do not try to anticipate the next speed constraint until we are within 150 NM. This threshold is
                // chosen because it guarantees that we don't overshoot any anticipated distance less than or equal to
                // 50 NM (50 NM + 100 NM maximum step distance).
                if (!useNextSpeedConstraint && nextSpeedConstraint && distanceToNextSpeedConstraint <= BoeingPathCalculator.MAX_DISTANCE_STEP + 92600) {
                    let casToAnticipate = undefined;
                    if (nextSpeedConstraint.maxCas < casToUse) {
                        casToAnticipate = nextSpeedConstraint.maxCas;
                    }
                    else if (isFinite(nextSpeedConstraint.maxMach)) {
                        const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                        if (nextSpeedConstraintMachCas < casToUse) {
                            casToAnticipate = nextSpeedConstraintMachCas;
                        }
                    }
                    if (casToAnticipate !== undefined) {
                        const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                        const timeToDecel = (tasToAnticipate - tas) / BoeingPathCalculator.CRUISE_ANTICIPATION_ASSUMED_DECELERATION;
                        const distanceToDecel = gs * timeToDecel + BoeingPathCalculator.CRUISE_ANTICIPATION_ASSUMED_DECELERATION / 2 * timeToDecel * timeToDecel;
                        // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                        // distance step if necessary so that the next step begins at the point at which we are predicted to
                        // need to start decelerating to reach the target speed 500 meters before the speed constraint.
                        if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                            useNextSpeedConstraint = true;
                            isAccelerating = true;
                            accelerationCas = casToUse;
                            continue;
                        }
                        else {
                            maxDistanceStep = Math.min(maxDistanceStep, distanceToNextSpeedConstraint - distanceToDecel - 500);
                        }
                    }
                }
                // ---- Compute simulation step deltas ----
                const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let engineGrossThrust;
                if (targetAltitude === currentAltitude) {
                    // We are currently cruising at the target altitude.
                    altitudeStep = 0;
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        deltaTas = targetTas - tas;
                        tasStep = deltaTas;
                        if (deltaTas > 0) {
                            // We are currently accelerating.
                            const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                            const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl, 0);
                            const [timeToAccel, distanceToAccel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, targetTas, 0, netThrustRequired / engineCount, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_LEVEL_ACCELERATION);
                            acceleration = deltaTas / timeToAccel;
                            distanceStep = distanceToAccel;
                            timeStep = timeToAccel;
                            engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
                        }
                        else {
                            // We are currently decelerating.
                            const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                            const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                            engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / thrustCorrection;
                            if (useNextSpeedConstraint) {
                                // We are currently decelerating to anticipate a flight plan speed constraint.
                                acceleration = BoeingPathCalculator.getRequiredAcceleration(distanceToNextSpeedConstraint, gs, gs + deltaTas);
                                distanceStep = distanceToNextSpeedConstraint;
                                timeStep = deltaTas / acceleration;
                            }
                            else {
                                // We are currently decelerating from climb speed to cruise speed.
                                const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(idleN1, mach, pressure, temperature);
                                acceleration = Math.min(this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0), -BoeingPathCalculator.MIN_LEVEL_DECELERATION);
                                timeStep = deltaTas / acceleration;
                                distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                            }
                        }
                    }
                    else {
                        engineGrossThrust = this.perfProvider.getLevelFlightRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, mach, 0, engineCount);
                        distanceStep = maxDistanceStep;
                        timeStep = distanceStep / gs;
                        tasStep = 0;
                        deltaTas = 0;
                    }
                }
                else {
                    // We are currently stepping to another target altitude.
                    let altitudeToAccel = 0;
                    let timeToAccel = 0;
                    let vs;
                    if (targetAltitude > currentAltitude) {
                        // We are currently stepping to a higher target altitude.
                        // Limit the altitude step to the maximum altitude step (1000 feet), the altitude remaining to the target
                        // altitude, or the altitude remaining to the transition/restriction altitudes.
                        altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
                        if (canUseTransitionCas && currentAltitude < transitionAltitude) {
                            altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
                        }
                        if (canUseRestrictionCas && currentAltitude < restrictionAltitude) {
                            altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
                        }
                        const temperatureK = temperature + 273.15;
                        const n1 = this.engineDataProvider[climbN1MethodName](currentAltitudeFeet, temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                        const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                        engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                        const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                        if (isAccelerating) {
                            const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                            deltaTas = targetTas - tas;
                            if (deltaTas > 0) {
                                // We are currently accelerating.
                                vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                                [timeToAccel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, targetTas, vs, engineNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_CLIMB_ACCELERATION);
                                altitudeToAccel = vs * timeToAccel;
                                acceleration = deltaTas / timeToAccel;
                            }
                            else {
                                // We are currently decelerating.
                                vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), BoeingPathCalculator.MIN_CLIMB_VS_MPS);
                                if (useNextSpeedConstraint) {
                                    // We are currently decelerating to anticipate a flight plan speed constraint.
                                    acceleration = BoeingPathCalculator.getRequiredAcceleration(distanceToNextSpeedConstraint, gs, gs + deltaTas);
                                }
                                else {
                                    // We are currently decelerating from climb speed to cruise speed.
                                    acceleration = BoeingPathCalculator.ASSUMED_CLIMB_DECELERATION;
                                }
                                timeToAccel = deltaTas / acceleration;
                                altitudeToAccel = vs * timeToAccel;
                            }
                        }
                        else {
                            // We are currently holding a constant speed.
                            vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), BoeingPathCalculator.MIN_CLIMB_VS_MPS);
                            deltaTas = 0;
                        }
                    }
                    else {
                        // We are currently stepping to a lower target altitude.
                        // Limit the altitude step to the maximum altitude step (1000 feet) or the altitude remaining to the target
                        // altitude. We don't need to worry about the transition/restriction altitudes because they are automatically
                        // cleared when initiating a step descent.
                        altitudeStep = Math.max(-BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
                        vs = BoeingPathCalculator.CRUISE_DESCENT_VS_MPS;
                        if (isAccelerating) {
                            const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                            deltaTas = targetTas - tas;
                            if (deltaTas > 0) {
                                // We are currently accelerating.
                                const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                                const netThrustRequired = this.perfProvider.getRequiredThrust(currentWeight, targetCl, targetTas, vs, 0);
                                [timeToAccel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, targetTas, vs, netThrustRequired / engineCount, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_DESCENT_ACCELERATION);
                                altitudeToAccel = vs * timeToAccel;
                                acceleration = deltaTas / timeToAccel;
                                engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
                            }
                            else {
                                // We are currently decelerating.
                                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                                engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / thrustCorrection;
                                if (useNextSpeedConstraint) {
                                    // We are currently decelerating to anticipate a flight plan speed constraint.
                                    acceleration = BoeingPathCalculator.getRequiredAcceleration(distanceToNextSpeedConstraint, gs, gs + deltaTas);
                                }
                                else {
                                    // We are currently decelerating from climb speed to cruise speed.
                                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(idleN1, mach, pressure, temperature);
                                    acceleration = Math.min(this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0), -BoeingPathCalculator.MIN_DESCENT_DECELERATION);
                                }
                                timeToAccel = deltaTas / acceleration;
                                altitudeToAccel = vs * timeToAccel;
                            }
                        }
                        else {
                            // We are currently holding a constant speed.
                            deltaTas = 0;
                            engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                        }
                    }
                    if (isAccelerating) {
                        // If we are currently accelerating toward a target speed, then we need to check if we are predicted to
                        // reach the target speed before the end of the planned altitude step. If so, then we need to end the
                        // current step when we reach the target speed.
                        if (altitudeToAccel < altitudeStep - 1) {
                            altitudeStep = altitudeToAccel;
                            timeStep = timeToAccel;
                            tasStep = deltaTas;
                        }
                        else {
                            timeStep = MathUtils.lerp(altitudeStep, 0, altitudeToAccel, 0, timeToAccel, true, true);
                            tasStep = MathUtils.lerp(altitudeStep, 0, altitudeToAccel, 0, deltaTas, true, true);
                        }
                    }
                    else {
                        acceleration = 0;
                        timeStep = altitudeStep / vs;
                        tasStep = 0;
                    }
                    distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                }
                if (distanceStep > maxDistanceStep + 1) {
                    if (isAccelerating) {
                        const oldTimeStep = timeStep;
                        timeStep = BoeingPathCalculator.timeToDistance(maxDistanceStep, gs, acceleration);
                        altitudeStep = MathUtils.lerp(timeStep, 0, oldTimeStep, 0, altitudeStep, true, true);
                        tasStep = MathUtils.lerp(timeStep, 0, oldTimeStep, 0, tasStep, true, true);
                    }
                    else {
                        timeStep = maxDistanceStep / gs;
                        altitudeStep = MathUtils.lerp(maxDistanceStep, 0, distanceStep, 0, altitudeStep);
                    }
                }
                distanceStep = Math.min(distanceStep, maxDistanceStep);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the distance step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceToLegEnd <= distanceStep + 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                if (advanceLegIndexTo !== undefined) {
                    distanceStep = distanceToLegEnd;
                    distanceToLegEnd = 0;
                }
                else {
                    distanceToLegEnd -= distanceStep;
                }
                currentAltitude += altitudeStep;
                if (Math.abs(currentAltitude - targetAltitude) < 1e-3) {
                    currentAltitude = targetAltitude;
                }
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                distanceToNextSpeedConstraint -= distanceStep;
                distanceToNextCruiseStep -= distanceStep;
                let endPressure;
                let casToTargetAtEnd;
                if (altitudeStep === 0) {
                    endPressure = pressure;
                    casToTargetAtEnd = casToTarget;
                }
                else {
                    endPressure = AeroMath.isaPressure(currentAltitude);
                    casToTargetAtEnd = Math.min(targetCas, AeroMath.machToCas(targetMach, endPressure));
                }
                if (isAccelerating) {
                    if (Math.abs(tasStep - deltaTas) < 1e-3) {
                        // The current simulation step ends at the acceleration target.
                        accelerationCas = casToTargetAtEnd;
                    }
                    else {
                        // The current simulation step ends before we are predicted to reach the acceleration target.
                        // For performance reasons we won't bother getting the temperature at the end of the vector.
                        const endCas = AeroMath.tasToCas(tas + tasStep, endPressure, temperature);
                        // Do not allow CAS to "overshoot" the target due to potential changes in static pressure across the
                        // vector causing changes in the target CAS.
                        const accelSign = deltaTas >= 0 ? 1 : -1;
                        if ((endCas - casToTargetAtEnd) * accelSign >= -1e-3) {
                            accelerationCas = casToTargetAtEnd;
                        }
                        else {
                            accelerationCas = endCas;
                        }
                    }
                }
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_h = (_p = pathLeg.vectors)[_q = currentVerticalPathVectorIndex++]) !== null && _h !== void 0 ? _h : (_p[_q] = BoeingPathCalculator.createVerticalPathVector());
                    vector.type = BoeingPathCalculator.getCruiseVectorType(altitudeStep, isAccelerating ? acceleration : 0);
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.simEndDistanceToLegEnd = distanceToLegEnd;
                    vector.endDistanceToLegEnd = distanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                    vector.targetMachSource = targetMachSource;
                    vector.duration = timeStep;
                    vector.gs = gs;
                    vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, endPressure);
                    }
                    else {
                        if (altitudeStep === 0) {
                            vector.endCas = vector.startCas;
                            vector.endMach = vector.startMach;
                        }
                        else {
                            vector.endCas = UnitType.MPS.convertTo(casToTargetAtEnd, UnitType.KNOT);
                            vector.endMach = AeroMath.casToMach(casToTargetAtEnd, endPressure);
                        }
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    pathLeg.vectors.length = currentVerticalPathVectorIndex;
                    pathLeg.simDistance = currentLegDistance;
                    pathLeg.simDuration = currentVerticalPathLegDuration;
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[advanceLegIndexTo];
                    currentLegDistance = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                    distanceToLegEnd = currentLegDistance;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_l = (_r = pathLeg.vectors)[0]) !== null && _l !== void 0 ? _l : (_r[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = BoeingPathCalculator.getCruiseVectorType(targetAltitude - currentAltitude, isAccelerating ? acceleration : 0);
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                currentLegDistance = (_o = (_m = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _m === void 0 ? void 0 : _m.distanceWithTransitions) !== null && _o !== void 0 ? _o : 0;
                distanceToLegEnd = currentLegDistance;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
            }
        }
    }
    /**
     * Simulates the VNAV performance (off-idle) descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param targetAltitude The altitude to target, in meters above MSL, at the end of the performance descent phase.
     * @param geoInterceptConstraintTargetAltitude The target altitude of the descent altitude constraint containing the
     * point where the performance descent intercepts the geometric descent path, or `undefined` if there is no such
     * constraint.
     * @param isGeoInterceptPathLevel Whether the geometric descent path is level at the point where the performance
     * descent intercepts it.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param estimatedTodDistance The lateral distance, in meters, from the top of descent to the first descent altitude
     * constraint along the flight plan.
     * @param todLegIndex The global index of the flight plan leg containing the top of descent.
     * @param todDistanceToLegEnd The lateral distance, in meters, from the top of descent to the end of its containing
     * leg.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the descent, exclusive.
     * @param engineCount The number of operational engines to simulate.
     * @returns The total simulated distance, in meters, of the performance descent phase.
     */
    simulatePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, isGeoInterceptPathLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedTodDistance, todLegIndex, todDistanceToLegEnd, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        if (todLegIndex >= lateralLegs.length) {
            verticalPath.todLegIndex = todLegIndex;
            verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
            verticalPath.perfDescentTodDistance = estimatedTodDistance;
            verticalPath.perfDescentSimDistance = 0;
            return 0;
        }
        const wingArea = this.perfProvider.getWingArea();
        // Find the vertical path vector
        let currentVerticalPathLegIndex = todLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let todCasToUse;
        let todWeight = 0;
        let useEstimatedWeight = false;
        let estimatedWeightStop = 0;
        let estimatedWeightStopDistanceToLegEnd = 0;
        const todPathLeg = verticalPath.legs[todLegIndex];
        // Note that we are guaranteed todPathLeg has at least one calculated vector due to the way in which todLegIndex
        // is chosen.
        if (todDistanceToLegEnd > todPathLeg.vectors[0].startDistanceToLegEnd + 1) {
            // The TOD is before the start of the first vector of the TOD leg. This can only happen if there is no valid
            // calculated vector that covers the TOD. In this case, we need to estimate what the airplane weight would be at
            // TOD. We will employ a crude method of estimation that assumes the airplane maintains a constant speed and N1
            // from TOD to the point where the first vector starts. During the simulation from TOD to the start of the first
            // vector, we will use an estimated weight that is linearly interpolated between the estimated TOD weight and the
            // weight at the start of the first vector.
            const firstVector = todPathLeg.vectors[0];
            useEstimatedWeight = true;
            estimatedWeightStop = firstVector.startWeight;
            estimatedWeightStopDistanceToLegEnd = firstVector.startDistanceToLegEnd;
            const distanceFromTod = todDistanceToLegEnd - estimatedWeightStopDistanceToLegEnd;
            const pressure = AeroMath.isaPressure(cruiseAltitude);
            const temperature = AeroMath.isaTemperature(cruiseAltitude);
            const mach = Math.min(descentMach, AeroMath.casToMach(descentCas, pressure));
            const n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach)
                + (cruiseAltitude === targetAltitude ? 0 : this.performanceDescentIdleN1Offset);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const timeFromTod = distanceFromTod / (soundSpeed * mach);
            const engineFuelFlow = this.perfProvider.getEngineFuelFlow(this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach));
            todWeight = estimatedWeightStop + engineFuelFlow * engineCount * timeFromTod / 3600;
            todCasToUse = UnitType.KNOT.convertTo(firstVector.startCas, UnitType.MPS);
        }
        else {
            // The TOD is after the start of the first vector of the TOD leg. We can grab the airplane weight at TOD from
            // the appropriate calculated vector. We also need to find the index at which to start inserting descent vectors.
            for (let i = 0; i < todPathLeg.vectors.length; i++) {
                const vector = todPathLeg.vectors[i];
                if (vector.startDistanceToLegEnd <= todDistanceToLegEnd) {
                    // The current vector starts at or after the TOD -> start inserting descent vectors at this index.
                    currentVerticalPathVectorIndex = i;
                    todCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                    todWeight = vector.startWeight;
                    break;
                }
                if (vector.endDistanceToLegEnd < todDistanceToLegEnd) {
                    // The current vector ends after the TOD -> change the vector to end at the TOD and start inserting descent
                    // vectors at the next index.
                    vector.endAltitude = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                    vector.endWeight = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                    // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                    // vector will be. For non-acceleration vectors, the end speed stays the same.
                    if (vector.endCas !== vector.startCas) {
                        // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                        // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                        // stays constant.
                        vector.endMach = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                    }
                    // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                    // vectors, but the absolute magnitude of the error should still be acceptable.
                    vector.duration = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                    vector.simEndDistanceToLegEnd = todDistanceToLegEnd;
                    vector.endDistanceToLegEnd = todDistanceToLegEnd;
                    currentVerticalPathVectorIndex = i + 1;
                    currentVerticalPathLegDuration += vector.duration;
                    todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                    todWeight = vector.endWeight;
                    break;
                }
                currentVerticalPathVectorIndex = i + 1;
                currentVerticalPathLegDuration += vector.duration;
                todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                todWeight = vector.endWeight;
            }
        }
        // If a TOC is defined, then check if the TOD lies before the TOC. If it does, then use the TOC weight as the weight
        // at TOD instead of the estimated weight at the TOD.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            if (todLegIndex < verticalPath.tocLegIndex
                || (todLegIndex === verticalPath.tocLegIndex && todDistanceToLegEnd > verticalPath.tocDistanceToLegEnd)) {
                todWeight = verticalPath.tocWeight;
            }
        }
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction or speed transition, or 1000 feet of descent, whichever is shorter.
        let currentAltitude = cruiseAltitude;
        let currentLegIndex = todLegIndex;
        let currentLeg = lateralLegs[todLegIndex];
        let distanceToLegEnd = todDistanceToLegEnd;
        let advanceLegIndexTo = undefined;
        const todVectorIndex = currentVerticalPathVectorIndex;
        let lastVerticalPathLegIndex = currentVerticalPathLegIndex;
        let lastVerticalPathVectorIndex = currentVerticalPathVectorIndex - 1;
        let lastDistanceToLegEnd = todDistanceToLegEnd;
        let currentWeight = todWeight;
        let totalDistanceCovered = 0;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        // Only apply transition and restriction speed limits if they are defined and the either we are intercepting the
        // geometric descent below the threshold altitudes or the intercept is at the threshold altitude and the geometric
        // descent path at the point of intercept descends past the threshold altitude (i.e. we will not level off at the
        // intercept).
        const canUseTransitionCas = transitionAltitude !== null
            && transitionCas !== null
            && (targetAltitude < transitionAltitude - 0.3048
                || (targetAltitude < transitionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < transitionAltitude - 0.3048)));
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        const canUseRestrictionCas = restrictionAltitude !== null
            && restrictionCas !== null
            && (targetAltitude < restrictionAltitude - 0.3048
                || (targetAltitude < restrictionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < restrictionAltitude - 0.3048)));
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = descentCas;
        const defaultTargetMach = descentMach;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        let isInLevelDecelerationPhase = true;
        let isDecelerating = true;
        let decelerationCas = undefined;
        let decelerationAccel = 0;
        let decelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude > targetAltitude || isInLevelDecelerationPhase) {
            // If the current leg is the leg that we want to advance to, reset the advance leg index so that we don't skip
            // the current leg.
            if (advanceLegIndexTo === currentLegIndex) {
                advanceLegIndexTo = undefined;
            }
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // If we are still at cruise altitude (i.e. level deceleration), then use cruise winds. Otherwise use descent
                // winds.
                if (currentAltitude === cruiseAltitude) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache);
                    deltaIsa = (_a = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _a !== void 0 ? _a : 0;
                }
                else {
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                    deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                }
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, currentAltitude - targetAltitude);
            let distanceStep;
            let timeStep;
            let mach;
            let tas;
            let gs;
            let cl;
            let n1;
            let vs;
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            useTransitionCas || (useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude);
            useRestrictionCas || (useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude);
            const { targetCas, targetCasSource, targetMach, targetMachSource } = BoeingPathCalculator.getTargetSpeedData(defaultTargetCas, defaultTargetMach, useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            todCasToUse !== null && todCasToUse !== void 0 ? todCasToUse : (todCasToUse = casToTarget);
            decelerationCas !== null && decelerationCas !== void 0 ? decelerationCas : (decelerationCas = todCasToUse);
            // Check if we need to continue to decelerate
            if (isDecelerating && (!isFinite(decelerationCas) || casToTarget >= decelerationCas - 0.1)) {
                isDecelerating = false;
                isInLevelDecelerationPhase = false;
                decelerationCas = casToTarget;
                // If we were only simulating the level deceleration phase, then end the simulation now that we are no longer
                // in it.
                if (currentAltitude <= targetAltitude) {
                    break;
                }
            }
            if (advanceLegIndexTo === undefined) {
                // We are not skipping the current leg.
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                let casToUse;
                if (isDecelerating) {
                    vs = isInLevelDecelerationPhase ? 0 : BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                    casToUse = decelerationCas;
                    mach = AeroMath.casToMach(decelerationCas, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    decelerationAccel = Math.min(-0.1, this.perfProvider.getAcceleration(this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) * engineCount, currentWeight, cl, tas, vs, 0));
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    const tasStep = Math.min(tas - targetTas, 3);
                    const accelTimeStep = tasStep / -decelerationAccel;
                    const accelAltitudeStep = -vs * accelTimeStep;
                    // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the first descent constraint).
                    if (accelAltitudeStep > altitudeStep) {
                        // vs cannot be 0 here
                        timeStep = altitudeStep / -vs;
                    }
                    else {
                        altitudeStep = accelAltitudeStep;
                        timeStep = accelTimeStep;
                    }
                    distanceStep = gs * timeStep + decelerationAccel / 2 * timeStep * timeStep;
                }
                else {
                    altitudeStep = Math.min(304.8, currentAltitude - targetAltitude);
                    casToUse = casToTarget;
                    mach = AeroMath.casToMach(casToUse, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    n1 = idleN1 + this.performanceDescentIdleN1Offset;
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 100 NM.
                            if (distanceToNextSpeedConstraint <= 185200) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // altitude step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters prior to the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isDecelerating = true;
                                    decelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                                    vs = Math.min(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), -1);
                                    altitudeStep = Math.min(altitudeStep, (distanceToNextSpeedConstraint - distanceToDecel - 500) / gs * -vs);
                                }
                            }
                        }
                    }
                    // If we are not yet using the speed restriction limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the restriction altitude, check if we need to start anticipating the speed restriction.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseRestrictionCas
                        && !useRestrictionCas
                        && restrictionCas < casToUse
                        && (targetAltitude < restrictionAltitude - 1)
                        && currentAltitude - restrictionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(restrictionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToRestriction = currentAltitude - restrictionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the restriction altitude.
                        if (altitudeToDecel >= altitudeToRestriction - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToRestriction - altitudeToDecel - 100);
                        }
                    }
                    // If we are not yet using the speed transition limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the transition altitude, check if we need to start anticipating the speed transition.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseTransitionCas
                        && !useTransitionCas
                        && transitionCas < casToUse
                        && currentAltitude - transitionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(transitionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToTransition = currentAltitude - transitionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // transition, immediately start decelerating towards the transition speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the transition altitude.
                        if (altitudeToDecel >= altitudeToTransition - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToTransition - altitudeToDecel - 100);
                        }
                    }
                }
                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                vs !== null && vs !== void 0 ? vs : (vs = Math.min(this.perfProvider.getVerticalSpeed((engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature)) * engineCount, currentWeight, cl, tas, 0), -1));
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = altitudeStep / -vs);
                distanceStep !== null && distanceStep !== void 0 ? distanceStep : (distanceStep = timeStep * gs);
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                if (distanceStep >= distanceToLegEnd) {
                    // Search forward in the lateral plan for a leg with a non-zero calculated distance until we are past the
                    // last eligible leg.
                    let searchLegIndex = currentLegIndex;
                    while (++searchLegIndex < endLegIndex) {
                        const searchLeg = lateralLegs[searchLegIndex];
                        if (searchLeg.calculated && searchLeg.calculated.distanceWithTransitions > 0) {
                            advanceLegIndexTo = searchLegIndex;
                            break;
                        }
                    }
                }
                const currentLegDistance = (_d = (_c = currentLeg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isDecelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, decelerationAccel);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * -vs;
                    currentLegIndex++;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_f = (_e = currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isDecelerating) {
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                }
                totalDistanceCovered += stepDistance;
                currentVerticalPathLegDuration += timeStep;
                currentAltitude -= altitudeStep;
                // If we are using estimated weight, then check if we have passed the point where we should stop using
                // estimated weight.
                if (useEstimatedWeight && (currentLegIndex > todLegIndex || distanceToLegEnd <= estimatedWeightStopDistanceToLegEnd)) {
                    useEstimatedWeight = false;
                }
                if (useEstimatedWeight) {
                    currentWeight = MathUtils.lerp(distanceToLegEnd, todDistanceToLegEnd, estimatedWeightStopDistanceToLegEnd, todWeight, estimatedWeightStop);
                }
                else {
                    const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                    currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                }
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isInLevelDecelerationPhase) {
                        vectorType = VerticalFlightPathVectorType.LevelDeceleration;
                    }
                    else if (isDecelerating) {
                        vectorType = VerticalFlightPathVectorType.IdleDescentDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.IdleDescent;
                    }
                    if (isDecelerating) {
                        // If we are decelerating, we need to check if we went straight from a level deceleration into a descent
                        // deceleration. If so, we need to insert a new vector.
                        if (!decelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            decelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not decelerating, we need to check if the current vector is a deceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = decelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        decelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isDecelerating || !decelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        decelerationVectorStarted = isDecelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isDecelerating) {
                        vector.endCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(decelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                    lastVerticalPathVectorIndex = vectorIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isDecelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex++;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    decelerationVectorStarted = false;
                }
            }
            else {
                // The current leg is being skipped, which can only happen if it has no calculated lateral path or the lateral
                // path has a distance of zero. Therefore we insert one zero-length vector into the vertical path for the leg
                // and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isDecelerating) {
                    vectorType = isInLevelDecelerationPhase ? VerticalFlightPathVectorType.LevelDeceleration : VerticalFlightPathVectorType.IdleDescentDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.IdleDescent;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isDecelerating) {
                    vector.startCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(decelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                lastVerticalPathVectorIndex = 0;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                decelerationVectorStarted = false;
            }
        }
        verticalPath.todLegIndex = todLegIndex;
        verticalPath.todVectorIndex = todVectorIndex;
        verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
        verticalPath.perfDescentTodDistance = estimatedTodDistance;
        verticalPath.perfDescentSimDistance = totalDistanceCovered;
        verticalPath.geoDescentSimInterceptLegIndex = lastVerticalPathLegIndex;
        verticalPath.geoDescentSimInterceptVectorIndex = lastVerticalPathVectorIndex;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.geoDescentInterceptWeight = currentWeight;
        return totalDistanceCovered;
    }
    /**
     * Simulates the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c;
        const verticalPath = verticalPathEntry.path;
        if (verticalPlan.firstDescentConstraintLegIndex === undefined
            || verticalPlan.lastDescentConstraintLegIndex === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptVectorIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptLegIndex === undefined
            || verticalPath.geoDescentInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptWeight === undefined) {
            return;
        }
        const firstDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const lastDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        if (!firstDescentConstraint || !lastDescentConstraint) {
            return;
        }
        // Start simulation at the active leg, or the start of the geometric descent, whichever one comes later.
        const startAtActive = activeLegIndex > verticalPath.geoDescentSimInterceptLegIndex
            || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex && activeDistanceToLegEnd < verticalPath.geoDescentSimInterceptDistanceToLegEnd);
        let startLegIndex = startAtActive ? activeLegIndex : verticalPath.geoDescentSimInterceptLegIndex;
        // Simulate until the MAP or the end of the flight plan, whichever one comes first.
        const endLegIndex = Math.min(lateralLegs.length, (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : Infinity);
        if (startLegIndex >= endLegIndex) {
            return;
        }
        let startDistanceToLegEnd;
        let startWeight;
        let startVerticalPathLegIndex = startLegIndex;
        let startVerticalPathVectorIndex = 0;
        let startVerticalPathLegDuration = 0;
        if (startAtActive) {
            startDistanceToLegEnd = activeDistanceToLegEnd;
            startWeight = activeWeight;
        }
        else {
            startDistanceToLegEnd = verticalPath.geoDescentSimInterceptDistanceToLegEnd;
            startWeight = verticalPath.geoDescentInterceptWeight;
            startVerticalPathVectorIndex = verticalPath.geoDescentSimInterceptVectorIndex + 1;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            for (let i = 0; i < startVerticalPathVectorIndex; i++) {
                startVerticalPathLegDuration += pathLeg.vectors[i].duration;
            }
        }
        let startLeg = lateralLegs[startLegIndex];
        // If the current leg is not calculated, we are already at or past the end of the leg, or we are initially
        // intercepting the geometric descent at the first descent constraint, advance to the next leg.
        if (!startLeg.calculated
            || startDistanceToLegEnd <= 0
            || (startLegIndex === verticalPath.geoDescentInterceptLegIndex
                && verticalPath.geoDescentInterceptLegIndex === verticalPlan.constraints[firstDescentConstraintIndex].index
                && verticalPath.geoDescentInterceptDistanceToLegEnd === 0)) {
            startLegIndex++;
            startLeg = lateralLegs[startLegIndex];
            startDistanceToLegEnd = (_c = (_b = startLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            pathLeg.vectors.length = startVerticalPathVectorIndex;
            pathLeg.simDuration = startVerticalPathLegDuration;
            startVerticalPathLegIndex = startLegIndex;
            startVerticalPathVectorIndex = 0;
            startVerticalPathLegDuration = 0;
        }
        if (startAtActive) {
            // If we are starting at the active leg, then we need to clear all vectors prior to the starting leg
            for (let i = 0; i < startLegIndex; i++) {
                const leg = verticalPath.legs[i];
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
        }
        this.simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount);
        this.simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount);
    }
    /**
     * Performs a coarse simulation of the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param lastDescentConstraintIndex The index of the last descent altitude constraint in the flight plan.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param endLegIndex The global index of the flight plan leg at which to end the simulation, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount) {
        // Simulate coarse descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, or the next change in target airspeed, whichever is shorter.
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var _m, _o, _p, _q;
        const verticalPath = verticalPathEntry.path;
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legIndexOffset = startLegIndex;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentLeg = lateralLegs[currentLegIndex];
        let currentCoarsePathLegIndex = 0;
        let currentCoarsePathVectorIndex = 0;
        let currentWeight = startWeight;
        let currentAltitudeConstraintIndex = -1;
        let priorAltitudeConstraintIndex = -1;
        let currentAltitudeConstraint = undefined;
        let priorAltitudeConstraint = undefined;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        let useTransitionCas = false;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useRestrictionCas = false;
        const defaultTargetCas = descentCas;
        const defaultTargetMach = descentMach;
        let legCourse = undefined;
        let lastLegCourseIndex = undefined;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentLegIndex < endLegIndex) {
            // Update the current and prior altitude constraints for the current leg.
            if (currentLegIndex <= lastDescentConstraint.index) {
                if (!currentAltitudeConstraint || currentLegIndex > currentAltitudeConstraint.index) {
                    currentAltitudeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, currentLegIndex);
                    priorAltitudeConstraintIndex = currentAltitudeConstraintIndex + 1;
                }
            }
            else {
                currentAltitudeConstraintIndex = -1;
                priorAltitudeConstraintIndex = -1;
            }
            currentAltitudeConstraint = verticalPlan.constraints[currentAltitudeConstraintIndex];
            priorAltitudeConstraint = verticalPlan.constraints[priorAltitudeConstraintIndex];
            let distanceStep = distanceToLegEnd;
            let startAltitude;
            let endAltitude;
            let fpa; // Negative = descending path.
            // Calculate the current vector's start and end altitude and FPA.
            if (currentAltitudeConstraint && priorAltitudeConstraint) {
                // We are not past the last descent constraint.
                const verticalLeg = currentAltitudeConstraint.legs[currentAltitudeConstraint.index - currentLegIndex];
                const desiredAltitude = VNavUtils.altitudeForDistance(verticalLeg.fpa, distanceToLegEnd) + verticalLeg.altitude;
                if (desiredAltitude > priorAltitudeConstraint.targetAltitude + 1) {
                    // The desired altitude on the current leg's vertical path exceeds the prior constraint's target altitude
                    // (with tolerance to guard against floating point error and generating very short vectors when the vertical
                    // path doesn't quite line up with the lateral leg distance). Therefore we will hold the prior constraint's
                    // target altitude until we intercept the vertical path.
                    startAltitude = priorAltitudeConstraint.targetAltitude;
                    endAltitude = startAltitude;
                    fpa = 0;
                    if (verticalLeg.fpa > 0 && verticalLeg.altitude < priorAltitudeConstraint.targetAltitude) {
                        distanceStep = MathUtils.lerp(startAltitude, verticalLeg.altitude, desiredAltitude, distanceToLegEnd, 0);
                    }
                }
                else {
                    endAltitude = verticalLeg.altitude;
                    startAltitude = desiredAltitude;
                    fpa = -verticalLeg.fpa;
                }
            }
            else {
                // We are past the last descent constraint. Therefore we will hold the target altitude of the last constraint.
                startAltitude = lastDescentConstraint.targetAltitude;
                endAltitude = startAltitude;
                fpa = 0;
            }
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (!useTransitionCas && canUseTransitionCas) {
                if (startAltitude < transitionAltitude - 0.3048 || (startAltitude < transitionAltitude + 0.3048 && endAltitude < transitionAltitude - 0.3048)) {
                    useTransitionCas = true;
                }
            }
            if (!useRestrictionCas && canUseRestrictionCas) {
                if (startAltitude < restrictionAltitude - 0.3048 || (startAltitude < restrictionAltitude + 0.3048 && endAltitude < restrictionAltitude - 0.3048)) {
                    useRestrictionCas = true;
                }
            }
            const { targetCas, targetCasSource, targetMach, targetMachSource } = BoeingPathCalculator.getTargetSpeedData(defaultTargetCas, defaultTargetMach, currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
            // If the vector didn't start below the transition altitude but will end below it, then we will end the vector
            // at the transition altitude.
            if (!useTransitionCas && canUseTransitionCas && endAltitude < transitionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(transitionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = transitionAltitude;
            }
            // If the vector didn't start below the restriction altitude but will end below it, then we will end the vector
            // at the restriction altitude.
            if (!useRestrictionCas && canUseRestrictionCas && endAltitude < restrictionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(restrictionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = restrictionAltitude;
            }
            // Check if we need to update winds and delta ISA offset.
            if (startAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(startAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = startAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(startAltitude);
            const temperature = AeroMath.isaTemperature(startAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                if (currentLegIndex !== lastLegCourseIndex) {
                    legCourse = legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    lastLegCourseIndex = currentLegIndex;
                }
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windVector && windVector[1] > 0 && legCourse !== undefined) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(legCourse, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const vs = gs * Math.tan(fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                if (distanceStep >= distanceToLegEnd - 1e-3) {
                    distanceStep = distanceToLegEnd;
                }
                const timeStep = distanceStep / gs;
                const engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = startAltitude;
                const stepStartWeight = currentWeight;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    currentLegIndex = advanceLegIndexTo;
                    if (currentLegIndex < endLegIndex) {
                        currentLeg = lateralLegs[advanceLegIndexTo];
                        distanceToLegEnd = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                }
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentCoarsePathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = (_d = (_m = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _d !== void 0 ? _d : (_m[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                    const vector = (_e = (_o = pathLeg.vectors)[currentCoarsePathVectorIndex]) !== null && _e !== void 0 ? _e : (_o[currentCoarsePathVectorIndex] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.targetCas = targetCas;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = targetMach;
                    vector.targetMachSource = targetMachSource;
                    vector.fpa = fpa;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentCoarsePathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const pathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    pathLeg.vectors.length = currentCoarsePathVectorIndex;
                    pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                    pathLeg.distance = currentLegDistance;
                    pathLeg.course = legCourse;
                    currentCoarsePathLegIndex = advanceLegIndexTo - startLegIndex;
                    currentCoarsePathVectorIndex = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = (_f = (_p = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _f !== void 0 ? _f : (_p[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                const vector = (_g = (_q = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_q[0] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = startAltitude;
                vector.endAltitude = endAltitude;
                vector.targetCas = targetCas;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = targetMach;
                vector.targetMachSource = targetMachSource;
                vector.fpa = 0;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                pathLeg.vectors.length = 1;
                pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                pathLeg.distance = 0;
                pathLeg.course = undefined;
                currentLegIndex++;
                if (currentLegIndex < endLegIndex) {
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                }
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
            }
        }
        // Delete all coarse path legs after the last simulated leg.
        coarsePath.legs.length = currentCoarsePathLegIndex;
        if (coarsePath.legs.length === 0) {
            return;
        }
        // Compute estimated deceleration times and distances.
        // Get the speed constraint in effect after sequencing the last leg.
        const endSpeedConstraint = nextSpeedConstraint && endLegIndex > nextSpeedConstraint.globalLegIndex ? nextSpeedConstraint : undefined;
        const { targetCas: endTargetCas, targetCasSource: endTargetCasSource, targetMach: endTargetMach, targetMachSource: endTargetMachSource } = BoeingPathCalculator.getTargetSpeedData(defaultTargetCas, defaultTargetMach, endSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
        let distanceToEnd = 0;
        let nextVector;
        let nextCasToTarget;
        let anticipatedTargetCas = Infinity;
        let anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
        let anticipatedTargetMach = Infinity;
        let anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
        for (let i = coarsePath.legs.length - 1; i >= 0; i--) {
            const leg = coarsePath.legs[i];
            for (let j = leg.vectors.length - 1; j >= 0; j--) {
                const vector = leg.vectors[j];
                // Check if we need to update winds and delta ISA offset.
                if (lastWeatherAltitude === undefined || Math.abs(vector.endAltitude - lastWeatherAltitude) > 1) {
                    const currentAltitudeFeet = UnitType.METER.convertTo(vector.endAltitude, UnitType.FOOT);
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                    deltaIsa = (_k = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _k !== void 0 ? _k : 0;
                    lastWeatherAltitude = vector.endAltitude;
                }
                const pressure = AeroMath.isaPressure(vector.endAltitude);
                const casToTarget = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, pressure));
                if (nextCasToTarget === undefined) {
                    // If nextCasToTarget is undefined, then we are not extending deceleration from the succeeding vector (the
                    // previous one to be iterated) into the current vector. Therefore, we will set the anticipated speed values to
                    // be equal to the target speed at the beginning of the succeeding vector.
                    if (nextVector) {
                        nextCasToTarget = Math.min(nextVector.targetCas, AeroMath.machToCas(nextVector.targetMach, pressure));
                        anticipatedTargetCas = nextVector.targetCas;
                        anticipatedTargetCasSource = nextVector.targetCasSource;
                        anticipatedTargetMach = nextVector.targetMach;
                        anticipatedTargetMachSource = nextVector.targetMachSource;
                    }
                    else {
                        nextCasToTarget = Math.min(endTargetCas, AeroMath.machToCas(endTargetMach, pressure));
                        anticipatedTargetCas = endTargetCas;
                        anticipatedTargetCasSource = endTargetCasSource;
                        anticipatedTargetMach = endTargetMach;
                        anticipatedTargetMachSource = endTargetMachSource;
                    }
                }
                if (isFinite(casToTarget) && isFinite(nextCasToTarget) && nextCasToTarget < casToTarget - 0.5) {
                    // We need to decelerate.
                    const initialMach = AeroMath.casToMach(casToTarget, pressure);
                    const finalMach = AeroMath.casToMach(nextCasToTarget, pressure);
                    const temperature = AeroMath.isaTemperature(vector.endAltitude) + deltaIsa;
                    const density = AeroMath.densityAir(pressure, temperature);
                    const soundSpeed = AeroMath.soundSpeedAir(temperature);
                    const initialTas = AeroMath.machToTas(initialMach, soundSpeed);
                    const finalTas = AeroMath.machToTas(finalMach, soundSpeed);
                    // Find the wind component along the leg's course.
                    let wind = 0;
                    if (leg.course !== undefined && windVector && windVector[0] > 0) {
                        wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(leg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                    }
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(initialTas, finalTas));
                    const initialGs = initialTas + wind;
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, initialMach);
                    const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, initialMach, pressure, temperature);
                    const vs = VNavUtils.altitudeForDistance(vector.fpa, initialGs);
                    const [timeToDecel, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineIdleNetThrust, engineCount, wingArea, 0, vector.endWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_DESCENT_DECELERATION);
                    vector.estimatedDecelTime = timeToDecel;
                    vector.estimatedDecelDistance = distanceToDecel + wind * timeToDecel;
                    vector.estimatedDecelStartTas = initialTas;
                    vector.estimatedDecelEndTas = finalTas;
                    vector.estimatedDecelWind = wind;
                    vector.anticipatedTargetCas = anticipatedTargetCas;
                    vector.anticipatedTargetCasSource = anticipatedTargetCasSource;
                    vector.anticipatedTargetMach = anticipatedTargetMach;
                    vector.anticipatedTargetMachSource = anticipatedTargetMachSource;
                    const vectorDistance = vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
                    if (vector.estimatedDecelDistance > vectorDistance) {
                        // The distance required to decelerate is longer than the vector. Therefore, we need to determine the
                        // speed at the start of the vector such that a deceleration starting at that speed will reach the
                        // anticipated target speed at the end of the vector.
                        const acceleration = (finalTas - initialTas) / timeToDecel;
                        vector.estimatedDecelTime = BoeingPathCalculator.timeToDistance(vectorDistance, initialTas + wind, acceleration);
                        vector.estimatedDecelDistance = vectorDistance;
                        // Check if we need to get updated weather data for the altitude at the start of the vector.
                        if (lastWeatherAltitude === undefined || Math.abs(vector.startAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(vector.startAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                            deltaIsa = (_l = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _l !== void 0 ? _l : 0;
                            lastWeatherAltitude = vector.startAltitude;
                        }
                        const vectorStartPressure = AeroMath.isaPressure(vector.startAltitude);
                        const vectorStartSoundSpeed = AeroMath.soundSpeedIsa(vector.startAltitude, deltaIsa);
                        let vectorStartTas = finalTas - acceleration * vector.estimatedDecelTime;
                        let vectorStartCas = AeroMath.machToCas(AeroMath.tasToMach(vectorStartTas, vectorStartSoundSpeed), vectorStartPressure);
                        // If the altitude is different between the start and end of the vector, then we need to make sure that the
                        // different airspeed conversions don't result in the estimated CAS at the start of the vector being less
                        // than the anticipated CAS at the end of the vector.
                        if (vectorStartCas < nextCasToTarget) {
                            vectorStartCas = nextCasToTarget;
                            vectorStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartCas, vectorStartPressure), vectorStartSoundSpeed);
                        }
                        // Check if the estimated CAS at the start of the vector is less than the (non-anticipated) target CAS at
                        // the start of the vector. If it is, then we need to extend the deceleration into the preceding vector
                        // (the next one to be iterated). If it is not, then we will have the deceleration start at the beginning
                        // of the vector at the non-anticipated target speed.
                        const vectorStartTargetCas = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, vectorStartPressure));
                        if (vectorStartCas < vectorStartTargetCas) {
                            vector.estimatedDecelStartTas = vectorStartTas;
                            // Set nextCasToTarget so that the preceding vector (the next one to be iterated) will anticipate the
                            // speed at the start of this vector required to meet this vector's anticipated speed target instead of
                            // this vector's target speed.
                            nextCasToTarget = vectorStartCas;
                        }
                        else {
                            vector.estimatedDecelStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartTargetCas, vectorStartPressure), vectorStartSoundSpeed);
                            nextCasToTarget = undefined;
                        }
                    }
                    else {
                        nextCasToTarget = undefined;
                    }
                }
                else {
                    vector.estimatedDecelTime = 0;
                    vector.estimatedDecelDistance = 0;
                    vector.estimatedDecelStartTas = 0;
                    vector.estimatedDecelEndTas = 0;
                    vector.estimatedDecelWind = 0;
                    vector.anticipatedTargetCas = Infinity;
                    vector.anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
                    vector.anticipatedTargetMach = Infinity;
                    vector.anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
                    nextCasToTarget = undefined;
                }
                nextVector = vector;
            }
            leg.endDistanceToEnd = distanceToEnd;
            distanceToEnd += leg.distance;
        }
    }
    /**
     * Performs a detailed simulation of the VNAV geometric descent phase of a flight plan.
     * @param verticalPathEntry The entry for the vertical flight path.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startVerticalPathLegIndex The index of the vertical path leg at which to start the simulation.
     * @param startVerticalPathVectorIndex The within-leg index of the vertical path vector at which to start the
     * simulation.
     * @param startVerticalPathLegDuration The total duration, in seconds, of all vertical path vectors in the leg
     * containing the start of the simulation that are situated prior to the start point.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount) {
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, the next change in target airspeed, or 1000 feet of descent, whichever is shorter.
        var _a, _b, _c, _d, _e;
        var _f, _g;
        const verticalPath = verticalPathEntry.path;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentVerticalPathLegIndex = startVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = startVerticalPathVectorIndex;
        let currentVerticalPathLegDuration = startVerticalPathLegDuration;
        let currentWeight = startWeight;
        let currentCoarsePathLegIndex = startLegIndex - coarsePath.legIndexOffset;
        let currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
        let currentCoarsePathVectorIndex = 0;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentCoarsePathLegIndex < coarsePath.legs.length) {
            // Find the coarse path vector containing the current position in the simulation.
            let coarsePathVector = currentCoarsePathLeg.vectors[currentCoarsePathVectorIndex];
            while (currentCoarsePathVectorIndex < currentCoarsePathLeg.vectors.length - 1 && coarsePathVector.endDistanceToLegEnd > distanceToLegEnd) {
                coarsePathVector = currentCoarsePathLeg.vectors[++currentCoarsePathVectorIndex];
            }
            // If the current coarse path vector has zero length, then currentAltitude will be set to the start altitude
            // because lerp() defaults to y0 when x0 and x1 are equal.
            const currentAltitude = MathUtils.lerp(distanceToLegEnd, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude, true, true);
            let altitudeStep;
            let distanceStep;
            // Check if we need to update winds and delta ISA offset.
            if (lastWeatherAltitude === undefined || Math.abs(currentAltitude - lastWeatherAltitude) > 1) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, pressure));
            if (currentCoarsePathLeg.distance > 0) {
                // Find the wind component along the leg's course.
                let wind = 0;
                if (currentCoarsePathLeg.course !== undefined && windVector && windVector[0] > 0) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS)
                        * Math.cos(MathUtils.diffAngleDeg(currentCoarsePathLeg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                let maxDistanceStep;
                let isDecelerating;
                let acceleration;
                if (coarsePathVector.estimatedDecelTime > 0) {
                    // The current coarse path vector ends with a deceleration to an anticipated target speed.
                    const decelStartDistanceToLegEnd = coarsePathVector.estimatedDecelDistance + coarsePathVector.endDistanceToLegEnd;
                    if (decelStartDistanceToLegEnd > distanceToLegEnd - 1e-3) {
                        // We are currently decelerating.
                        maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                        isDecelerating = true;
                        acceleration = (coarsePathVector.estimatedDecelEndTas - coarsePathVector.estimatedDecelStartTas) / coarsePathVector.estimatedDecelTime;
                    }
                    else {
                        // We have not yet reached the point where deceleration starts. We need to ensure that the current vector
                        // does not extend beyond the deceleration start point.
                        maxDistanceStep = distanceToLegEnd - decelStartDistanceToLegEnd;
                        isDecelerating = false;
                        acceleration = 0;
                    }
                }
                else {
                    // The current coarse path vector does not end with a deceleration.
                    maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    isDecelerating = false;
                    acceleration = 0;
                }
                if (coarsePathVector.fpa < 0) {
                    const maxAltitudeStep = currentAltitude - MathUtils.lerp(distanceToLegEnd - maxDistanceStep, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude);
                    if (maxAltitudeStep > BoeingPathCalculator.MAX_ALTITUDE_STEP + BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_ALTITUDE_STEP / maxAltitudeStep * maxDistanceStep;
                        altitudeStep = BoeingPathCalculator.MAX_ALTITUDE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                        altitudeStep = maxAltitudeStep;
                    }
                }
                else {
                    if (maxDistanceStep > BoeingPathCalculator.MAX_DISTANCE_STEP + BoeingPathCalculator.MAX_DISTANCE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                    }
                    altitudeStep = 0;
                }
                let endDistanceToLegEnd;
                let endAltitude;
                let shouldAdvanceVector;
                // Check if we need to advance to the next coarse path vector after the current step, with tolerance for
                // floating point errors.
                if (distanceToLegEnd - distanceStep < coarsePathVector.endDistanceToLegEnd + 1e-3) {
                    distanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    endDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd;
                    endAltitude = coarsePathVector.endAltitude;
                    shouldAdvanceVector = true;
                }
                else {
                    endDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    endAltitude = currentAltitude - altitudeStep;
                    shouldAdvanceVector = false;
                }
                let startCas;
                let startMach;
                let endCas;
                let endMach;
                let mach;
                let tas;
                let gs;
                let timeStep;
                if (isDecelerating) {
                    const decelStartDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd + coarsePathVector.estimatedDecelDistance;
                    const startTimeToDecelEnd = distanceToLegEnd >= decelStartDistanceToLegEnd - 1
                        ? coarsePathVector.estimatedDecelTime
                        : BoeingPathCalculator.timeToDistance(distanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const endTimeToDecelEnd = endDistanceToLegEnd <= coarsePathVector.endDistanceToLegEnd + 1
                        ? 0
                        : BoeingPathCalculator.timeToDistance(endDistanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const startTas = coarsePathVector.estimatedDecelEndTas - acceleration * startTimeToDecelEnd;
                    const endTas = coarsePathVector.estimatedDecelEndTas - acceleration * endTimeToDecelEnd;
                    tas = startTas;
                    mach = AeroMath.tasToMach(tas, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(startTas, endTas));
                    gs = tas + wind;
                    timeStep = BoeingPathCalculator.timeToDistance(distanceStep, gs, acceleration);
                    if (!isFinite(timeStep)) {
                        timeStep = distanceStep / ((startTas + endTas) / 2 + wind);
                    }
                    if (altitudeStep > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                            deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                            lastWeatherAltitude = endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(endAltitude, deltaIsa);
                        endMach = AeroMath.tasToMach(endTas, endSoundSpeed);
                        endCas = AeroMath.machToCas(endMach, endPressure);
                    }
                    else {
                        endMach = AeroMath.tasToMach(endTas, soundSpeed);
                        endCas = AeroMath.machToCas(endMach, pressure);
                    }
                    startMach = AeroMath.tasToMach(startTas, soundSpeed);
                    startCas = AeroMath.machToCas(startMach, pressure);
                    if (startCas < endCas) {
                        startCas = endCas;
                        startMach = AeroMath.casToMach(startCas, pressure);
                    }
                }
                else {
                    mach = AeroMath.casToMach(casToTarget, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                    gs = tas + wind;
                    timeStep = distanceStep / gs;
                    startCas = casToTarget;
                    startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (altitudeStep > 1) {
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endCasToTarget = coarsePathVector.targetCas;
                        const endMachCasToTarget = AeroMath.machToCas(coarsePathVector.targetMach, endPressure);
                        if (endMachCasToTarget <= endCasToTarget) {
                            endCas = endMachCasToTarget;
                            endMach = coarsePathVector.targetMach;
                        }
                        else {
                            endCas = endCasToTarget;
                            endMach = AeroMath.casToMach(casToTarget, endPressure);
                        }
                    }
                    else {
                        endCas = startCas;
                        endMach = startMach;
                    }
                }
                const vs = gs * Math.tan(coarsePathVector.fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let engineGrossThrust;
                if (isDecelerating) {
                    // Assume engines are at idle if we are decelerating.
                    engineGrossThrust = this.perfProvider.getEngineIdleGrossThrust(pressure, temperature, mach);
                }
                else {
                    engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                }
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg at the end of the step. If so, advance to the next leg.
                let advanceLegIndexTo = undefined;
                if (shouldAdvanceVector && currentCoarsePathVectorIndex + 1 >= currentCoarsePathLeg.vectors.length) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                distanceToLegEnd = endDistanceToLegEnd;
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_c = (_f = pathLeg.vectors)[currentVerticalPathVectorIndex]) !== null && _c !== void 0 ? _c : (_f[currentVerticalPathVectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    if (isDecelerating) {
                        vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                        vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    }
                    else {
                        vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.targetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                        vector.targetMachSource = coarsePathVector.targetMachSource;
                    }
                    vector.startCas = UnitType.MPS.convertTo(startCas, UnitType.KNOT);
                    vector.startMach = startMach;
                    vector.endCas = UnitType.MPS.convertTo(endCas, UnitType.KNOT);
                    vector.endMach = endMach;
                    vector.duration = timeStep;
                    vector.simEndDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentVerticalPathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentCoarsePathLeg.distance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentLegIndex = advanceLegIndexTo;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    currentCoarsePathLegIndex = advanceLegIndexTo - coarsePath.legIndexOffset;
                    currentCoarsePathVectorIndex = 0;
                    if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                        currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                        distanceToLegEnd = currentCoarsePathLeg.distance;
                    }
                }
                else if (shouldAdvanceVector) {
                    currentCoarsePathVectorIndex++;
                }
            }
            else {
                // The current leg has a distance of zero. Therefore we insert one zero-length vector into the vertical path
                // for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_d = (_g = pathLeg.vectors)[0]) !== null && _d !== void 0 ? _d : (_g[0] = BoeingPathCalculator.createVerticalPathVector());
                const isDecelerating = coarsePathVector.anticipatedTargetCasSource !== VerticalFlightPathVectorSpeedSource.None
                    || coarsePathVector.anticipatedTargetMachSource !== VerticalFlightPathVectorSpeedSource.None;
                vector.gs = AeroMath.casToTas(casToTarget, pressure, temperature);
                vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = coarsePathVector.startAltitude;
                vector.endAltitude = coarsePathVector.endAltitude;
                if (isDecelerating) {
                    vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                    vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    vector.startMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelStartTas, soundSpeed);
                    vector.startCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.startMach, pressure), UnitType.KNOT);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(coarsePathVector.endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(coarsePathVector.endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                            deltaIsa = (_e = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _e !== void 0 ? _e : 0;
                            lastWeatherAltitude = coarsePathVector.endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(coarsePathVector.endAltitude, deltaIsa);
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, endSoundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, endPressure), UnitType.KNOT);
                    }
                    else {
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, soundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, pressure), UnitType.KNOT);
                    }
                }
                else {
                    vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.targetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                    vector.targetMachSource = coarsePathVector.targetMachSource;
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endCasToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, endPressure));
                        vector.endMach = UnitType.MPS.convertTo(endCasToTarget, UnitType.KNOT);
                        vector.endCas = AeroMath.casToMach(endCasToTarget, endPressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    vector.endCas = vector.startCas;
                    vector.endMach = vector.startMach;
                }
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
                if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                    currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    distanceToLegEnd = currentCoarsePathLeg.distance;
                }
            }
        }
    }
    /**
     * Creates a new speed constraint list item.
     * @returns A new speed constraint list item.
     */
    static createSpeedConstraintListItem() {
        return {
            globalLegIndex: 0,
            flightPhase: VerticalFlightPhase.Climb,
            speedConstraint: {
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS
            },
            isMissedApproach: false,
            minCas: -Infinity,
            maxCas: Infinity,
            minMach: -Infinity,
            maxMach: Infinity
        };
    }
    /**
     * Creates a new planned cruise step object.
     * @returns A new planned cruise step object.
     */
    static createPlannedCruiseStep() {
        return {
            globalLegIndex: 0,
            toAltitude: 0,
            deferredDistance: 0,
            isInvalid: false
        };
    }
    /**
     * Creates a new vertical flight path.
     * @param planIndex The index of the path's associated flight plan. Defaults to `0`.
     * @returns A new vertical flight path.
     */
    static createVerticalPath(planIndex = 0) {
        return {
            planIndex,
            legs: [],
            cruiseSteps: [],
            isPending: false,
            tocLegIndex: undefined,
            tocVectorIndex: undefined,
            tocDistanceToLegEnd: undefined,
            tocWeight: undefined,
            predictedCruiseDistance: undefined,
            predictedCruiseDuration: undefined,
            todLegIndex: undefined,
            todVectorIndex: undefined,
            todDistanceToLegEnd: undefined,
            perfDescentTodDistance: undefined,
            perfDescentSimDistance: undefined,
            geoDescentInterceptLegIndex: undefined,
            geoDescentInterceptDistanceToLegEnd: undefined,
            geoDescentSimInterceptLegIndex: undefined,
            geoDescentSimInterceptVectorIndex: undefined,
            geoDescentSimInterceptDistanceToLegEnd: undefined,
            geoDescentInterceptWeight: undefined
        };
    }
    /**
     * Creates a new vertical flight path leg.
     * @returns A new vertical flight path leg.
     */
    static createVerticalPathLeg() {
        return {
            vectors: [],
            simDistance: 0,
            simDuration: 0
        };
    }
    /**
     * Creates a new vertical flight path vector.
     * @returns A new vertical flight path vector.
     */
    static createVerticalPathVector() {
        return {
            type: VerticalFlightPathVectorType.Climb,
            simStartDistanceToLegEnd: 0,
            simEndDistanceToLegEnd: 0,
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: NaN,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: NaN,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            startCas: 0,
            startMach: 0,
            endCas: 0,
            endMach: 0,
            gs: 0,
            startWeight: 0,
            endWeight: 0,
            duration: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path vector.
     * @returns A new geometric descent coarse vertical flight path vector.
     */
    static createCruiseStep() {
        return {
            globalLegIndex: -1,
            distanceToLegEnd: 0,
            fromAltitude: 0,
            toAltitude: 0,
            plannedStepIndex: -1
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path.
     * @returns A new geometric descent coarse vertical flight path.
     */
    static createGeometricDescentCoarsePath() {
        return {
            legs: [],
            legIndexOffset: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path leg.
     * @returns A new geometric descent coarse vertical flight path leg.
     */
    static createGeometricDescentCoarseLeg() {
        return {
            vectors: [],
            altitudeConstraintIndex: -1,
            distance: 0,
            endDistanceToEnd: 0,
            course: undefined
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path vector.
     * @returns A new geometric descent coarse vertical flight path vector.
     */
    static createGeometricDescentCoarseVector() {
        return {
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: Infinity,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: Infinity,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            fpa: 0,
            anticipatedTargetCas: Infinity,
            anticipatedTargetCasSource: VerticalFlightPathVectorSpeedSource.None,
            anticipatedTargetMach: Infinity,
            anticipatedTargetMachSource: VerticalFlightPathVectorSpeedSource.None,
            estimatedDecelTime: 0,
            estimatedDecelDistance: 0,
            estimatedDecelStartTas: 0,
            estimatedDecelEndTas: 0,
            estimatedDecelWind: 0,
            startWeight: 0,
            endWeight: 0
        };
    }
    /**
     * Copies a vertical flight path.
     * @param source The path to copy from.
     * @param target The path to copy to. If not defined, a new vertical flight path will be created.
     * @returns The vertical flight path that was copied to.
     */
    static copyVerticalPath(source, target) {
        if (!target) {
            target = BoeingPathCalculator.createVerticalPath(source.planIndex);
        }
        target.legs.length = source.legs.length;
        for (let i = 0; i < source.legs.length; i++) {
            target.legs[i] = BoeingPathCalculator.copyVerticalPathLeg(source.legs[i], target.legs[i]);
        }
        target.tocLegIndex = source.tocLegIndex;
        target.tocVectorIndex = source.tocVectorIndex;
        target.tocDistanceToLegEnd = source.tocDistanceToLegEnd;
        target.tocWeight = source.tocWeight;
        target.predictedCruiseDistance = source.predictedCruiseDistance;
        target.predictedCruiseDuration = source.predictedCruiseDuration;
        target.todLegIndex = source.todLegIndex;
        target.todVectorIndex = source.todVectorIndex;
        target.todDistanceToLegEnd = source.todDistanceToLegEnd;
        target.perfDescentTodDistance = source.perfDescentTodDistance;
        target.perfDescentSimDistance = source.perfDescentSimDistance;
        target.geoDescentInterceptLegIndex = source.geoDescentInterceptLegIndex;
        target.geoDescentInterceptDistanceToLegEnd = source.geoDescentInterceptDistanceToLegEnd;
        target.geoDescentSimInterceptLegIndex = source.geoDescentSimInterceptLegIndex;
        target.geoDescentSimInterceptVectorIndex = source.geoDescentSimInterceptVectorIndex;
        target.geoDescentSimInterceptDistanceToLegEnd = source.geoDescentSimInterceptDistanceToLegEnd;
        target.geoDescentInterceptWeight = source.geoDescentInterceptWeight;
        return target;
    }
    /**
     * Copies a vertical flight path leg.
     * @param source The leg to copy from.
     * @param target The leg to copy to. If not defined, a new vertical flight path leg will be created.
     * @returns The vertical flight path leg that was copied to.
     */
    static copyVerticalPathLeg(source, target) {
        var _a;
        if (!target) {
            target = BoeingPathCalculator.createVerticalPathLeg();
        }
        target.vectors.length = source.vectors.length;
        for (let i = 0; i < source.vectors.length; i++) {
            target.vectors[i] = Object.assign((_a = target.vectors[i]) !== null && _a !== void 0 ? _a : {}, source.vectors[i]);
        }
        target.simDistance = source.simDistance;
        target.simDuration = source.simDuration;
        return target;
    }
    /**
     * Gets the time required to travel a given distance with constant acceleration.
     * @param distance The distance to travel.
     * @param v0 The initial velocity. The value should be expressed in units of `distance` per unit time.
     * @param acceleration The acceleration. The value should be expressed in units of `distance` per unit time squared.
     * @returns The time required to travel the specified distance given the specified constant acceleration from the
     * initial velocity. The value is expressed in the unit of time chosen for `v0` and `acceleration`.
     */
    static timeToDistance(distance, v0, acceleration) {
        if (acceleration === 0) {
            return distance / v0;
        }
        const a = acceleration / 2;
        const b = v0;
        const c = -distance;
        return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * Gets the acceleration required to change velocity from an initial to a final value over a given distance.
     * @param distance The distance over which to accelerate.
     * @param v0 The initial velocity, expressed in units of {@linkcode distance} over time.
     * @param v1 The final velocity, expressed in units of {@linkcode distance} over time.
     * @returns The acceleration required to change from the specified initial to final velocities over the specified
     * distance. The acceleration is expressed in units of {@linkcode distance} over time squared.
     */
    static getRequiredAcceleration(distance, v0, v1) {
        return (v1 * v1 - v0 * v0) / (2 * distance);
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a speed constraint in the
     * same flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param speedConstraint The speed constraint to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified speed constraint.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToSpeedConstraint(lateralLegs, speedConstraint, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= speedConstraint.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(speedConstraint.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(speedConstraint.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance;
        }
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a cruise step in the same
     * flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param cruiseStep The cruise step to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified cruise step.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToCruiseStep(lateralLegs, cruiseStep, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= cruiseStep.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(cruiseStep.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance - cruiseStep.distanceToLegEnd;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(cruiseStep.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance - cruiseStep.distanceToLegEnd;
        }
    }
    /**
     * Gets the calibrated airspeed (CAS) to target, in meters per second.
     * @param defaultCas The default CAS to target, in meters per second.
     * @param speedConstraint The speed constraint in effect.
     * @param transitionCas The transition speed in effect, in meters per second.
     * @param restrictionCas The restriction speed in effect, in meters per second.
     * @returns The calibrated airspeed (CAS) to target, in meters per second, given the specified default CAS target,
     * speed constraint, and transition and restriction speeds.
     */
    static getTargetCas(defaultCas, speedConstraint, transitionCas, restrictionCas) {
        let targetCas = defaultCas;
        if (speedConstraint) {
            if (speedConstraint.minCas > targetCas) {
                targetCas = speedConstraint.minCas;
            }
            if (speedConstraint.maxCas < targetCas) {
                targetCas = speedConstraint.maxCas;
            }
        }
        if (restrictionCas !== undefined && restrictionCas < targetCas) {
            targetCas = restrictionCas;
        }
        if (transitionCas !== undefined && transitionCas < targetCas) {
            targetCas = transitionCas;
        }
        return targetCas;
    }
    /**
     * Gets the mach number to target.
     * @param defaultMach The default mach number to target.
     * @param speedConstraint The speed constraint in effect.
     * @returns The mach number to target, given the specified default mach target and speed constraint.
     */
    static getTargetMach(defaultMach, speedConstraint) {
        let targetMach = defaultMach;
        if (speedConstraint) {
            if (speedConstraint.minMach > targetMach) {
                targetMach = speedConstraint.minMach;
            }
            if (speedConstraint.maxMach < targetMach) {
                targetMach = speedConstraint.maxMach;
            }
        }
        return targetMach;
    }
    /**
     * Gets target speed data.
     * @param scheduleCas The scheduled calibrated airspeed, in meters per second, or `Infinity` if there is no scheduled
     * calibrated airspeed.
     * @param scheduleMach The scheduled mach number, or `Infinity` if there is no scheduled mach number.
     * @param speedConstraint The speed constraint in effect.
     * @param transitionCas The transition speed in effect, in meters per second.
     * @param restrictionCas The restriction speed in effect, in meters per second.
     * @param out The object to which to write the results.
     * @returns The target speed data given the specified scheduled speeds, speed constraint, and transition/restriction
     * speed limits.
     */
    static getTargetSpeedData(scheduleCas, scheduleMach, speedConstraint, transitionCas, restrictionCas, out) {
        out.targetCas = scheduleCas;
        out.targetCasSource = isFinite(scheduleCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        out.targetMach = scheduleMach;
        out.targetMachSource = isFinite(scheduleMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        if (speedConstraint) {
            if (speedConstraint.minCas > out.targetCas) {
                out.targetCas = speedConstraint.minCas;
                out.targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (speedConstraint.maxCas < out.targetCas) {
                out.targetCas = speedConstraint.maxCas;
                out.targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (speedConstraint.minMach > out.targetMach) {
                out.targetMach = speedConstraint.minCas;
                out.targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (speedConstraint.maxMach < out.targetMach) {
                out.targetMach = speedConstraint.maxMach;
                out.targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
        }
        if (restrictionCas !== undefined && restrictionCas < out.targetCas) {
            out.targetCas = restrictionCas;
            out.targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (transitionCas !== undefined && transitionCas < out.targetCas) {
            out.targetCas = transitionCas;
            out.targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        return out;
    }
    /**
     * Gets the average true course, in degrees, along a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The average true course, in degrees, along the specified flight plan leg, or `undefined` if the
     * leg's lateral path has not been calculated or its lateral distance is zero.
     */
    static getAverageLegCourse(leg) {
        if (leg.calculated
            && leg.calculated.startLat !== undefined
            && leg.calculated.startLon !== undefined
            && leg.calculated.endLat !== undefined
            && leg.calculated.endLon !== undefined) {
            const legCourse = GeoPoint.finalBearing(leg.calculated.startLat, leg.calculated.startLon, leg.calculated.endLat, leg.calculated.endLon);
            if (!isFinite(legCourse)) {
                return undefined;
            }
            else {
                return legCourse;
            }
        }
        else {
            return undefined;
        }
    }
    /**
     * Gets the effective wind component, in meters per second, along a course. The effective wind component is defined
     * such that for an airplane whose ground track is equal to the course, the airplane's ground speed is equal to the
     * airplane's true airspeed plus the effective wind component.
     * @param course The true course along which to get the wind component, in degrees.
     * @param windDirection The true wind direction, in degrees.
     * @param windSpeed The wind speed, in knots.
     * @param tas The airplane's true airspeed, in meters per second. If not defined, then the tailwind component along
     * the specified course will be returned (i.e. the scalar projection of the wind vector onto the course vector)
     * instead of the effective wind component.
     * @returns The effective wind component, in meters per second, along the specified course.
     */
    static getAlongCourseWindComponent(course, windDirection, windSpeed, tas) {
        if (windSpeed > 0) {
            const windMps = UnitType.KNOT.convertTo(windSpeed, UnitType.MPS);
            // Tailwind component along the course.
            const tailwind = windMps * Math.cos(MathUtils.diffAngleDeg(course, windDirection + 180, false) * Avionics.Utils.DEG2RAD);
            if (tas === undefined) {
                return tailwind;
            }
            else {
                // The airplane must adjust its heading (and therefore the direction of its TAS vector) to compensate for
                // crosswind in order to stay on course. In doing so, the along-course component of the TAS vector decreases.
                const cross = Math.sqrt(Math.max(windMps * windMps - tailwind * tailwind, 0));
                const alongCourseTas = Math.sqrt(Math.max(tas * tas - cross * cross, 0));
                return alongCourseTas + tailwind - tas;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * Gets an appropriate cruise vertical flight path vector type.
     * @param altitudeStep The altitude step for the vector, in meters.
     * @param acceleration The acceleration for the vector, in meters per second squared.
     * @returns An appropriate cruise vertical flight path vector type for a vector with the specified altitude step
     * and acceleration.
     */
    static getCruiseVectorType(altitudeStep, acceleration) {
        if (altitudeStep === 0) {
            if (acceleration === 0) {
                return VerticalFlightPathVectorType.Cruise;
            }
            else if (acceleration < 0) {
                return VerticalFlightPathVectorType.CruiseDeceleration;
            }
            else {
                return VerticalFlightPathVectorType.CruiseAcceleration;
            }
        }
        else if (altitudeStep > 0) {
            if (acceleration === 0) {
                return VerticalFlightPathVectorType.CruiseStepClimb;
            }
            else if (acceleration < 0) {
                return VerticalFlightPathVectorType.CruiseStepClimbDeceleration;
            }
            else {
                return VerticalFlightPathVectorType.CruiseStepClimbAcceleration;
            }
        }
        else {
            if (acceleration === 0) {
                return VerticalFlightPathVectorType.CruiseStepDescent;
            }
            else if (acceleration < 0) {
                return VerticalFlightPathVectorType.CruiseStepDescentDeceleration;
            }
            else {
                return VerticalFlightPathVectorType.CruiseStepDescentAcceleration;
            }
        }
    }
    /**
     * Gets the geo circle representation of the course at and the position vector of a point along a flight plan leg's
     * lateral flight path.
     * @param legCalc The lateral flight path calculations for a flight plan leg.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of the flight plan leg.
     * @param courseOut The geo circle to which write the flight path course at the query point.
     * @param positionOut The 3D vector to which to write the position vector of the query point.
     * @returns Whether a course and position vector were successfully found for the query point.
     */
    static getCourseAndPositionAlongLeg(legCalc, distanceToLegEnd, courseOut, positionOut) {
        // Iterate over all vectors (including transitions) in the leg in forward order until we reach the query point.
        let distanceToGo = legCalc.distanceWithTransitions - distanceToLegEnd;
        let vectors = legCalc.ingress;
        let vectorIndex = 0;
        let vector = vectors[vectorIndex];
        let lastVector = undefined;
        // ingress vectors
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // ingress to egress vectors
        vectors = legCalc.ingressToEgress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // egress vectors
        vectors = legCalc.egress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // If we have exhausted all vectors on the leg without reaching the query point, advance past the end of the last
        // vector (if it exists).
        if (lastVector) {
            FlightPathUtils.setGeoCircleFromVector(lastVector, courseOut);
            courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(lastVector.endLat, lastVector.endLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
            return true;
        }
        return false;
    }
}
BoeingPathCalculator.MAX_DISTANCE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.MAX_DISTANCE_STEP_TOL = 18520; // meters (10 nautical miles)
BoeingPathCalculator.MAX_ALTITUDE_STEP = 304.8; // meters (1000 feet)
BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL = 30.48; // meters (100 feet)
BoeingPathCalculator.CLIMB_ACCEL_VS_MPS = UnitType.FPM.convertTo(500, UnitType.MPS);
BoeingPathCalculator.DESCENT_DECEL_VS_MPS = UnitType.FPM.convertTo(-500, UnitType.MPS);
BoeingPathCalculator.MIN_GROUND_SPEED = 25.722; // meters per second (50 knots)
BoeingPathCalculator.MIN_CLIMB_VS_MPS = UnitType.FPM.convertTo(200, UnitType.MPS);
BoeingPathCalculator.MIN_CLIMB_ACCELERATION = UnitType.KNOT_PER_SEC.convertTo(0.1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_LEVEL_ACCELERATION = UnitType.KNOT_PER_SEC.convertTo(0.1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_LEVEL_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(0.5, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_DESCENT_ACCELERATION = UnitType.KNOT_PER_SEC.convertTo(0.1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_DESCENT_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(0.5, UnitType.MPS_PER_SEC);
BoeingPathCalculator.ASSUMED_CLIMB_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(-1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.CRUISE_STEP_START_MARGIN = 926000; // meters (500 nautical miles)
BoeingPathCalculator.CRUISE_STEP_TOD_MARGIN = 370400; // meters (200 nautical miles)
BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP_TOL = 18520; // meters (10 nautical miles)
BoeingPathCalculator.CRUISE_STEP_EVALUATE_LOOKAHEAD = 926000; // meters (500 nautical miles)
BoeingPathCalculator.CRUISE_STEP_CLIMB_RESIDUAL_VS_MPS = UnitType.FPM.convertTo(200, UnitType.MPS);
BoeingPathCalculator.CRUISE_DESCENT_VS_MPS = UnitType.FPM.convertTo(-1250, UnitType.MPS);
BoeingPathCalculator.CRUISE_ANTICIPATION_ASSUMED_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(-2, UnitType.MPS_PER_SEC);
BoeingPathCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingPathCalculator.vec3Cache = [Vec3Math.create()];
BoeingPathCalculator.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
BoeingPathCalculator.windCache = new Float64Array(2);
BoeingPathCalculator.econSpeedCache = new Float64Array(2);
BoeingPathCalculator.targetSpeedDataCache = {
    targetCas: Infinity,
    targetCasSource: VerticalFlightPathVectorSpeedSource.None,
    targetMach: Infinity,
    targetMachSource: VerticalFlightPathVectorSpeedSource.None
};
BoeingPathCalculator.getCourseAndPositionAlongLegCache = {
    geoPoint: [new GeoPoint(0, 0)]
};

var BoeingVNavVars;
(function (BoeingVNavVars) {
    BoeingVNavVars["VNAVDesiredState"] = "L:WTAP_Boeing_VNav_Desired_State";
    BoeingVNavVars["RNP"] = "L:WTAP_Boeing_VNav_RNP";
    BoeingVNavVars["PerformanceTODDistance"] = "L:WTAP_VNav_Distance_To_Performance_TOD";
    BoeingVNavVars["PerformanceTODLegIndex"] = "L:WTAP_VNav_Performance_TOD_Leg_Index";
    BoeingVNavVars["PerformanceTODDistanceInLeg"] = "L:WTAP_VNav_Performance_TOD_Distance_In_Leg";
})(BoeingVNavVars || (BoeingVNavVars = {}));
/** A publisher for Boeing VNAV sim var events. */
class BoeingVNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(BoeingVNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
BoeingVNavSimVarPublisher.simvars = new Map([
    ['boeingvnav_desired_state', { name: BoeingVNavVars.VNAVDesiredState, type: SimVarValueType.Enum }],
    ['boeingvnav_rnp', { name: BoeingVNavVars.RNP, type: SimVarValueType.Number }],
    ['boeingvnav_performance_tod_distance', { name: BoeingVNavVars.PerformanceTODDistance, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_leg_distance', { name: BoeingVNavVars.PerformanceTODDistanceInLeg, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_global_leg_index', { name: BoeingVNavVars.PerformanceTODLegIndex, type: SimVarValueType.Number }],
]);

/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["TerminalDeparture"] = 2] = "TerminalDeparture";
    CDIScaleLabel[CDIScaleLabel["TerminalArrival"] = 3] = "TerminalArrival";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 4] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 5] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["Approach"] = 6] = "Approach";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 7] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/**
 * Sim var names for Boeing LNAV-related data.
 */
var BoeingLNavDataVars;
(function (BoeingLNavDataVars) {
    /** The global leg index of the flight plan leg that is nominally being tracked by LNAV. */
    BoeingLNavDataVars["NominalLegIndex"] = "L:WTBoeing_LNavData_Nominal_Leg_Index";
    /** The current CDI scale label. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    BoeingLNavDataVars["CDIScaleLabel"] = "L:WTBoeing_LNavData_CDI_Scale_Label";
    /** The current lateral RNP in nautical miles */
    BoeingLNavDataVars["RNP"] = "L:WTBoeing_LNavData_RNP";
    /** The nominal distance remaining to the end of the currently tracked flight plan leg. */
    BoeingLNavDataVars["TrackedLegEndDistance"] = "L:WTBoeing_LNavData_Tracked_Leg_End_Distance";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Distance_Direct";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationRunwayDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Runway_Distance_Direct";
    /** The flight plan distance to the final approach fix, in nautical miles. */
    BoeingLNavDataVars["FafDistance"] = "L:WTBoeing_LNavData_Faf_Distance";
    /** The direct distance to the missed approach point fix, in nautical miles, or -1 if invalid. */
    BoeingLNavDataVars["MapDistanceDirect"] = "L:WTBoeing_LNavData_Map_Distance";
    /** The total direct distance in nautical miles, or 0 when invalid. */
    BoeingLNavDataVars["TotalDistanceDirect"] = "L:WTBoeing_LNavData_Total_Distance_Direct";
})(BoeingLNavDataVars || (BoeingLNavDataVars = {}));
/**
 * A publisher for Boeing LNAV-related data sim var events.
 */
class BoeingLNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(BoeingLNavDataSimVarPublisher.simvars, bus);
    }
}
BoeingLNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale_label', { name: BoeingLNavDataVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavdata_rnp', { name: BoeingLNavDataVars.RNP, type: SimVarValueType.Number }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }],
    ['lnavdata_total_distance_direct', { name: BoeingLNavDataVars.TotalDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_nominal_leg_index', { name: BoeingLNavDataVars.NominalLegIndex, type: SimVarValueType.Number }],
    ['lnavdata_tracked_leg_end_distance', { name: BoeingLNavDataVars.TrackedLegEndDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance_direct', { name: BoeingLNavDataVars.DestinationDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_destination_runway_distance_direct', { name: BoeingLNavDataVars.DestinationRunwayDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_faf', { name: BoeingLNavDataVars.FafDistance, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_map_direct', { name: BoeingLNavDataVars.MapDistanceDirect, type: SimVarValueType.NM }],
]);

/** base publisher for simvars */
class BoeingAPSimVarPublisher extends SimVarPublisher {
    /**
     * Create a BoeingAPSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(BoeingAPSimVarPublisher.simvars, bus, pacer);
    }
}
BoeingAPSimVarPublisher.simvars = new Map([
    ['ap_boeing_disconnected', { name: 'L:WT_Boeing_Autopilot_Disconnected', type: SimVarValueType.Bool }],
    ['ap_boeing_selected_ias', { name: 'AUTOPILOT AIRSPEED HOLD VAR:1', type: SimVarValueType.Knots }],
    ['ap_boeing_selected_mach', { name: 'AUTOPILOT MACH HOLD VAR:1', type: SimVarValueType.Number }],
    ['ap_boeing_mcp_speed_is_mach', { name: 'L:XMLVAR_AirSpeedIsInMach', type: SimVarValueType.Bool }],
    ['ap_boeing_track_mode_active', { name: 'L:XMLVAR_TRK_MODE_ACTIVE', type: SimVarValueType.Bool }],
    ['ap_boeing_approach_mode_armed', { name: 'L:AP_APR_ARMED', type: SimVarValueType.Bool }],
    ['ap_boeing_autothrottle_armed', { name: 'L:AS01B_AUTO_THROTTLE_ARM_STATE', type: SimVarValueType.Bool }],
]);

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
var BoeingFlightPlans;
(function (BoeingFlightPlans) {
    BoeingFlightPlans[BoeingFlightPlans["ACT_RTE_PLAN_INDEX"] = 0] = "ACT_RTE_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_1_INACTIVE_PLAN_INDEX"] = 1] = "RTE_1_INACTIVE_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_1_MOD_PLAN_INDEX"] = 2] = "RTE_1_MOD_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_2_INACTIVE_PLAN_INDEX"] = 3] = "RTE_2_INACTIVE_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_2_MOD_PLAN_INDEX"] = 4] = "RTE_2_MOD_PLAN_INDEX";
})(BoeingFlightPlans || (BoeingFlightPlans = {}));
var BoeingUserDataKeys;
(function (BoeingUserDataKeys) {
    BoeingUserDataKeys["USER_DATA_KEY_ALTN"] = "wtboeing.altn";
    BoeingUserDataKeys["USER_DATA_KEY_FIX_INFO"] = "wtboeing.fix-info";
    BoeingUserDataKeys["USER_DATA_KEY_NEW_INACTIVE_PLAN"] = "wtboeing.new-inactive-plan";
    BoeingUserDataKeys["USER_DATA_KEY_NEW_UPLINKED_PLAN"] = "wtboeing.new-uplinked-plan";
    BoeingUserDataKeys["USER_DATA_KEY_UPLINKED_PLAN_ID"] = "wtboeing.uplinked-plan-id";
    BoeingUserDataKeys["USER_DATA_KEY_ROUTE"] = "wtboeing.route";
    BoeingUserDataKeys["USER_DATA_KEY_VISUAL_APPROACH"] = "wtboeing.visual-approach";
    BoeingUserDataKeys["USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA"] = "wtboeing.visual-approach-vfr-vpa";
    BoeingUserDataKeys["USER_DATA_KEY_HUD_TAKEOFF"] = "wtboeing.hud-takeoff";
    BoeingUserDataKeys["USER_DATA_KEY_VNAV_DES_PENDING"] = "wtboeing.vnav-des-pending";
    BoeingUserDataKeys["USER_DATA_KEY_VNAV_CRUISE_CLIMB_PENDING"] = "wtboeing.vnav-cruise-climb-pending";
    BoeingUserDataKeys["USER_DATA_KEY_DIRECT_TO_PENDING"] = "wtboeing.direct-to-pending";
})(BoeingUserDataKeys || (BoeingUserDataKeys = {}));

/**
 * Statuses for a Boeing autothrottle.
 */
var BoeingAutothrottleStatus;
(function (BoeingAutothrottleStatus) {
    BoeingAutothrottleStatus["Off"] = "Off";
    BoeingAutothrottleStatus["Disconnected"] = "Disconnected";
    BoeingAutothrottleStatus["Armed"] = "Armed";
    BoeingAutothrottleStatus["On"] = "On";
})(BoeingAutothrottleStatus || (BoeingAutothrottleStatus = {}));
/**
 * Boeing autothrottle system modes.
 */
var BoeingAutothrottleModes;
(function (BoeingAutothrottleModes) {
    /** Null mode. */
    BoeingAutothrottleModes["NONE"] = "";
    /** Autothrottle servos are disabled to allow throttle to be held in place during takeoff and climb while below 400 feet AGL. */
    BoeingAutothrottleModes["TAKEOFF_HOLD"] = "TO HOLD";
    /** Autothrottle servos are disabled to allow throttle to be manipulated in FLC/VNAV SPD descent or climb. */
    BoeingAutothrottleModes["HOLD"] = "HOLD";
    /** Autothrottle targets thrust for a climb or descent rate depending on the AFDS pitch mode. */
    BoeingAutothrottleModes["THR"] = "THR";
    /** Autothrottle hold protection has failed. */
    BoeingAutothrottleModes["HOLD_FAIL"] = "HOLD FAIL";
    /** Autothrottle targets takeoff thrust. */
    BoeingAutothrottleModes["TO"] = "TO";
    /** Autothrottle targets CLB thrust. */
    BoeingAutothrottleModes["CLIMB"] = "CLIMB";
    /** Autothrottle targets Max Continuous thrust. */
    BoeingAutothrottleModes["CON"] = "CON";
    /** Autothrottle targets GA thrust. */
    BoeingAutothrottleModes["GA"] = "GA";
    /** Autothrottle targets thrust to climb at minimum 2000 fpm, up to GA thrust limit. */
    BoeingAutothrottleModes["GA_THR"] = "GA THR";
    /** Autothrottle targets a set airspeed. */
    BoeingAutothrottleModes["SPD"] = "SPD";
    /** Autothrottle targets idle thrust. */
    BoeingAutothrottleModes["IDLE"] = "IDLE";
    /** Autothrottle reduces throttles to idle during landing once below 40 AGL. */
    BoeingAutothrottleModes["RETARD"] = "RETARD";
})(BoeingAutothrottleModes || (BoeingAutothrottleModes = {}));

/**
 * A utility class for working with Boeing flight path calculations.
 */
class BoeingFlightPathUtils {
}
/** The flight path calculator plans turns at these bank angles */
BoeingFlightPathUtils.flightPathBankAngleTable = [
    [15, 0],
    [25, 100],
    [25, 375],
    [19, 450],
];

const definitions = {
    'manualZfw': {
        defaultValue: null,
    },
    'manualGw': {
        defaultValue: null,
    },
    'takeoffGw': {
        defaultValue: null,
    },
    'cruiseCg': {
        defaultValue: null,
    },
    'manualLateralRnp': {
        defaultValue: null,
    },
    'manualVerticalRnp': {
        defaultValue: null,
    },
    'takeoffFlaps': {
        defaultValue: null,
    },
    'takeoffCg': {
        defaultValue: null,
    },
    'takeoffAssumedTemp': {
        defaultValue: null,
    },
    'takeoffThrustMode': {
        defaultValue: TakeoffThrustMode.TO,
    },
    'takeoffThrustReductionPoint': {
        defaultValue: 1500,
    },
    'takeoffAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffEoAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffTemp': {
        defaultValue: null,
    },
    'takeoffWind': {
        defaultValue: null,
    },
    'takeoffRunwayWind': {
        defaultValue: null,
    },
    'takeoffRunwaySlope': {
        defaultValue: 0,
    },
    'takeoffRunwayCondition': {
        defaultValue: RunwayCondition.DRY,
    },
    'climbThrustMode': {
        defaultValue: ClimbThrustMode.CLB,
    },
    'climbSegmentExists': {
        defaultValue: false,
    },
    'cruiseRequiredTpr': {
        defaultValue: 0, // TODO Replace with actual value
    },
    'takeoffAirportIcao': {
        defaultValue: null,
    },
    'originRunway': {
        defaultValue: null,
    },
    'takeoffRunway': {
        defaultValue: null,
    },
    'takeoffRunwayPositionShift': {
        defaultValue: null,
    },
    'approachAirportIcao': {
        defaultValue: null,
    },
    'approachRunway': {
        defaultValue: null,
    },
    'approachLandingRef': {
        defaultValue: 1,
    },
    'glideSlope': {
        defaultValue: GlideslopeStatus.ON,
        differentiateInModPlan: true,
    },
    'approachWindCorrection': {
        defaultValue: 5,
    },
    'approachFlapSpeed': {
        defaultValue: null,
    },
    'cruiseAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedLimitCas': {
        defaultValue: 250,
    },
    'climbSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'climbSpeedRestrCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedRestrAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'descentSpeedLimitCas': {
        defaultValue: 240,
    },
    'descentSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'descentSpeedRestrCas': {
        defaultValue: null,
    },
    'descentSpeedRestrAltitude': {
        defaultValue: null,
    },
    'transitionAltitude': {
        defaultValue: 18000,
    },
    'transitionLevel': {
        defaultValue: 18000,
    },
    'stepSize': {
        defaultValue: 'ICAO',
    },
    'reserveFuel': {
        defaultValue: null,
    },
    'costIndex': {
        defaultValue: null,
    },
    'currentThrustMode': {
        defaultValue: null,
    },
    'speedMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbEconCas': {
        defaultValue: 310,
    },
    'speedClimbEconMach': {
        defaultValue: .85,
    },
    'speedClimbSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedClimbSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedCruiseEconCas': {
        defaultValue: 310,
    },
    'speedCruiseEconMach': {
        defaultValue: .850,
    },
    'speedCruiseEconUnit': {
        defaultValue: 'cas',
    },
    'speedCruiseSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedDescentEconCas': {
        defaultValue: 290,
    },
    'speedDescentEconMach': {
        defaultValue: .850,
    },
    'speedDescentSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'thermalAntiIceAltitude': {
        defaultValue: null,
    },
    'alternateCruiseAltitude': {
        defaultValue: 37000,
    },
    'alternateSpeedValue': {
        defaultValue: 250,
    },
    'alternateSpeedIsMach': {
        defaultValue: false,
    },
};

/**
 * Proxied `MutableSubscribable` that mirrors a property desired to be accessed by {@link PerformancePlanProxy}
 */
class ProxiedPerformancePlanProperty extends AbstractSubscribable {
    /**
     * Ctor
     *
     * @param key property key
     * @param proxy the proxy this property belongs to
     * @param editInPlace whether the property can be edited without a new flight plan being created
     */
    constructor(key, proxy, editInPlace = false) {
        super();
        this.key = key;
        this.proxy = proxy;
        this.editInPlace = editInPlace;
        this.targetPlan = null;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subject = Subject.create(null);
        this.backSubjectSubscription = undefined;
    }
    /**
     * Switches the target plan
     *
     * @param plan the new target plan
     */
    switchToPlan(plan) {
        var _a;
        this.targetPlan = plan;
        (_a = this.backSubjectSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
        this.backSubjectSubscription = this.backingSubject().sub((it) => {
            this.subject.set(it);
        }, true);
    }
    /**
     * Returns the backing subject in the target plan for the property
     *
     * @returns the subject
     *
     * @throws if no target plan exists
     */
    backingSubject() {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        return this.targetPlan[this.key];
    }
    /**
     * Resets the property to its default value according to the default values performance plan
     */
    resetToDefault() {
        const defaultValue = this.proxy.defaultValuesPlan[this.key];
        this.proxy.onBeforeEdit(this, defaultValue);
        this.backingSubject().set(defaultValue.get());
        this.proxy.onAfterEdit(this, defaultValue);
    }
    /** @inheritDoc */
    get() {
        if (!this.targetPlan) {
            return null;
        }
        return this.backingSubject().get();
    }
    /** @inheritDoc */
    set(value) {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        this.proxy.onBeforeEdit(this, value);
        this.backingSubject().set(value);
        this.proxy.onAfterEdit(this, value);
    }
    /** @inheritDoc */
    sub(handler, initialNotify, paused) {
        return this.subject.sub(handler, initialNotify, paused);
    }
    /** @inheritDoc */
    unsub(handler) {
        return this.subject.unsub(handler);
    }
}

/**
 * Utils for performance plans
 */
class PerformancePlanUtils {
    /**
     * Serializes a plan
     *
     * @param plan the plan to serialize
     *
     * @returns the serialized JSON string
     */
    static serialize(plan) {
        const tmpObj = {};
        Object.keys(plan).forEach((key) => {
            tmpObj[key] = plan[key].get();
        });
        return JSON.stringify(tmpObj);
    }
    /**
     * Deserializes a serialized performance plan into a plan
     *
     * @param data the serialized data string
     * @param plan the plan to deserialize into
     */
    static deserializeInto(data, plan) {
        const customData = JSON.parse(data);
        Object.keys(customData).forEach((key) => {
            const value = customData[key];
            if (value !== undefined) {
                plan[key].set(value);
            }
        });
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @returns a performance plan with default values filled
     */
    static createPlanFromDefinitions() {
        const plan = {};
        for (const [key, definition] of Object.entries(definitions)) {
            plan[key] = Subject.create(definition.defaultValue);
        }
        return plan;
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @param partialProxy an object containing the callbacks to attach to the proxy
     *
     * @returns a performance plan with default values filled
     */
    static createProxyFromDefinitions(partialProxy) {
        const proxy = {
            defaultValuesPlan: partialProxy.defaultValuesPlan,
            /** @inheritDoc */
            switchToPlan(plan, initial) {
                for (const [key, definition] of Object.entries(definitions)) {
                    if (initial || definition.differentiateInModPlan) {
                        this[key].switchToPlan(plan);
                    }
                }
            },
            /** @inheritDoc */
            onBeforeEdit(property, newValue) {
                partialProxy.onBeforeEdit(property, newValue);
            },
            /** @inheritDoc */
            onAfterEdit(property, newValue) {
                partialProxy.onAfterEdit(property, newValue);
            },
        };
        for (const [key, definition] of Object.entries(definitions)) {
            const property = new ProxiedPerformancePlanProperty(key, proxy, !definition.differentiateInModPlan);
            proxy[key] = property;
        }
        return proxy;
    }
}

/**
 * Correlates flight plan indices with performance plan objects
 */
class PerformancePlanRepository {
    /**
     * Ctor
     * @param flightPlanner a flight planner instance
     * @param bus the event bus
     */
    constructor(flightPlanner, bus) {
        this.flightPlanner = flightPlanner;
        this.bus = bus;
        this.repoId = Math.floor(Math.random() * 10000000);
        this._plans = [];
        this.plans = this._plans;
        this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[BoeingFlightPlans.ACT_RTE_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        const sub = this.bus.getSubscriber();
        sub.on('fplOriginDestChanged').handle((data) => {
            if (data.type === OriginDestChangeType.OriginAdded || data.type === OriginDestChangeType.OriginRemoved) {
                this.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, data.planIndex);
            }
        });
        sub.on('performancePlanChanged').handle((data) => {
            if (data.repoId !== this.repoId) {
                PerformancePlanUtils.deserializeInto(data.serializedPlan, this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX]);
                if (this.has(data.planIndex)) {
                    this.copy(PerformancePlanRepository.SYNC_PLAN_INDEX, data.planIndex, true);
                }
            }
        });
    }
    /**
     * Whether the repository has a performance plan already stored for a given index
     *
     * @param index the index
     *
     * @returns boolean
     */
    has(index) {
        return this._plans[index] !== undefined;
    }
    /**
     * Returns a performance plan for a given flight plan index, or creates it
     *
     * @param index flight plan index
     *
     * @throws if an invalid flight plan index is specified
     *
     * @returns the performance plan
     */
    forFlightPlanIndex(index) {
        const existing = this._plans[index];
        if (!existing) {
            return this.create(index);
        }
        return existing;
    }
    /**
     * Gets the active plan. This is the plan that always exists even if there is no valid flight plan yet.
     * @returns the active plan
     */
    getActivePlan() {
        return this._plans[BoeingFlightPlans.ACT_RTE_PLAN_INDEX];
    }
    /**
     * Returns the performance plan containing default values
     *
     * @returns the plan
     */
    defaultValuesPlan() {
        return this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX];
    }
    /**
     * Returns whether this plan repository has nay valid plans
     *
     * @returns boolean
     */
    hasAnyPlan() {
        return this._plans.some((it, index) => !!it && this.flightPlanner.hasFlightPlan(index));
    }
    /**
     * Creates a performance plan at the given index if it doesn't exist, or returns the existing one
     *
     * @param atIndex the index
     *
     * @returns the created plan
     */
    create(atIndex) {
        if (!this.has(atIndex)) {
            const newPerformancePlan = PerformancePlanUtils.createPlanFromDefinitions();
            this._plans[atIndex] = newPerformancePlan;
            return newPerformancePlan;
        }
        else {
            return this._plans[atIndex];
        }
    }
    /**
     * Copies a performance plan onto another
     *
     * @param from from index
     * @param to to index
     * @param skipChecks whether to skip flight planner checks
     */
    copy(from, to, skipChecks = false) {
        const fromPlan = this._plans[from];
        const toPlan = skipChecks ? this._plans[to] : this.forFlightPlanIndex(to);
        // Copy data
        for (const key in toPlan) {
            const fromValue = fromPlan[key];
            const toValue = toPlan[key];
            if (fromValue instanceof Subject && toValue instanceof Subject) {
                toValue.set(fromValue.get());
            }
        }
    }
    /**
     * Triggers a synchronisation of the active plan performance plan over the EventBus.
     * @param planIndex the plan index
     */
    triggerSync(planIndex) {
        const packet = {
            repoId: this.repoId,
            planIndex,
            serializedPlan: PerformancePlanUtils.serialize(this._plans[planIndex]),
        };
        this.bus.getPublisher().pub('performancePlanChanged', packet, true, true);
    }
}
PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX = Number.MAX_SAFE_INTEGER;
PerformancePlanRepository.SYNC_PLAN_INDEX = PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX - 1;

/**
 * Boeing aural alert IDs.
 */
var BoeingAuralAlertIds;
(function (BoeingAuralAlertIds) {
    // TODO Modify as needed, these are copied from the g3000
    BoeingAuralAlertIds["TawsRtc"] = "boeing-taws-rtc";
    BoeingAuralAlertIds["TawsIti"] = "boeing-taws-iti";
    BoeingAuralAlertIds["TawsRoc"] = "boeing-taws-roc";
    BoeingAuralAlertIds["TawsIoi"] = "boeing-taws-ioi";
    BoeingAuralAlertIds["TawsEdr"] = "boeing-taws-edr";
    BoeingAuralAlertIds["TawsEcr"] = "boeing-taws-ecr";
    BoeingAuralAlertIds["AutopilotDisconnect"] = "boeing-autopilot-disconnect";
    BoeingAuralAlertIds["AutopilotDisengage"] = "boeing-autopilot-disengage";
    BoeingAuralAlertIds["LandingGear"] = "boeing-landing-gear";
    BoeingAuralAlertIds["Minimums"] = "boeing-minimums";
    BoeingAuralAlertIds["CabinAltitude"] = "boeing-cabin-altitude";
    BoeingAuralAlertIds["CabinDeltaPressure"] = "boeing-cabin-delta-pressure";
    BoeingAuralAlertIds["MasterWarning"] = "boeing-master-warning";
    BoeingAuralAlertIds["TcasRA"] = "boeing-tcas-ra";
    BoeingAuralAlertIds["AutothrottleDisconnect"] = "boeing-autothrottle-disconnect";
    BoeingAuralAlertIds["AutothrottleDisengage"] = "boeing-autothrottle-disengage";
    BoeingAuralAlertIds["PfdAlert"] = "boeing-pfd-alert";
    BoeingAuralAlertIds["MasterCaution"] = "boeing-master-caution";
    BoeingAuralAlertIds["TouchdownCallout"] = "boeing-touchdown-callout";
    BoeingAuralAlertIds["TcasTA"] = "boeing-tcas-ta";
    BoeingAuralAlertIds["AltitudeAlert"] = "boeing-altitude-alert";
    BoeingAuralAlertIds["VerticalTrack"] = "boeing-vertical-track";
})(BoeingAuralAlertIds || (BoeingAuralAlertIds = {}));
/**
 * A utility class for working with Boeing aural alerts.
 */
class BoeingAuralAlertUtils {
}
/** The name of the primary Boeing aural alert queue. */
BoeingAuralAlertUtils.PRIMARY_QUEUE = 'boeing-aural-primary';
/** A map from Boeing aural alert IDs to their default priorities. */
BoeingAuralAlertUtils.PRIORITIES = {
    // TODO Modify as needed, these are copied from the g3000
    [BoeingAuralAlertIds.TawsRtc]: -10,
    [BoeingAuralAlertIds.TawsIti]: -10,
    [BoeingAuralAlertIds.TawsRoc]: -10,
    [BoeingAuralAlertIds.TawsIoi]: -10,
    [BoeingAuralAlertIds.TawsEdr]: -10,
    [BoeingAuralAlertIds.TawsEcr]: -10,
    [BoeingAuralAlertIds.AutopilotDisconnect]: -20,
    [BoeingAuralAlertIds.AutopilotDisengage]: -20,
    [BoeingAuralAlertIds.LandingGear]: -30,
    [BoeingAuralAlertIds.Minimums]: -40,
    [BoeingAuralAlertIds.CabinAltitude]: -50,
    [BoeingAuralAlertIds.CabinDeltaPressure]: -60,
    [BoeingAuralAlertIds.MasterWarning]: -70,
    [BoeingAuralAlertIds.TcasRA]: -80,
    [BoeingAuralAlertIds.AutothrottleDisconnect]: -90,
    [BoeingAuralAlertIds.AutothrottleDisengage]: -90,
    [BoeingAuralAlertIds.PfdAlert]: -100,
    [BoeingAuralAlertIds.MasterCaution]: -110,
    [BoeingAuralAlertIds.TouchdownCallout]: -120,
    [BoeingAuralAlertIds.TcasTA]: -130,
    [BoeingAuralAlertIds.AltitudeAlert]: -140,
    [BoeingAuralAlertIds.VerticalTrack]: -150
};

var BoeingInhibitStates;
(function (BoeingInhibitStates) {
    BoeingInhibitStates["EngineStopped"] = "engine-shutdown-inhibit";
    BoeingInhibitStates["EngineStarting"] = "engine-start-inhibit";
    BoeingInhibitStates["OnGroundAllShutoff"] = "on-ground-all-shutoff";
    BoeingInhibitStates["TakingOff"] = "takeoff-inhibit";
    BoeingInhibitStates["BeforeCruiseFlightPhases"] = "all-prior-cruise";
    BoeingInhibitStates["DuringAndAfterCruiseFlightPhases"] = "all-past-cruise";
    BoeingInhibitStates["BeforeTakeoff"] = "all-before-takeoff";
    BoeingInhibitStates["AfterTakeoff"] = "all-after-takeoff";
    BoeingInhibitStates["NotInCruise"] = "not-in-cruise";
})(BoeingInhibitStates || (BoeingInhibitStates = {}));

/**
 * Altitude-related CAS message IDs.
 */
var AltitudeCrewAlertIDs;
(function (AltitudeCrewAlertIDs) {
    AltitudeCrewAlertIDs["AltitudeAlert"] = "altitude-alert";
})(AltitudeCrewAlertIDs || (AltitudeCrewAlertIDs = {}));
/**
 * Manages altitude-related CAS and aural alerts.
 */
class AltitudeCrewAlerts {
    /**
     * Creates an instance of AltitudeCrewAlerts.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.auralAlertPublisher = this.bus.getPublisher();
        this.registrationManager = new CasRegistrationManager(this.bus);
        this.auralRegistrationManager = new AuralAlertRegistrationManager(this.bus);
        this.altitudeAlertState = ConsumerSubject.create(null, AltAlertState.DISABLED);
        const engStoppedAndStarting = [BoeingInhibitStates.EngineStopped, BoeingInhibitStates.EngineStarting];
        this.registrationManager.register({ uuid: AltitudeCrewAlertIDs.AltitudeAlert, message: 'ALTITUDE ALERT', inhibitedBy: engStoppedAndStarting, debounceTime: 500 });
        this.auralRegistrationManager.register({
            uuid: BoeingAuralAlertIds.AltitudeAlert,
            queue: BoeingAuralAlertUtils.PRIMARY_QUEUE,
            priority: BoeingAuralAlertUtils.PRIORITIES[BoeingAuralAlertIds.AltitudeAlert],
            // TODO This is the incorrect sound according the the FCOM and pilots, it should be the Beeper sound, but we don't have it yet
            sequence: 'tone_altitude_alert_default',
            continuous: false,
            repeat: false,
            timeout: 3000,
        });
        this.initAlerts();
    }
    /**
     * Initalizes altitude CAS and aural alerts.
     */
    initAlerts() {
        const sub = this.bus.getSubscriber();
        this.altitudeAlertState.setConsumer(sub.on('altitude_alert'));
        CasAlertTransporter.create(this.bus, AltitudeCrewAlertIDs.AltitudeAlert, AnnunciationType.Caution)
            .bind(this.altitudeAlertState, altitudeAlert => altitudeAlert === AltAlertState.DEVIATION_200);
        this.altitudeAlertState.sub(state => {
            if (state === AltAlertState.WITHIN_900) {
                this.auralAlertPublisher.pub('aural_alert_activate', BoeingAuralAlertIds.AltitudeAlert, true, false);
            }
            else {
                this.auralAlertPublisher.pub('aural_alert_deactivate', BoeingAuralAlertIds.AltitudeAlert, true, false);
            }
        }, true);
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A Boeing airspeed indicator.
 */
class AirspeedIndicator extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.maxSpeedRangeRef = FSComponent.createRef();
        this.minManeuverSpeedRangeRef = FSComponent.createRef();
        this.minSpeedRangeRef = FSComponent.createRef();
        this.selectedSpeedBugRef = FSComponent.createRef();
        this.vnavSpeedBandRef = FSComponent.createRef();
        this.flapSpeedBugPositions = Array.from(this.props.flapSpeedBugDataProvider.data.keys());
        this.flapSpeedBugRefs = new Map(Array.from(this.props.flapSpeedBugDataProvider.data.keys(), position => [position, FSComponent.createRef()]));
        this.vrBugRef = FSComponent.createRef();
        this.v2BugRef = FSComponent.createRef();
        this.v1BugRef = FSComponent.createRef();
        this.v1BugClampedRef = FSComponent.createRef();
        this.vrefBugRef = FSComponent.createRef();
        this.vrefBugClampedRef = FSComponent.createRef();
        this.showManeuverSpeedBands = SubscribableUtils.toSubscribable((_a = this.props.showManeuverSpeedBands) !== null && _a !== void 0 ? _a : true, true);
        this.v1Setting = this.props.vSpeedSettings.getSettings(VSpeedType.V1).value;
        this.vrSetting = this.props.vSpeedSettings.getSettings(VSpeedType.Vr).value;
        this.v2Setting = this.props.vSpeedSettings.getSettings(VSpeedType.V2).value;
        this.vrefSetting = this.props.vSpeedSettings.getSettings(VSpeedType.Vref).value;
        this.pixelPerKnot = this.props.windowHeight / AirspeedIndicator.WINDOW_IAS;
        this.v1BugPositionClamp = this.props.v1BugPositionClamp / this.props.windowHeight;
        this.vrefBugPositionClamp = this.props.vrefBugPositionClamp / this.props.windowHeight;
        this.tapeTickCount = AirspeedIndicator.WINDOW_IAS * 2 / AirspeedIndicator.TAPE_TICK_INTERVAL + 1;
        this.tapeCenterTickOffset = Math.floor(this.tapeTickCount / 2);
        this.tapeTickSpeeds = ArrayUtils.create(this.tapeTickCount, index => Subject.create((index - this.tapeCenterTickOffset) * AirspeedIndicator.TAPE_TICK_INTERVAL, SubscribableUtils.NUMERIC_NAN_EQUALITY));
        this.tapeCenterIas = 0;
        this.tapeScrolledIas = 0;
        this.tapeTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', '%', 'px'));
        this.trendVectorScaleTransform = CssTransformSubject.create(CssTransformBuilder.scaleY());
        this.trendVectorTranslateTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.isTrendVectorHidden = Subject.create(false);
        this.truncateVrLabel = MappedSubject.create(([v1, vr, v2]) => vr > 50 && ((v1 > 50 && Math.abs(vr - v1) <= 4) || (v2 > 50 && Math.abs(vr - v2) <= 4)), this.v1Setting, this.vrSetting, this.v2Setting).pause();
        this.v1ReadoutHidden = Subject.create(false);
        this.v1ReadoutText = Subject.create('');
        this.vrefReadoutHidden = Subject.create(false);
        this.vrefReadoutText = Subject.create('');
        this.isRadioAltAbove100 = this.props.dataProvider.radioAltitude.map((alt, previousVal) => alt >= (previousVal ? 90 : 110)).pause();
        this.isSpeedBelowMinManeuver = MappedSubject.create(([ias, minManeuverIas]) => minManeuverIas !== null && ias < minManeuverIas, this.props.dataProvider.ias, this.props.dataProvider.minimumManeuveringIas).pause();
        this.scrollerIas = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.isReadoutAlertActive = Subject.create(false);
        this.isPaused = true;
        this.pauseableSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.resume();
        this.readoutAlertPipe = this.isSpeedBelowMinManeuver.pipe(this.isReadoutAlertActive, true);
        const updateMinimumManeuveringSpeed = this.updateMinimumManeuveringSpeed.bind(this);
        const updateVNavSpeedBand = this.updateVNavSpeedBand.bind(this);
        this.pauseableSubs.push(this.props.dataProvider.ias.sub(this.updateIas.bind(this), true, this.isPaused), this.props.dataProvider.maximumIas.sub(this.updateMaximumSpeed.bind(this), false, this.isPaused), this.props.dataProvider.minimumManeuveringIas.sub(updateMinimumManeuveringSpeed, false, this.isPaused), this.props.dataProvider.minimumIas.sub(this.updateMinimumSpeed.bind(this), false, this.isPaused), this.showManeuverSpeedBands.sub(updateMinimumManeuveringSpeed, false, this.isPaused), this.props.dataProvider.iasTrend.sub(this.onTrendChanged.bind(this), this.isPaused), this.isRadioAltAbove100.sub(this.onRadioAltAbove100Changed.bind(this), true, this.isPaused), this.props.flapRetractionDataProvider.isFirstFlapRetractionStarted.sub(this.updateMinimumManeuveringSpeedVisibility.bind(this), false, this.isPaused), this.props.dataProvider.selectedSpeedIas.sub(this.updateSelectedSpeedBug.bind(this), false, this.isPaused), this.props.vnavSpeedBandDataProvider.minimumIas.sub(updateVNavSpeedBand, false, this.isPaused), this.props.vnavSpeedBandDataProvider.maximumIas.sub(updateVNavSpeedBand, false, this.isPaused), ...Array.from(this.props.flapSpeedBugDataProvider.data, ([position, data]) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return data.maneuverIas.sub(this.updateFlapSpeedBug.bind(this, this.flapSpeedBugRefs.get(position), data), true, this.isPaused);
        }), this.vrSetting.sub(this.updateVSpeedBug.bind(this, this.vrBugRef, this.vrSetting), false, this.isPaused), this.v2Setting.sub(this.updateVSpeedBug.bind(this, this.v2BugRef, this.v2Setting), false, this.isPaused), this.v1Setting.sub(this.onV1Changed.bind(this), false, this.isPaused), this.vrefSetting.sub(this.onVrefChanged.bind(this), false, this.isPaused), this.v1Setting.pipe(this.v1ReadoutText, value => value.toFixed(0), this.isPaused), this.props.performancePlan.approachFlapSpeed.pipe(this.vrefReadoutText, data => {
            var _a;
            if (data === null) {
                return '';
            }
            return `${((_a = data[0]) !== null && _a !== void 0 ? _a : 0).toFixed(0)}/${data[1].toFixed(0)}`;
        }, this.isPaused));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.truncateVrLabel.resume();
        this.isRadioAltAbove100.resume();
        for (const sub of this.pauseableSubs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        var _a;
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.truncateVrLabel.pause();
        this.isRadioAltAbove100.pause();
        this.isSpeedBelowMinManeuver.pause();
        for (const sub of this.pauseableSubs) {
            sub.pause();
        }
        (_a = this.readoutAlertPipe) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /**
     * Gets the position of an indicated airspeed on this indicator's tape window, with `0` at the top of the window and
     * `1` at the bottom.
     * @param ias An indicated airspeed, in knots.
     * @returns The position of the specified indicated airspeed on this indicator's tape window, with `0` at the top of
     * the window and `1` at the bottom.
     */
    getTapeWindowPosition(ias) {
        return 0.5 - (ias - this.tapeScrolledIas) / AirspeedIndicator.WINDOW_IAS;
    }
    /**
     * A callback called when the IAS updates from the event bus.
     * @param ias The current IAS value.
     */
    updateIas(ias) {
        const clampedIas = MathUtils.clamp(ias, 30, 999);
        this.scrollerIas.set(clampedIas);
        let tapeTranslation = (clampedIas - this.tapeCenterIas) / (AirspeedIndicator.WINDOW_IAS * 2) * 100;
        if (Math.abs(tapeTranslation) > 25) {
            // We need to reset the tape's center altitude such that the tape translation is back within +/-25%.
            this.tapeCenterIas = MathUtils.round(clampedIas, 100);
            for (let i = 0; i < this.tapeTickSpeeds.length; i++) {
                this.tapeTickSpeeds[i].set((i - this.tapeCenterTickOffset) * AirspeedIndicator.TAPE_TICK_INTERVAL + this.tapeCenterIas);
            }
            tapeTranslation = (clampedIas - this.tapeCenterIas) / (AirspeedIndicator.WINDOW_IAS * 2) * 100;
        }
        this.tapeTransform.transform.set(0, tapeTranslation, 0, undefined, 0.02);
        this.tapeTransform.resolve();
        this.tapeScrolledIas = clampedIas;
        this.updateAllBugsAndRanges();
    }
    /**
     * Responds to when the airspeed trend changes.
     * @param trend The new airspeed trend, in knots.
     */
    onTrendChanged(trend) {
        const absoluteTrend = Math.abs(trend);
        if (absoluteTrend > 5) {
            this.trendVectorScaleTransform.transform.set(trend < 0 ? -1 : 1);
            this.trendVectorScaleTransform.resolve();
            this.trendVectorTranslateTransform.transform.set(0, -this.pixelPerKnot * Math.min(absoluteTrend, AirspeedIndicator.HALF_WINDOW_IAS * 1.5), 0, undefined, 0.1);
            this.trendVectorTranslateTransform.resolve();
            this.isTrendVectorHidden.set(false);
        }
        else {
            this.isTrendVectorHidden.set(true);
        }
    }
    /**
     * A method called to update all bugs and ranges on the tape.
     */
    updateAllBugsAndRanges() {
        this.updateMaximumSpeed();
        this.updateMinimumManeuveringSpeed();
        this.updateMinimumSpeed();
        this.updateSelectedSpeedBug();
        this.updateVNavSpeedBand();
        for (let i = 0; i < this.flapSpeedBugPositions.length; i++) {
            const position = this.flapSpeedBugPositions[i];
            this.updateFlapSpeedBug(this.flapSpeedBugRefs.get(position), this.props.flapSpeedBugDataProvider.data.get(position));
        }
        this.updateAllVSpeedBugs();
    }
    /**
     * Updates this indicator's displayed maximum speed.
     */
    updateMaximumSpeed() {
        this.maxSpeedRangeRef.instance.updatePosition(this.getTapeWindowPosition(this.props.dataProvider.maximumIas.get()));
    }
    /**
     * Updates this indicator's displayed minimum maneuvering speed.
     */
    updateMinimumManeuveringSpeed() {
        let position;
        if (this.showManeuverSpeedBands.get()) {
            const ias = this.props.dataProvider.minimumManeuveringIas.get();
            position = ias === null ? 2 : this.getTapeWindowPosition(ias);
        }
        else {
            position = 2;
        }
        this.minManeuverSpeedRangeRef.instance.updatePosition(position);
    }
    /**
     * Updates this indicator's displayed minimum speed.
     */
    updateMinimumSpeed() {
        const ias = this.props.dataProvider.minimumIas.get();
        this.minSpeedRangeRef.instance.updatePosition(ias === null ? 2 : this.getTapeWindowPosition(ias));
    }
    /**
     * Updates the visibility of this indicator's maximum speed range.
     */
    updateMaximumSpeedVisibility() {
        this.maxSpeedRangeRef.instance.setIsVisible(this.isRadioAltAbove100.get());
    }
    /**
     * Updates the visibility of this indicator's minimum maneuvering speed range.
     */
    updateMinimumManeuveringSpeedVisibility() {
        this.minManeuverSpeedRangeRef.instance.setIsVisible(this.isRadioAltAbove100.get() && this.props.flapRetractionDataProvider.isFirstFlapRetractionStarted.get());
    }
    /**
     * Updates the visibility of this indicator's minimum speed range.
     */
    updateMinimumSpeedVisibility() {
        this.minSpeedRangeRef.instance.setIsVisible(this.isRadioAltAbove100.get());
    }
    /**
     * Updates the visibility of all of this indicator's speed ranges.
     */
    updateAllSpeedRangeVisibilities() {
        this.updateMaximumSpeedVisibility();
        this.updateMinimumManeuveringSpeedVisibility();
        this.updateMinimumSpeedVisibility();
    }
    /**
     * Updates the visibility and position of this indicator's selected speed bug.
     */
    updateSelectedSpeedBug() {
        const ias = this.props.dataProvider.selectedSpeedIas.get();
        if (ias === null) {
            this.selectedSpeedBugRef.instance.setIsVisible(false);
        }
        else {
            this.selectedSpeedBugRef.instance.setIsVisible(true);
            this.selectedSpeedBugRef.instance.updatePosition(this.getTapeWindowPosition(ias));
        }
    }
    /**
     * Updates the visibility and position of this indicator's VNAV speed band.
     */
    updateVNavSpeedBand() {
        const minIas = this.props.vnavSpeedBandDataProvider.minimumIas.get();
        const maxIas = this.props.vnavSpeedBandDataProvider.maximumIas.get();
        if (minIas === null || maxIas === null) {
            this.vnavSpeedBandRef.instance.setIsVisible(false);
        }
        else {
            this.vnavSpeedBandRef.instance.setIsVisible(true);
            this.vnavSpeedBandRef.instance.updatePosition(this.getTapeWindowPosition(minIas), this.getTapeWindowPosition(maxIas));
        }
    }
    /**
     * Updates the visibility and position of a flap maneuver speed bug.
     * @param ref A reference to the speed bug to update.
     * @param data Data describing the speed bug to update.
     */
    updateFlapSpeedBug(ref, data) {
        const ias = data.maneuverIas.get();
        if (ias === null) {
            ref.instance.setIsVisible(false);
        }
        else {
            ref.instance.setIsVisible(true);
            ref.instance.updatePosition(this.getTapeWindowPosition(ias));
        }
    }
    /**
     * Updates the visibility and positions of all V-speed bugs.
     */
    updateAllVSpeedBugs() {
        this.updateVSpeedBug(this.vrBugRef, this.props.vSpeedSettings.getSettings(VSpeedType.Vr).value);
        this.updateVSpeedBug(this.v2BugRef, this.props.vSpeedSettings.getSettings(VSpeedType.V2).value);
        this.updateVSpeedBug(this.v1BugRef, this.props.vSpeedSettings.getSettings(VSpeedType.V1).value);
        this.updateVSpeedBug(this.v1BugClampedRef, this.props.vSpeedSettings.getSettings(VSpeedType.V1).value);
        this.updateVSpeedBug(this.vrefBugRef, this.props.vSpeedSettings.getSettings(VSpeedType.Vref).value);
        this.updateVSpeedBug(this.vrefBugClampedRef, this.props.vSpeedSettings.getSettings(VSpeedType.Vref).value);
        this.updateVSpeedReadoutVisibility(this.v1ReadoutHidden, this.v1Setting, -Infinity, this.v1BugPositionClamp);
        this.updateVSpeedReadoutVisibility(this.vrefReadoutHidden, this.vrefSetting, -Infinity, Infinity);
    }
    /**
     * Updates the visibility and position of a V-speed bug.
     * @param ref A reference to the speed bug to update.
     * @param setting The user setting that controls the value of the bug's V-speed.
     */
    updateVSpeedBug(ref, setting) {
        const ias = setting.value;
        if (ias <= 50) {
            ref.instance.setIsVisible(false);
        }
        else {
            ref.instance.setIsVisible(true);
            ref.instance.updatePosition(this.getTapeWindowPosition(ias));
        }
    }
    /**
     * Updates the visibility of a V-speed readout.
     * @param isHidden The subject that controls whether the readout is hidden.
     * @param setting The user setting that controls the value of the V-speed.
     * @param minPosition A minimum position limit on this indicator's tape window, with `0` at the top and `1` at the
     * bottom, such that the readout is displayed if the corresponding V-speed bug is positioned within the limit.
     * @param maxPosition A maximum position limit on this indicator's tape window, with `0` at the top and `1` at the
     * bottom, such that the readout is displayed if the corresponding V-speed bug is positioned within the limit.
     */
    updateVSpeedReadoutVisibility(isHidden, setting, minPosition, maxPosition) {
        const ias = setting.value;
        if (ias <= 50) {
            isHidden.set(true);
        }
        else {
            const position = this.getTapeWindowPosition(ias);
            isHidden.set(position < minPosition || position > maxPosition);
        }
    }
    /**
     * Responds to when whether the airplane's radio altitude is above 100 feet changes.
     * @param isAbove100 Whether the airplane's radio altitude is above 100 feet.
     */
    onRadioAltAbove100Changed(isAbove100) {
        this.updateAllSpeedRangeVisibilities();
        if (isAbove100) {
            this.isSpeedBelowMinManeuver.resume();
            this.readoutAlertPipe.resume(true);
        }
        else {
            this.isSpeedBelowMinManeuver.pause();
            this.readoutAlertPipe.pause();
            this.isReadoutAlertActive.set(false);
        }
    }
    /**
     * Responds to when the V1 speed value changes.
     */
    onV1Changed() {
        this.updateVSpeedBug(this.v1BugRef, this.v1Setting);
        this.updateVSpeedBug(this.v1BugClampedRef, this.v1Setting);
        this.updateVSpeedReadoutVisibility(this.v1ReadoutHidden, this.v1Setting, -Infinity, this.v1BugPositionClamp);
    }
    /**
     * Responds to when the Vref speed value changes.
     */
    onVrefChanged() {
        this.updateVSpeedBug(this.vrefBugRef, this.vrefSetting);
        this.updateVSpeedBug(this.vrefBugClampedRef, this.vrefSetting);
        this.updateVSpeedReadoutVisibility(this.vrefReadoutHidden, this.vrefSetting, -Infinity, Infinity);
    }
    /** @inheritdoc */
    render() {
        const zipperUnitHeight = Math.round(this.pixelPerKnot * 2.5) * 2;
        return (FSComponent.buildComponent("div", { class: "airspeed-box" },
            FSComponent.buildComponent("div", { class: "airspeed", style: `position: absolute; top: 0px; height: ${this.props.windowHeight}px;` },
                FSComponent.buildComponent("div", { class: "airspeed-mask", style: "position: absolute; top: 0px; height: 100%; overflow: hidden;" },
                    FSComponent.buildComponent("div", { class: "airspeed-tape", style: {
                            'position': 'absolute',
                            'top': '-50%',
                            'height': `${this.props.windowHeight * 2}px`,
                            'transform': this.tapeTransform
                        } },
                        FSComponent.buildComponent("div", { class: "airspeed-tape-tick-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAirspeedTapeTicks()),
                        FSComponent.buildComponent("div", { class: "airspeed-tape-label-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAirspeedTapeLabels())),
                    FSComponent.buildComponent(SpeedRange, { ref: this.maxSpeedRangeRef, type: "max", tapeWindowHeight: this.props.windowHeight, repeatingHeight: zipperUnitHeight, class: "airspeed-range-container-max" }),
                    FSComponent.buildComponent(SpeedRange, { ref: this.minManeuverSpeedRangeRef, type: "min", tapeWindowHeight: this.props.windowHeight, class: "airspeed-range-container-min-maneuver" }),
                    FSComponent.buildComponent(SpeedRange, { ref: this.minSpeedRangeRef, type: "min", tapeWindowHeight: this.props.windowHeight, repeatingHeight: zipperUnitHeight, class: "airspeed-range-container-min" }),
                    FSComponent.buildComponent("div", { class: {
                            'airspeed-trend-vector': true,
                            'hidden': this.isTrendVectorHidden,
                        }, style: {
                            'position': 'absolute',
                            'bottom': '50%',
                            'height': '50%',
                            'overflow': 'hidden',
                            'transform': this.trendVectorScaleTransform,
                            'transform-origin': '50% 100%'
                        } },
                        FSComponent.buildComponent("div", { style: { 'position': 'absolute', 'left': '0px', 'top': '100%', 'width': '100%', 'height': '150%', 'transform': this.trendVectorTranslateTransform } },
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-stem shadow", style: "position: absolute; bottom: 0px;" },
                                FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "airspeed-trend-vector-stroke" })),
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-pointer shadow", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                                FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "airspeed-trend-vector-stroke" })),
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-stem", style: "position: absolute; bottom: 0px;" },
                                FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "airspeed-trend-vector-stroke" })),
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-pointer", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                                FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "airspeed-trend-vector-stroke" })))),
                    FSComponent.buildComponent(SpeedBug, { ref: this.selectedSpeedBugRef, tapeWindowHeight: this.props.windowHeight, clamp: true, class: "airspeed-bug-selected" },
                        FSComponent.buildComponent("svg", { viewBox: "0 -14 56 28", preserveAspectRatio: "none", class: "airspeed-bug-selected-symbol", style: "overflow: visible;" },
                            FSComponent.buildComponent("path", { d: "M 0 0 L 22 -14 l 34 0 l 0 28 l -34 0 z", class: "airspeed-bug-selected-stroke shadow" }),
                            FSComponent.buildComponent("path", { d: "M 0 0 L 22 -14 l 34 0 l 0 28 l -34 0 z", class: "airspeed-bug-selected-stroke" }))),
                    FSComponent.buildComponent(VNavSpeedBand, { ref: this.vnavSpeedBandRef, tapeWindowHeight: this.props.windowHeight }),
                    Array.from(this.flapSpeedBugRefs).map(([position, ref]) => {
                        return (FSComponent.buildComponent(TickLabelSpeedBug, { ref: ref, tapeWindowHeight: this.props.windowHeight, tick: true, label: position === 0 ? 'UP' : position.toString().padStart(2, ' '), class: "airspeed-bug-flap" }));
                    }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.vrBugRef, tapeWindowHeight: this.props.windowHeight, tick: true, label: this.truncateVrLabel.map(truncate => truncate ? '  R' : 'VR'), class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.v2BugRef, tapeWindowHeight: this.props.windowHeight, tick: true, label: "V2", class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.v1BugRef, tapeWindowHeight: this.props.windowHeight, tick: true, class: "airspeed-bug-vspeed airspeed-bug-vspeed-large" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.v1BugClampedRef, tapeWindowHeight: this.props.windowHeight, label: "V1", clamp: Vec2Math.create(this.v1BugPositionClamp, Infinity), class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent("div", { class: { 'airspeed-vspeed-readout': true, 'airspeed-v1-readout': true, 'hidden': this.v1ReadoutHidden } }, this.v1ReadoutText),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.vrefBugRef, tapeWindowHeight: this.props.windowHeight, tick: true, class: "airspeed-bug-vspeed airspeed-bug-vspeed-large" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.vrefBugClampedRef, tapeWindowHeight: this.props.windowHeight, label: "REF", clamp: Vec2Math.create(-Infinity, this.vrefBugPositionClamp), class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent("div", { class: { 'airspeed-vspeed-readout': true, 'airspeed-vref-readout': true, 'hidden': this.vrefReadoutHidden } }, this.vrefReadoutText)),
                FSComponent.buildComponent("div", { class: "airspeed-readout" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 103 96", preserveAspectRatio: "none", "stroke-linejoin": "round", class: { 'airspeed-readout-box': true, 'warning': this.isReadoutAlertActive }, style: "overflow: visible;" },
                        FSComponent.buildComponent("path", { class: "airspeed-readout-box-border shadow", d: "M 0 0 l 86 0 l 0 33 l 17 15 l -17 15 l 0 33 l -86 0 z" }),
                        FSComponent.buildComponent("path", { class: "airspeed-readout-box-border", d: "M 0 0 l 86 0 l 0 33 l 17 15 l -17 15 l 0 33 l -86 0 z" })),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerIas, base: 10, factor: 100, scrollThreshold: 99, renderDigit: digit => digit === 0 ? ' ' : (Math.abs(digit) % 10).toString(), nanString: '-', class: 'airspeed-digit-scroller airspeed-hundreds-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerIas, base: 10, factor: 10, scrollThreshold: 9, nanString: '-', class: 'airspeed-digit-scroller airspeed-tens-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerIas, base: 10, factor: 1, nanString: '-', class: 'airspeed-digit-scroller airspeed-ones-scroller' })))));
    }
    /**
     * Builds the tick marks on the airspeed tape.
     * @returns The tick marks on the airspeed tape, as an array of VNodes.
     */
    buildAirspeedTapeTicks() {
        const tickIntervalPx = AirspeedIndicator.TAPE_TICK_INTERVAL * this.pixelPerKnot;
        const isHiddenMap = (ias) => ias < 30 || ias > 999;
        const isMajorMap = (ias) => ias % 20 === 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const ias = this.tapeTickSpeeds[index];
            const y = (this.tapeTickCount - index - 1) * tickIntervalPx;
            return (FSComponent.buildComponent("div", { class: {
                    'airspeed-tape-tick': true,
                    'airspeed-tape-tick-major': ias.map(isMajorMap),
                    'hidden': ias.map(isHiddenMap)
                }, style: `position: absolute; top: ${y}px; transform: translateY(-50%);` }));
        });
    }
    /**
     * Builds the labels on the airspeed tape.
     * @returns The labels on the airspeed tape, as an array of VNodes.
     */
    buildAirspeedTapeLabels() {
        const labelIntervalPx = AirspeedIndicator.TAPE_TICK_INTERVAL * this.pixelPerKnot;
        const isHiddenMap = (ias) => ias < 30 || ias > 999 || ias % 20 !== 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const ias = this.tapeTickSpeeds[index];
            const y = (this.tapeTickCount - index - 1) * labelIntervalPx;
            return (FSComponent.buildComponent("div", { class: {
                    'airspeed-tape-label': true,
                    'hidden': ias.map(isHiddenMap)
                }, style: `position: absolute; right: 0%; top: ${y}px; transform: translateY(-50%)` }, ias));
        });
    }
}
/** The airspeed indicator tape window's IAS range, in knots. */
AirspeedIndicator.WINDOW_IAS = 120;
AirspeedIndicator.HALF_WINDOW_IAS = AirspeedIndicator.WINDOW_IAS / 2;
/** The IAS interval between each airspeed indicator tape tick, in knots. */
AirspeedIndicator.TAPE_TICK_INTERVAL = 10;
/**
 * An airspeed indicator speed range.
 */
class SpeedRange extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.repeatingHeight = this.props.repeatingHeight !== undefined && this.props.repeatingHeight > 0
            ? Math.ceil(this.props.tapeWindowHeight / this.props.repeatingHeight) * this.props.repeatingHeight
            : this.props.tapeWindowHeight;
        this.height = this.repeatingHeight * 2;
        this.repeatingHeightRelative = this.repeatingHeight / this.props.tapeWindowHeight;
        this.heightRelative = this.repeatingHeightRelative * 2;
        this.getTranslateMethod = this.props.type === 'min'
            ? 'getTranslateMin'
            : 'getTranslateMax';
        this.transform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', 'px', 'px'));
        this.hidden = Subject.create(false);
    }
    /**
     * Sets this range's visibility.
     * @param visible The range visibility.
     */
    setIsVisible(visible) {
        this.hidden.set(!visible);
    }
    /**
     * Updates this speed range's position.
     * @param iasPosition The position of this speed range's reference airspeed on its parent indicator's tape window,
     * with `0` at the top of the window and `1` at the bottom.
     */
    updatePosition(iasPosition) {
        this.transform.transform.set(0, this[this.getTranslateMethod](iasPosition), 0, undefined, 0.1);
        this.transform.resolve();
    }
    /**
     * Gets the y-translation, in pixels, required to place this minimum speed range at a given position on its parent
     * indicator's tape window.
     * @param iasPosition A position on this speed range's parent indicator's tape window, with `0` at the top of the
     * window and `1` at the bottom.
     * @returns The y-translation, in pixels, required to place this minimum speed range at a given position on its
     * parent indicator's tape window.
     */
    getTranslateMin(iasPosition) {
        if (iasPosition >= 1.1) {
            return 1.1 * this.props.tapeWindowHeight;
        }
        else if (iasPosition > 1 - this.heightRelative) {
            return iasPosition * this.props.tapeWindowHeight;
        }
        else {
            return ((iasPosition - (1 - this.repeatingHeightRelative)) % this.repeatingHeightRelative + 1 - this.repeatingHeightRelative) * this.props.tapeWindowHeight;
        }
    }
    /**
     * Gets the y-translation, in pixels, required to place this maximum speed range at a given position on its parent
     * indicator's tape window.
     * @param iasPosition A position on this speed range's parent indicator's tape window, with `0` at the top of the
     * window and `1` at the bottom.
     * @returns The y-translation, in pixels, required to place this maximum speed range at a given position on its
     * parent indicator's tape window.
     */
    getTranslateMax(iasPosition) {
        if (iasPosition <= -0.1) {
            return -0.1 * this.props.tapeWindowHeight;
        }
        else if (iasPosition < this.heightRelative) {
            return iasPosition * this.props.tapeWindowHeight;
        }
        else {
            return ((iasPosition - this.repeatingHeightRelative) % this.repeatingHeightRelative + this.repeatingHeightRelative) * this.props.tapeWindowHeight;
        }
    }
    /** @inheritdoc */
    render() {
        const cssClasses = {
            'airspeed-range-container': true,
            'hidden': this.hidden
        };
        const classesToAdd = this.props.class
            ? FSComponent.parseCssClassesFromString(this.props.class, classToAdd => classToAdd !== 'airspeed-range-container' && classToAdd !== 'hidden')
            : undefined;
        if (classesToAdd) {
            for (const classToAdd of classesToAdd) {
                cssClasses[classToAdd] = true;
            }
        }
        return (FSComponent.buildComponent("div", { class: cssClasses, style: {
                'position': 'absolute',
                'top': this.props.type === 'max' ? `${-this.height}px` : '0px',
                'height': `${this.height}px`,
                'transform': this.transform
            } },
            FSComponent.buildComponent("div", { class: "airspeed-range shadow" }),
            FSComponent.buildComponent("div", { class: "airspeed-range" })));
    }
}
/**
 * A speed bug for the airspeed indicator.
 */
class SpeedBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.clamp = this.props.clamp
            ? this.props.clamp === true ? Vec2Math.create(0, 1) : this.props.clamp
            : undefined;
        this.transform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', 'px', 'px'));
        this.isVisible = Subject.create(true);
        this.isInBounds = Subject.create(false);
        this.hidden = MappedSubject.create(([visible, inBounds]) => !visible || !inBounds, this.isVisible, this.isInBounds);
    }
    /**
     * Sets this bug's visibility.
     * @param visible The bug visibility.
     */
    setIsVisible(visible) {
        this.isVisible.set(visible);
    }
    /**
     * Updates this bug's position.
     * @param iasPosition The position of this bug's reference airspeed on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     */
    updatePosition(iasPosition) {
        if (this.clamp) {
            iasPosition = MathUtils.clamp(iasPosition, this.clamp[0], this.clamp[1]);
        }
        this.isInBounds.set(iasPosition >= -0.1 && iasPosition <= 1.1);
        this.transform.transform.set(0, MathUtils.clamp(iasPosition, -0.1, 1.1) * this.props.tapeWindowHeight, 0, undefined, 0.1);
        this.transform.resolve();
    }
    /** @inheritdoc */
    render() {
        const cssClasses = {
            'airspeed-bug': true,
            'hidden': this.hidden
        };
        const classesToAdd = this.props.class
            ? FSComponent.parseCssClassesFromString(this.props.class, classToAdd => classToAdd !== 'airspeed-bug' && classToAdd !== 'hidden')
            : undefined;
        if (classesToAdd) {
            for (const classToAdd of classesToAdd) {
                cssClasses[classToAdd] = true;
            }
        }
        return (FSComponent.buildComponent("div", { class: cssClasses, style: {
                'position': 'absolute',
                'top': '0px',
                'transform': this.transform
            } }, this.props.children));
    }
}
/**
 * An airspeed indicator speed bug which renders an optional tick and label.
 */
class TickLabelSpeedBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.label = SubscribableUtils.isSubscribable(this.props.label)
            ? this.props.label.map(SubscribableMapFunctions.identity())
            : this.props.label;
    }
    /**
     * Sets this bug's visibility.
     * @param visible The bug visibility.
     */
    setIsVisible(visible) {
        this.ref.instance.setIsVisible(visible);
    }
    /**
     * Updates this bug's position.
     * @param iasPosition The position of this bug's reference airspeed on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     */
    updatePosition(iasPosition) {
        this.ref.instance.updatePosition(iasPosition);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(SpeedBug, { ref: this.ref, tapeWindowHeight: this.props.tapeWindowHeight, clamp: this.props.clamp, class: `airspeed-bug-ticklabel ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            this.props.tick && (FSComponent.buildComponent("div", { class: "airspeed-bug-ticklabel-tick" })),
            this.label && (FSComponent.buildComponent("div", { class: "airspeed-bug-ticklabel-label" }, this.label))));
    }
}
/**
 * A VNAV speed band for the airspeed indicator.
 */
class VNavSpeedBand extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.transform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px', 'px', 'px'), CssTransformBuilder.translateY('%')));
        this.height = Subject.create(0);
        this.isVisible = Subject.create(true);
        this.isInBounds = Subject.create(false);
        this.hidden = MappedSubject.create(([visible, inBounds]) => !visible || !inBounds, this.isVisible, this.isInBounds);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.transform.transform.getChild(1).set(-50);
        this.transform.resolve();
    }
    /**
     * Sets this band's visibility.
     * @param visible The band visibility.
     */
    setIsVisible(visible) {
        this.isVisible.set(visible);
    }
    /**
     * Updates this band's position.
     * @param minPosition The position of this band's lower limit on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     * @param maxPosition The position of this band's upper limit on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     */
    updatePosition(minPosition, maxPosition) {
        const isInBounds = minPosition > maxPosition && minPosition > -0.1 && maxPosition < 1.1;
        if (isInBounds) {
            this.isInBounds.set(true);
            const mid = (minPosition + maxPosition) / 2 * this.props.tapeWindowHeight;
            const height = (minPosition - maxPosition) * this.props.tapeWindowHeight;
            this.transform.transform.getChild(0).set(0, mid, 0, undefined, 0.1);
            this.transform.resolve();
            this.height.set(Math.round(height));
        }
        else {
            this.isInBounds.set(false);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'airspeed-vnav-speed-band': true,
                'hidden': this.hidden
            }, style: {
                'position': 'absolute',
                'top': '0px',
                'height': this.height.map(height => `${height}px`),
                'transform': this.transform
            } },
            FSComponent.buildComponent("div", { class: "airspeed-vnav-speed-band-stroke shadow" }),
            FSComponent.buildComponent("div", { class: "airspeed-vnav-speed-band-stroke" })));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link AirspeedIndicatorDataProvider}.
 */
class DefaultAirspeedIndicatorDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param iasTrendBounds The boundaries, as `[min, max]` in knots, to which indicated airspeed is clamped when
     * calculating the indicated airspeed trend. Defaults to `[30, 999]`.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, index, iasTrendBounds = Vec2Math.create(30, 999), useSelector = false) {
        this.bus = bus;
        this.iasTrendBounds = iasTrendBounds;
        this.useSelector = useSelector;
        this._ias = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.ias = this._ias;
        this._mach = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.mach = this._mach;
        this.machToKiasFactorSource = ConsumerValue.create(null, 0).pause();
        this.machToKiasFactorSmoother = new ExpSmoother(1000 / Math.LN2);
        this._machToKiasFactor = Subject.create(0);
        /** @inheritdoc */
        this.machToKiasFactor = this._machToKiasFactor;
        this.selectedSpeedIsMach = ConsumerSubject.create(null, false).pause();
        this.selectedIasSource = ConsumerSubject.create(null, 0).pause();
        this.selectedMachSource = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.selectedIas = MappedSubject.create(([isMach, ias]) => isMach ? null : ias, this.selectedSpeedIsMach, this.selectedIasSource);
        /** @inheritdoc */
        this.selectedMach = MappedSubject.create(([isMach, mach]) => isMach ? mach : null, this.selectedSpeedIsMach, this.selectedMachSource);
        this._selectedSpeedIas = Subject.create(null);
        /** @inheritdoc */
        this.selectedSpeedIas = this._selectedSpeedIas;
        this._maximumIas = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.maximumIas = this._maximumIas;
        this._minimumManeuveringIas = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.minimumManeuveringIas = this._minimumManeuveringIas;
        this._minimumIas = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.minimumIas = this._minimumIas;
        this._radioAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.radioAltitude = this._radioAltitude;
        this._selectedAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.selectedAltitude = this._selectedAltitude;
        this.iasLookahead = new Lookahead(6000, 2000 / Math.LN2, 1000 / Math.LN2);
        this._iasTrend = Subject.create(0);
        /** @inheritdoc */
        this.iasTrend = this._iasTrend;
        this.isAdcAirspeedDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isAdcDataFailed = this.isAdcAirspeedDataValid.map(SubscribableMapFunctions.not());
        this.simRate = ConsumerValue.create(null, 1).pause();
        this.pauseable = [
            this._ias,
            this._mach,
            this.machToKiasFactorSource,
            this.selectedSpeedIsMach,
            this.selectedIasSource,
            this.selectedMachSource,
            this._maximumIas,
            this._minimumManeuveringIas,
            this._minimumIas,
            this._radioAltitude,
            this._selectedAltitude,
            this.isAdcAirspeedDataValid,
            this.simRate
        ];
        this.lastUpdateTime = undefined;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAirspeedIndicatorDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this._selectedAltitude.setConsumer(sub.on('ap_altitude_selected_3'));
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAirspeedDataValid.setConsumer(sub.on(`adc_selector_speed_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAirspeedDataValid.setConsumer(sub.on(`adc_speed_data_valid_${index}`));
            }
            this._ias.setConsumer(sub.on(`adc_ias_${index}`));
            this._mach.setConsumer(sub.on(`adc_mach_number_${index}`));
            this.machToKiasFactorSource.setConsumer(sub.on(`adc_mach_to_kias_factor_${index}`));
        }, true);
        this.selectedSpeedIsMach.setConsumer(sub.on('fms_speed_autopilot_target_is_mach'));
        this.selectedIasSource.setConsumer(sub.on('fms_speed_autopilot_target_ias'));
        this.selectedMachSource.setConsumer(sub.on('fms_speed_autopilot_target_mach'));
        this._maximumIas.setConsumer(sub.on('speedlimit_max_ias'));
        this._minimumManeuveringIas.setConsumer(sub.on('speedlimit_min_maneuver_ias'));
        this._minimumIas.setConsumer(sub.on('speedlimit_min_ias'));
        this.simRate.setConsumer(sub.on('simRate'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultAirspeedIndicatorDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        this.updateSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultAirspeedIndicatorDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        this.updateSub.pause();
        this.lastUpdateTime = undefined;
        this.machToKiasFactorSmoother.reset();
        this.iasLookahead.reset();
    }
    /**
     * Executes this data provider's periodic updates.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        var _a;
        const dt = (time - ((_a = this.lastUpdateTime) !== null && _a !== void 0 ? _a : time)) * this.simRate.get();
        this.lastUpdateTime = time;
        this._machToKiasFactor.set(this.machToKiasFactorSmoother.next(this.machToKiasFactorSource.get(), dt));
        this._iasTrend.set(this.iasLookahead.nextTrend(MathUtils.clamp(this.ias.get(), this.iasTrendBounds[0], this.iasTrendBounds[1]), dt));
        if (this.selectedSpeedIsMach.get()) {
            this._selectedSpeedIas.set(this.selectedMachSource.get() * this._machToKiasFactor.get());
        }
        else {
            this._selectedSpeedIas.set(this.selectedIasSource.get());
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.updateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * A Boeing selected airspeed display box.
 */
class AirspeedSelectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.text = MappedSubject.create(([ias, mach]) => {
            if (ias !== null) {
                return ias.toFixed(0);
            }
            if (mach !== null) {
                const rounded = Math.round(mach * 1000);
                if (rounded < 1000) {
                    return `.${rounded}`;
                }
                else {
                    return mach.toFixed(3);
                }
            }
            return '';
        }, this.props.dataProvider.selectedIas, this.props.dataProvider.selectedMach).pause();
        this.isPaused = true;
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.text.resume();
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.text.pause();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "airspeed-select-box" },
            FSComponent.buildComponent("div", { class: "airspeed-select-value" }, this.text)));
    }
}

/**
 * Display modes for {@link GsMachReadout}.
 */
var GsMachReadoutMode;
(function (GsMachReadoutMode) {
    GsMachReadoutMode["None"] = "None";
    GsMachReadoutMode["GroundSpeed"] = "GroundSpeed";
    GsMachReadoutMode["Mach"] = "Mach";
})(GsMachReadoutMode || (GsMachReadoutMode = {}));
/**
 * A Boeing digital groundspeed/mach readout display. Displays mach when airspeed is at or above mach 0.4 and
 * groundspeed otherwise.
 */
class GsMachReadout extends DisplayComponent {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        super(...arguments);
        this.mach = (_b = (_a = this.props.airspeedIndicatorDataProvider) === null || _a === void 0 ? void 0 : _a.mach) !== null && _b !== void 0 ? _b : Subject.create(0);
        this.groundSpeed = (_d = (_c = this.props.groundSpeedDataProvider) === null || _c === void 0 ? void 0 : _c.groundSpeed) !== null && _d !== void 0 ? _d : Subject.create(0);
        this.mode = MappedSubject.create(([mach, isAdcDataFailed, isGsDataFailed, showGs, showMach], previousVal) => {
            if (showMach && !isAdcDataFailed && mach >= (previousVal === GsMachReadoutMode.Mach ? 0.38 : 0.4)) {
                return GsMachReadoutMode.Mach;
            }
            else if (showGs && !isGsDataFailed) {
                return GsMachReadoutMode.GroundSpeed;
            }
            else {
                return GsMachReadoutMode.None;
            }
        }, (_e = this.mach) !== null && _e !== void 0 ? _e : Subject.create(0), (_g = (_f = this.props.airspeedIndicatorDataProvider) === null || _f === void 0 ? void 0 : _f.isAdcDataFailed) !== null && _g !== void 0 ? _g : Subject.create(true), (_j = (_h = this.props.groundSpeedDataProvider) === null || _h === void 0 ? void 0 : _h.isDataFailed) !== null && _j !== void 0 ? _j : Subject.create(true), SubscribableUtils.toSubscribable((_k = this.props.showGs) !== null && _k !== void 0 ? _k : this.props.groundSpeedDataProvider !== undefined, true), SubscribableUtils.toSubscribable((_l = this.props.showMach) !== null && _l !== void 0 ? _l : this.props.airspeedIndicatorDataProvider !== undefined, true));
        this.machRounded = this.mach.map(SubscribableMapFunctions.withPrecision(0.001)).pause();
        this.gsRounded = this.groundSpeed.map(SubscribableMapFunctions.withPrecision(1)).pause();
        this.text = Subject.create('');
        this.alertTimer = new DebounceTimer();
        this.isAlertActive = Subject.create(false);
        this.hidden = this.mode.map(mode => mode === GsMachReadoutMode.None);
        this.isAlive = true;
        this.isPaused = true;
    }
    /** @inheritdoc */
    onAfterRender() {
        if (this.props.mode) {
            this.modePipe = this.mode.pipe(this.props.mode);
        }
        const machPipe = this.machRounded.pipe(this.text, mach => {
            const rounded = Math.round(mach * 1000);
            if (rounded < 1000) {
                return `.${rounded}`;
            }
            else {
                return mach.toFixed(3);
            }
        }, true);
        const gsPipe = this.gsRounded.pipe(this.text, gs => gs.toFixed(0), true);
        const deactivateAlert = this.isAlertActive.set.bind(this.isAlertActive, false);
        this.mode.sub(mode => {
            let activateAlert = true;
            switch (mode) {
                case GsMachReadoutMode.Mach:
                    gsPipe.pause();
                    machPipe.resume(true);
                    break;
                case GsMachReadoutMode.GroundSpeed:
                    machPipe.pause();
                    gsPipe.resume(true);
                    break;
                default:
                    machPipe.pause();
                    gsPipe.pause();
                    activateAlert = false;
            }
            if (activateAlert) {
                this.isAlertActive.set(true);
                this.alertTimer.schedule(deactivateAlert, GsMachReadout.ALERT_DURATION);
            }
            else {
                this.alertTimer.clear();
            }
        }, true);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     * @throws Error if this component has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('GsMachReadout: cannot resume a dead display');
        }
        this.isPaused = false;
        this.gsRounded.resume();
        this.machRounded.resume();
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     * @throws Error if this component has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('GsMachReadout: cannot pause a dead display');
        }
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.gsRounded.pause();
        this.machRounded.pause();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'gs-mach-readout': true,
                'hidden': this.hidden,
                'gs-mach-readout-alert': this.isAlertActive
            } },
            FSComponent.buildComponent("span", { class: { 'gs-mach-readout-prefix': true, 'hidden': this.mode.map(mode => mode !== GsMachReadoutMode.GroundSpeed) } }, "GS"),
            FSComponent.buildComponent("span", { class: 'gs-mach-readout-value' }, this.text)));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.isAlive = false;
        this.alertTimer.clear();
        this.hidden.destroy();
        this.mode.destroy();
        this.machRounded.destroy();
        this.gsRounded.destroy();
        (_a = this.modePipe) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}
GsMachReadout.ALERT_DURATION = 10000; // milliseconds

/**
 * A Boeing "NO VSPD" failure flag.
 */
class NoVSpdFlag extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.isOnGround = ConsumerSubject.create(null, false).pause();
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        this.vSpeedSettings = VSpeedUserSettings.getManager(this.props.bus);
        this.hidden = MappedSubject.create(([isAirspeedDataFailed, isOnGround, phase, v1, vr, v2, vref]) => {
            return isAirspeedDataFailed || !isOnGround || phase > FmsOperatingPhase.TAKEOFF || v1 > 50 || vr > 50 || v2 > 50 || vref > 50;
        }, this.props.isAirspeedDataFailed, this.isOnGround, this.fmsOperatingPhase, this.vSpeedSettings.getSettings(VSpeedType.V1).value, this.vSpeedSettings.getSettings(VSpeedType.Vr).value, this.vSpeedSettings.getSettings(VSpeedType.V2).value, this.vSpeedSettings.getSettings(VSpeedType.Vref).value).pause();
        this.isPaused = true;
        this.pauseable = [
            this.isOnGround,
            this.fmsOperatingPhase,
            this.hidden
        ];
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'no-vspd-flag': true, 'hidden': this.hidden } },
            "NO",
            FSComponent.buildComponent("br", null),
            "V",
            FSComponent.buildComponent("br", null),
            "S",
            FSComponent.buildComponent("br", null),
            "P",
            FSComponent.buildComponent("br", null),
            "D"));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link VNavSpeedBandDataProvider}.
 */
class DefaultVNavSpeedBandDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.minimumIasSource = ConsumerSubject.create(null, null).pause();
        this.maximumIasSource = ConsumerSubject.create(null, null).pause();
        this._minimumIas = Subject.create(null);
        /** @inheritdoc */
        this.minimumIas = this._minimumIas;
        this._maximumIas = Subject.create(null);
        /** @inheritdoc */
        this.maximumIas = this._maximumIas;
        this.vnavMode = ConsumerSubject.create(null, BoeingVNavModes.NONE).pause();
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        // The speedband is only available in descent phase (not approach!) with VNAV PTH
        this.isAvail = MappedSubject.create(([fmsOperatingPhase, vnavMode]) => fmsOperatingPhase === FmsOperatingPhase.DESCENT
            && (vnavMode === BoeingVNavModes.PATH_DESCENT || vnavMode === BoeingVNavModes.PATH_IDLE), this.fmsOperatingPhase, this.vnavMode);
        this.pauseable = [
            this.minimumIasSource,
            this.maximumIasSource,
            this.fmsOperatingPhase,
            this.vnavMode,
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVNavSpeedBandDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.minimumIasSource.setConsumer(sub.on('vnav_boeing_band_speed_min'));
        this.maximumIasSource.setConsumer(sub.on('vnav_boeing_band_speed_max'));
        this.vnavMode.setConsumer(sub.on('vnav_boeing_vnav_mode'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this.minimumIasPipe = this.minimumIasSource.pipe(this._minimumIas, true);
        this.maximumIasPipe = this.maximumIasSource.pipe(this._maximumIas, true);
        this.isAvailSub = this.isAvail.sub(isAvail => {
            if (isAvail) {
                this.minimumIasPipe.resume(true);
                this.maximumIasPipe.resume(true);
            }
            else {
                this.minimumIasPipe.pause();
                this.maximumIasPipe.pause();
                this._minimumIas.set(null);
                this._maximumIas.set(null);
            }
        }, false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultVNavSpeedBandDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        this.isAvailSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultVNavSpeedBandDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        this.isAvailSub.pause();
        this.minimumIasPipe.pause();
        this.maximumIasPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * A Boeing altimeter.
 */
class Altimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.metricAltitudeBoxElement = FSComponent.createRef();
        this.metricAltitudeValue = Subject.create(0);
        this.pixelPerFoot = this.props.windowHeight / Altimeter.WINDOW_ALTITUDE;
        this.tapeTickCount = Altimeter.WINDOW_ALTITUDE * 2 / Altimeter.TAPE_TICK_INTERVAL + 1;
        this.tapeCenterTickOffset = Math.floor(this.tapeTickCount / 2);
        this.tapeTickAltitudes = ArrayUtils.create(this.tapeTickCount, index => Subject.create((index - this.tapeCenterTickOffset) * Altimeter.TAPE_TICK_INTERVAL, SubscribableUtils.NUMERIC_NAN_EQUALITY));
        this.tapeCenterAltitude = 0;
        this.tapeScrolledAltitude = 0;
        this.tapeTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', '%', 'px'));
        this.groundRibbonTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', 'px', 'px'));
        this.isGroundRibbonHidden = Subject.create(false);
        this.preselectBugTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px', 'px', 'px'), CssTransformBuilder.translateY('%')));
        this.baroMinsBugTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px', 'px', 'px'), CssTransformBuilder.translateY('%')));
        this.isBaroMinsBugHidden = Subject.create(false);
        this.isBaroMinsAlertActive = Subject.create(false);
        this.isBaroMinsBugFlashing = Subject.create(false);
        this.baroMinsBugFlashTimer = new DebounceTimer();
        this.trendVectorScaleTransform = CssTransformSubject.create(CssTransformBuilder.scaleY());
        this.trendVectorTranslateTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.isTrendVectorHidden = Subject.create(false);
        this.scrollerAltitude = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.scrollerAltitude10000 = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.isReadoutAlertActive = Subject.create(false);
        this.isReadoutBold = Subject.create(false);
        this.landingElevation = MappedSubject.create(([landingElevation, isQfe]) => landingElevation === null ? null : isQfe ? 0 : landingElevation, this.props.dataProvider.landingElevation, this.props.isQfe).pause();
        this.radioGroundElevation = MappedSubject.create(([indicatedAltitude, radioAltitude]) => indicatedAltitude - radioAltitude, this.props.dataProvider.indicatedAltitude, this.props.dataProvider.radioAltitude).pause();
        this.groundRibbonAltitude = Subject.create(0);
        this.isPaused = true;
        this.pauseableSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.preselectBugTransform.transform.getChild(1).set(-50);
        this.baroMinsBugTransform.transform.getChild(1).set(-50);
        this.landingElevationPipe = this.landingElevation.pipe(this.groundRibbonAltitude, elev => elev === null ? 0 : elev, true);
        this.radioGroundElevationPipe = this.radioGroundElevation.pipe(this.groundRibbonAltitude, true);
        this.pauseableSubs.push(this.props.dataProvider.indicatedAltitude.sub(this.updateAltitude.bind(this), true, this.isPaused), this.props.dataProvider.selectedAltitude.sub(this.updateSelectedAltitudeBug.bind(this), true, this.isPaused), this.props.minimumsDataProvider.baroMinimums.sub(this.updateBaroMinimumsBug.bind(this), true, this.isPaused), this.props.dataProvider.landingElevation.sub(elev => {
            var _a, _b, _c, _d;
            if (elev === null) {
                (_a = this.landingElevationPipe) === null || _a === void 0 ? void 0 : _a.pause();
                this.radioGroundElevation.resume();
                (_b = this.radioGroundElevationPipe) === null || _b === void 0 ? void 0 : _b.resume(true);
            }
            else {
                this.radioGroundElevation.pause();
                (_c = this.radioGroundElevationPipe) === null || _c === void 0 ? void 0 : _c.pause();
                (_d = this.landingElevationPipe) === null || _d === void 0 ? void 0 : _d.resume(true);
            }
        }, true, this.isPaused), this.props.dataProvider.altitudeAlertState.sub(this.onAltitudeAlertStateChanged.bind(this), true, this.isPaused), this.props.minimumsDataProvider.isBaroMinimumsAlertActive.pipe(this.isBaroMinsAlertActive, this.isPaused), this.props.showMetric.sub(showMetric => {
            this.metricAltitudeBoxElement.instance.classList.toggle('hidden', !showMetric);
        }, true, this.isPaused)
        // TODO: Hook up "no landing altitude" state to toggle "no-ldg-alt" CSS class on .altimeter element
        );
        if (this.props.supportTrendVector) {
            this.pauseableSubs.push(this.props.dataProvider.altitudeTrend.sub(this.onTrendChanged.bind(this), this.isPaused));
        }
        this.groundRibbonAltitude.sub(this.updateGroundRibbon.bind(this), true);
        const deactivateMinsBugFlash = this.isBaroMinsBugFlashing.set.bind(this.isBaroMinsBugFlashing, false);
        this.props.minimumsDataProvider.isBaroMinimumsAlertActive.sub(isActive => {
            if (isActive) {
                this.isBaroMinsBugFlashing.set(true);
                this.baroMinsBugFlashTimer.schedule(deactivateMinsBugFlash, Altimeter.MINIMUMS_FLASH_DURATION);
            }
            else {
                this.baroMinsBugFlashTimer.clear();
                deactivateMinsBugFlash();
            }
        }, true);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.landingElevation.resume();
        for (const sub of this.pauseableSubs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        var _a, _b;
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const sub of this.pauseableSubs) {
            sub.pause();
        }
        this.landingElevation.pause();
        this.radioGroundElevation.pause();
        (_a = this.landingElevationPipe) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.radioGroundElevationPipe) === null || _b === void 0 ? void 0 : _b.pause();
    }
    /**
     * A method called to update the location of the Selected Altitude Bug on the altitude tape.
     */
    updateSelectedAltitudeBug() {
        const deltaBug = this.tapeScrolledAltitude - this.props.dataProvider.selectedAltitude.get();
        this.preselectBugTransform.transform
            .getChild(0)
            .set(0, MathUtils.clamp(deltaBug, -Altimeter.HALF_WINDOW_ALTITUDE, Altimeter.HALF_WINDOW_ALTITUDE) * this.pixelPerFoot, 0, undefined, 0.1);
        this.preselectBugTransform.resolve();
    }
    /**
     * A method called to update the location of the Baro Minimums Bug on the altitude tape.
     */
    updateBaroMinimumsBug() {
        const minimums = this.props.minimumsDataProvider.baroMinimums.get();
        let isVisible = false;
        if (minimums !== null) {
            const deltaBug = this.tapeScrolledAltitude - minimums;
            // Allow the bug to scroll off the tape window, but then hide it once it reaches far enough out of bounds so that
            // we don't keep updating the bug when it can't be seen.
            const maxDelta = Altimeter.HALF_WINDOW_ALTITUDE + 100;
            if (Math.abs(deltaBug) < maxDelta && this.tapeScrolledAltitude >= -2000 && this.tapeScrolledAltitude <= 99900) {
                this.baroMinsBugTransform.transform
                    .getChild(0)
                    .set(0, deltaBug * this.pixelPerFoot, 0, undefined, 0.1);
                this.baroMinsBugTransform.resolve();
                isVisible = true;
            }
        }
        this.isBaroMinsBugHidden.set(!isVisible);
    }
    /**
     * A method called to update the location of the Ground Ribbon on the altitude tape.
     */
    updateGroundRibbon() {
        const groundAltitude = this.groundRibbonAltitude.get();
        let isVisible = false;
        if (this.tapeScrolledAltitude >= -2000 && this.tapeScrolledAltitude <= 99900) {
            // Ground ribbon elements span from ground altitude to ground altitude + 1000 feet. Therefore, with a tape window
            // of 800 feet (400 feet on either side of the indicated altitude), the ground ribbon is visible with indicated
            // altitude within 400 feet below to 1400 feet above ground altitude. We will add 100 feet of buffer to both ends
            // of this range (the ground ribbon stripes do extend below the actual ground altitude but by less than 100 feet)
            // and render/update the ribbon only when indicated altitude is within the buffered range.
            const deltaAltitude = this.tapeScrolledAltitude - groundAltitude;
            if (deltaAltitude >= -500 && deltaAltitude <= 1500) {
                this.groundRibbonTransform.transform.set(0, this.pixelPerFoot * deltaAltitude, 0, undefined, 0.1);
                this.groundRibbonTransform.resolve();
                isVisible = true;
            }
        }
        this.isGroundRibbonHidden.set(!isVisible);
    }
    /**
     * Responds to when the altitude trend changes.
     * @param trend The new altitude trend, in feet.
     */
    onTrendChanged(trend) {
        const absoluteTrend = Math.abs(trend);
        if (absoluteTrend > 30) {
            this.trendVectorScaleTransform.transform.set(trend < 0 ? -1 : 1);
            this.trendVectorScaleTransform.resolve();
            this.trendVectorTranslateTransform.transform.set(0, -this.pixelPerFoot * Math.min(absoluteTrend, Altimeter.HALF_WINDOW_ALTITUDE * 1.5), 0, undefined, 0.1);
            this.trendVectorTranslateTransform.resolve();
            this.isTrendVectorHidden.set(false);
        }
        else {
            this.isTrendVectorHidden.set(true);
        }
    }
    /**
     * Updates the altitude indicator when the altitude changes.
     * @param indicatedAlt The new altitude value.
     */
    updateAltitude(indicatedAlt) {
        this.metricAltitudeValue.set(Math.round(UnitType.FOOT.convertTo(indicatedAlt, UnitType.METER)));
        if (indicatedAlt < -2000 || indicatedAlt > 99900) {
            this.scrollerAltitude.set(NaN);
            this.scrollerAltitude10000.set(NaN);
        }
        else {
            this.scrollerAltitude.set(indicatedAlt);
            if (indicatedAlt >= 0) {
                this.scrollerAltitude10000.set(indicatedAlt);
            }
            else {
                // If indicated altitude is negative, we need the 10000 digit scroller to transition from the zero symbol
                // to the negative sign from 0 to -20 feet.
                this.scrollerAltitude10000.set(Math.max(-9980 + indicatedAlt, -10000));
            }
        }
        if (indicatedAlt < -2000 || indicatedAlt > 99900) {
            this.tapeTransform.transform.set(0, 0, 0);
        }
        else {
            let tapeTranslation = (indicatedAlt - this.tapeCenterAltitude) / (Altimeter.WINDOW_ALTITUDE * 2) * 100;
            if (Math.abs(tapeTranslation) > 25) {
                // We need to reset the tape's center altitude such that the tape translation is back within +/-25%.
                this.tapeCenterAltitude = MathUtils.round(indicatedAlt, 100);
                for (let i = 0; i < this.tapeTickAltitudes.length; i++) {
                    this.tapeTickAltitudes[i].set((i - this.tapeCenterTickOffset) * Altimeter.TAPE_TICK_INTERVAL + this.tapeCenterAltitude);
                }
                tapeTranslation = (indicatedAlt - this.tapeCenterAltitude) / (Altimeter.WINDOW_ALTITUDE * 2) * 100;
            }
            this.tapeTransform.transform.set(0, tapeTranslation, 0, undefined, 0.02);
        }
        this.tapeTransform.resolve();
        this.tapeScrolledAltitude = indicatedAlt;
        this.updateSelectedAltitudeBug();
        this.updateBaroMinimumsBug();
        this.updateGroundRibbon();
    }
    /**
     * Responds to when the altitude alert state changes.
     * @param state The new altitude alert state.
     */
    onAltitudeAlertStateChanged(state) {
        // set styles
        this.isReadoutAlertActive.set(state === AltAlertState.DEVIATION_200);
        this.isReadoutBold.set(state === AltAlertState.DEVIATION_200 || state === AltAlertState.WITHIN_900);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "altimeter-box" },
            FSComponent.buildComponent("div", { class: "altimeter", style: `position: absolute; top: 0px; height: ${this.props.windowHeight}px;` },
                FSComponent.buildComponent("div", { class: "altitude-mask", style: "position: absolute; top: 0px; height: 100%; overflow: hidden;" },
                    FSComponent.buildComponent("div", { class: "altimeter-tape", style: {
                            'position': 'absolute',
                            'top': '-50%',
                            'height': `${this.props.windowHeight * 2}px`,
                            'transform': this.tapeTransform
                        } },
                        FSComponent.buildComponent("div", { class: "altimeter-tape-tick-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAltitudeTapeTicks()),
                        FSComponent.buildComponent("div", { class: "altimeter-tape-label-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAltitudeTapeLabels())),
                    this.renderGroundRibbon(),
                    FSComponent.buildComponent("svg", { viewBox: "0 0 53 88", preserveAspectRatio: "none", class: "altimeter-preselect-bug", style: { 'position': 'absolute', 'top': '50%', 'overflow': 'visible', 'transform': this.preselectBugTransform } },
                        FSComponent.buildComponent("path", { d: "m 53 0 l -53 0 l 0 29 l 13 15 l -13 15 l 0 29 l 53 0 Z", class: "altimeter-preselect-bug-stroke shadow" }),
                        FSComponent.buildComponent("path", { d: "m 53 0 l -53 0 l 0 29 l 13 15 l -13 15 l 0 29 l 53 0 Z", class: "altimeter-preselect-bug-stroke" })),
                    FSComponent.buildComponent("svg", { viewBox: "0 -25 144 50", preserveAspectRatio: "none", class: { 'altimeter-baro-mins-bug': true, 'hidden': this.isBaroMinsBugHidden, 'warning': this.isBaroMinsAlertActive, 'flash': this.isBaroMinsBugFlashing }, style: { 'position': 'absolute', 'top': '50%', 'overflow': 'visible', 'transform': this.baroMinsBugTransform } },
                        FSComponent.buildComponent("path", { d: "M 144 0 L 19 0 L 0 25 L 0 -25 L 19 0", stroke: "currentColor", class: "altimeter-baro-mins-bug-stroke" })),
                    this.props.supportTrendVector === true && this.renderTrendVector()),
                FSComponent.buildComponent("div", { class: "metric-altitude-box hidden", ref: this.metricAltitudeBoxElement },
                    FSComponent.buildComponent("div", { class: "metric-altitude-value-container" },
                        FSComponent.buildComponent("span", { class: "value" }, this.metricAltitudeValue),
                        FSComponent.buildComponent("span", { class: "unit" }, "M"))),
                FSComponent.buildComponent("div", { class: "altimeter-readout" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 146 88", preserveAspectRatio: "none", "stroke-linejoin": "round", class: { 'altimeter-readout-box': true, 'warning': this.isReadoutAlertActive, 'bold': this.isReadoutBold }, style: "overflow: visible;" },
                        FSComponent.buildComponent("path", { class: "altimeter-readout-box-border shadow", d: "M 17 0 l 129 0 l 0 88 l -129 0 l 0 -29 l -17 -15 l 17 -15 z" }),
                        FSComponent.buildComponent("path", { class: "altimeter-readout-box-border", d: "M 17 0 l 129 0 l 0 88 l -129 0 l 0 -29 l -17 -15 l 17 -15 z" })),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude10000, base: 10, factor: 10000, scrollThreshold: 9980, renderDigit: (digit) => digit === 0 ? '$' : digit < 0 ? '-' : (digit % 10).toString(), nanString: ' ', class: 'alt-digit-scroller alt-ten-thousands-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude, base: 10, factor: 1000, scrollThreshold: 980, renderDigit: (digit) => (Math.abs(digit) % 10).toString(), nanString: ' ', class: 'alt-digit-scroller alt-thousands-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude, base: 10, factor: 100, scrollThreshold: 80, renderDigit: (digit) => (Math.abs(digit) % 10).toString(), nanString: ' ', class: 'alt-digit-scroller alt-hundreds-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude, base: 5, factor: 20, renderDigit: (digit) => ((Math.abs(digit) % 5) * 20).toString().padStart(2, '0'), nanString: '--', class: 'alt-digit-scroller alt-tens-scroller' }))),
            FSComponent.buildComponent("div", { class: "altimeter-ldg-alt-flag" }, "LDG ALT")));
    }
    /**
     * Builds the tick marks on the altitude tape.
     * @returns The tick marks on the altitude tape, as an array of VNodes.
     */
    buildAltitudeTapeTicks() {
        const tickIntervalPx = Altimeter.TAPE_TICK_INTERVAL * this.pixelPerFoot;
        const is500Map = (altitude) => altitude % 500 === 0;
        const is1000Map = (altitude) => altitude % 1000 === 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const altitude = this.tapeTickAltitudes[index];
            const y = (this.tapeTickCount - index - 1) * tickIntervalPx;
            const is500 = altitude.map(is500Map);
            const is1000 = altitude.map(is1000Map);
            return (FSComponent.buildComponent("div", { class: { 'altimeter-tape-tick': true, 'altimeter-tape-tick-500': is500, 'altimeter-tape-tick-1000': is1000 }, style: `position: absolute; top: ${y}px; transform: translateY(-50%);` }));
        });
    }
    /**
     * Builds the labels on the altitude tape.
     * @returns The labels on the altitude tape, as an array of VNodes.
     */
    buildAltitudeTapeLabels() {
        const labelIntervalPx = Altimeter.TAPE_TICK_INTERVAL * this.pixelPerFoot;
        const bigTextMap = (altitude) => {
            if (isNaN(altitude)) {
                return '';
            }
            if (altitude < 0 && altitude > -1000) {
                return '-';
            }
            else if (altitude >= 0 && altitude < 1000) {
                return '';
            }
            else {
                return Math.trunc(altitude / 1000).toString();
            }
        };
        const smallTextMap = (altitude) => {
            if (isNaN(altitude)) {
                return '';
            }
            const mod = Math.abs(altitude) % 1000;
            return mod === 0 ? '000' : mod.toString();
        };
        const is1000Map = (altitude) => altitude % 1000 === 0;
        const isHiddenMap = (altitude) => altitude % 200 !== 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const altitude = this.tapeTickAltitudes[index];
            const y = (this.tapeTickCount - index - 1) * labelIntervalPx;
            return (FSComponent.buildComponent("div", { class: {
                    'altimeter-tape-label': true,
                    'altimeter-tape-label-1000': altitude.map(is1000Map),
                    'hidden': altitude.map(isHiddenMap)
                }, style: `position: absolute; right: 0%; top: ${y}px; transform: translateY(-50%)` },
                FSComponent.buildComponent("div", { class: "altimeter-tape-label-bar altimeter-tape-label-bar-top", style: "position: absolute;" }),
                FSComponent.buildComponent("div", { class: "altimeter-tape-label-bar altimeter-tape-label-bar-bottom", style: "position: absolute;" }),
                FSComponent.buildComponent("div", { class: 'altimeter-tape-label-numbers' },
                    FSComponent.buildComponent("span", { class: "altimeter-tape-label-big" }, altitude.map(bigTextMap)),
                    FSComponent.buildComponent("span", { class: "altimeter-tape-label-small" }, altitude.map(smallTextMap)))));
        });
    }
    /**
     * Renders this altimeter's ground ribbon.
     * @returns This altimeter's ground ribbon, as a VNode.
     */
    renderGroundRibbon() {
        const top = Math.round(this.pixelPerFoot * -1000);
        const middle = Math.round(this.pixelPerFoot * -500);
        return (FSComponent.buildComponent("div", { class: { 'altimeter-ground-ribbon': true, 'hidden': this.isGroundRibbonHidden }, style: { 'position': 'absolute', 'top': '50%', 'transform': this.groundRibbonTransform } },
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-upper shadow", style: `position: absolute; top: calc(${top}px + var(--altimeter-ground-ribbon-stem-shadow-upper-y-offset, 0px)); height: calc(${middle - top}px + var(--altimeter-ground-ribbon-stem-shadow-upper-height-offset, 0px))` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-lower shadow", style: `position: absolute; top: calc(${middle}px + var(--altimeter-ground-ribbon-stem-shadow-lower-y-offset, 0px)); height: calc(${-middle}px + var(--altimeter-ground-ribbon-stem-shadow-lower-height-offset, 0px))` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-ground-line shadow", style: "position: absolute; top: var(--altimeter-ground-ribbon-ground-line-shadow-y-offset, 0px);" }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-upper", style: `position: absolute; top: ${top}px; height: ${middle - top}px` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-lower", style: `position: absolute; top: ${middle}px; height: ${-middle}px` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-ground-line", style: "position: absolute; top: 0px;" }),
            FSComponent.buildComponent("svg", { viewBox: "0 0 125 50", preserveAspectRatio: "none", class: "altimeter-ground-ribbon-stripes", style: "position: absolute; top: 0px;" },
                FSComponent.buildComponent("path", { d: "M 0 48 L 2 50 M 0 35 L 15 50 M 0 20 L 30 50 M 45 50 L 0 5 M 25 0 L 75 50 M 60 50 L 10 0 M 90 50 L 40 0 M 55 0 L 105 50 M 120 50 L 70 0 M 85 0 L 125 40 M 100 0 L 125 25 M 115 0 L 125 10 M 180 32", class: "altimeter-ground-ribbon-stripes-stroke" }))));
    }
    /**
     * Renders this altimeter's altitude trend vector.
     * @returns This altimeter's altitude trend vector, as a VNode.
     */
    renderTrendVector() {
        return (FSComponent.buildComponent("div", { class: {
                'altimeter-trend-vector': true,
                'hidden': this.isTrendVectorHidden,
            }, style: {
                'position': 'absolute',
                'bottom': '50%',
                'height': '50%',
                'overflow': 'hidden',
                'transform': this.trendVectorScaleTransform,
                'transform-origin': '50% 100%'
            } },
            FSComponent.buildComponent("div", { style: { 'position': 'absolute', 'left': '0px', 'top': '100%', 'width': '100%', 'height': '150%', 'transform': this.trendVectorTranslateTransform } },
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-stem shadow", style: "position: absolute; bottom: 0px;" },
                    FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "altimeter-trend-vector-stroke" })),
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-pointer shadow", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "altimeter-trend-vector-stroke" })),
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-stem", style: "position: absolute; bottom: 0px;" },
                    FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "altimeter-trend-vector-stroke" })),
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-pointer", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "altimeter-trend-vector-stroke" })))));
    }
}
/** The altimeter tape window's altitude range, in feet. */
Altimeter.WINDOW_ALTITUDE = 800;
Altimeter.HALF_WINDOW_ALTITUDE = Altimeter.WINDOW_ALTITUDE / 2;
/** The altitude interval between each altimeter tape tick. */
Altimeter.TAPE_TICK_INTERVAL = 100;
Altimeter.MINIMUMS_FLASH_DURATION = 3000; // milliseconds

/**
 * An altimeter barometric settings display.
 */
class AltimeterBaroDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.settingText = MappedSubject.create(([isStd, setting, showMetric]) => isStd ? 'STD' : showMetric ? UnitType.IN_HG.convertTo(setting, UnitType.HPA).toFixed(0) : setting.toFixed(2), this.props.dataProvider.isStd, this.props.dataProvider.baroInHg, this.props.showMetric).pause();
        this.settingUnitText = MappedSubject.create(([isStd, showMetric]) => isStd ? '' : showMetric ? 'HPA' : 'IN', this.props.dataProvider.isStd, this.props.showMetric).pause();
        this.settingReference = MappedSubject.create(([isStd, isQfe]) => isStd ? null : isQfe ? 'QFE' : 'QNH', this.props.dataProvider.isStd, this.props.dataProvider.isQfe).pause();
        this.settingReferenceTimer = new DebounceTimer();
        this.settingReferenceText = Subject.create('');
        this.preselectText = MappedSubject.create(([isPreselectManual, preselect, showMetric]) => isPreselectManual ? showMetric ? UnitType.IN_HG.convertTo(preselect, UnitType.HPA).toFixed(0) : preselect.toFixed(2) : '', this.props.dataProvider.isPreselectManual, this.props.dataProvider.preselectInHg, this.props.showMetric).pause();
        this.preselectUnitText = MappedSubject.create(([isPreselectManual, showMetric]) => isPreselectManual ? showMetric ? 'HPA' : 'IN' : '', this.props.dataProvider.isPreselectManual, this.props.showMetric).pause();
        this.preselectReferenceText = MappedSubject.create(([isPreselectManual, isQfe]) => isPreselectManual && isQfe ? 'QFE' : '', this.props.dataProvider.isPreselectManual, this.props.dataProvider.isQfe).pause();
        this.afdsBaroSourceText = this.props.dataProvider.afdsBaroSource;
        this.isStd = this.props.dataProvider.isStd.map(SubscribableMapFunctions.identity()).pause();
        this.isBaroAlertActive = this.props.dataProvider.isBaroAlertActive.map(SubscribableMapFunctions.identity()).pause();
        this.isQfeAlertActive = Subject.create(false);
        this.isPaused = true;
        this.pauseable = [
            this.settingText,
            this.settingUnitText,
            this.preselectText,
            this.preselectUnitText,
            this.preselectReferenceText,
            this.isStd,
            this.isBaroAlertActive
        ];
    }
    /** @inheritdoc */
    onAfterRender() {
        const deactivateQfeAlert = this.isQfeAlertActive.set.bind(this.isQfeAlertActive, false);
        const clearReferenceText = this.settingReferenceText.set.bind(this.settingReferenceText, '');
        this.settingReference.resume();
        this.settingReference.sub(reference => {
            switch (reference) {
                case 'QNH':
                    deactivateQfeAlert();
                    this.settingReferenceText.set('QNH');
                    this.settingReferenceTimer.schedule(clearReferenceText, AltimeterBaroDisplay.QNH_DURATION);
                    break;
                case 'QFE':
                    this.settingReferenceText.set('QFE');
                    this.isQfeAlertActive.set(true);
                    this.settingReferenceTimer.schedule(deactivateQfeAlert, AltimeterBaroDisplay.QFE_ALERT_DURATION);
                    break;
                default:
                    clearReferenceText();
                    deactivateQfeAlert();
                    this.settingReferenceTimer.clear();
            }
        }, true);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'alt-baro': true,
                'alt-baro-std': this.isStd,
                'alt-baro-alert': this.isBaroAlertActive,
                'alt-baro-qfe-alert': this.isQfeAlertActive
            } },
            FSComponent.buildComponent("div", { class: "alt-baro-row alt-baro-top" },
                FSComponent.buildComponent("div", { class: "alt-baro-source" }, this.afdsBaroSourceText),
                FSComponent.buildComponent("div", { class: "alt-baro-setting" },
                    FSComponent.buildComponent("div", { class: "alt-baro-setting-inner" },
                        FSComponent.buildComponent("div", { class: "alt-baro-value-wrapper" },
                            FSComponent.buildComponent("div", { class: "alt-baro-value" }, this.settingText)),
                        FSComponent.buildComponent("div", { class: "alt-baro-unit" }, this.settingUnitText))),
                FSComponent.buildComponent("div", { class: "alt-baro-reference" }, this.settingReferenceText)),
            FSComponent.buildComponent("div", { class: "alt-baro-row alt-baro-bottom" },
                FSComponent.buildComponent("div", { class: "alt-baro-uplink" }),
                FSComponent.buildComponent("div", { class: "alt-baro-setting" },
                    FSComponent.buildComponent("div", { class: "alt-baro-setting-inner" },
                        FSComponent.buildComponent("div", { class: "alt-baro-value-wrapper" },
                            FSComponent.buildComponent("div", { class: "alt-baro-value" }, this.preselectText)),
                        FSComponent.buildComponent("div", { class: "alt-baro-unit" }, this.preselectUnitText))),
                FSComponent.buildComponent("div", { class: "alt-baro-reference" }, this.preselectReferenceText))));
    }
}
AltimeterBaroDisplay.QNH_DURATION = 10000; // milliseconds
AltimeterBaroDisplay.QFE_ALERT_DURATION = 10000; // milliseconds

/**
 * A default implementation of {@link AltimeterDataProvider} which sources data from one ADC at a time or from the ADC
 * chosen by an ADC selector.
 */
class DefaultAltimeterDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param perfPlan The performance plan that is the source of this provider's landing elevation data.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param landingElevationOffset The offset, in feet, to apply to this provider's landing elevation value.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, perfPlan, index, landingElevationOffset, useSelector = false) {
        this.bus = bus;
        this.perfPlan = perfPlan;
        this.landingElevationOffset = landingElevationOffset;
        this.useSelector = useSelector;
        this._indicatedAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.indicatedAltitude = this._indicatedAltitude;
        this._radioAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.radioAltitude = this._radioAltitude;
        this._selectedAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.selectedAltitude = this._selectedAltitude;
        this.verticalSpeed = ConsumerSubject.create(null, 0).pause();
        // Vertical speed is already smoothed by the sim, so no need to further smooth it when calculating the trend.
        /** @inheritdoc */
        this.altitudeTrend = this.verticalSpeed.map(vs => vs / 10);
        this._landingElevation = Subject.create(null);
        /** @inheritdoc */
        this.landingElevation = this._landingElevation;
        this._altitudeAlertState = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.altitudeAlertState = this._altitudeAlertState;
        this.isAdcAltitudeDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isAdcDataFailed = this.isAdcAltitudeDataValid.map(SubscribableMapFunctions.not());
        this.ppos = ConsumerValue.create(null, undefined);
        this.pauseable = [
            this._indicatedAltitude,
            this._radioAltitude,
            this._selectedAltitude,
            this.verticalSpeed,
            this._altitudeAlertState,
            this.isAdcAltitudeDataValid,
            this.ppos
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAltimeterDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this._selectedAltitude.setConsumer(sub.on('ap_altitude_selected_3'));
        this._altitudeAlertState.setConsumer(sub.on('altitude_alert'));
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_altitude_data_valid_${index}`));
            }
            this._indicatedAltitude.setConsumer(sub.on(`adc_indicated_alt_${index}`));
            this.verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
        }, true);
        // TODO: What happens to landing elevation when GPS position is not available?
        this.ppos.setConsumer(sub.on('gps-position'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAltimeterDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAltimeterDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /**
     * Executes this data provider's periodic updates.
     */
    update() {
        const ppos = this.ppos.get();
        if (!ppos) {
            this._landingElevation.set(null);
            return;
        }
        const takeoffRunway = this.perfPlan.originRunway.get();
        const approachRunway = this.perfPlan.approachRunway.get();
        if (!takeoffRunway) {
            this._landingElevation.set(null);
            return;
        }
        if (approachRunway) {
            const distanceToTakeoffRunway = GeoPoint.distance(ppos.lat, ppos.long, takeoffRunway.latitude, takeoffRunway.longitude);
            const distanceToApproachRunway = GeoPoint.distance(ppos.lat, ppos.long, approachRunway.latitude, approachRunway.longitude);
            if (distanceToApproachRunway < distanceToTakeoffRunway || distanceToTakeoffRunway > 0.116147 /* 400 NM */) {
                this._landingElevation.set(UnitType.METER.convertTo(approachRunway.elevation, UnitType.FOOT) + this.landingElevationOffset);
            }
            else {
                this._landingElevation.set(UnitType.METER.convertTo(takeoffRunway.elevation, UnitType.FOOT) + this.landingElevationOffset);
            }
        }
        else {
            this._landingElevation.set(UnitType.METER.convertTo(takeoffRunway.elevation, UnitType.FOOT) + this.landingElevationOffset);
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.updateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * A Boeing altitude preselector display box.
 */
class AltPreselectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.altAlerterRef = FSComponent.createRef();
        this.metricAltRef = FSComponent.createRef();
        this.selectedAltitudeHundredsSubject = ComputedSubject.create(null, (feetAlt) => {
            return feetAlt ? `${feetAlt % 1000}`.padEnd(3, '0') : '-----';
        });
        this.selectedAltitudeThousandsSubject = ComputedSubject.create(null, (feetAlt) => {
            return feetAlt ? `${Math.floor(feetAlt / 1000)}` : '';
        });
        this.metricAltSubject = ComputedSubject.create(null, (feetAlt) => {
            return feetAlt ? `${MathUtils.round(UnitType.FOOT.convertTo(feetAlt, UnitType.METER), 10)}` : '-----';
        });
        this.isPaused = true;
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.props.selectedAltitude.sub(this.updateSelectedAltitude.bind(this), true, this.isPaused), this.props.showMetric.sub(v => {
            this.metricAltRef.instance.classList.toggle('hidden', !v);
        }, true, this.isPaused), this.props.altitudeAlertState.sub(this.onAlerterStateChanged.bind(this), true, this.isPaused));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const sub of this.subs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const sub of this.subs) {
            sub.pause();
        }
    }
    /**
     * A method called when a selected altitude value changes from the event bus.
     * @param alt The selected altitude value.
     */
    updateSelectedAltitude(alt) {
        this.selectedAltitudeThousandsSubject.set(alt);
        this.selectedAltitudeHundredsSubject.set(alt);
        this.metricAltSubject.set(alt);
    }
    /**
     * A method called when the alt alerter state is changed.
     * @param state is the altitude alerter state
     */
    onAlerterStateChanged(state) {
        this.altAlerterRef.instance.classList.toggle('approaching-alert-border', state === AltAlertState.WITHIN_900);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "alt-preselect-container" },
            FSComponent.buildComponent("div", { class: "alt-preselect-box metric hidden", ref: this.metricAltRef },
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("span", { class: "alt-preselect-hundreds metric" },
                        this.metricAltSubject,
                        FSComponent.buildComponent("span", { class: "alt-preselect-unit" }, "M")))),
            FSComponent.buildComponent("div", { class: "black-box alt-preselect-box" },
                FSComponent.buildComponent("div", { class: "alt-preselect-value", ref: this.altAlerterRef },
                    FSComponent.buildComponent("span", { class: "alt-preselect-thousands" }, this.selectedAltitudeThousandsSubject),
                    FSComponent.buildComponent("span", { class: "alt-preselect-hundreds" }, this.selectedAltitudeHundredsSubject)))));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link BaroDataProvider} which sources data from one ADC at a time or from the ADC
 * chosen by an ADC selector.
 */
class DefaultBaroDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param perfPlan The active performance plan.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, perfPlan, index, useSelector = false) {
        this.bus = bus;
        this.perfPlan = perfPlan;
        this.useSelector = useSelector;
        this._baroInHg = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.baroInHg = this._baroInHg;
        this._isStd = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isStd = this._isStd;
        this._preselectInHg = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.preselectInHg = this._preselectInHg;
        this._isPreselectManual = Subject.create(false);
        /** @inheritdoc */
        this.isPreselectManual = this._isPreselectManual;
        /** @inheritdoc */
        this.isQfe = this.perfPlan.approachLandingRef.map(ref => ref === 0).pause();
        this._isBaroAlertActive = Subject.create(false);
        /** @inheritdoc */
        this.isBaroAlertActive = this._isBaroAlertActive;
        this.apEngaged = ConsumerSubject.create(null, false).pause();
        this.fd1Engaged = ConsumerSubject.create(null, false).pause();
        this.fd2Engaged = ConsumerSubject.create(null, false).pause();
        this._afdsBaroSource = MappedSubject.create(
        // We only model one altimeter and one flight director, so AFDS source is always left.
        ([apEngaged, fd1Engaged, fd2Engaged]) => apEngaged || fd1Engaged || fd2Engaged ? 'L' : '', this.apEngaged, this.fd1Engaged, this.fd2Engaged);
        /** @inheritdoc */
        this.afdsBaroSource = this._afdsBaroSource;
        this.indicatedAltitude = ConsumerValue.create(null, 0);
        this.manualPreselectArmedValue = undefined;
        this.isClimbingBaroAlertArmed = false;
        this.isDescendingBaroAlertArmed = false;
        this.isAdcAltitudeDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isDataFailed = this.isAdcAltitudeDataValid.map(SubscribableMapFunctions.not());
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.pauseable = [
            this._baroInHg,
            this._isStd,
            this._preselectInHg,
            this.isQfe,
            this.indicatedAltitude,
            this.isAdcAltitudeDataValid,
            this.apEngaged,
            this.fd1Engaged,
            this.fd2Engaged,
        ];
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultBaroDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_altitude_data_valid_${index}`));
            }
            this._baroInHg.setConsumer(sub.on(`adc_altimeter_baro_setting_inhg_${index}`));
            this._isStd.setConsumer(sub.on(`adc_altimeter_baro_is_std_${index}`));
            this._preselectInHg.setConsumer(sub.on(`adc_altimeter_baro_preselect_inhg_${index}`));
            this.indicatedAltitude.setConsumer(sub.on(`adc_indicated_alt_${index}`));
        }, true);
        this.apEngaged.setConsumer(sub.on('ap_master_status'));
        this.fd1Engaged.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.fd2Engaged.setConsumer(sub.on('ap_boeing_flight_director_is_active_2'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultBaroDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
        this.updateSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultBaroDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        this.updateSub.pause();
        this.isClimbingBaroAlertArmed = false;
        this.isDescendingBaroAlertArmed = false;
    }
    /**
     * Updates this data provider.
     */
    update() {
        this.updateManualPreselect();
        this.updateBaroAlert();
    }
    /**
     * Updates whether preselected baro setting has been manually changed.
     */
    updateManualPreselect() {
        if (this._isStd.get()) {
            if (this.manualPreselectArmedValue === undefined) {
                this.manualPreselectArmedValue = this._preselectInHg.get();
            }
            else {
                if (this._preselectInHg.get() !== this.manualPreselectArmedValue) {
                    this.manualPreselectArmedValue = undefined;
                    this._isPreselectManual.set(true);
                }
            }
        }
        else {
            this.manualPreselectArmedValue = undefined;
            this._isPreselectManual.set(false);
        }
    }
    /**
     * Updates the state of the baro alert.
     */
    updateBaroAlert() {
        if (this.isDataFailed.get()) {
            this._isBaroAlertActive.set(false);
            this.isClimbingBaroAlertArmed = false;
            this.isDescendingBaroAlertArmed = false;
            return;
        }
        let isAlertActive = false;
        const isStd = this._isStd.get();
        const indicatedAltitude = this.indicatedAltitude.get();
        const transitionAltitude = this.perfPlan.transitionAltitude.get();
        const transitionLevel = this.perfPlan.transitionLevel.get();
        if (this.isClimbingBaroAlertArmed) {
            if (!isStd && indicatedAltitude > transitionAltitude) {
                isAlertActive = true;
            }
            else if (isStd) {
                this.isClimbingBaroAlertArmed = false;
            }
        }
        else {
            this.isClimbingBaroAlertArmed = !isStd && indicatedAltitude <= transitionAltitude;
        }
        if (this.isDescendingBaroAlertArmed) {
            if (isStd && indicatedAltitude < transitionLevel) {
                isAlertActive = true;
            }
            else if (!isStd) {
                this.isDescendingBaroAlertArmed = false;
            }
        }
        else {
            this.isDescendingBaroAlertArmed = isStd && indicatedAltitude >= transitionLevel;
        }
        this._isBaroAlertActive.set(isAlertActive);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.updateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * An approach reference display.
 */
class ApproachReference extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.hidden = MappedSubject.create(([approachName, hudTakeoff]) => approachName === null && !hudTakeoff, this.props.dataProvider.approachName, this.props.dataProvider.hudTakeoffIsActive).pause();
        this.line1Hidden = this.props.dataProvider.approachIsVisual.map(isVisual => isVisual === true).pause();
        this.identText = MappedSubject.create(([isLoc, locIdent, locFreq, name]) => { var _a; return isLoc ? ((_a = locIdent !== null && locIdent !== void 0 ? locIdent : locFreq === null || locFreq === void 0 ? void 0 : locFreq.toFixed(2)) !== null && _a !== void 0 ? _a : '') : (name !== null && name !== void 0 ? name : ''); }, this.props.dataProvider.approachIsLoc, this.props.dataProvider.locIdent, this.props.dataProvider.locFrequency, this.props.dataProvider.approachName).pause();
        this.courseText = this.props.dataProvider.approachCourse.map(course => {
            if (course === null) {
                return '';
            }
            const rounded = Math.round(course);
            return rounded === 0 ? 360 : rounded.toString().padStart(3, '0');
        }).pause();
        this.frequencyDisagree = this.props.dataProvider.tunedLocFrequencyDisagree.map(disagree => disagree === true).pause();
        this.courseDisagree = this.props.dataProvider.selectedLocCourseDisagree.map(disagree => disagree === true).pause();
        this.locDmeRounded = this.props.dataProvider.locDme.map(dme => dme === null ? null : MathUtils.round(dme, 0.1)).pause();
        this.mapDistanceRounded = this.props.dataProvider.approachMapDistance.map(dme => dme === null ? null : MathUtils.round(dme, 0.1)).pause();
        this.distanceText = MappedSubject.create(([isLoc, locDme, mapIdent, mapDistance]) => {
            let prefix;
            let distance;
            if (isLoc) {
                prefix = 'DME';
                distance = locDme;
            }
            else {
                prefix = mapIdent !== null && mapIdent !== void 0 ? mapIdent : '';
                distance = mapDistance;
            }
            if (distance === null) {
                return `${prefix} ---`;
            }
            else {
                return `${prefix} ${distance >= 100 ? distance.toFixed(0) : distance.toFixed(1)}`;
            }
        }, this.props.dataProvider.approachIsLoc, this.locDmeRounded, this.props.dataProvider.approachMapIdent, this.mapDistanceRounded).pause();
        this.pauseable = [
            this.hidden,
            this.line1Hidden,
            this.identText,
            this.courseText,
            this.frequencyDisagree,
            this.courseDisagree,
            this.distanceText
        ];
        this.isPaused = true;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.approachIsLocSub = this.props.dataProvider.approachIsLoc.sub(this.onApproachIsLocChanged.bind(this), true, this.isPaused);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        var _a;
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
        (_a = this.approachIsLocSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        var _a;
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        (_a = this.approachIsLocSub) === null || _a === void 0 ? void 0 : _a.pause();
        this.locDmeRounded.pause();
        this.mapDistanceRounded.pause();
    }
    /**
     * Responds to when whether the selected approach is a localizer-based approach changes.
     * @param isLoc Whether the selected approach is a localizer-based approach, or `null` if approach data is
     * unavailable.
     */
    onApproachIsLocChanged(isLoc) {
        if (isLoc === null) {
            this.locDmeRounded.pause();
            this.mapDistanceRounded.pause();
        }
        else if (isLoc) {
            this.mapDistanceRounded.pause();
            this.locDmeRounded.resume();
        }
        else {
            this.locDmeRounded.pause();
            this.mapDistanceRounded.resume();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'approach-reference': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent("div", { class: {
                    'approach-reference-line': true,
                    'approach-reference-line-1': true,
                    'hidden': this.line1Hidden
                } },
                FSComponent.buildComponent("span", { class: { 'approach-reference-ident': true, 'approach-reference-disagree': this.frequencyDisagree } }, this.identText),
                "/",
                FSComponent.buildComponent("span", { class: { 'approach-reference-course': true, 'approach-reference-disagree': this.courseDisagree } },
                    this.courseText,
                    "\u00B0")),
            FSComponent.buildComponent("div", { class: "approach-reference-line approach-reference-line-2" }, this.distanceText)));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link ApproachReferenceDataProvider}.
 */
class DefaultApproachReferenceDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     */
    constructor(bus, ilsNavIndicator) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.hudTakeoffRunway = ConsumerSubject.create(null, null).pause();
        this.onGround = ConsumerSubject.create(null, true);
        this.flightDirector1 = ConsumerSubject.create(null, false);
        this.flightDirector2 = ConsumerSubject.create(null, false);
        this.isFlightDirectorOn = MappedSubject.create(SubscribableMapFunctions.or(), this.flightDirector1, this.flightDirector2);
        this.approachDetails = ConsumerSubject.create(null, undefined).pause();
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        this.approachTuningMode = ConsumerSubject.create(null, ApproachTuningMode.Park).pause();
        this.distanceToDest = ConsumerSubject.create(null, 0).pause();
        this.todLegIndex = ConsumerSubject.create(null, -1).pause();
        this.distanceToTod = ConsumerSubject.create(null, 0).pause();
        this.isCloseToDest = this.distanceToDest.map(distance => distance < 150); // < 150 NM
        this.isCloseToTod = MappedSubject.create(([legIndex, distance]) => legIndex >= 0 && distance < 92600, // < 50 NM
        this.todLegIndex, this.distanceToTod);
        this.isTakeoffDataAvailable = MappedSubject.create(([hudTakeoffRunway, onGround, fmsOperatingPhase]) => hudTakeoffRunway !== null && onGround && fmsOperatingPhase <= FmsOperatingPhase.TAKEOFF, this.hudTakeoffRunway, this.onGround, this.fmsOperatingPhase);
        /** Approach reference data shows within 150 of dest, within 50 of ToD, during descent, or when manually tuned for a precision app */
        this.isApproachDataAvailable = MappedSubject.create(([approachDetails, approachTuningMode, closeToDest, closeToToD, fmsOperatingPhase]) => {
            if (approachDetails === undefined) {
                return false;
            }
            if (approachDetails.approachName === '') {
                return false;
            }
            const apprIsLoc = BoeingFmsUtils.isLocalizerApproach(approachDetails.approachType);
            if (((!apprIsLoc || (apprIsLoc && approachTuningMode === ApproachTuningMode.Autotuned)) && (closeToDest || closeToToD))
                || fmsOperatingPhase === FmsOperatingPhase.DESCENT || fmsOperatingPhase === FmsOperatingPhase.APPROACH) {
                return true;
            }
            return apprIsLoc && approachTuningMode === ApproachTuningMode.ManuallyTuned;
        }, this.approachDetails, this.approachTuningMode, this.isCloseToDest, this.isCloseToTod, this.fmsOperatingPhase);
        this.isVisApproach = this.approachDetails.map(details => details && details.approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL);
        this.isLocApproach = this.approachDetails.map(details => details && BoeingFmsUtils.isLocalizerApproach(details.approachType));
        /** @inheritdoc */
        this.approachName = MappedSubject.create(([approachDetails, isAvail]) => !isAvail || !approachDetails || approachDetails.approachName === '' ? null : approachDetails.approachName, this.approachDetails, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.approachCourse = MappedSubject.create(([takeoffRunway, isTakeoffAvail, approachDetails, isApproachAvail]) => {
            if (isTakeoffAvail && takeoffRunway && takeoffRunway.ilsFrequency) {
                return takeoffRunway.ilsFrequency.localizerCourse;
            }
            else if (isApproachAvail && approachDetails && approachDetails.finalApproachCourse >= 0) {
                return approachDetails.finalApproachCourse;
            }
            return null;
        }, this.hudTakeoffRunway, this.isTakeoffDataAvailable, this.approachDetails, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.approachMapIdent = MappedSubject.create(([approachDetails, isAvail]) => !isAvail || !approachDetails || approachDetails.missedApproachFacility === null
            ? null
            : ICAO.getIdent(approachDetails.missedApproachFacility.icao), this.approachDetails, this.isApproachDataAvailable);
        this.distanceToMap = ConsumerSubject.create(null, Number.MAX_SAFE_INTEGER);
        /** @inheritdoc */
        this.approachMapDistance = MappedSubject.create(([distanceToRunway, isAvail]) => !isAvail || distanceToRunway >= Number.MAX_SAFE_INTEGER ? null : distanceToRunway, this.distanceToMap, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.approachIsVisual = MappedSubject.create(([isVis, isAvail]) => !isAvail ? null : isVis, this.isVisApproach, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.hudTakeoffIsActive = MappedSubject.create(([onGround, hudTakeoffRunway, flightDirector, fmsPhase]) => onGround && hudTakeoffRunway !== null && flightDirector && fmsPhase <= FmsOperatingPhase.TAKEOFF, this.onGround, this.hudTakeoffRunway, this.isFlightDirectorOn, this.fmsOperatingPhase);
        /** @inheritdoc */
        this.approachIsLoc = MappedSubject.create(([isLoc, isApprAvail, isHudTo]) => isHudTo ? true : !isApprAvail ? null : isLoc, this.isLocApproach, this.isApproachDataAvailable, this.hudTakeoffIsActive);
        /** @inheritdoc */
        this.locIdent = MappedSubject.create(([takeoffRunway, isTakeoffAvail, approachDetails, isApproachAvail]) => {
            if (isTakeoffAvail && takeoffRunway && takeoffRunway.ilsFrequency) {
                return ICAO.getIdent(takeoffRunway.ilsFrequency.icao);
            }
            else if (isApproachAvail && approachDetails && approachDetails.referenceFacility && approachDetails.referenceFacility.type === VorType.ILS) {
                return ICAO.getIdent(approachDetails.referenceFacility.icao);
            }
            return null;
        }, this.hudTakeoffRunway, this.isTakeoffDataAvailable, this.approachDetails, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.locFrequency = MappedSubject.create(([takeoffRunway, isTakeoffAvail, approachDetails, isApproachAvail]) => {
            if (isTakeoffAvail && takeoffRunway && takeoffRunway.ilsFrequency) {
                return takeoffRunway.ilsFrequency.freqMHz;
            }
            else if (isApproachAvail && approachDetails && approachDetails.referenceFacility && approachDetails.referenceFacility.type === VorType.ILS) {
                return approachDetails.referenceFacility.freqMHz;
            }
            return null;
        }, this.hudTakeoffRunway, this.isTakeoffDataAvailable, this.approachDetails, this.isApproachDataAvailable);
        this.isLocDmeValid = MappedSubject.create(([isTakeoffAvail, isApproachAvail, isLocApproach, hasDme, signal]) => (isTakeoffAvail || (isApproachAvail && isLocApproach)) && hasDme && signal !== null && signal > 0, this.isTakeoffDataAvailable, this.isApproachDataAvailable, this.isLocApproach, this.ilsNavIndicator.hasDme, this.ilsNavIndicator.signalStrength).pause();
        this._locDme = Subject.create(null);
        /** @inheritdoc */
        this.locDme = this._locDme;
        this.tunedLocFrequencyDisagreeSource = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.tunedLocFrequencyDisagree = MappedSubject.create(([isAvail, isLocApproach, disagree]) => !isAvail || !isLocApproach ? null : disagree, this.isApproachDataAvailable, this.isLocApproach, this.tunedLocFrequencyDisagreeSource);
        this.selectedLocCourseDisagreeSource = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.selectedLocCourseDisagree = MappedSubject.create(([isAvail, isLocApproach, disagree]) => !isAvail || !isLocApproach ? null : disagree, this.isApproachDataAvailable, this.isLocApproach, this.selectedLocCourseDisagreeSource);
        this.pauseable = [
            this.hudTakeoffRunway,
            this.onGround,
            this.flightDirector1,
            this.flightDirector2,
            this.approachDetails,
            this.fmsOperatingPhase,
            this.approachTuningMode,
            this.distanceToDest,
            this.todLegIndex,
            this.distanceToTod,
            this.distanceToMap,
            this.isLocDmeValid,
            this.tunedLocFrequencyDisagreeSource,
            this.selectedLocCourseDisagreeSource
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultApproachReferenceDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.hudTakeoffRunway.setConsumer(sub.on('boeing_hud_takeoff_runway_set'));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.flightDirector1.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.flightDirector2.setConsumer(sub.on('ap_boeing_flight_director_is_active_2'));
        this.approachDetails.setConsumer(sub.on('active_approach_details_set'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this.approachTuningMode.setConsumer(sub.on('approach_tuning_mode'));
        this.distanceToDest.setConsumer(sub.on('lnavdata_destination_distance_direct'));
        this.todLegIndex.setConsumer(sub.on('boeingvnav_performance_tod_global_leg_index'));
        this.distanceToTod.setConsumer(sub.on('boeingvnav_performance_tod_distance'));
        this.distanceToMap.setConsumer(sub.on('lnavdata_distance_to_map_direct'));
        this.tunedLocFrequencyDisagreeSource.setConsumer(sub.on('approach_frequency_mismatch'));
        this.selectedLocCourseDisagreeSource.setConsumer(sub.on('approach_course_mismatch'));
        this.locDmePipe = this.ilsNavIndicator.distance.pipe(this._locDme, true);
        this.isLocDmeValidSub = this.isLocDmeValid.sub(isValid => {
            if (isValid) {
                this.locDmePipe.resume(true);
            }
            else {
                this.locDmePipe.pause();
                this._locDme.set(null);
            }
        }, false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultApproachReferenceDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
        this.isLocDmeValidSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultApproachReferenceDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        this.isLocDmeValidSub.pause();
        this.locDmePipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * A Boeing deviation indicator.
 */
class DeviationIndicator extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.npDeviationScaled = MappedSubject.create(([deviation, rnp]) => deviation === null ? null : deviation / rnp, this.props.npDeviation, this.props.rnp).pause();
        this.isNpDeviationNotFullScale = this.npDeviationScaled.map(deviation => deviation !== null && Math.abs(deviation) < 1.1);
        /** Maneuvering space available to stay within 95% RNP requirement (considering estimated ANP) */
        this.maneuverSpace = MappedSubject.create(([rnp, anp]) => anp < 0 ? 0 : MathUtils.clamp(rnp - anp, 0, rnp), this.props.rnp, this.props.anp).pause();
        this.maneuverSpaceScaled = MappedSubject.create(([rnp, anp]) => {
            if (anp < 0 || rnp <= 0) {
                return 0;
            }
            return MathUtils.clamp(rnp - anp, 0, rnp) / rnp;
        }, this.props.rnp, this.props.anp).pause();
        this.isNpAlertActive = MappedSubject.create(SubscribableMapFunctions.and(), this.props.isNpDeviationAlertActive, this.props.npDeviationVisible);
        this.npDeviationHidden = this.props.npDeviationVisible.map(SubscribableMapFunctions.not()).pause();
        this.npScaleHidden = MappedSubject.create(SubscribableMapFunctions.nor(), this.props.npScaleVisible, this.props.ianScaleVisible).pause();
        this.npDeviationPointerHidden = MappedSubject.create(SubscribableMapFunctions.or(), this.npDeviationHidden, this.npScaleHidden);
        this.isNpDeviationScaleFlashActive = Subject.create(false);
        this.npDeviationScaleFlashTimer = new DebounceTimer();
        this.isNpDeviationPointerFlashActive = Subject.create(false);
        this.npDeviationPointerFlashTimer = new DebounceTimer();
        this.ianDeviationScaled = MappedSubject.create(([deviation, rnp]) => deviation === null ? null : deviation / rnp, this.props.ianDeviation, this.props.rnp).pause();
        /** IAN FAC/GP indicator is white when non-precision deviation is shown */
        this.isIanDeviationPointerSubdued = this.props.npDeviationVisible.map(SubscribableMapFunctions.identity()).pause();
        this.isIanDeviationNotFullScale = MappedSubject.create(([deviation, subdued]) => deviation !== null && Math.abs(deviation) < 1.1 && !subdued, this.ianDeviationScaled, this.isIanDeviationPointerSubdued);
        this.isIanAlertActive = MappedSubject.create(SubscribableMapFunctions.and(), this.props.isIanDeviationAlertActive, this.props.ianDeviationVisible);
        this.ianDeviationHidden = this.props.ianDeviationVisible.map(SubscribableMapFunctions.not()).pause();
        this.ianScaleHidden = this.props.ianScaleVisible.map(SubscribableMapFunctions.not()).pause();
        this.ianDeviationPointerHidden = MappedSubject.create(SubscribableMapFunctions.or(), this.ianDeviationHidden, this.ianScaleHidden);
        this.isIanDeviationPointerFlashActive = Subject.create(false);
        this.ianDeviationPointerFlashTimer = new DebounceTimer();
        // NP scale is shared by NP and IAN pointers
        this.isNpScaleAlertActive = MappedSubject.create(([isUnableRnpAlertActive, npScaleVisible, isNpDeviationAlertActive, isIanDeviationAlertActive]) => npScaleVisible && (isUnableRnpAlertActive || isNpDeviationAlertActive || isIanDeviationAlertActive), this.props.isUnableRnpAlertActive, this.props.npScaleVisible, this.isNpAlertActive, this.isIanAlertActive);
        this.anpBarsHidden = MappedSubject.create(SubscribableMapFunctions.nor(), this.props.npDeviationVisible, this.props.ianDeviationVisible);
        this.isLsDeviationValid = this.props.lsDeviation.map(deviation => deviation !== null).pause();
        this.lsDeviationScaled = MappedSubject.create(([deviation, reducedScale]) => deviation === null ? null : reducedScale ? deviation * 1.5 : deviation * 0.5, this.props.lsDeviation, (_a = this.props.expandedLsScale) !== null && _a !== void 0 ? _a : Subject.create(false)).pause();
        this.isLsDeviationAlertActive = this.props.isLsDeviationAlertActive.map(SubscribableMapFunctions.identity());
        this.isLsDeviationFlashActive = Subject.create(false);
        this.lsDeviationFlashTimer = new DebounceTimer();
        /** Landing System scale is shown when LS signal is valid and NPS not shown */
        this.lsScaleHidden = MappedSubject.create(([lsRequested, npsShown]) => !lsRequested || npsShown, this.props.lsScaleVisible, this.props.npScaleVisible).pause();
        /** Landing System indicator is filled when with 2.5 dots (0.3875 ddm for loc, 0.4375 ddm for gs), and active source */
        this.isLsDeviationPointerFilled = MappedSubject.create(([lsDeviation, npScaleVisible, alert]) => lsDeviation !== null && Math.abs(lsDeviation) < 2.5 && !npScaleVisible && !alert, this.props.lsDeviation, this.props.npScaleVisible, this.props.isLsDeviationAlertActive).pause();
        /** Landing System indicator is white when non-precision scale is shown */
        this.isLsDeviationPointerSubdued = this.props.npScaleVisible.map(SubscribableMapFunctions.identity()).pause();
        this.anpBarLeftTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.anpBarRightTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.npDeviationPointerTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.ianDeviationPointerTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.lsDeviationPointerTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.isAlive = true;
        this.isAwake = false;
        this.isRendered = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isRendered = true;
        this.maneuverSpaceScaled.sub(this.updateAnpBars.bind(this), true);
        this.npDeviationScaled.sub(this.updateNpDeviationPointer.bind(this), true);
        // shared by NP and IAN
        const deactivateNpDeviationScaleFlash = this.isNpDeviationScaleFlashActive.set.bind(this.isNpDeviationScaleFlashActive, false);
        this.isNpScaleAlertActive.sub(alert => {
            if (alert) {
                this.isNpDeviationScaleFlashActive.set(true);
                this.npDeviationScaleFlashTimer.schedule(deactivateNpDeviationScaleFlash, DeviationIndicator.NP_SCALE_FLASH_DURATION);
            }
            else {
                this.npDeviationScaleFlashTimer.clear();
                deactivateNpDeviationScaleFlash();
            }
        }, true);
        const deactivateNpDeviationPointerFlash = this.isNpDeviationPointerFlashActive.set.bind(this.isNpDeviationPointerFlashActive, false);
        this.isNpAlertActive.sub(alert => {
            if (alert) {
                this.isNpDeviationPointerFlashActive.set(true);
                this.npDeviationPointerFlashTimer.schedule(deactivateNpDeviationPointerFlash, DeviationIndicator.NP_POINTER_FLASH_DURATION);
            }
            else {
                this.npDeviationPointerFlashTimer.clear();
                deactivateNpDeviationPointerFlash();
            }
        }, true);
        this.ianDeviationScaled.sub(this.updateIanDeviationPointer.bind(this), true);
        const deactivateIanDeviationPointerFlash = this.isIanDeviationPointerFlashActive.set.bind(this.isIanDeviationPointerFlashActive, false);
        this.isIanAlertActive.sub(alert => {
            if (alert) {
                this.isIanDeviationPointerFlashActive.set(true);
                this.ianDeviationPointerFlashTimer.schedule(deactivateIanDeviationPointerFlash, DeviationIndicator.IAN_POINTER_FLASH_DURATION);
            }
            else {
                this.ianDeviationPointerFlashTimer.clear();
                deactivateIanDeviationPointerFlash();
            }
        }, true);
        this.lsDeviationScaled.sub(this.updateLsDeviationPointer.bind(this), true);
        const deactivateLsDeviationFlash = this.isLsDeviationFlashActive.set.bind(this.isLsDeviationFlashActive, false);
        this.isLsDeviationAlertActive.sub(alert => {
            if (alert) {
                this.isLsDeviationFlashActive.set(true);
                this.lsDeviationFlashTimer.schedule(deactivateLsDeviationFlash, DeviationIndicator.LS_POINTER_FLASH_DURATION);
            }
            else {
                this.lsDeviationFlashTimer.clear();
                deactivateLsDeviationFlash();
            }
        }, true);
        if (this.props.isLsPointerFlashing) {
            this.isLsPointerFlashingPipe = this.isLsDeviationFlashActive.pipe(this.props.isLsPointerFlashing);
        }
        if (this.isAwake) {
            this.wakeSubscriptions();
        }
    }
    /**
     * Resumes all of this indicator's subscriptions that need to be resumed and paused when the indicator is awake and
     * asleep, respectively.
     */
    wakeSubscriptions() {
        this.npDeviationScaled.resume();
        this.maneuverSpace.resume();
        this.maneuverSpaceScaled.resume();
        this.npDeviationHidden.resume();
        this.npScaleHidden.resume();
        this.ianDeviationScaled.resume();
        this.ianDeviationHidden.resume();
        this.ianScaleHidden.resume();
        this.isIanDeviationPointerSubdued.resume();
        this.isLsDeviationValid.resume();
        this.lsDeviationScaled.resume();
        this.lsScaleHidden.resume();
        this.isLsDeviationPointerFilled.resume();
        this.isLsDeviationPointerSubdued.resume();
    }
    /**
     * Wakes this indicator. While awake, this indicator will update its rendered elements.
     * @throws Error if this indicator has been destroyed.
     */
    wake() {
        if (!this.isAlive) {
            throw new Error('DeviationIndicator: cannot wake a dead indicator');
        }
        if (this.isAwake) {
            return;
        }
        this.isAwake = true;
        if (!this.isRendered) {
            return;
        }
        this.wakeSubscriptions();
    }
    /**
     * Puts this indicator to sleep. While asleep, this indicator will not update its rendered elements.
     * @throws Error if this indicator has been destroyed.
     */
    sleep() {
        if (!this.isAlive) {
            throw new Error('DeviationIndicator: cannot sleep a dead indicator');
        }
        if (!this.isAwake) {
            return;
        }
        this.isAwake = false;
        if (!this.isRendered) {
            return;
        }
        this.npDeviationScaled.pause();
        this.maneuverSpace.pause();
        this.maneuverSpaceScaled.pause();
        this.npDeviationHidden.pause();
        this.npScaleHidden.pause();
        this.ianDeviationScaled.pause();
        this.ianDeviationHidden.pause();
        this.ianScaleHidden.pause();
        this.isIanDeviationPointerSubdued.pause();
        this.isLsDeviationValid.pause();
        this.lsDeviationScaled.pause();
        this.lsScaleHidden.pause();
        this.isLsDeviationPointerFilled.pause();
        this.isLsDeviationPointerSubdued.pause();
    }
    /**
     * Updates the position of this indicator's NP deviation pointer.
     */
    updateNpDeviationPointer() {
        var _a;
        const deviation = -((_a = this.npDeviationScaled.get()) !== null && _a !== void 0 ? _a : 0);
        this.npDeviationPointerTransform.transform.set(MathUtils.clamp(deviation, -1.1, 1.1) * 40, 0, 0, 0.1);
        this.npDeviationPointerTransform.resolve();
    }
    /**
     * Updates the position of this indicator's IAN deviation pointer.
     */
    updateIanDeviationPointer() {
        var _a;
        const deviation = -((_a = this.ianDeviationScaled.get()) !== null && _a !== void 0 ? _a : 0);
        this.ianDeviationPointerTransform.transform.set(MathUtils.clamp(deviation, -1.1, 1.1) * 40, 0, 0, 0.1);
        this.ianDeviationPointerTransform.resolve();
    }
    /**
     * Updates the position of this indicator's landing system deviation pointer.
     */
    updateLsDeviationPointer() {
        var _a;
        const deviation = (_a = this.lsDeviationScaled.get()) !== null && _a !== void 0 ? _a : 0;
        const deviationLimit = this.props.lsDeviationLimit === undefined ? 1.25 : this.props.lsDeviationLimit;
        this.lsDeviationPointerTransform.transform.set(MathUtils.clamp(deviation, -deviationLimit, deviationLimit) * 40, 0, 0, 0.1);
        this.lsDeviationPointerTransform.resolve();
    }
    /**
     * Updates this indicator's ANP bars.
     * @param maneuverSpaceScaled The current NP maneuver space (RNP minus ANP) divided by RNP.
     */
    updateAnpBars(maneuverSpaceScaled) {
        const offset = maneuverSpaceScaled * 80 / 0.88;
        this.anpBarLeftTransform.transform.set(-offset, 0, 0, 0.1);
        this.anpBarLeftTransform.resolve();
        this.anpBarRightTransform.transform.set(offset, 0, 0, 0.1);
        this.anpBarRightTransform.resolve();
    }
    /** @inheritdoc */
    render() {
        var _a, _b, _c, _d;
        return (FSComponent.buildComponent("div", { class: "deviation-box" },
            FSComponent.buildComponent("div", { class: {
                    'deviation-background-fmc': true,
                    'translucent-box': true,
                    'hidden': this.npScaleHidden
                } }),
            FSComponent.buildComponent("div", { class: {
                    'deviation-background-ls': true,
                    'translucent-box': true,
                    'hidden': this.lsScaleHidden
                } }),
            FSComponent.buildComponent("div", { class: {
                    'deviation-scale-container': true,
                    'deviation-scale-container-np': true,
                    'hidden': this.npScaleHidden,
                    'alert': this.isNpAlertActive,
                    'flash': this.isNpDeviationScaleFlashActive
                } },
                FSComponent.buildComponent("svg", { class: "deviation-scale deviation-scale-np", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" },
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "68%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "68%" })),
                FSComponent.buildComponent("div", { class: { 'hidden': this.anpBarsHidden }, style: "position: absolute; left: 6%; top: 0px; width: 88%; height: 100%; overflow: hidden;" },
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar-end", style: "position: absolute; left: 0px;" }),
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar", style: {
                            'position': 'absolute',
                            'right': '50%',
                            'width': '50%',
                            'transform': this.anpBarLeftTransform
                        } }),
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar-end", style: "position: absolute; right: 0px;" }),
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar", style: {
                            'position': 'absolute',
                            'left': '50%',
                            'width': '50%',
                            'transform': this.anpBarRightTransform
                        } })),
                FSComponent.buildComponent("svg", { class: "deviation-scale deviation-scale-np", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" },
                    FSComponent.buildComponent("line", { x1: "10%", y1: "16%", x2: "10%", y2: "58%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "10%", y1: "16%", x2: "10%", y2: "58%" }),
                    FSComponent.buildComponent("line", { x1: "90%", y1: "16%", x2: "90%", y2: "58%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "90%", y1: "16%", x2: "90%", y2: "58%" }),
                    FSComponent.buildComponent("g", { class: "fac-gp-ticks", visibility: this.props.ianScaleVisible.map(vis => vis ? 'inherit' : 'hidden') },
                        FSComponent.buildComponent("line", { x1: "30%", y1: "16%", x2: "30%", y2: "58%", class: "shadow" }),
                        FSComponent.buildComponent("line", { x1: "30%", y1: "16%", x2: "30%", y2: "58%" }),
                        FSComponent.buildComponent("line", { x1: "70%", y1: "16%", x2: "70%", y2: "58%", class: "shadow" }),
                        FSComponent.buildComponent("line", { x1: "70%", y1: "16%", x2: "70%", y2: "58%" })))),
            FSComponent.buildComponent("div", { class: {
                    'translatable': true,
                    'hidden': this.npDeviationPointerHidden,
                    'alert': this.isNpAlertActive,
                    'flash': this.isNpDeviationPointerFlashActive
                }, style: {
                    'transform': this.npDeviationPointerTransform
                } },
                FSComponent.buildComponent("svg", { viewBox: "-12 0 24 32", class: {
                        'deviation-pointer': true,
                        'deviation-pointer-np': true
                    }, style: "overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", stroke: "var(--deviation-pointer-np-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isNpDeviationNotFullScale.map(filled => filled ? 'var(--deviation-pointer-np-color)' : 'none') }))),
            FSComponent.buildComponent("div", { class: {
                    'translatable': true,
                    'hidden': this.ianDeviationPointerHidden,
                    'alert': this.isIanAlertActive,
                    'flash': this.isIanDeviationPointerFlashActive
                }, style: {
                    'transform': this.ianDeviationPointerTransform
                } },
                FSComponent.buildComponent("svg", { viewBox: "-12 0 24 32", class: {
                        'deviation-pointer': true,
                        'deviation-pointer-ian': true,
                        'deviation-pointer-ian-subdued': this.isIanDeviationPointerSubdued
                    }, style: "overflow: visible;" },
                    FSComponent.buildComponent("g", { visibility: this.isIanDeviationPointerSubdued.map((v) => v ? 'inherit' : 'hidden') },
                        FSComponent.buildComponent("path", { d: "M 0 0 l 9 24 l -18 0 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 0 0 l 9 24 l -18 0 z", stroke: "var(--deviation-pointer-ian-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isIanDeviationNotFullScale.map(filled => filled ? 'var(--deviation-pointer-ian-color)' : 'none') })),
                    FSComponent.buildComponent("g", { visibility: this.isIanDeviationPointerSubdued.map((v) => v ? 'hidden' : 'inherit') },
                        FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", stroke: "var(--deviation-pointer-ian-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isIanDeviationNotFullScale.map(filled => filled ? 'var(--deviation-pointer-ian-color)' : 'none') })))),
            FSComponent.buildComponent("div", { class: {
                    'translatable': true,
                    'hidden': this.isLsDeviationValid.map(SubscribableMapFunctions.not()),
                    'alert': this.isLsDeviationAlertActive,
                    'flash': this.isLsDeviationFlashActive
                }, style: {
                    'transform': this.lsDeviationPointerTransform
                } },
                FSComponent.buildComponent("svg", { viewBox: "-17 -9 34 18", class: {
                        'deviation-pointer': true,
                        'deviation-pointer-ls': true,
                        'deviation-pointer-ls-subdued': this.isLsDeviationPointerSubdued
                    }, style: "overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 -9 l 17 9 l -17 9 l -17 -9 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 0 -9 l 17 9 l -17 9 l -17 -9 z", stroke: "var(--deviation-pointer-ls-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isLsDeviationPointerFilled.map(filled => filled ? 'var(--deviation-pointer-ls-color)' : 'none') }))),
            FSComponent.buildComponent("div", { class: {
                    'deviation-scale-container': true,
                    'deviation-scale-container-ls': true,
                    'hidden': this.lsScaleHidden,
                    'alert': this.isLsDeviationAlertActive
                } },
                FSComponent.buildComponent("svg", { class: "deviation-scale deviation-scale-ls", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" },
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "95%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "95%" }),
                    FSComponent.buildComponent("g", { visibility: (_b = (_a = this.props.expandedLsScale) === null || _a === void 0 ? void 0 : _a.map(reduced => reduced ? 'hidden' : 'inherit')) !== null && _b !== void 0 ? _b : 'inherit' },
                        [-2, -1, 1, 2].map(position => FSComponent.buildComponent("circle", { cx: `${(position * 20) + 50}%`, cy: "50%", r: "var(--deviation-scale-ls-dot-radius)", class: "deviation-scale-ls-dot shadow" })),
                        [-2, -1, 1, 2].map(position => FSComponent.buildComponent("circle", { cx: `${(position * 20) + 50}%`, cy: "50%", r: "var(--deviation-scale-ls-dot-radius)", class: "deviation-scale-ls-dot" }))),
                    FSComponent.buildComponent("g", { visibility: (_d = (_c = this.props.expandedLsScale) === null || _c === void 0 ? void 0 : _c.map(reduced => reduced ? 'inherit' : 'hidden')) !== null && _d !== void 0 ? _d : 'hidden' },
                        [-1.5, 1.5].map(position => FSComponent.buildComponent("rect", { x: `${(position * 20) + 50}%`, y: "50%", width: "var(--deviation-scale-ls-reduced-dot-width)", height: "var(--deviation-scale-ls-reduced-dot-height)", class: "deviation-scale-ls-reduced-dot shadow", style: "transform: translate(calc(-1 * var(--deviation-scale-ls-reduced-dot-width) / 2), calc(-1 * var(--deviation-scale-ls-reduced-dot-height) / 2))" })),
                        [-1.5, 1.5].map(position => FSComponent.buildComponent("rect", { x: `${(position * 20) + 50}%`, y: "50%", width: "var(--deviation-scale-ls-reduced-dot-width)", height: "var(--deviation-scale-ls-reduced-dot-height)", class: "deviation-scale-ls-reduced-dot", style: "transform: translate(calc(-1 * var(--deviation-scale-ls-reduced-dot-width) / 2), calc(-1 * var(--deviation-scale-ls-reduced-dot-height) / 2))" })))))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.isAlive = false;
        this.npDeviationScaleFlashTimer.clear();
        this.npDeviationPointerFlashTimer.clear();
        this.lsDeviationFlashTimer.clear();
        this.npDeviationScaled.destroy();
        this.maneuverSpace.destroy();
        this.maneuverSpaceScaled.destroy();
        this.npDeviationHidden.destroy();
        this.npScaleHidden.destroy();
        this.isNpAlertActive.destroy();
        this.isLsDeviationValid.destroy();
        this.lsDeviationScaled.destroy();
        this.isLsDeviationAlertActive.destroy();
        this.lsScaleHidden.destroy();
        this.isLsDeviationPointerFilled.destroy();
        this.isLsDeviationPointerSubdued.destroy();
        (_a = this.isLsPointerFlashingPipe) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}
DeviationIndicator.NP_SCALE_FLASH_DURATION = 3000; // milliseconds
DeviationIndicator.NP_POINTER_FLASH_DURATION = 10000; // milliseconds
DeviationIndicator.IAN_POINTER_FLASH_DURATION = 10000; // milliseconds
DeviationIndicator.LS_POINTER_FLASH_DURATION = 10000; // milliseconds

/**
 * A default implementation of {@link LateralDeviationDataProvider}.
 */
class DefaultLateralDeviationDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     * @param fmsPosIndex The index of the FMS position system that is the source of this provider's data.
     */
    constructor(bus, ilsNavIndicator, fmsPosIndex) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.lateralNavSource = ConsumerSubject.create(null, NavigationSource.NONE).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        this._rnp = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.rnp = this._rnp;
        this._anp = Subject.create(-1);
        /** @inheritdoc */
        this.anp = this._anp;
        /** @inheritdoc */
        this.isLateralNavSourceNp = this.lateralNavSource.map(source => source === NavigationSource.NPS);
        this._isApLateralTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.lateralActive === APLateralModes.TO || fmaData.lateralActive === APLateralModes.GA);
        });
        /** @inheritdoc */
        this.isApLateralTogaActive = this._isApLateralTogaActive;
        this._isApVerticalTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.verticalActive === APVerticalModes.TO || fmaData.verticalActive === APVerticalModes.GA);
        });
        /** @inheritdoc */
        this.isApVerticalTogaActive = this._isApVerticalTogaActive;
        this._npDeviation = Subject.create(null);
        /** @inheritdoc */
        this.npDeviation = this._npDeviation;
        this._isUnableRnp = Subject.create(false);
        /** @inheritdoc */
        this.isUnableRnp = this._isUnableRnp;
        this._isNpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isNpDeviationExcessive = this._isNpDeviationExcessive;
        this._locDeviation = Subject.create(null);
        /** @inheritdoc */
        this.locDeviation = this._locDeviation;
        this._isApLocActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.LOC);
        /** @inheritdoc */
        this.isApLocActive = this._isApLocActive;
        this._isApTakeoffLocActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.TO_LOC);
        /** @inheritdoc */
        this.isApTakeoffLocActive = this._isApTakeoffLocActive;
        this._isLocDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isLocDeviationExcessive = this._isLocDeviationExcessive;
        /** @inheritdoc */
        this.isLateralNavSourceFac = this.lateralNavSource.map(source => source === NavigationSource.IAN);
        this._facDeviation = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.facDeviation = this._facDeviation;
        this._isApFacActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.FMS_LOC);
        /** @inheritdoc */
        this.isApFacActive = this._isApFacActive;
        this._isFacDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isFacDeviationExcessive = this._isFacDeviationExcessive;
        this.anpSource = ConsumerSubject.create(null, 0).pause();
        this.anpPipe = this.anpSource.pipe(this._anp, true);
        this.lnavXtkAvailable = ConsumerSubject.create(null, false).pause();
        this.lnavXtk = ConsumerSubject.create(null, 0).pause();
        this.xtkPipe = this.lnavXtk.pipe(this._npDeviation, true);
        this.facAvailable = ConsumerSubject.create(null, false).pause();
        this.locDeviationPipe = this.ilsNavIndicator.lateralDeviation.pipe(this._locDeviation, dev => dev === null ? 0 : dev * 2.5, true);
        this.apMaster = ConsumerSubject.create(null, false).pause();
        this.fdActive = ConsumerSubject.create(null, false).pause();
        this.radioAltitude = ConsumerSubject.create(null, 0).pause();
        this.fmsPosSystemState = ConsumerSubject.create(null, undefined).pause();
        this.isFmsPosDataValid = this.fmsPosSystemState.map(state => {
            return state !== undefined && (state.current === undefined || state.current === AvionicsSystemState.On);
        });
        this.hasNpDeviation = MappedSubject.create(([isDataValid, lateralNavSource, xtkAvailable]) => isDataValid && xtkAvailable && lateralNavSource === NavigationSource.NPS, this.isFmsPosDataValid, this.lateralNavSource, this.lnavXtkAvailable);
        this.isUnableRnpSource = MappedSubject.create(([rnp, anp]) => anp >= 0 && anp >= rnp, this._rnp, this._anp);
        this.isUnableRnpTimer = new DebounceTimer();
        this.isNpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._npDeviation, this.isLateralNavSourceNp);
        this.isNpDeviationExcessiveTimer = new DebounceTimer();
        this.isFacDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._facDeviation, this.isLateralNavSourceFac);
        this.isFacDeviationExcessiveTimer = new DebounceTimer();
        this.hasLocDeviation = MappedSubject.create(([signal, isLoc, facAvailable]) => !!isLoc && signal !== null && signal > 0 && !facAvailable, this.ilsNavIndicator.signalStrength, this.ilsNavIndicator.hasLocalizer, this.facAvailable).pause();
        this.excessiveLocDeviationMode = MappedSubject.create(([apMaster, fdActive, isApTakeoffLocActive, radioAltitude]) => {
            if (isApTakeoffLocActive) {
                return 'takeoff';
            }
            else if ((apMaster || fdActive) && radioAltitude < 500) {
                return 'loc';
            }
            else {
                return 'none';
            }
        }, this.apMaster, this.fdActive, this._isApTakeoffLocActive, this.radioAltitude);
        this.fdTakeoffDeviation = ConsumerSubject.create(null, null).pause();
        this.excessiveLocDeviationPipe = this._locDeviation.pipe(this._isLocDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 1, true);
        this.excessiveTakeoffDeviationPipe = this.fdTakeoffDeviation.pipe(this._isLocDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 23, true);
        this.pauseableSubjects = [
            this._rnp,
            this.anpSource,
            this.lnavXtkAvailable,
            this.lnavXtk,
            this.facAvailable,
            this._facDeviation,
            this.lateralNavSource,
            this.fmaData,
            this.apMaster,
            this.fdActive,
            this.radioAltitude,
            this.fmsPosSystemState,
            this.hasLocDeviation,
            this.fdTakeoffDeviation
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultLateralDeviationDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._rnp.setConsumer(sub.on('lnavdata_rnp'));
        this.lnavXtk.setConsumer(sub.on('lnav_xtk'));
        this.lnavXtkAvailable.setConsumer(sub.on('lnav_is_tracking'));
        this.lateralNavSource.setConsumer(sub.on('lateral_nav_source'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.apMaster.setConsumer(sub.on('ap_master_status'));
        this.fdActive.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            this.fmsPosSystemState.setConsumer(sub.on(`fms_pos_state_${index}`));
            this.anpSource.setConsumer(sub.on(`fms_pos_anp_${index}`));
        }, true);
        this.fmsPosDataValidSub = this.isFmsPosDataValid.sub(this.onFmsPosDataValidChanged.bind(this), false, true);
        this.hasNpDeviationSub = this.hasNpDeviation.sub(this.onHasNpDeviationChanged.bind(this), false, true);
        this.facAvailable.setConsumer(sub.on('boeing_ian_fac_available'));
        this._facDeviation.setConsumer(sub.on('boeing_ian_fac_deviation'));
        this.fdTakeoffDeviation.setConsumer(sub.on('fd_takeoff_deviation'));
        const activateUnableRnp = this._isUnableRnp.set.bind(this._isUnableRnp, true);
        this.isUnableRnpSub = this.isUnableRnpSource.sub(isUnableRnp => {
            if (isUnableRnp) {
                this.isUnableRnpTimer.schedule(activateUnableRnp, DefaultLateralDeviationDataProvider.UNABLE_RNP_DELAY);
            }
            else {
                this.isUnableRnpTimer.clear();
                this._isUnableRnp.set(false);
            }
        }, false, true);
        const activateExcessiveNpDeviation = this._isNpDeviationExcessive.set.bind(this._isNpDeviationExcessive, true);
        this.isNpDeviationExcessiveSub = this.isNpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isNpDeviationExcessiveTimer.schedule(activateExcessiveNpDeviation, DefaultLateralDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY);
            }
            else {
                this.isNpDeviationExcessiveTimer.clear();
                this._isNpDeviationExcessive.set(false);
            }
        }, false, true);
        const activateExcessiveFacDeviation = this._isFacDeviationExcessive.set.bind(this._isFacDeviationExcessive, true);
        this.isFacDeviationExcessiveSub = this.isFacDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isFacDeviationExcessiveTimer.schedule(activateExcessiveFacDeviation, DefaultLateralDeviationDataProvider.EXCESSIVE_FAC_DEVIATION_DELAY);
            }
            else {
                this.isFacDeviationExcessiveTimer.clear();
                this._isFacDeviationExcessive.set(false);
            }
        }, false, true);
        this.hasLocDeviationSub = this.hasLocDeviation.sub(this.onHasLocDeviationChanged.bind(this), false, true);
        this.excessiveLocDeviationModeSub = this.excessiveLocDeviationMode.sub(this.onExcessiveLocDeviationModeChanged.bind(this), false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Responds to when FMS position data validity changes.
     * @param isDataValid Whether FMS position data is valid.
     */
    onFmsPosDataValidChanged(isDataValid) {
        if (isDataValid) {
            this.anpPipe.resume(true);
        }
        else {
            this.anpPipe.pause();
            this._anp.set(-1);
        }
    }
    /**
     * Responds to when NP deviation availability changes.
     * @param hasNpDeviation Whether NP deviation is available.
     */
    onHasNpDeviationChanged(hasNpDeviation) {
        if (hasNpDeviation) {
            this.xtkPipe.resume(true);
        }
        else {
            this.xtkPipe.pause();
            this._npDeviation.set(null);
        }
    }
    /**
     * Responds to when localizer deviation availability changes.
     * @param hasLocDeviation Whether localizer deviation is available.
     */
    onHasLocDeviationChanged(hasLocDeviation) {
        if (hasLocDeviation) {
            this.locDeviationPipe.resume(true);
        }
        else {
            this.locDeviationPipe.pause();
            this._locDeviation.set(null);
        }
    }
    /**
     * Responds to when the excessive localizer deviation evaluation mode changes.
     * @param mode The new excessive evaluation deviation mode.
     */
    onExcessiveLocDeviationModeChanged(mode) {
        this.excessiveTakeoffDeviationPipe.pause();
        this.excessiveLocDeviationPipe.pause();
        switch (mode) {
            case 'takeoff':
                this.excessiveTakeoffDeviationPipe.resume(true);
                break;
            case 'loc':
                this.excessiveLocDeviationPipe.resume(true);
                break;
            default:
                this._isLocDeviationExcessive.set(false);
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultLateralDeviationDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseableSubjects) {
            subject.resume();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.isNpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.isFacDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.hasLocDeviationSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.excessiveLocDeviationModeSub) === null || _g === void 0 ? void 0 : _g.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultLateralDeviationDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        for (const subject of this.pauseableSubjects) {
            subject.pause();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.isNpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.isFacDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.hasLocDeviationSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.excessiveLocDeviationModeSub) === null || _g === void 0 ? void 0 : _g.pause();
        this.locDeviationPipe.pause();
        this.excessiveLocDeviationPipe.pause();
        this.excessiveTakeoffDeviationPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        (_a = this.fmsPosIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseableSubjects) {
            subject.destroy();
        }
    }
}
DefaultLateralDeviationDataProvider.UNABLE_RNP_DELAY = 5000; // milliseconds
DefaultLateralDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY = 5000; // milliseconds
DefaultLateralDeviationDataProvider.EXCESSIVE_FAC_DEVIATION_DELAY = 5000; // milliseconds

/**
 * A Boeing navigation source display.
 */
class NavigationSourceDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.isFacDeviationValid = this.props.lateralDeviationDataProvider.facDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isLocDeviationValid = this.props.lateralDeviationDataProvider.locDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isGpDeviationValid = this.props.verticalDeviationDataProvider.gpDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isGsDeviationValid = this.props.verticalDeviationDataProvider.gsDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isApTogaActive = MappedSubject.create(SubscribableMapFunctions.or(), this.props.lateralDeviationDataProvider.isApLateralTogaActive, this.props.isVerticalTogaNp ? this.props.lateralDeviationDataProvider.isApVerticalTogaActive : Subject.create(false)).pause();
        this.text = MappedSubject.create(([isLateralNp, isFacDeviationValid, isLocDeviationValid, isVerticalNp, isGpDeviationValid, isGsDeviationValid, isApTogaActive]) => {
            // Sim doesn't have GLS, so we are not going to consider those cases.
            if (isVerticalNp || isGpDeviationValid || isApTogaActive) {
                // Vertical source is FMC.
                if (isLateralNp || isFacDeviationValid || isApTogaActive) {
                    // Lateral source is FMC.
                    return 'FMC';
                }
                else if (isLocDeviationValid) {
                    // Lateral source is ILS.
                    return 'ILS/FMC';
                }
                else {
                    return 'FMC';
                }
            }
            else if (isGsDeviationValid) {
                // If we have a valid glideslope deviation, then both the lateral and vertical source must be ILS.
                return 'ILS';
            }
            else {
                // Vertical source is none.
                if (isLateralNp || isFacDeviationValid || isApTogaActive) {
                    // Lateral source is FMC.
                    return 'FMC';
                }
                else if (isLocDeviationValid) {
                    // Lateral source is ILS.
                    return 'ILS';
                }
            }
            return '';
        }, this.props.lateralDeviationDataProvider.isLateralNavSourceNp, this.isFacDeviationValid, this.isLocDeviationValid, this.props.verticalDeviationDataProvider.isVerticalNavSourceNp, this.isGpDeviationValid, this.isGsDeviationValid, this.isApTogaActive).pause();
        this.isTextSmall = this.text.map(text => text.length > 3);
        this.isTextHidden = this.text.map(text => text.length === 0);
        this.isPaused = true;
        this.pauseable = [
            this.isFacDeviationValid,
            this.isLocDeviationValid,
            this.isGpDeviationValid,
            this.isGsDeviationValid,
            this.isApTogaActive,
            this.text
        ];
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'navigation-source': true,
                'navigation-source-small': this.isTextSmall,
                'hidden': this.isTextHidden
            } }, this.text));
    }
}
NavigationSourceDisplay.isDeviationValid = (deviation) => deviation !== null;

/**
 * A default implementation of {@link VerticalDeviationDataProvider}.
 */
class DefaultVerticalDeviationDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     * @param fmsPosIndex The index of the FMS position system that is the source of this provider's data.
     */
    constructor(bus, ilsNavIndicator, fmsPosIndex) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.verticalNavSource = ConsumerSubject.create(null, NavigationSource.NONE).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        this._fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        /** @inheritdoc */
        this.fmsOperatingPhase = this._fmsOperatingPhase;
        this._rnp = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.rnp = this._rnp;
        this._anp = Subject.create(-1);
        /** @inheritdoc */
        this.anp = this._anp;
        /** @inheritdoc */
        this.isVerticalNavSourceNp = this.verticalNavSource.map(source => source === NavigationSource.NPS);
        this._verticalPathAvailable = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isVerticalPathAvailable = this._verticalPathAvailable;
        this._isApLateralTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.lateralActive === APLateralModes.TO || fmaData.lateralActive === APLateralModes.GA);
        });
        /** @inheritdoc */
        this.isApLateralTogaActive = this._isApLateralTogaActive;
        this._isApVerticalTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.verticalActive === APVerticalModes.TO || fmaData.verticalActive === APVerticalModes.GA);
        });
        /** @inheritdoc */
        this.isApVerticalTogaActive = this._isApVerticalTogaActive;
        this._npDeviation = Subject.create(null);
        /** @inheritdoc */
        this.npDeviation = this._npDeviation;
        this._isUnableRnp = Subject.create(false);
        /** @inheritdoc */
        this.isUnableRnp = this._isUnableRnp;
        this._isNpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isNpDeviationExcessive = this._isNpDeviationExcessive;
        this._gsDeviation = Subject.create(null);
        /** @inheritdoc */
        this.gsDeviation = this._gsDeviation;
        this._isApGsActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.GS);
        /** @inheritdoc */
        this.isApGsActive = this._isApGsActive;
        this.isApTakeoffLocActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.TO_LOC);
        this._isGsDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isGsDeviationExcessive = this._isGsDeviationExcessive;
        /** @inheritdoc */
        this.isVerticalNavSourceGp = this.verticalNavSource.map(source => source === NavigationSource.IAN);
        this._gpDeviation = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.gpDeviation = this._gpDeviation;
        this._isApGpActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.GP);
        /** @inheritdoc */
        this.isApGpActive = this._isApGpActive;
        this._isGpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isGpDeviationExcessive = this._isGpDeviationExcessive;
        this.anpSource = ConsumerSubject.create(null, 0).pause();
        this.anpPipe = this.anpSource.pipe(this._anp, true);
        this._isApFlareActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.FLARE);
        /** @inheritdoc */
        this.isApFlareActive = this._isApFlareActive;
        this.vDev = ConsumerSubject.create(null, 0).pause();
        this.vDevPipe = this.vDev.pipe(this._npDeviation, error => -error, true);
        this.gpAvailable = ConsumerSubject.create(null, false).pause();
        this.gsDeviationPipe = this.ilsNavIndicator.verticalDeviation.pipe(this._gsDeviation, dev => dev === null ? 0 : -dev * 2.5, true);
        this.apMaster = ConsumerSubject.create(null, false).pause();
        this.fdActive = ConsumerSubject.create(null, false).pause();
        this.radioAltitude = ConsumerSubject.create(null, 0).pause();
        this.fmsPosSystemState = ConsumerSubject.create(null, undefined).pause();
        this.isFmsPosDataValid = this.fmsPosSystemState.map(state => {
            return state !== undefined && (state.current === undefined || state.current === AvionicsSystemState.On);
        });
        this.hasNpDeviation = MappedSubject.create(([verticalPathAvailable, verticalNavSource]) => verticalPathAvailable && verticalNavSource === NavigationSource.NPS, this._verticalPathAvailable, this.verticalNavSource);
        this.isUnableRnpSource = MappedSubject.create(([rnp, anp]) => anp >= 0 && anp >= rnp, this._rnp, this._anp);
        this.isUnableRnpTimer = new DebounceTimer();
        this.isNpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._npDeviation, this.isVerticalNavSourceNp);
        this.isNpDeviationExcessiveTimer = new DebounceTimer();
        this.isGpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._gpDeviation, this.isVerticalNavSourceGp);
        this.isGpDeviationExcessiveTimer = new DebounceTimer();
        this.hasGsDeviation = MappedSubject.create(([signal, isGs, gpAvailable, toLocActive]) => !!isGs && signal !== null && signal > 0 && !gpAvailable && !toLocActive, this.ilsNavIndicator.signalStrength, this.ilsNavIndicator.hasGlideSlope, this.gpAvailable, this.isApTakeoffLocActive);
        this.evalExcessiveGsDeviation = MappedSubject.create(([apMaster, fdActive, radioAltitude]) => (apMaster || fdActive) && radioAltitude < 500, this.apMaster, this.fdActive, this.radioAltitude);
        this.excessiveGsDeviationPipe = this._gsDeviation.pipe(this._isGsDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 1, true);
        this.pauseableSubjects = [
            this._fmsOperatingPhase,
            this._rnp,
            this.anpSource,
            this._verticalPathAvailable,
            this.vDev,
            this.verticalNavSource,
            this.fmaData,
            this.gpAvailable,
            this._gpDeviation,
            this.apMaster,
            this.fdActive,
            this.radioAltitude,
            this.fmsPosSystemState,
            this.hasGsDeviation
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this._rnp.setConsumer(sub.on('boeingvnav_rnp'));
        this.vDev.setConsumer(sub.on('vnav_vertical_deviation'));
        this.verticalNavSource.setConsumer(sub.on('vertical_nav_source'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.apMaster.setConsumer(sub.on('ap_master_status'));
        this.fdActive.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            this.fmsPosSystemState.setConsumer(sub.on(`fms_pos_state_${index}`));
            this.anpSource.setConsumer(sub.on(`fms_pos_vertical_anp_${index}`));
        }, true);
        this.fmsPosDataValidSub = this.isFmsPosDataValid.sub(this.onFmsPosDataValidChanged.bind(this), false, true);
        this.hasNpDeviationSub = this.hasNpDeviation.sub(this.onHasNpDeviationChanged.bind(this), false, true);
        this._verticalPathAvailable.setConsumer(sub.on('vnav_path_available'));
        this.gpAvailable.setConsumer(sub.on('boeing_ian_gp_available'));
        this._gpDeviation.setConsumer(sub.on('boeing_ian_gp_deviation'));
        const activateUnableRnp = this._isUnableRnp.set.bind(this._isUnableRnp, true);
        this.isUnableRnpSub = this.isUnableRnpSource.sub(isUnableRnp => {
            if (isUnableRnp) {
                this.isUnableRnpTimer.schedule(activateUnableRnp, DefaultVerticalDeviationDataProvider.UNABLE_RNP_DELAY);
            }
            else {
                this.isUnableRnpTimer.clear();
                this._isUnableRnp.set(false);
            }
        }, false, true);
        const activateExcessiveNpDeviation = this._isNpDeviationExcessive.set.bind(this._isNpDeviationExcessive, true);
        this.isNpDeviationExcessiveSub = this.isNpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isNpDeviationExcessiveTimer.schedule(activateExcessiveNpDeviation, DefaultVerticalDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY);
            }
            else {
                this.isNpDeviationExcessiveTimer.clear();
                this._isNpDeviationExcessive.set(false);
            }
        }, false, true);
        const activateExcessiveGpDeviation = this._isGpDeviationExcessive.set.bind(this._isGpDeviationExcessive, true);
        this.isGpDeviationExcessiveSub = this.isGpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isGpDeviationExcessiveTimer.schedule(activateExcessiveGpDeviation, DefaultVerticalDeviationDataProvider.EXCESSIVE_GP_DEVIATION_DELAY);
            }
            else {
                this.isGpDeviationExcessiveTimer.clear();
                this._isGpDeviationExcessive.set(false);
            }
        }, false, true);
        this.hasGsDeviationSub = this.hasGsDeviation.sub(this.onHasGsDeviationChanged.bind(this), false, true);
        this.evalExcessiveGsDeviationSub = this.evalExcessiveGsDeviation.sub(this.onEvalExcessiveGsDeviationChanged.bind(this), false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Responds to when FMS position data validity changes.
     * @param isDataValid Whether FMS position data is valid.
     */
    onFmsPosDataValidChanged(isDataValid) {
        if (isDataValid) {
            this.anpPipe.resume(true);
        }
        else {
            this.anpPipe.pause();
            this._anp.set(-1);
        }
    }
    /**
     * Responds to when NP deviation availability changes.
     * @param hasNpDeviation Whether NP deviation is available.
     */
    onHasNpDeviationChanged(hasNpDeviation) {
        if (hasNpDeviation) {
            this.vDevPipe.resume(true);
        }
        else {
            this.vDevPipe.pause();
            this._npDeviation.set(null);
        }
    }
    /**
     * Responds to when glideslope deviation availability changes.
     * @param hasGsDeviation Whether glideslope deviation is available.
     */
    onHasGsDeviationChanged(hasGsDeviation) {
        if (hasGsDeviation) {
            this.gsDeviationPipe.resume(true);
        }
        else {
            this.gsDeviationPipe.pause();
            this._gsDeviation.set(null);
        }
    }
    /**
     * Responds to when whether to evaluate excessive glideslope deviation changes.
     * @param evaluate Whether to evaluate excessive glideslope deviation.
     */
    onEvalExcessiveGsDeviationChanged(evaluate) {
        if (evaluate) {
            this.excessiveGsDeviationPipe.resume(true);
        }
        else {
            this.excessiveGsDeviationPipe.pause();
            this._isGsDeviationExcessive.set(false);
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseableSubjects) {
            subject.resume();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.isGpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.isNpDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.hasGsDeviationSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.evalExcessiveGsDeviationSub) === null || _g === void 0 ? void 0 : _g.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        for (const subject of this.pauseableSubjects) {
            subject.pause();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.isGpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.isNpDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.hasGsDeviationSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.evalExcessiveGsDeviationSub) === null || _g === void 0 ? void 0 : _g.pause();
        this.gsDeviationPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        (_a = this.fmsPosIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseableSubjects) {
            subject.destroy();
        }
    }
}
DefaultVerticalDeviationDataProvider.UNABLE_RNP_DELAY = 5000; // milliseconds
DefaultVerticalDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY = 5000; // milliseconds
DefaultVerticalDeviationDataProvider.EXCESSIVE_GP_DEVIATION_DELAY = 5000; // milliseconds

/**
 * An FMA mode display slot.
 */
class FmaModeSlot extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootCssClass = SetSubject.create(['fma-mode']);
        this.activeModeText = Subject.create('');
        this.alertTimer = new DebounceTimer();
        this.isActiveFailed = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isFailedSub = this.props.isFailed.sub(isFailed => {
            if (isFailed) {
                this.onFailed();
            }
            else if (this.isActiveFailed) {
                this.onRecovered();
            }
        }, true);
        this.activeModeSub = this.props.active.sub(active => {
            this.onActiveModeChanged(active);
        }, true);
    }
    /**
     * Responds to changes in this slot's active mode.
     * @param active The active mode.
     */
    onActiveModeChanged(active) {
        this.activeModeText.set(active);
        if (active.length > 0) {
            this.addBox();
        }
        else {
            this.removeBox();
        }
    }
    /**
     * Responds to when this slot's mode enters a failed state.
     */
    onFailed() {
        this.isActiveFailed = true;
        this.rootCssClass.add('fma-mode-failed');
    }
    /**
     * Responds to when this slot's mode exits a failed state.
     */
    onRecovered() {
        this.isActiveFailed = false;
        this.rootCssClass.delete('fma-mode-failed');
        if (this.activeModeText.get().length > 0) {
            this.addBox();
        }
    }
    /**
     * Adds the FMA alert box style.
     */
    addBox() {
        // schedule clears pending timers
        this.alertTimer.schedule(() => {
            this.rootCssClass.delete('fma-mode-alert');
        }, FmaModeSlot.ALERT_DURATION);
        this.rootCssClass.add('fma-mode-alert');
    }
    /**
     * Removes the FMA alert box style.
     */
    removeBox() {
        this.rootCssClass.delete('fma-mode-alert');
        this.alertTimer.clear();
    }
    /** @inheritdoc */
    render() {
        if (this.props.class !== undefined) {
            const reservedClasses = ['fma-mode', 'fma-mode-alert', 'fma-mode-failed'];
            if (typeof this.props.class === 'string') {
                FSComponent.parseCssClassesFromString(this.props.class)
                    .filter(cssClass => !reservedClasses.includes(cssClass))
                    .forEach(cssClass => { this.rootCssClass.add(cssClass); });
            }
            else {
                this.cssClassSub = FSComponent.bindCssClassSet(this.rootCssClass, this.props.class, reservedClasses);
            }
        }
        return (FSComponent.buildComponent("div", { class: this.rootCssClass }, this.activeModeText));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.cssClassSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.activeModeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.isFailedSub) === null || _c === void 0 ? void 0 : _c.destroy();
        super.destroy();
    }
}
FmaModeSlot.ALERT_DURATION = 10000; // milliseconds

/**
 * Computes a smoothed flight path to be used for a flight path vector.
 */
class FlightPathVectorComputer {
    /**
     * Creates a new instance of FlightPathVectorComputer.
     * @param trackSmoothingTau The smoothing time constant for ground track, in milliseconds.
     * @param gsSmoothingTau The smoothing time constant for ground speed, in milliseconds.
     * @param vsSmoothingTau The smoothing time constant for vertical speed, in milliseconds.
     * @param accelSmoothingTau The smoothing time constant for acceleration, in milliseconds.
     */
    constructor(trackSmoothingTau, gsSmoothingTau, vsSmoothingTau, accelSmoothingTau) {
        this._track = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._gs = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._vs = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._pitch = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._speed = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._acceleration = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        /**
         * The computed flight path true ground track, in degrees. Has a value of `NaN` if this computer has not been updated
         * since it was created or reset.
         */
        this.fpTrack = this._track;
        /**
         * The computed flight path ground speed, in knots. Has a value of `NaN` if this computer has not been updated since
         * it was created or reset.
         */
        this.fpGs = this._gs;
        /**
         * The computed flight path vertical speed, in feet per minute. Has a value of `NaN` if this computer has not been
         * updated since it was created or reset.
         */
        this.fpVs = this._vs;
        /**
         * The computed flight path pitch angle, in degrees. Positive values represent ascending flight paths. Has a value of
         * `NaN` if this computer has not been updated since it was created or reset.
         */
        this.fpPitch = this._pitch;
        /**
         * The computed flight path speed, in knots. Has a value of `NaN` if this computer has not been updated since it was
         * created or reset.
         */
        this.fpSpeed = this._speed;
        /**
         * The computed flight path acceleration, in knots per second. Has a value of `NaN` if this computer has not been
         * updated since it was created or reset.
         */
        this.fpAcceleration = this._acceleration;
        this.trackSmoother = new ExpSmoother(trackSmoothingTau);
        this.gsSmoother = new ExpSmoother(gsSmoothingTau);
        this.vsSmoother = new ExpSmoother(vsSmoothingTau);
        this.accelSmoother = new ExpSmoother(accelSmoothingTau);
    }
    /**
     * Updates this computer's flight path values.
     * @param heading The airplane's current true heading, in degrees.
     * @param groundTrack The airplane's current true ground track, in degrees.
     * @param groundSpeed The airplane's current ground speed, in knots.
     * @param verticalSpeed The airplane's current vertical speed, in feet per minute.
     * @param acceleration The airplane's current along-track acceleration, in knots per second.
     * @param dt The time elapsed since the last update, in milliseconds.
     */
    update(heading, groundTrack, groundSpeed, verticalSpeed, acceleration, dt) {
        let gs = this.gsSmoother.next(groundSpeed, dt);
        let vs = this.vsSmoother.next(verticalSpeed, dt);
        const accel = this.accelSmoother.next(acceleration, dt);
        // Sim can report wildly oscillating numbers for ground track at low speeds, so use heading when < 5 knots GS.
        this._track.set(this.smoothGroundTrack(groundSpeed < 5 ? heading : groundTrack, dt));
        // With smoothing, GS/VS will never reach zero from a positive initial value, so we will manually set them to zero
        // once they are below a certain threshold (in this case 1 mm/sec).
        if (gs < 1.94e-3) {
            gs = 0;
        }
        if (Math.abs(vs) < 0.197) {
            vs = 0;
        }
        this._gs.set(gs);
        this._vs.set(vs);
        const vsKnot = UnitType.FPM.convertTo(vs, UnitType.KNOT);
        const speed = Math.hypot(gs, vsKnot);
        // We don't want the pitch value to oscillate when absolute speed is low, so we will manually set it to zero when
        // speed is less than 5 knots.
        this._pitch.set(speed < 5 ? 0 : Math.atan2(vsKnot, gs) * Avionics.Utils.RAD2DEG);
        this._speed.set(speed);
        this._acceleration.set(accel);
    }
    /**
     * Smooths a ground track value.
     * @param track A ground track value.
     * @param dt The elapsed time, in milliseconds, since the last smoothed value was calculated.
     * @returns A smoothed ground track value.
     */
    smoothGroundTrack(track, dt) {
        const last = this.trackSmoother.last();
        if (last !== null && !isNaN(last)) {
            // need to handle wraparounds
            let delta = track - last;
            if (delta > 180) {
                delta = delta - 360;
            }
            else if (delta < -180) {
                delta = delta + 360;
            }
            track = last + delta;
        }
        const next = last !== null && isNaN(last) ? this.trackSmoother.reset(track) : this.trackSmoother.next(track, dt);
        const normalized = (next + 360) % 360; // enforce range 0-359
        return this.trackSmoother.reset(normalized);
    }
    /**
     * Resets this computer's flight path values to `NaN`.
     */
    reset() {
        this.trackSmoother.reset();
        this.gsSmoother.reset();
        this.vsSmoother.reset();
        this.accelSmoother.reset();
        this._track.set(NaN);
        this._gs.set(NaN);
        this._vs.set(NaN);
        this._pitch.set(NaN);
        this._speed.set(NaN);
        this._acceleration.set(NaN);
    }
}

/**
 * A default implementation of {@link GroundSpeedDataProvider} which sources data either from one IRS at a time or from
 * the IRS chosen by an IRS selector.
 */
class DefaultGroundSpeedDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of the IRS that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the IRS selector to use to choose the source IRS if `useSelector` is `true`.
     * @param useSelector Whether to source data from the IRS chosen by an IRS selector. Defaults to `false`.
     */
    constructor(bus, index, useSelector = false) {
        this.bus = bus;
        this.useSelector = useSelector;
        this._groundSpeed = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.groundSpeed = this._groundSpeed;
        this.isIrsInertialDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isDataFailed = this.isIrsInertialDataValid.map(SubscribableMapFunctions.not());
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.pauseable = [
            this._groundSpeed,
            this.isIrsInertialDataValid
        ];
        if (useSelector) {
            this.irsSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.irsIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.irsIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultGroundSpeedDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        if (this.irsSelectorIndex) {
            this.irsSelectorIndexSub = this.irsSelectorIndex.sub(index => {
                this.irsIndex.setConsumer(sub.on(`irs_selector_selected_index_${index}`));
                this.isIrsInertialDataValid.setConsumer(sub.on(`irs_selector_inertial_data_valid_${index}`));
            }, true);
        }
        this.irsIndexSub = this.irsIndex.sub(index => {
            if (!this.useSelector) {
                this.isIrsInertialDataValid.setConsumer(sub.on(`irs_inertial_data_valid_${index}`));
            }
            this._groundSpeed.setConsumer(sub.on(`irs_ground_speed_${index}`));
        }, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultGroundSpeedDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultGroundSpeedDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        (_a = this.irsSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.irsIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        if (this.useSelector) {
            this.irsIndex.destroy();
        }
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * A default implementation of {@link VerticalSpeedDataProvider} which sources data from one ADC at a time or from the
 * ADC chosen by an ADC selector.
 */
class DefaultVerticalSpeedDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, index, useSelector = false) {
        this.bus = bus;
        this.useSelector = useSelector;
        this._verticalSpeed = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.verticalSpeed = this._verticalSpeed;
        this.selectedVerticalSpeedSource = ConsumerSubject.create(null, 0).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        /** @inheritdoc */
        this.selectedVerticalSpeed = MappedSubject.create(([selectedVs, fmaData]) => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.VS ? selectedVs : null, this.selectedVerticalSpeedSource, this.fmaData);
        this.isAdcAltitudeDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isDataFailed = this.isAdcAltitudeDataValid.map(SubscribableMapFunctions.not());
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.pauseable = [
            this._verticalSpeed,
            this.selectedVerticalSpeedSource,
            this.fmaData,
            this.isAdcAltitudeDataValid
        ];
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalSpeedDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_altitude_data_valid_${index}`));
            }
            this._verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
        }, true);
        this.selectedVerticalSpeedSource.setConsumer(sub.on('ap_vs_selected'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalSpeedDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalSpeedDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * The Boeing vertical speed indicator.
 */
class VerticalSpeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.topReadoutHidden = Subject.create(false);
        this.bottomReadoutHidden = Subject.create(false);
        this.selectedBugHidden = Subject.create(false);
        this.selectedBugTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.translateY('%')));
        this.pointerY1 = Subject.create(0);
        this.pointerY2 = Subject.create(0);
        this.topReadoutValue = Subject.create(0);
        this.bottomReadoutValue = Subject.create(0);
        this.isPaused = true;
        this.pauseableSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.selectedBugTransform.transform.getChild(1).set(-50);
        this.pauseableSubs.push(this.props.dataProvider.verticalSpeed.sub(this.onVerticalSpeedChanged.bind(this), true, this.isPaused), this.props.dataProvider.selectedVerticalSpeed.pipe(this.selectedBugHidden, selected => selected === null, this.isPaused), this.props.dataProvider.selectedVerticalSpeed.sub(this.onSelectedVerticalSpeedChanged.bind(this), true, this.isPaused));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const sub of this.pauseableSubs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const sub of this.pauseableSubs) {
            sub.pause();
        }
    }
    /**
     * Responds to when vertical speed changes.
     * @param verticalSpeed The new vertical speed, in feet per minute.
     */
    onVerticalSpeedChanged(verticalSpeed) {
        if (verticalSpeed >= 400) {
            this.topReadoutHidden.set(false);
            this.topReadoutValue.set(MathUtils.floor(Math.abs(verticalSpeed), 50));
        }
        else {
            this.topReadoutHidden.set(true);
        }
        if (verticalSpeed <= -400) {
            this.bottomReadoutHidden.set(false);
            this.bottomReadoutValue.set(MathUtils.floor(Math.abs(verticalSpeed), 50));
        }
        else {
            this.bottomReadoutHidden.set(true);
        }
        const pointerPosition = this.getVerticalSpeedPosition(verticalSpeed) * this.props.scaleHeight;
        this.pointerY1.set(MathUtils.round(pointerPosition, 0.1));
        this.pointerY2.set(MathUtils.round(MathUtils.lerp(this.props.scaleWidth, 0, this.props.scaleWidth + this.props.pointerOriginOffset, 0, pointerPosition), 0.1));
    }
    /**
     * Responds to changes in the selected vertical speed.
     * @param selected The new selected vertical speed, in feet per minute.
     */
    onSelectedVerticalSpeedChanged(selected) {
        const bugPosition = this.getVerticalSpeedPosition(selected !== null && selected !== void 0 ? selected : 0) * this.props.scaleHeight;
        this.selectedBugTransform.transform.getChild(0).set(0, bugPosition, 0, undefined, 0.1);
        this.selectedBugTransform.resolve();
    }
    /**
     * Gets the vertical position on this indicator's scale corresponding to a given vertical speed, scaled to the range
     * `[-0.5, 0.5]`.
     * @param verticalSpeed A vertical speed, in feet per minute.
     * @returns The vertical position on this indicator's scale corresponding to the specified vertical speed, scaled to
     * the range `[-0.5, 0.5]`.
     */
    getVerticalSpeedPosition(verticalSpeed) {
        if (verticalSpeed === 0) {
            return 0;
        }
        const sign = verticalSpeed < 0 ? -1 : 1;
        verticalSpeed *= sign;
        if (verticalSpeed < 1000) {
            return -sign * MathUtils.lerp(verticalSpeed, 0, 1000, 0, 0.225);
        }
        else if (verticalSpeed < 2000) {
            return -sign * MathUtils.lerp(verticalSpeed, 1000, 2000, 0.225, 0.385);
        }
        else if (verticalSpeed < 6000) {
            return -sign * MathUtils.lerp(verticalSpeed, 2000, 6000, 0.385, 0.5);
        }
        else {
            return -sign * 0.5;
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "vertical-speed" },
            FSComponent.buildComponent("div", { class: "vertical-speed-coordinate-box", style: `position: absolute; top: 50%; width: ${this.props.scaleWidth}px; height: 0px;` },
                this.renderScale(),
                FSComponent.buildComponent("svg", { viewBox: `0 ${-this.props.scaleHeight / 2} ${this.props.scaleWidth} ${this.props.scaleHeight}`, class: "vertical-speed-pointer-container", style: `position: absolute; left: 0px; top: ${-this.props.scaleHeight / 2}px; width: ${this.props.scaleWidth}px; height: ${this.props.scaleHeight}px; overflow: visible;` },
                    FSComponent.buildComponent("line", { x1: 0, y1: this.pointerY1, x2: this.props.scaleWidth, y2: this.pointerY2, class: "vertical-speed-pointer shadow" }),
                    FSComponent.buildComponent("line", { x1: 0, y1: this.pointerY1, x2: this.props.scaleWidth, y2: this.pointerY2, class: "vertical-speed-pointer" })),
                FSComponent.buildComponent("svg", { viewBox: "-5 -5 10 10", preserveAspectRatio: "none", class: { 'vertical-speed-bug': true, 'hidden': this.selectedBugHidden }, style: {
                        'position': 'absolute',
                        'top': '0px',
                        'transform': this.selectedBugTransform,
                        'overflow': 'visible'
                    } },
                    FSComponent.buildComponent("line", { x1: -5, y1: -5, x2: 5, y2: -5, class: "vertical-speed-bug-bar shadow" }),
                    FSComponent.buildComponent("line", { x1: -5, y1: 5, x2: 5, y2: 5, class: "vertical-speed-bug-bar shadow" }),
                    FSComponent.buildComponent("line", { x1: -5, y1: -5, x2: 5, y2: -5, class: "vertical-speed-bug-bar" }),
                    FSComponent.buildComponent("line", { x1: -5, y1: 5, x2: 5, y2: 5, class: "vertical-speed-bug-bar" }))),
            FSComponent.buildComponent("div", { class: { 'vertical-speed-readout': true, 'vertical-speed-readout-top': true, 'hidden': this.topReadoutHidden } }, this.topReadoutValue),
            FSComponent.buildComponent("div", { class: { 'vertical-speed-readout': true, 'vertical-speed-readout-bottom': true, 'hidden': this.bottomReadoutHidden } }, this.bottomReadoutValue)));
    }
    /**
     * Renders this indicator's scale.
     * @returns This indicator's scale, as a VNode.
     */
    renderScale() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("svg", { class: "vertical-speed-scale-tick-container", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 1px; overflow: visible;" },
                [-6000, -4000, -2000, -1500, -1000, -500, 0, 500, 1000, 1500, 2000, 4000, 6000].map((fpm, index) => {
                    const y = this.getVerticalSpeedPosition(fpm) * this.props.scaleHeight;
                    const length = fpm === 0 ? this.props.scaleZeroTickLength : this.props.scaleTickLength;
                    return (FSComponent.buildComponent("line", { x1: this.props.scaleTickOffset, y1: y, x2: this.props.scaleTickOffset + length, y2: y, class: {
                            'vertical-speed-scale-tick': true,
                            'shadow': true,
                            'vertical-speed-scale-tick-zero': fpm === 0,
                            'vertical-speed-scale-tick-major': index % 2 === 0,
                            'vertical-speed-scale-tick-minor': fpm !== 0 && index % 2 === 1
                        } }));
                }),
                [-6000, -4000, -2000, -1500, -1000, -500, 0, 500, 1000, 1500, 2000, 4000, 6000].map((fpm, index) => {
                    const y = this.getVerticalSpeedPosition(fpm) * this.props.scaleHeight;
                    const length = fpm === 0 ? this.props.scaleZeroTickLength : this.props.scaleTickLength;
                    return (FSComponent.buildComponent("line", { x1: this.props.scaleTickOffset, y1: y, x2: this.props.scaleTickOffset + length, y2: y, class: {
                            'vertical-speed-scale-tick': true,
                            'vertical-speed-scale-tick-zero': fpm === 0,
                            'vertical-speed-scale-tick-major': index % 2 === 0,
                            'vertical-speed-scale-tick-minor': fpm !== 0 && index % 2 === 1
                        } }));
                })),
            /* Labels */
            [-6000, -2000, -1000, 1000, 2000, 6000].map(fpm => {
                return (FSComponent.buildComponent("div", { class: "vertical-speed-scale-label", style: `position: absolute; top: ${this.getVerticalSpeedPosition(fpm) * this.props.scaleHeight}px;` }, (Math.abs(fpm) / 1000).toFixed(0)));
            })));
    }
}

/**
 * A default implementation of {@link AoaDataProvider}.
 */
class DefaultAoaDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param aoaIndex The index of the AoA computer that is the source of this provider's data.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     */
    constructor(bus, aoaIndex, adcIndex) {
        this.bus = bus;
        this._aoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.aoa = this._aoa;
        this._normAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.normAoa = this._normAoa;
        this._stallAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.stallAoa = this._stallAoa;
        this._zeroLiftAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.zeroLiftAoa = this._zeroLiftAoa;
        this.ias = ConsumerValue.create(null, 0);
        this._isOnGround = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.isOnGround = this._isOnGround;
        this.aoaCoefSmoother = new ExpSmoother(DefaultAoaDataProvider.AOA_COEF_SMOOTHING_TAU);
        this._normAoaIasCoef = Subject.create(null);
        /** @inheritdoc */
        this.normAoaIasCoef = this._normAoaIasCoef;
        this._normAoaIasCoef1g = Subject.create(null);
        /** @inheritdoc */
        this.normAoaIasCoef1g = this._normAoaIasCoef1g;
        this._isDataFailed = Subject.create(false);
        /** @inheritdoc */
        this.isDataFailed = this._isDataFailed;
        this.loadFactorSource = ConsumerValue.create(null, 1);
        this.loadFactorSmoother = new ExpSmoother(DefaultAoaDataProvider.LOAD_FACTOR_SMOOTHING_TAU);
        this.loadFactor = 1;
        this.aoaSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.adcSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.isAdcDataFailed = false;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.aoaIndex = SubscribableUtils.toSubscribable(aoaIndex, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        this._isOnGround.setConsumer(sub.on('on_ground'));
        this.aoaIndexSub = this.aoaIndex.sub(index => {
            this._aoa.setConsumer(sub.on(`aoa_aoa_${index}`));
            this._normAoa.setConsumer(sub.on(`aoa_norm_aoa_${index}`));
            this._stallAoa.setConsumer(sub.on(`aoa_stall_aoa_${index}`));
            this._zeroLiftAoa.setConsumer(sub.on(`aoa_zero_lift_aoa_${index}`));
            this.loadFactorSource.setConsumer(sub.on(`aoa_load_factor_${index}`));
            this.aoaSystemState.setConsumer(sub.on(`aoa_state_${index}`));
        }, true);
        this.adcIndexSub = this.adcIndex.sub(index => {
            this.ias.setConsumer(sub.on(`adc_ias_${index}`));
            this.adcSystemState.setConsumer(sub.on(`adc_state_${index}`));
        }, true);
        this.aoaSystemState.sub(state => {
            if (state.current === undefined || state.current === AvionicsSystemState.On) {
                this._isDataFailed.set(false);
            }
            else {
                this._isDataFailed.set(true);
            }
        }, true);
        this.adcSystemState.sub(state => {
            this.isAdcDataFailed = !(state.current === undefined || state.current === AvionicsSystemState.On);
        }, true);
        this.clockSub = sub.on('realTime').handle(this.update.bind(this));
        if (paused) {
            this.pause();
        }
    }
    /** @inheritdoc */
    aoaToNormAoa(aoa) {
        const zeroLiftAoa = this._zeroLiftAoa.get();
        return (aoa - zeroLiftAoa) / (this._stallAoa.get() - zeroLiftAoa);
    }
    /** @inheritdoc */
    normAoaToAoa(normAoa) {
        const zeroLiftAoa = this._zeroLiftAoa.get();
        return normAoa * (this._stallAoa.get() - zeroLiftAoa) + zeroLiftAoa;
    }
    /** @inheritdoc */
    estimateIasFromAoa(aoa, loadFactor) {
        return this.estimateIasFromNormAoa(this.aoaToNormAoa(aoa), loadFactor);
    }
    /** @inheritdoc */
    estimateIasFromNormAoa(normAoa, loadFactor) {
        var _a;
        const ratio = loadFactor === undefined ? 1 : loadFactor / this.loadFactor;
        return Math.sqrt(((_a = this._normAoaIasCoef.get()) !== null && _a !== void 0 ? _a : NaN) * ratio / normAoa);
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot resume a dead provider');
        }
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this._aoa.resume();
        this._normAoa.resume();
        this._stallAoa.resume();
        this._zeroLiftAoa.resume();
        this.loadFactorSource.resume();
        this.ias.resume();
        this._isOnGround.resume();
        this.aoaSystemState.resume();
        this.adcSystemState.resume();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot pause a dead provider');
        }
        if (this.isPaused) {
            return;
        }
        this._aoa.pause();
        this._normAoa.pause();
        this._stallAoa.pause();
        this._zeroLiftAoa.pause();
        this.loadFactorSource.pause();
        this.ias.pause();
        this._isOnGround.pause();
        this.aoaSystemState.pause();
        this.adcSystemState.pause();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.pause();
        this.lastUpdateTime = undefined;
        this.aoaCoefSmoother.reset();
        this.loadFactorSmoother.reset();
        this.isPaused = true;
    }
    /**
     * Updates this data provider.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (this._isDataFailed.get() || this.isAdcDataFailed || this._isOnGround.get()) {
            this._normAoaIasCoef.set(null);
            this.loadFactor = 1;
            this.aoaCoefSmoother.reset();
            this.loadFactorSmoother.reset();
            this.lastUpdateTime = undefined;
            return;
        }
        const dt = this.lastUpdateTime === undefined ? 0 : Math.max(0, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
        const normAoa = this._normAoa.get();
        const ias = this.ias.get();
        const iasSquared = ias * ias;
        const coef = normAoa * iasSquared;
        this._normAoaIasCoef.set(this.aoaCoefSmoother.next(coef, dt));
        this.loadFactor = this.loadFactorSmoother.next(this.loadFactorSource.get(), dt);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        this._aoa.destroy();
        this._normAoa.destroy();
        this._stallAoa.destroy();
        this._zeroLiftAoa.destroy();
        this.loadFactorSource.destroy();
        this.ias.destroy();
        this._isOnGround.destroy();
        this.aoaSystemState.destroy();
        this.adcSystemState.destroy();
        (_a = this.aoaIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.clockSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}
DefaultAoaDataProvider.AOA_COEF_SMOOTHING_TAU = 2000 / Math.LN2;
DefaultAoaDataProvider.LOAD_FACTOR_SMOOTHING_TAU = 2000 / Math.LN2;

/**
 * An abstract implementation of {@link BoeingSpeedProvider} which handles the computation of economy (ECON) speeds.
 */
class AbstractBoeingSpeedProvider {
    /**
     * Creates a new instance of AbstractBoeingSpeedProvider.
     * @param engineDataProvider A provider of airplane engine data.
     */
    constructor(engineDataProvider) {
        this.engineDataProvider = engineDataProvider;
    }
    /** @inheritdoc */
    getEconCruiseSpeed(costIndex, altitude, weight, headwind, out, pressure) {
        pressure !== null && pressure !== void 0 ? pressure : (pressure = AeroMath.isaPressure(UnitType.FOOT.convertTo(altitude, UnitType.METER)));
        // TODO: Get rid of hardcoded constants based on 787 numbers.
        // First we need to determine the limits of any FMC commanded speed:
        // During cruise the maximum ECON speed is MMO/VMO - 5 knots.
        const vmoCas = Math.round(this.getVmo(altitude));
        const vmoReducedBy5 = vmoCas - 5;
        const mmo = this.getMmo();
        const mmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(mmo, pressure), UnitType.MPS);
        const mmoReducedBy5 = AeroMath.casToMach(UnitType.MPS.convertFrom(mmoCas - 5, UnitType.KNOT), pressure);
        // 1. ECON mach calculation:
        // We use LRC mach as baseline, as it already incorporates alt and weight.
        const lrcMach = this.engineDataProvider.getLongRangeCruiseMach(weight, altitude);
        // LRC speed is assumed to match ECON speed at Ci = ~180 and at Ci = 0 we assume a speed drop of -1%.
        // So, to calculate the ci based ECON mach, we scale LRC speed accordingly.
        const ci0EconMach = lrcMach * 0.99;
        const ciAdjustedEconMach = ci0EconMach + lrcMach * costIndex / 18000.0;
        // Next, the headwind is used to calculate a wind related ECON mach offset.
        // From the ECON-mach tables of comparable long range widebodies, we find that the impact on ECON mach (for a change between
        // 100 kts headwind vs 100 kts tailwind) at mtow is 4 times less than at empty weight. At the same time, changing alt from
        // FL270 to FL Max results also in a 4 times smaller impact.
        const headwindInducedOffset = (headwind / 10000) // Gives a +/- 0.01 offset when headwind changes +/- 100 kts
            * MathUtils.lerp(altitude, 27000, 43000, 2, 0.5) // multiplied with 2 @FL270 ... 0.5 @FL430
            * (-0.000009679 * weight + 5.891) // and multiplied with 3 @OEW ... 0.3 @MTOW
        ;
        // We can wrap up the calculation by adding the wind induced offset (headwind -> increase ECON mach,
        // tailwind -> decrease ECON mach) and clip the maximum at Mmo and the minimum at ci0CruiseMach (see Boeing PDF on cost index):
        const windAndCiAdjustedEconMach = MathUtils.clamp(ciAdjustedEconMach + headwindInducedOffset, ci0EconMach, mmo);
        // 2. ECON cas calculation
        // Based on the Boeing PDF AERO_FuelConsSeries, ECON cruise cas limits are defined as follows:
        // - min ci -> 290, max ci -> vmo reduced by 5,
        // For any intermediate ci values, we scale between the limits, while considering, that most of the cas range
        // is covered by a small portion of the full ci range. Evidence from videos suggest, that climb ECON cas
        // often lingers around the 300 mark. So define the lerp table as follows:
        // - ci0 -> 290, ci300 -> 340 and ci9999 -> vmo - 5
        const econCas = Math.round((costIndex <= 300
            ? MathUtils.lerp(costIndex, 0, 300, 290, 340, true, true)
            : MathUtils.lerp(costIndex, 300, 9999, 340, Math.max(vmoReducedBy5, 340), true, true)) + headwindInducedOffset / 10);
        out[0] = Math.min(econCas, vmoReducedBy5);
        out[1] = Math.min(windAndCiAdjustedEconMach, mmoReducedBy5);
        return out;
    }
    /** @inheritdoc */
    getEconDescentSpeed(costIndex, altitude, weight, out, pressure) {
        pressure !== null && pressure !== void 0 ? pressure : (pressure = AeroMath.isaPressure(UnitType.FOOT.convertTo(altitude, UnitType.METER)));
        // First we need to determine the limits of any FMC commanded speed:
        // During descent the maximum ECON speed is MMO/VMO - 16 knots.
        const vmoCas = Math.round(this.getVmo(altitude));
        const vmoReducedBy16 = vmoCas - 16;
        const mmo = this.getMmo();
        const mmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(mmo, pressure), UnitType.MPS);
        const mmoReducedBy16 = AeroMath.casToMach(UnitType.MPS.convertFrom(mmoCas - 16, UnitType.KNOT), pressure);
        // 1. ECON mach calculation:
        // We use LRC mach as baseline, as it already incorporates alt and weight.
        const lrcMach = this.engineDataProvider.getLongRangeCruiseMach(weight, altitude);
        // LRC speed is assumed to match ECON speed at Ci = ~180 and at Ci = 0 we assume a speed drop of -1%.
        // So, to calculate the ci based ECON mach, we scale LRC speed accordingly.
        const ci0EconMach = lrcMach * 0.99;
        const ciAdjustedEconMach = ci0EconMach + lrcMach * costIndex / 18000.0;
        // 2. ECON cas calculation
        // Based on the Boeing PDF AERO_FuelConsSeries, ECON descent cas limits are defined as follows:
        // - min ci -> 250 (max L/D), max ci -> vmo reduced by 16,
        // For any intermediate ci values, we scale between the limits, while considering, that most of the cas range
        // is covered by a small portion of the full ci range. Evidence from videos suggest, that climb ECON cas
        // often lingers around the 300 mark. So define the lerp table as follows:
        // - ci0 -> 250, ci100 -> 320 and ci9999 -> 344 (vmo - 16)
        const econCas = Math.round(costIndex <= 100
            ? MathUtils.lerp(costIndex, 0, 100, 250, 320, true, true)
            : MathUtils.lerp(costIndex, 100, 9999, 320, Math.max(vmoReducedBy16, 320), true, true));
        out[0] = Math.min(econCas, vmoReducedBy16);
        out[1] = Math.min(ciAdjustedEconMach, mmoReducedBy16);
        return out;
    }
}

/* eslint-disable jsdoc/require-jsdoc */
/**
 * TODO: This needs to have the aircraft specific performance values split out from the static constants and methods.
 * Boeing Performance Math Utility Class.
 */
class BoeingAeroMath {
    // TODO: Clean up these various delta/pressure ratio methods....
    /**
     * Calculates the current dynamic pressure ratio.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg.
     * @param mach The current aircraft mach number.
     * @returns the current dynamic pressure ratio.
     */
    static calcDynamicPressureRatio(ambientPressure, mach) {
        return 1481.4 * Math.pow(mach, 2) * BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure);
    }
    /**
     * Calculate atmospheric pressure ratio from pressure altitude
     * @todo belongs somewhere else
     * @param zp Pressure altitude in feet
     * @param tropopause Tropopause altitude in feet
     * @returns Atmospheric pressure ratio (delta)
     */
    static deltaFromPressureAlt(zp, tropopause = 36089.24) {
        return zp < tropopause ? ((288.15 - 0.0019812 * zp) / 288.15) ** 5.25588 : 0.22336 * Math.E ** ((36089.24 - zp) / 20805.7);
    }
    /**
     * Calculate the Delta Pressure Ratio for a given altitude above sea level.
     * @param altitude The altitude, in Ft.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAltitude(altitude) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
        return isa[1] * 100 / BoeingAeroMath.slIsaPres;
    }
    /**
     * Calculate the Delta Pressure Ratio for a given ambient pressure.
     * @param ambientPressure The ambient pressure, in inHg.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAmbientPressure(ambientPressure) {
        return ambientPressure / 29.92;
    }
    /**
     * Calculate the Delta Total Pressure Ratio for a given Delta Pressure Ratio and Mach.
     * @param deltaPressureRatio The Delta Pressure Ratio.
     * @param mach The Mach.
     * @returns The Delta Total Pressure Ratio.
     */
    static calcDeltaTotalPressureRatio(deltaPressureRatio, mach) {
        return deltaPressureRatio * Math.pow(1 + 0.2 * (Math.pow(mach, 2)), 3.5);
    }
    /**
     * Calculates a thrust correction factor. Multiplying the correction factor by uncorrected thrust yields corrected
     * thrust.
     * @param mach The mach number.
     * @param ambientPressure The ambient pressure in inHg.
     * @returns The thrust correction factor for the specified parameters.
     */
    static calculateThrustCorrectionFactor(mach, ambientPressure) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        return 1 / (deltaPressureRatio * totalInletPressureMachRise);
    }
    /**
     * Gets the ISA Standard Temp and Press from Altitude.
     * @param altitude The altitude in feet.
     * @param isaPresDeviation Optional Pressure Deviation, in inHg.
     * @param isaTempDeviation Optional Temperature Deviation, in C.
     * @returns an array of [temp K, pressure HPA]
     */
    static calcIsaFromAltitude(altitude, isaPresDeviation, isaTempDeviation) {
        if (isaPresDeviation !== undefined) {
            altitude = BoeingAeroMath.calcPressureAltitude(altitude, 29.92 + isaPresDeviation);
        }
        let temp = 0.0;
        let pressure = 0.0;
        if (altitude <= 36089) {
            // 36089 is the altitude of the top of the troposphere
            temp = BoeingAeroMath.slIsaTemp + (-BoeingAeroMath.lapseFt * altitude);
            pressure = BoeingAeroMath.slIsaPres * Math.pow((BoeingAeroMath.slIsaTemp / temp), (0.034163203 / -0.0065));
        }
        else if (altitude <= 65616) {
            // 65616 is the altitude of the tropopause
            // 22335.6 is the pressure at the base of the tropopause in PA
            // const tropoPres = 22335.6;
            // tropoTemp = 216.65;
            temp = 216.65;
            pressure = 0.223356 * 101325 * Math.exp(-0.000157688 * (altitude - 36089));
        }
        else {
            temp = NaN;
            pressure = NaN;
        }
        return [temp + (isaTempDeviation !== null && isaTempDeviation !== void 0 ? isaTempDeviation : 0), pressure / 100];
    }
    /**
     * Calculate the speed of sound from temperature.
     * @param ambientTemperature The ambient temperature, in C.
     * @returns The speed of sound in ft/s.
     */
    static calcSpeedOfSoundFromTemp(ambientTemperature) {
        return Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE));
    }
    /**
     * Calculate the pressure altitude from Indicated Altitude and Sea Level Pressure.
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Pressure Altitude.
     */
    static calcPressureAltitude(indicatedAltitude, baroSettingInHg) {
        return indicatedAltitude + (1000 * (29.92 - baroSettingInHg));
    }
    /**
     * Calculate the static pre
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Static Pressure in inHg.
     */
    static calcStaticPressure(indicatedAltitude, baroSettingInHg) {
        return UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(BoeingAeroMath.calcPressureAltitude(indicatedAltitude, baroSettingInHg))[1], UnitType.IN_HG);
    }
    /**
     * Calculate the Impact Pressure from CAS.
     * @param cas Calibrated Airspeed in knots.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromCas(cas) {
        return BoeingAeroMath.airDensity * Math.pow(UnitType.KNOT.convertTo(cas, UnitType.MPS), 2) / 2;
    }
    /**
     * Calculate the Impact Pressure.
     * @param mach Mach Number.
     * @param ambientPressure The Ambient Pressure, in inHg.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromMach(mach, ambientPressure) {
        return 100 * (UnitType.IN_HG.convertTo(ambientPressure, UnitType.HPA) * (Math.pow(1 + Math.pow(0.2 * mach, 2), 2 / 7) - 1));
    }
    /**
     * Calculate the Mach number from airspeed, altitude and pressure.
     * @param cas Calibrated Airspeed in knots.
     * @param indicatedAltitude Indicated Altitude in Feet.
     * @param baroSettingInHg The local altimeter setting in inHg.
     * @returns The current Mach Number.
     */
    static calcMachFromCasAltitudePressure(cas, indicatedAltitude, baroSettingInHg) {
        const impactPressure = BoeingAeroMath.calcImpactPressureFromCas(cas);
        const staticPressure = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        return Math.sqrt(5 * (Math.pow((impactPressure / staticPressure) + 1, 2 / 7) - 1));
    }
    /**
     * Calculate static air temperature (SAT, also OAT), from total air temperature (TAT) and Mach.
     * @param tat Total Air Temp in degrees C.
     * @param mach Mach number.
     * @returns The Static Air Temperature in degrees C.
     */
    static calcSatFromTatAndMach(tat, mach) {
        // Gamma minus 1 / 2 = 0.2
        return UnitType.KELVIN.convertTo(UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) / (1 + (Math.pow(mach, 2) * 0.2)), UnitType.CELSIUS);
    }
    /**
     * Calculate the True Airspeed from Altitude, Temperature and Calibrated Airspeed.
     * @param altitude Altitude in Feet.
     * @param tat Total Air Temp in degrees C.
     * @param cas Calibrated Airspeed in KT.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns True Airspeed in KT.
     */
    static calcTasFromCas(altitude, tat, cas, baroSettingInHg) {
        const pressureAltitude = BoeingAeroMath.calcPressureAltitude(altitude, baroSettingInHg);
        const isa = BoeingAeroMath.calcIsaFromAltitude(pressureAltitude);
        const isaPres = isa[1];
        const mach = BoeingAeroMath.calcMachFromCasAltitudePressure(cas, altitude, baroSettingInHg);
        const temp = UnitType.CELSIUS.convertTo(BoeingAeroMath.calcSatFromTatAndMach(tat, mach), UnitType.KELVIN);
        const alpha = Math.sqrt(BoeingAeroMath.gammaGasVolume * temp);
        const tas = Math.sqrt(5) * alpha * Math.sqrt(Math.pow(((BoeingAeroMath.slIsaPres / isaPres) *
            (Math.pow((cas * cas / BoeingAeroMath.sqrtGammaGasSlNmSqd5) + 1, BoeingAeroMath.gammaOverGammaMinus1) - 1) + 1), BoeingAeroMath.gammaMinus1OverGamma) - 1);
        return UnitType.FPS.convertTo(tas, UnitType.KNOT);
    }
    /**
     * Calculate EAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientPressure Ambient Pressure, in inHg.
     * @returns The Equivalent Airspeed (EAS).
     */
    static calcEasFromMachAndAmbientPressure(mach, ambientPressure) {
        return UnitType.FPS.convertTo(BoeingAeroMath.sound * mach *
            Math.sqrt(BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure)), UnitType.KNOT);
    }
    /**
     * Calculate CAS from EAS.
     * @param eas Equivalent Airspeed in knots
     * @param pressureAlt The current pressure altitude, in Feet.
     * @returns Calibrated airspeed in knots
     */
    static easToCas(eas, pressureAlt) {
        const delta = BoeingAeroMath.deltaFromPressureAlt(pressureAlt);
        return 1479.1 * Math.sqrt((1 + delta * ((1 + 1 / delta * (eas / 1479.1) ** 2) ** 3.5 - 1)) ** (1 / 3.5) - 1);
    }
    /**
     * Calculate CAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientTemp Ambient Temperature, in C.
     * @returns The True Airspeed (TAS).
     */
    static calcTasFromMachAndTemp(mach, ambientTemp) {
        return mach * BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemp);
    }
    /**
     * Calculate density altitude from indicated altitude, barometer setting and static air temperature.
     * @param indicatedAltitude indicated altitude in feet (ft)
     * @param baroSettingInHg barometer setting in inches of mercury (inHg)
     * @param sat static air temperature in degrees celsius (°C)
     * @returns density altitude in feet (ft)
     */
    static calcDensityAltitude(indicatedAltitude, baroSettingInHg, sat) {
        const stationPressurePa = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        const stationPressureinHg = UnitType.HPA.convertTo(stationPressurePa / 100, UnitType.IN_HG);
        const tempR = 459.67 + UnitType.CELSIUS.convertTo(sat, UnitType.FAHRENHEIT);
        // NWS Calculation for ASOS/AWOS
        return 145422.16 * (1 - Math.pow(17.326 * stationPressureinHg / tempR, 0.235));
    }
    /**
     * Calculate observed wind from true airspeed, ground speed, magnetic heading and magnetic track.
     * @param tas The true airspeed in KT.
     * @param gs The ground speed in KT.
     * @param heading The current magnetic heading in degrees.
     * @param track The current magnetic ground track in degrees.
     * @returns Array of [wind direction degrees mag, wind speed kt].
     */
    static calcWind(tas, gs, heading, track) {
        const headingRad = UnitType.DEGREE.convertTo(heading, UnitType.RADIAN);
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windComponentNorth = gs * Math.cos(trackRad) - tas * Math.cos(headingRad);
        const windComponentEast = gs * Math.sin(trackRad) - tas * Math.sin(headingRad);
        const windDirection = NavMath.normalizeHeading(90 - Math.round(UnitType.RADIAN.convertTo(Math.atan2(-windComponentNorth, -windComponentEast), UnitType.DEGREE)));
        const windSpeed = Math.sqrt(Math.pow(windComponentNorth, 2) + Math.pow(windComponentEast, 2));
        return [windDirection, windSpeed];
    }
    /**
     * Calculate headwind and crosswind components from the current ground track, wind speed and wind direction.
     * @param track Current magnetic ground track.
     * @param windSpeed Current wind speed in kt.
     * @param windDirection Current wind direction in degrees magnetic.
     * @returns Array of [headwind component in kt (+ is headwind, - is tailwind),
     * crosswind component in kt (+ is Left crosswind, - is Right crosswind)].
     */
    static calcRelativeWindComponents(track, windSpeed, windDirection) {
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windDirectionRad = UnitType.DEGREE.convertTo(windDirection, UnitType.RADIAN);
        return [
            Math.round(windSpeed * (Math.cos(trackRad - windDirectionRad))),
            Math.round(windSpeed * (Math.sin(trackRad - windDirectionRad)))
        ];
    }
}
/** ISA temp at Sea Level in Kelvin  */
BoeingAeroMath.slIsaTemp = 288.15;
/** ISA pressure at Sea Level in Pascals  */
BoeingAeroMath.slIsaPres = 101325;
/** Specific heat ratio for air  */
BoeingAeroMath.gamma = 1.4;
/** Constant: gamma over gamma minus 1 */
BoeingAeroMath.gammaOverGammaMinus1 = BoeingAeroMath.gamma / (BoeingAeroMath.gamma - 1);
/** Constant: gamma minus 1 over gamma */
BoeingAeroMath.gammaMinus1OverGamma = (BoeingAeroMath.gamma - 1) / BoeingAeroMath.gamma;
/** Specific gas constant in Kelvin (from the world)  */
BoeingAeroMath.gasKelvin = 287.05;
/** Specific gas constant in Rankine (from sim code) */
BoeingAeroMath.gasRankine = 1716;
/** Specific heat ratio for air times gas constant.  */
BoeingAeroMath.gammaGas = BoeingAeroMath.gamma * BoeingAeroMath.gasKelvin;
/** Specific heat ratio for air times gas constant divided per cubic ft.  */
BoeingAeroMath.gammaGasVolume = BoeingAeroMath.gammaGas / Math.pow(UnitType.FOOT.convertTo(1, UnitType.METER), 2);
/** Constant: gammaGas * slIsaTemp */
BoeingAeroMath.gammaGasSl = BoeingAeroMath.gammaGas * BoeingAeroMath.slIsaTemp;
/** Constant: sqrt gammaGasSl * nm */
BoeingAeroMath.sqrtGammaGasSlNm = Math.sqrt(BoeingAeroMath.gammaGasSl) * UnitType.METER.convertTo(3600.0, UnitType.NMILE);
/** Constant: 5 * sqrtGammaGasSlNm squared  */
BoeingAeroMath.sqrtGammaGasSlNmSqd5 = 5.0 * BoeingAeroMath.sqrtGammaGasSlNm * BoeingAeroMath.sqrtGammaGasSlNm;
/** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
BoeingAeroMath.lapseFt = 0.0019812;
/** Fluid density of Air in kg/m^3.  */
BoeingAeroMath.airDensity = 1.225;
/** Gravity at SL ft/s^2.  */
BoeingAeroMath.gravity = 32.17405;
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;
/** Speed of Sound at SL ft/s.  */
BoeingAeroMath.sound = Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE);

/* eslint-disable max-len */
/**
 * An interface for accessing aircraft specific performance data.
 */
class BoeingPerformanceDataProvider {
    constructor() {
        /** Aircraft Specific values from flight_model.cfg and engines.cfg files.  */
        this.aircraftFlightModel = this.getAircraftFlightModel();
        this.aspectRatio = Math.pow(this.aircraftFlightModel.wing_span, 2) / this.aircraftFlightModel.wing_area;
    }
    /**
     * Calculate the Optimum (best range) Altitude for a specific Mach.
     * @param mach The Mach number.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude, in FT.
     */
    calcOptimumAltitudeFromCruiseMach(mach, weight) {
        const rangeTable = [];
        let altitude = 25000;
        while (altitude <= 41000) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            altitude += 1000;
        }
        const maxRange = Math.max(...rangeTable);
        const optAltitude = 25000 + 1000 * rangeTable.findIndex(v => v === maxRange);
        return optAltitude;
    }
    /**
     * Calculate the Optimum (best range) Mach for a specific Altitude.
     * @param altitude The Altitude, in FT.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Mach.
     */
    calcOptimumCruiseMachFromAltitude(altitude, weight) {
        const rangeTable = [];
        let mach = .7;
        while (mach <= 0.9) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            mach += 0.01;
        }
        const maxRange = Math.max(...rangeTable);
        const optMach = .7 + (0.01 * rangeTable.findIndex(v => v === maxRange));
        return optMach;
    }
    /**
     * Calculate the Optimum (best range) Mach and Altitude for a specific aircraft weight.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude and Mach as [Alt in FT, Mach].
     */
    calcOptimumCruiseMachAndAltitude(weight) {
        const rangeTable = [];
        let mach = 70;
        let altitude = 25000;
        while (Math.round(altitude) <= 41000) {
            while (Math.round(mach) <= 90) {
                const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
                const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
                const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
                const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach / 100, ambientTemperature);
                const cl = this.calculateCL(weight, ambientPressure, mach / 100);
                const netThrust = this.calculateThrustRequired(weight, cl, 0);
                const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach / 100, altitude, ambientTemperature, ambientPressure);
                const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
                const rangePerThousandPounds = (1000 / fuelFlow) * tas;
                rangeTable.push(rangePerThousandPounds);
                mach += 1;
            }
            altitude += 1000;
            mach = 70;
        }
        //21 values per altitude
        const maxRange = Math.max(...rangeTable);
        const index = rangeTable.findIndex(v => v === maxRange);
        const altIndex = Math.floor(index / 21);
        const machIndex = index - (altIndex * 21);
        const optMach = .7 + (0.01 * machIndex);
        const optAlt = 25000 + (altIndex * 1000);
        return [optAlt, optMach];
    }
    /**
     * Calculates the current Lift Coefficient.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg
     * @param mach The current aircraft mach number.
     * @returns the current lift coefficient.
     */
    calculateCL(aircraftWeight, ambientPressure, mach) {
        return aircraftWeight / (BoeingAeroMath.calcDynamicPressureRatio(ambientPressure, mach) * this.aircraftFlightModel.wing_area);
    }
    /**
     * Gets the number of possible aircraft configurations, clean and flaps.
     * @returns The number of aircraft configurations.
     */
    getNumberOfConfigurations() {
        return this.aircraftFlightModel.cl_cd.length;
    }
    /**
     * Calculates the current drag coefficient.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The Drag Coefficient
     */
    calculateCD(cl, flapsIndex) {
        const correctedCl = cl - this.aircraftFlightModel.cl_cd[flapsIndex][0];
        const parasiticDrag = this.aircraftFlightModel.cl_cd[flapsIndex][1];
        const inducedDrag = (Math.pow(correctedCl, 2) * this.aircraftFlightModel.induced_drag_scalar) /
            (Math.PI * this.aircraftFlightModel.oswald_efficiency_factor * this.aspectRatio);
        return parasiticDrag + inducedDrag;
    }
    /**
     * Calculates the efficiency factor.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the efficiency factor.
     */
    calculateEfficiency(cl, flapsIndex) {
        return cl / this.calculateCD(cl, flapsIndex);
    }
    /**
     * Calculates the best L/D speed by finding a mach value at the altitude that produces the highest L/D ratio.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param altitude Altitude to find the best econ speed for.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best Econ Speed in Mach.
     */
    calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex) {
        const ambientPressure = UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(altitude)[1], UnitType.IN_HG);
        let machTarget = 0.5;
        let clTarget = 0;
        let ldTarget = 0;
        let iterations = 0;
        while (iterations < 300) {
            clTarget = this.calculateCL(aircraftWeight, ambientPressure, machTarget);
            const newldTarget = this.calculateEfficiency(clTarget, flapsIndex);
            if (newldTarget > ldTarget) {
                ldTarget = newldTarget;
                machTarget += .01;
            }
            else {
                return machTarget -= .01;
            }
            iterations++;
        }
        return machTarget;
    }
    /**
     * Gets the best econ speed based on CAFE/Carson Speed multiplier against best L/D speed.
     * @param aircraftWeight The aircraft weight.
     * @param altitude The altitide to find the best speed at.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best econ speed.
     */
    calculateBestEconSpeed(aircraftWeight, altitude, flapsIndex) {
        return 1.32 * this.calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex);
    }
    /**
     * Calculates the total required net thrust to maintain the current speed and altitude.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The total required net thrust.
     */
    calculateThrustRequired(aircraftWeight, cl, flapsIndex) {
        return aircraftWeight / this.calculateEfficiency(cl, flapsIndex);
    }
    /**
     * Calculates an FPA for a total net thrust at a constant speed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The predicted FPA in Degrees.
     */
    calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex) {
        return Avionics.Utils.RAD2DEG * Math.asin((totalNetThrust / aircraftWeight) - (1 / this.calculateEfficiency(cl, flapsIndex)));
    }
    /**
     * Calculates a vertical speed for a total net thrust for a constant true airspeed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the predicted VS in FPM
     */
    calculateConstantSpeedVerticalSpeedFromThrust(totalNetThrust, tas, aircraftWeight, cl, flapsIndex) {
        return VNavUtils.getVerticalSpeedFromFpa(this.calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex), tas);
    }
    /**
     * Calculates a total net thrust at a constant speed for a given FPA
     * @param fpa Flight Path Angle in degrees (+ve = up)
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @param accelFactor Acceleration factor (see {@link calculateAccelerationFactor}).
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForFpa(fpa, aircraftWeight, cl, flapsIndex, accelFactor) {
        return aircraftWeight * (accelFactor * Math.sin(fpa * Avionics.Utils.DEG2RAD) + 1 / this.calculateEfficiency(cl, flapsIndex));
    }
    /**
     * Calculates a total net thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/min
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @param accelFactor Acceleration factor (see {@link calculateAccelerationFactor}).
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex, accelFactor) {
        return this.calculateConstantSpeedThrustForFpa(VNavUtils.getFpaFromVerticalSpeed(vs, tas), aircraftWeight, cl, flapsIndex, accelFactor);
    }
    /**
     * Calculates a gross thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/min
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param enginesAvailable The number of engines currently running to provide the thrust
     * @param altitude Pressure altitude in feet
     * @param isaDeviation ISA temperature deviation in °C
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @param speedTargetIsMach True if the speed target is a constant mach, otherwise constant CAS is assumed.
     * @returns Total Net Thrust in LBS.
     */
    calculateCorrectedN1ForVerticalSpeed(vs, tas, aircraftWeight, enginesAvailable, altitude, isaDeviation, flapsIndex, speedTargetIsMach = false) {
        const [isaTempK] = BoeingAeroMath.calcIsaFromAltitude(altitude);
        const [ambientTempK, ambientPressHpa] = BoeingAeroMath.calcIsaFromAltitude(altitude, undefined, isaDeviation);
        const ambientTemperature = UnitType.KELVIN.convertTo(ambientTempK, UnitType.CELSIUS);
        const ambientPressure = UnitType.HPA.convertTo(ambientPressHpa, UnitType.IN_HG);
        const mach = AeroMath.tasToMach(UnitType.KNOT.convertTo(tas, UnitType.MPS), AeroMath.soundSpeedAir(ambientTemperature));
        const cl = this.calculateCL(aircraftWeight, ambientPressure, mach);
        const accelFactor = this.calculateAccelerationFactor(altitude, mach, speedTargetIsMach, ambientTempK, isaTempK);
        const netThrust = this.calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex, accelFactor);
        const netThrustPerEngine = netThrust / Math.max(1, enginesAvailable);
        const [, cn1] = this.findGrossThrustAndCn1FromNetThrust(BoeingPerformanceDataProvider.vec2Cache, netThrustPerEngine, mach, altitude, ambientTemperature, ambientPressure);
        return cn1;
    }
    /**
     * Calculates the acceleration factor (1 + V/g . dV/dh) for climb/descent performance.
     * @param altitude Pressure altitude in feet.
     * @param mach Mach number.
     * @param constantMach True for constant CAS, false for constant mach.
     * @param ambientTemp Ambient temperature in K.
     * @param isaTemp Ambient temperature in K.
     * @param tropopause The tropopause altitude in feet, defaults to ISA (36089 feet).
     * @returns The acceleration factor for climb/descent performance.
     */
    calculateAccelerationFactor(altitude, mach, constantMach, ambientTemp, isaTemp, tropopause = 36089) {
        if (!constantMach) {
            const m2 = mach * mach;
            const phi = (Math.pow((1 + 0.2 * m2), 3.5) - 1) / (0.7 * m2 * Math.pow(1 + 0.2 * m2, 3.5));
            const tempRatio = isaTemp / ambientTemp; // Tisa / T
            if (altitude > tropopause) {
                // constant cas above the tropopause
                return 1 + 0.7 * m2 * phi;
            }
            // constant cas below the tropopause
            return 1 + 0.7 * m2 * (phi - 0.190263 * (tempRatio));
        }
        else if (altitude > tropopause) {
            // constant mach above the tropopause
            return 1;
        }
        else {
            // constant mach below the tropopause
            return 1 - 0.13318 * mach * mach * isaTemp / ambientTemp;
        }
    }
    /**
     * Calculates fuel flow from a corrected thrust and corrected ram drag.
     * @param thrust Corrected Net thrust (if ram drag is given) or corrected gross thrust, in LBS.
     * @param ramDrag An optional corrected ram drag, in LBS.
     * @returns The calculated fuel flow, in LBS/HR.
     */
    calculateFuelFlowFromThrust(thrust, ramDrag) {
        if (ramDrag !== undefined) {
            return (thrust + ramDrag) * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
        }
        return thrust * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param n1 The corrected N1 percent.
     * @param mach The mach number.
     * @returns The corrected gross thrust, in pounds, at the specified corrected N1 and mach.
     */
    calculateThrustFromCorrectedN1(n1, mach) {
        return this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, n1) * this.aircraftFlightModel.static_thrust;
    }
    /**
     * Calculates idle corrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @returns The idle corrected N1 (%) at the specified mach number.
     */
    calculateIdleCorrectedN1(ambientTemperature, mach) {
        // TODO Should this use ambient or TAT? We call it with TAT right now
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        return (mach * this.aircraftFlightModel.mach_influence_on_n1) + (this.aircraftFlightModel.low_idle_n1 / Math.sqrt(thetaTotalTempRatio));
    }
    /**
     * Calculates uncorrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @param correctedN1 The corrected n1.
     * @returns The uncorrected N1 (%) at the specified mach number.
     */
    uncorrectN1(ambientTemperature, mach, correctedN1) {
        const totalInletTempMachRise = 1.0 + 0.2 * mach * mach;
        const StandardSeaLevelTemperature = BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        const ambientRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const theta_temperature_ratio = ambientRankine / StandardSeaLevelTemperature;
        const thetaTotalTempRatio = theta_temperature_ratio * totalInletTempMachRise;
        return correctedN1 * Math.sqrt(thetaTotalTempRatio);
    }
    /**
     * Calculates idle corrected gross thrust, in LBS, for one engine.
     * @param ambientTemperature The Ambient Temperature at the aircraft location in C.
     * @param mach The current aircraft mach number.
     * @returns The idle corrected gross thrust, in LBS, for one engine.
     */
    calculateIdleThrust(ambientTemperature, mach) {
        return this.calculateThrustFromCorrectedN1(this.calculateIdleCorrectedN1(ambientTemperature, mach), mach);
    }
    /**
     * Calculates the uncorrected ram drag provided by an engine, in pounds.
     * @param mach The airplane's mach number.
     * @param n1 The engine's corrected N1, as a percent.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius.
     * @param ambientPressure The ambient pressure, in inches of mercury.
     * @param inletTemp The engine inlet temperature, in Rankine.
     * @returns The uncorrected ram drag provided by an engine, in pounds, with the specified parameters.
     */
    calculateRamDrag(mach, n1, ambientTemperature, ambientPressure, inletTemp) {
        const airflowTableResult = this.aircraftFlightModel.corrected_airflow_table.get(n1, mach);
        const correctedAirflow = airflowTableResult * this.aircraftFlightModel.inlet_area;
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        const deltaTotalPressureRatio = deltaPressureRatio * totalInletPressureMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE; //Divide by sim normal SL temp constant to get thetaTTR
        const airflow = correctedAirflow * deltaTotalPressureRatio / Math.sqrt(thetaTotalTempRatio);
        const speedOfSound = BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemperature);
        return speedOfSound * mach * airflow / BoeingAeroMath.gravity; // Ram Drag in pounds
    }
    /**
     * Finds the uncorrected gross thrust, in pounds, provided by an engine when it is providing a given uncorrected net
     * thrust.
     * @param netThrust The uncorrected net thrust, in pounds, for which to find the gross thrust.
     * @param mach The airplane's mach number.
     * @param altitude The airplane's pressure altitude, in feet.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius. Defaults to ISA temperature for
     * the specified pressure altitude.
     * @param ambientPressure The ambient pressure, in inches of mercury. Defaults to ISA pressure for the specified
     * pressure altitude.
     * @param idleN1 The engine's idle corrected N1, as a percent. If not defined, it will be calculated from the specified mach
     * number and temperature.
     * @returns The uncorrected gross thrust, in pounds, provided by the engine with the specified parameters when it is
     * providing the specified uncorrected net thrust.
     */
    findGrossThrustFromNetThrust(netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1) {
        this.findGrossThrustAndCn1FromNetThrust(BoeingPerformanceDataProvider.vec2Cache, netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1);
        return BoeingPerformanceDataProvider.vec2Cache[0];
    }
    /**
     * Finds the uncorrected gross thrust, in pounds, provided by an engine when it is providing a given uncorrected net
     * thrust.
     * @param out A Vec2 to write the results.
     * @param netThrust The uncorrected net thrust, in pounds, for which to find the gross thrust.
     * @param mach The airplane's mach number.
     * @param altitude The airplane's pressure altitude, in feet.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius. Defaults to ISA temperature for
     * the specified pressure altitude.
     * @param ambientPressure The ambient pressure, in inches of mercury. Defaults to ISA pressure for the specified
     * pressure altitude.
     * @param idleN1 The engine's idle corrected N1, as a percent. If not defined, it will be calculated from the specified mach
     * number and temperature.
     * @returns The uncorrected gross thrust, in pounds, provided by the engine with the specified parameters when it is
     * providing the specified uncorrected net thrust, and the corrected N1 value.
     */
    findGrossThrustAndCn1FromNetThrust(out, netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1) {
        if (!ambientTemperature || !ambientPressure) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            if (!ambientTemperature) {
                ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            }
            if (!ambientPressure) {
                ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            }
        }
        idleN1 !== null && idleN1 !== void 0 ? idleN1 : (idleN1 = this.calculateIdleCorrectedN1(ambientTemperature, mach));
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const thrustCorrectionFactor = BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        const correctedNetThrust = netThrust * thrustCorrectionFactor;
        let lowCorrectedN1 = idleN1;
        let highCorrectedN1 = 110;
        let numIterations = 0;
        let estimatedCorrectedGrossThrust = 0;
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const lowCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, lowCorrectedN1) * this.aircraftFlightModel.static_thrust;
        let lowCorrectedNetThrust = lowCorrectedGrossThrust - this.calculateRamDrag(mach, lowCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        if (correctedNetThrust <= lowCorrectedNetThrust) {
            out[0] = lowCorrectedGrossThrust / thrustCorrectionFactor;
            out[1] = lowCorrectedN1;
            return out;
        }
        const highCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, highCorrectedN1) * this.aircraftFlightModel.static_thrust;
        let highCorrectedNetThrust = highCorrectedGrossThrust - this.calculateRamDrag(mach, highCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        const epsilon = this.aircraftFlightModel.static_thrust * 0.001;
        let estimatedCorrectedN1 = 0;
        while (numIterations < 100) {
            estimatedCorrectedN1 = MathUtils.lerp(correctedNetThrust, lowCorrectedNetThrust, highCorrectedNetThrust, lowCorrectedN1, highCorrectedN1);
            estimatedCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, estimatedCorrectedN1)
                * this.aircraftFlightModel.static_thrust;
            /** corrected net thrust estimate */
            const estimatedNetThrust = estimatedCorrectedGrossThrust
                - (this.calculateRamDrag(mach, estimatedCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor);
            if (Math.abs(estimatedNetThrust - correctedNetThrust) < epsilon) {
                out[0] = estimatedCorrectedGrossThrust / thrustCorrectionFactor;
                out[1] = estimatedCorrectedN1;
                return out;
            }
            const errorSign = Math.sign(estimatedNetThrust - correctedNetThrust);
            if (errorSign < 0) {
                lowCorrectedN1 = estimatedCorrectedN1;
                lowCorrectedNetThrust = estimatedNetThrust;
            }
            else {
                highCorrectedN1 = estimatedCorrectedN1;
                highCorrectedNetThrust = estimatedNetThrust;
            }
            numIterations++;
        }
        out[0] = estimatedCorrectedGrossThrust / thrustCorrectionFactor;
        out[1] = estimatedCorrectedN1;
        return out;
    }
}
BoeingPerformanceDataProvider.vec2Cache = Vec2Math.create();
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;

/**
 * An default implementation of {@link BoeingPathPerformanceProvider} which derives performance data from a
 * {@link BoeingPerformanceDataProvider}.
 */
class DefaultBoeingPathPerformanceProvider {
    /**
     * Creates an instance of DefaultBoeingPathPerformanceProvider.
     * @param performanceData The aircraft's performance data provider.
     */
    constructor(performanceData) {
        this.performanceData = performanceData;
    }
    /** @inheritdoc */
    getWingArea() {
        return this.performanceData.aircraftFlightModel.wing_area * 0.09290304;
    }
    /** @inheritdoc */
    getThrustCorrectionFactor(pressure, mach) {
        return BoeingAeroMath.calculateThrustCorrectionFactor(mach, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineIdleCorrectedN1(temperature, mach) {
        return this.performanceData.calculateIdleCorrectedN1(temperature, mach);
    }
    /** @inheritdoc */
    getEngineIdleGrossThrust(pressure, temperature, mach) {
        return this.getEngineCorrectedGrossThrust(this.getEngineIdleCorrectedN1(temperature, mach), mach) / this.getThrustCorrectionFactor(pressure, mach);
    }
    /** @inheritdoc */
    getEngineCorrectedGrossThrust(n1, mach) {
        return this.performanceData.calculateThrustFromCorrectedN1(n1, mach);
    }
    /** @inheritdoc */
    getEngineRamDrag(n1, mach, pressure, temperature) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(temperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        return this.performanceData.calculateRamDrag(mach, n1, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG), inletTemp);
    }
    /** @inheritdoc */
    getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) {
        return this.getEngineCorrectedGrossThrust(n1, mach) / this.getThrustCorrectionFactor(pressure, mach) - this.getEngineRamDrag(n1, mach, pressure, temperature);
    }
    /** @inheritdoc */
    estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature) {
        return this.performanceData.findGrossThrustFromNetThrust(netThrust, mach, 0, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineFuelFlow(grossThrust) {
        return this.performanceData.calculateFuelFlowFromThrust(grossThrust);
    }
    /** @inheritdoc */
    getRequiredThrust(weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return weight * (sin + this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos));
    }
    /** @inheritdoc */
    getLevelFlightRequiredThrust(weight, cl, flapsIndex) {
        return this.performanceData.calculateThrustRequired(weight, cl, flapsIndex);
    }
    /** @inheritdoc */
    getRequiredEngineGrossThrust(weight, cl, pressure, temperature, tas, vs, flapsIndex, engineCount, mach) {
        mach !== null && mach !== void 0 ? mach : (mach = AeroMath.tasToMach(tas, AeroMath.soundSpeedAir(temperature)));
        const netThrustRequired = this.getRequiredThrust(weight, cl, tas, vs, flapsIndex);
        return this.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
    }
    /** @inheritdoc */
    getLevelFlightRequiredEngineGrossThrust(weight, cl, pressure, temperature, mach, flapsIndex, engineCount) {
        const netThrustRequired = this.performanceData.calculateThrustRequired(weight, cl, flapsIndex);
        return this.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
    }
    /** @inheritdoc */
    getRequiredEngineGrossThrustFromNetThrust(netThrust, pressure, temperature, mach) {
        const idleN1 = this.getEngineIdleCorrectedN1(temperature, mach);
        const idleNetThrust = this.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
        return netThrust <= idleNetThrust
            ? this.getEngineCorrectedGrossThrust(idleN1, mach) / this.getThrustCorrectionFactor(pressure, mach)
            : this.estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature);
    }
    /** @inheritdoc */
    getVerticalSpeed(netThrust, weight, cl, tas, flapsIndex) {
        return UnitType.FPM.convertTo(this.performanceData.calculateConstantSpeedVerticalSpeedFromThrust(netThrust, UnitType.MPS.convertTo(tas, UnitType.KNOT), weight, cl, flapsIndex), UnitType.MPS);
    }
    /** @inheritdoc */
    getAcceleration(netThrust, weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return UnitType.G_ACCEL.convertTo(netThrust / weight - sin - this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos), UnitType.MPS_PER_SEC);
    }
    /** @inheritdoc */
    estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineNetThrust, engineCount, wingArea, flapsIndex, weight, pressure, temperature, out, density, soundSpeed, minAccel = 0.1) {
        let totalTime = 0;
        let totalDistance = 0;
        if (density === undefined) {
            density = AeroMath.densityAir(pressure, temperature);
        }
        // For performance reasons, only calculate engine fuel flow at the starting speed.
        const initialMach = AeroMath.tasToMach(initialTas, soundSpeed !== null && soundSpeed !== void 0 ? soundSpeed : AeroMath.soundSpeedAir(temperature));
        const grossThrustPerEngineRequired = this.getRequiredEngineGrossThrustFromNetThrust(engineNetThrust, pressure, temperature, initialMach);
        const engineFuelFlow = this.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
        let currentTas = initialTas;
        while (Math.abs(finalTas - currentTas) > 0.1) {
            const weightNewtons = weight * 4.44822;
            let acceleration = this.getAcceleration(engineNetThrust * engineCount, weight, AeroMath.liftCoefficient(weightNewtons, wingArea, density, currentTas), currentTas, vs, flapsIndex);
            if (finalTas - currentTas > 0) {
                acceleration = Math.max(minAccel, acceleration);
            }
            else {
                acceleration = Math.min(-minAccel, acceleration);
            }
            const tasStep = MathUtils.clamp(finalTas - currentTas, -3, 3);
            const timeStep = tasStep / acceleration;
            totalTime += timeStep;
            totalDistance += currentTas * timeStep + acceleration * timeStep * timeStep / 2;
            currentTas += acceleration * timeStep;
            weight = Math.max(0, weight - engineFuelFlow * timeStep);
        }
        return Vec2Math.set(totalTime, totalDistance, out);
    }
}

/** Keep this in sync with WTB748_Common.css & WTB78x_Common.css */
class BoeingColors {
}
BoeingColors.black = 'black';
BoeingColors.blackTranslucent = 'rgba(0, 0, 0, 0.2)';
BoeingColors.white = 'white';
BoeingColors.gray = 'hsl(0, 0%, 70%)';
BoeingColors.darkGray = 'hsl(0, 0%, 50%)';
BoeingColors.blue = 'hsl(230, 100%, 51%)';
BoeingColors.red = 'red';
BoeingColors.amber = 'hsl(45, 100%, 50%)';
BoeingColors.green = '#49e700';
BoeingColors.magenta = 'magenta';
BoeingColors.cyan = 'hsl(195, 100%, 50%)';

const MIN_PREDICTIONS_IAS = 160;
const NULL_WIND_ENTRY = { speed: 0, direction: 0, trueDegrees: false };
/**
 * An implementation of {@link FlightPlanPredictionsProvider} that uses {@link BoeingPathCalculator}
 */
class BoeingFlightPlanPredictionsProvider {
    /**
     * Ctor
     * @param bus the bus
     * @param fmsPosIndex the index of the fms position to use
     * @param planIndex the index of the plan to predict data for
     * @param updatePeriod the update period, in milliseconds, at which to update plan predictions
     * @param flightPlanner the flight planner
     * @param windPlanner the wind planner
     * @param verticalPathCalculator the path calculator
     * @param performancePlanRepository the perf plan repo
     * @param perfProvider the perf provider
     * @param facLoader the fac loader
     */
    constructor(bus, fmsPosIndex, planIndex, updatePeriod, flightPlanner, windPlanner, verticalPathCalculator, performancePlanRepository, perfProvider, facLoader) {
        this.bus = bus;
        this.fmsPosIndex = fmsPosIndex;
        this.planIndex = planIndex;
        this.updatePeriod = updatePeriod;
        this.flightPlanner = flightPlanner;
        this.windPlanner = windPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.perfProvider = perfProvider;
        this.facLoader = facLoader;
        this.onPredictionsUpdated = new SubEvent();
        this.updateDebouncer = new DebounceTimer();
        this.realTimeValue = ConsumerValue.create(null, -1);
        this.simTimeValue = ConsumerValue.create(null, -1);
        this.activeLegDistanceAlongValue = ConsumerValue.create(null, -1);
        this.activeLegDtgValue = ConsumerValue.create(null, -1);
        this.pposValue = ConsumerValue.create(null, new LatLongAlt(0, 0));
        this.casValue = ConsumerValue.create(null, 0);
        this.indicatedAltValue = ConsumerValue.create(null, 0);
        /** Indicated airspeed in knots. */
        this.indicatedSpeedValue = ConsumerValue.create(null, 0);
        this.oatValue = ConsumerValue.create(null, 0);
        this.isaValue = ConsumerValue.create(null, 0);
        this.ambientWindMagnitudeValue = ConsumerValue.create(null, 0);
        this.ambientWindDirectionValue = ConsumerValue.create(null, 0);
        this.fobValue = ConsumerValue.create(null, -1);
        this.fuelWeightValue = ConsumerValue.create(null, -1);
        this.fuelFlowValue = ConsumerValue.create(null, -1);
        this.planPredictions = new Map();
        this.trackedFacilityEntries = new Map();
        this.trackedFacilityEntryPredictions = new Map();
        this.trackFacilityLastUpdates = new Map();
        this.resolvedFacilities = new Map();
        this.destinationPredictions = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: true,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
        this.pposPrediction = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: false,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: 0,
        };
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.cachedSyncPacket = { planPredictions: {}, destinationPredictions: {}, trackedFacilityPredictions: {} };
        this.cachedSyncPositions = [];
        this.cachedSyncFacilityPositions = {};
        this.syncSub = this.bus.getSubscriber();
        this.syncPub = this.bus.getPublisher();
        this.initialized = false;
        this.useLocalCalculations = true;
    }
    /**
     * Fixes a Predictions object that was deserialized from JSON.
     * @param predictions The deserialized predictions object.
     * @returns The fixed predictions object.
     */
    static fixDeserializedPredictions(predictions) {
        var _a, _b, _c, _d, _e, _f;
        // We return a new object here to ensure that we don't forget to handle new fields.
        return {
            ident: predictions.ident,
            position: new GeoPoint((_a = predictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = predictions.position.lon) !== null && _b !== void 0 ? _b : NaN),
            valid: predictions.valid,
            distance: (_c = predictions.distance) !== null && _c !== void 0 ? _c : NaN,
            estimatedTimeOfArrival: (_d = predictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN,
            fob: (_e = predictions.fob) !== null && _e !== void 0 ? _e : NaN,
            altitude: (_f = predictions.altitude) !== null && _f !== void 0 ? _f : NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
    }
    /**
     * Initializes the predictor
     *
     * @param useLocalCalculations whether to use local calculations or receive calculations from another calculator
     */
    init(useLocalCalculations) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.useLocalCalculations = useLocalCalculations;
        const sub = this.bus.getSubscriber();
        if (useLocalCalculations) {
            this.setupLocalSyncEvents();
        }
        else {
            this.setupRemoteSyncEvents();
        }
        this.pposValue.setConsumer(sub.on(`fms_pos_gps-position_${this.fmsPosIndex}`));
        this.indicatedAltValue.setConsumer(sub.on('indicated_alt'));
        this.indicatedSpeedValue.setConsumer(sub.on('ias'));
        this.simTimeValue.setConsumer(sub.on('simTime'));
        if (useLocalCalculations) {
            this.realTimeValue.setConsumer(sub.on('realTime'));
            this.activeLegDistanceAlongValue.setConsumer(sub.on('lnav_leg_distance_along'));
            this.activeLegDtgValue.setConsumer(sub.on('lnav_leg_distance_remaining'));
            this.casValue.setConsumer(sub.on('ias'));
            this.oatValue.setConsumer(sub.on('ambient_temp_c'));
            this.isaValue.setConsumer(sub.on('isa_temp_c'));
            this.ambientWindMagnitudeValue.setConsumer(sub.on('ambient_wind_velocity'));
            this.ambientWindDirectionValue.setConsumer(sub.on('ambient_wind_direction'));
            this.fobValue.setConsumer(sub.on('fuel_total_weight'));
            this.fuelWeightValue.setConsumer(sub.on('fuel_weight_per_gallon'));
            this.fuelFlowValue.setConsumer(sub.on('fuel_flow_total'));
            sub.on('fplLegChange').handle(({ legIndex, type }) => {
                const legPredictions = this.planPredictions.get(legIndex);
                switch (type) {
                    case LegEventType.Removed:
                        legPredictions && (legPredictions.valid = false);
                }
            });
        }
        sub.on('realTime').whenChangedBy(this.updatePeriod).handle(this.requestPredictionsUpdate.bind(this));
    }
    /** Set a request to recalculate the predictions */
    requestPredictionsUpdate() {
        // we use a debounce timer to ensure we aren't re-calculating too frequently
        if (!this.updateDebouncer.isPending()) {
            this.updateDebouncer.schedule(() => {
                this.updatePposPrediction();
                if (this.useLocalCalculations) {
                    this.updatePredictions();
                }
            }, 500);
        }
    }
    /**
     * Sets up sync events for receiving remote calculations
     */
    setupRemoteSyncEvents() {
        this.syncSub.on('boeing_predictions_sync').handle((predictions) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
            for (const [index, legPredictions] of Object.entries(predictions.planPredictions)) {
                const existing = this.planPredictions.get(parseInt(index));
                if (existing) {
                    existing.ident = legPredictions.ident;
                    existing.position.set((_a = legPredictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = legPredictions.position.lon) !== null && _b !== void 0 ? _b : NaN);
                    existing.valid = legPredictions.valid;
                    existing.distance = (_c = legPredictions.distance) !== null && _c !== void 0 ? _c : NaN;
                    existing.estimatedTimeOfArrival = (_d = legPredictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN;
                    existing.fob = (_e = legPredictions.fob) !== null && _e !== void 0 ? _e : NaN;
                    existing.altitude = (_f = legPredictions.altitude) !== null && _f !== void 0 ? _f : NaN;
                    existing.speed = (_g = legPredictions.speed) !== null && _g !== void 0 ? _g : NaN;
                    existing.isSpeedMach = (_h = legPredictions.isSpeedMach) !== null && _h !== void 0 ? _h : false;
                    existing.duration = (_j = legPredictions.duration) !== null && _j !== void 0 ? _j : NaN;
                }
                else {
                    this.planPredictions.set(parseInt(index), BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(legPredictions));
                }
            }
            this.destinationPredictions.ident = predictions.destinationPredictions.ident;
            this.destinationPredictions.position.set((_k = predictions.destinationPredictions.position.lat) !== null && _k !== void 0 ? _k : NaN, (_l = predictions.destinationPredictions.position.lon) !== null && _l !== void 0 ? _l : NaN);
            this.destinationPredictions.valid = predictions.destinationPredictions.valid;
            this.destinationPredictions.distance = (_m = predictions.destinationPredictions.distance) !== null && _m !== void 0 ? _m : NaN;
            this.destinationPredictions.estimatedTimeOfArrival = (_o = predictions.destinationPredictions.estimatedTimeOfArrival) !== null && _o !== void 0 ? _o : NaN;
            this.destinationPredictions.fob = (_p = predictions.destinationPredictions.fob) !== null && _p !== void 0 ? _p : NaN;
            for (const [id, facilityPredictions] of Object.entries(predictions.trackedFacilityPredictions)) {
                const existing = this.trackedFacilityEntryPredictions.get(id);
                if (existing && facilityPredictions) {
                    existing.ident = facilityPredictions.ident;
                    existing.position.set((_q = facilityPredictions.position.lat) !== null && _q !== void 0 ? _q : NaN, (_r = facilityPredictions.position.lon) !== null && _r !== void 0 ? _r : NaN);
                    existing.valid = facilityPredictions.valid;
                    existing.distance = (_s = facilityPredictions.distance) !== null && _s !== void 0 ? _s : NaN;
                    existing.estimatedTimeOfArrival = (_t = facilityPredictions.estimatedTimeOfArrival) !== null && _t !== void 0 ? _t : NaN;
                    existing.fob = (_u = facilityPredictions.fob) !== null && _u !== void 0 ? _u : NaN;
                    existing.altitude = (_v = facilityPredictions.altitude) !== null && _v !== void 0 ? _v : NaN;
                    existing.speed = (_w = facilityPredictions.speed) !== null && _w !== void 0 ? _w : NaN;
                    existing.isSpeedMach = (_x = facilityPredictions.isSpeedMach) !== null && _x !== void 0 ? _x : false;
                    existing.duration = (_y = facilityPredictions.duration) !== null && _y !== void 0 ? _y : NaN;
                }
                else if (facilityPredictions) {
                    this.trackedFacilityEntryPredictions.set(id, BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(facilityPredictions));
                }
                else {
                    this.trackedFacilityEntryPredictions.set(id, undefined);
                }
            }
            this.onPredictionsUpdated.notify(this);
        });
    }
    /**
     * Sets up sync events for starting/stopping facility tracking from other predictors
     */
    setupLocalSyncEvents() {
        this.syncSub.on('boeing_predictions_start_tracking_facility').handle(({ id, entry }) => {
            this.startTrackingFacility(id, entry);
        });
        this.syncSub.on('boeing_predictions_stop_tracking_facility').handle((id) => {
            this.stopTrackingFacility(id);
        });
    }
    /**
     * Updates predictions for the flight plan, then notifies subscribers.
     */
    updatePredictions() {
        this.updatePredictionsInternal();
        this.onPredictionsUpdated.notify(this);
        this.syncPredictions();
    }
    /**
     * Update the current ppos 'prediction' with live values.
     */
    updatePposPrediction() {
        this.pposPrediction.position.set(this.pposValue.get().lat, this.pposValue.get().long);
        this.pposPrediction.valid = true;
        this.pposPrediction.distance = 0;
        this.pposPrediction.estimatedTimeOfArrival = this.simTimeValue.get() / 1000;
        this.pposPrediction.fob = this.fobValue.get();
        this.pposPrediction.altitude = UnitType.METER.convertFrom(this.indicatedAltValue.get(), UnitType.FOOT);
        this.pposPrediction.speed = this.indicatedSpeedValue.get();
    }
    /**
     * Updates predictions for the flight plan
     */
    updatePredictionsInternal() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return;
        }
        const cruiseAlt = this.performancePlanRepository.getActivePlan().cruiseAltitude.get();
        const zeroFuelWeight = this.performancePlanRepository.getActivePlan().manualZfw.get();
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        const verticalPath = this.verticalPathCalculator.getVerticalFlightPath(this.planIndex);
        const unixTimestamp = this.simTimeValue.get() / 1000;
        const canComputeAdvancedPredictions = cruiseAlt !== null && zeroFuelWeight !== null;
        const pposValue = this.pposValue.get();
        this.geoPointCache[2].set(pposValue.lat, pposValue.long);
        const _lastPosition = this.geoPointCache[2];
        const altitude = this.indicatedAltValue.get();
        const cas = this.casValue.get();
        const deltaIsa = this.oatValue.get() - this.isaValue.get();
        let _lastGroundSpeedMps = AeroMath.casToTasIsa(cas, altitude, deltaIsa);
        let accumulatedDistance = 0;
        let accumulatedTime = 0;
        for (let i = 0; i < plan.length; i++) {
            let legPredictions = this.planPredictions.get(i);
            const lateralLeg = plan.getLeg(i);
            const previousLateralLeg = plan.tryGetLeg(i - 1);
            const matchingVerticalLeg = verticalPath.legs[i];
            if (i < plan.activeLateralLeg || !matchingVerticalLeg) {
                if (legPredictions) {
                    legPredictions.valid = false;
                }
                this.invalidateTrackedFacilitiesForPosition(i);
                continue;
            }
            const legIsFollowingDiscontinuity = previousLateralLeg
                && ((BoeingFmsUtils.isDiscontinuityLeg(previousLateralLeg.leg.type) && !BitFlags.isAll(previousLateralLeg.flags, LegDefinitionFlags.DirectTo))
                    || BoeingFmsUtils.isVectorsLeg(previousLateralLeg === null || previousLateralLeg === void 0 ? void 0 : previousLateralLeg.leg.type));
            if (legPredictions === undefined) {
                legPredictions = {
                    ident: (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '',
                    position: new GeoPoint(0, 0),
                    valid: true,
                    distance: NaN,
                    estimatedTimeOfArrival: NaN,
                    fob: NaN,
                    altitude: NaN,
                    speed: NaN,
                    isSpeedMach: false,
                    duration: NaN,
                };
                this.planPredictions.set(i, legPredictions);
            }
            legPredictions.ident = (_b = lateralLeg.name) !== null && _b !== void 0 ? _b : '';
            let legDistance = NaN;
            let predictFromPpos = false;
            if (i === plan.activeLateralLeg) {
                // Active leg
                if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type) && matchingVerticalLeg.vectors.length > 0) {
                    // Active vectors leg
                    this.offsetPposAlongVectorsLeg(lateralLeg, 0.1, this.geoPointCache[1]);
                    this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1], legPredictions);
                    accumulatedDistance = legPredictions.distance;
                    // We skip the rest, and do not care about tracked facilities because who would put one on a VECTORS?
                    continue;
                }
                else {
                    accumulatedDistance += UnitType.METER.convertFrom(this.activeLegDtgValue.get(), UnitType.NMILE);
                    if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                        // Active non-vectors leg with a valid VNAV profile
                        accumulatedTime += (_c = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _c !== void 0 ? _c : matchingVerticalLeg.simDuration;
                    }
                    else {
                        // Active non-vectors leg without a valid VNAV profile
                        predictFromPpos = true;
                    }
                }
            }
            else if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type)) {
                // Upcoming vectors legs
                const previousPredictions = this.planPredictions.get(i - 1);
                if (previousPredictions) {
                    legPredictions.valid = previousPredictions.valid;
                    legPredictions.position.set(previousPredictions.position);
                    legPredictions.distance = previousPredictions.distance;
                    legPredictions.estimatedTimeOfArrival = previousPredictions.estimatedTimeOfArrival;
                    legPredictions.fob = previousPredictions.fob;
                    legPredictions.altitude = previousPredictions.altitude;
                    legPredictions.speed = previousPredictions.speed;
                    legPredictions.isSpeedMach = previousPredictions.isSpeedMach;
                    legPredictions.duration = previousPredictions.duration;
                }
                else {
                    legPredictions.valid = false;
                }
                accumulatedDistance += (_d = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _d !== void 0 ? _d : matchingVerticalLeg.simDistance;
                accumulatedTime += (_e = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _e !== void 0 ? _e : matchingVerticalLeg.simDuration;
                continue;
            }
            else if (legIsFollowingDiscontinuity) {
                if (((_f = lateralLeg.calculated) === null || _f === void 0 ? void 0 : _f.endLat) && lateralLeg.calculated.endLon) {
                    // Upcoming leg after discontinuity with valid termination point
                    const distance = GeoPoint.distance(_lastPosition.lat, _lastPosition.lon, lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                    const distanceMeters = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    accumulatedDistance += distanceMeters;
                    accumulatedTime += distanceMeters / _lastGroundSpeedMps;
                }
                else {
                    // Upcoming leg after discontinuity without a valid termination point
                    legPredictions.valid = false;
                    continue;
                }
            }
            else if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                // Upcoming non-vectors leg with a valid VNAV profile
                accumulatedDistance += (_g = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _g !== void 0 ? _g : matchingVerticalLeg.simDistance;
                accumulatedTime += (_h = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _h !== void 0 ? _h : matchingVerticalLeg.simDuration;
            }
            else if (lateralLeg.calculated) {
                // Upcoming non-vectors leg without a valid VNAV profile
                accumulatedDistance += lateralLeg.calculated.distanceWithTransitions;
                accumulatedTime += lateralLeg.calculated.distanceWithTransitions / _lastGroundSpeedMps;
            }
            legDistance = accumulatedDistance;
            if (canComputeAdvancedPredictions && predictFromPpos && ((_j = lateralLeg.calculated) === null || _j === void 0 ? void 0 : _j.endLat) && lateralLeg.calculated.endLon) {
                this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1].set((_k = lateralLeg.calculated) === null || _k === void 0 ? void 0 : _k.endLat, (_l = lateralLeg.calculated) === null || _l === void 0 ? void 0 : _l.endLon), legPredictions);
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (canComputeAdvancedPredictions && matchingVerticalLeg && matchingVerticalLeg.vectors.length !== 0) {
                const lastVector = this.getVerticalVectorForPredictions(matchingVerticalLeg);
                legPredictions.valid = true;
                legPredictions.position.set((_o = (_m = lateralLeg.calculated) === null || _m === void 0 ? void 0 : _m.endLat) !== null && _o !== void 0 ? _o : NaN, (_q = (_p = lateralLeg.calculated) === null || _p === void 0 ? void 0 : _p.endLon) !== null && _q !== void 0 ? _q : NaN);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = unixTimestamp + accumulatedTime;
                legPredictions.fob = lastVector.endWeight - zeroFuelWeight;
                legPredictions.altitude = lastVector.endAltitude;
                const predictedCas = lastVector.endCas;
                const predictedMach = lastVector.endMach;
                const targetCas = lastVector.targetCas;
                const targetMach = lastVector.targetMach;
                // TODO get pressure from vector
                const pressure = AeroMath.isaPressure(lastVector.endAltitude);
                const machCasEquivalent = AeroMath.machToCas(targetMach, pressure);
                const targetMachCasEquivalentKnots = UnitType.KNOT.convertFrom(machCasEquivalent, UnitType.MPS);
                if (targetMachCasEquivalentKnots < targetCas) {
                    legPredictions.speed = predictedMach;
                    legPredictions.isSpeedMach = true;
                }
                else {
                    legPredictions.speed = predictedCas;
                    legPredictions.isSpeedMach = false;
                }
                legPredictions.duration = matchingVerticalLeg.vectors.reduce((acc, vec) => acc + vec.duration, 0);
                const gs = this.getPredictedGroundSpeedAtEndOfLeg(matchingVerticalLeg);
                if (gs !== undefined && gs !== 0) {
                    _lastGroundSpeedMps = gs;
                }
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (lateralLeg.calculated && lateralLeg.calculated.endLat !== undefined && lateralLeg.calculated.endLon !== undefined) {
                legPredictions.valid = true;
                legPredictions.position.set(lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = NaN;
                legPredictions.fob = NaN;
                legPredictions.altitude = NaN;
                legPredictions.speed = NaN;
                legPredictions.isSpeedMach = false;
                legPredictions.duration = NaN;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            else {
                legPredictions.valid = false;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            if (legPredictions.valid) {
                Number.isFinite(legPredictions.position.lat) && _lastPosition.set(legPredictions.position);
            }
        }
        // Update tracked facilities with no leg index
        if (canComputeAdvancedPredictions) {
            for (const [id, entry] of this.getTrackedFacilityEntriesForPosition('direct')) {
                this.updateTrackedFacilityPredictionsFromPpos(id, entry);
            }
        }
        else {
            this.invalidateAllTrackedFacilities();
        }
        this.updateDestinationPredictions(canComputeAdvancedPredictions);
    }
    /**
     * Sync locally calculated predictions data to remote instruments
     */
    syncPredictions() {
        for (const [index, legPredictions] of this.planPredictions.entries()) {
            if (!this.cachedSyncPacket.planPredictions[index]) {
                this.cachedSyncPacket.planPredictions[index] = {};
            }
            Object.assign(this.cachedSyncPacket.planPredictions[index], legPredictions);
            if (!this.cachedSyncPositions[index]) {
                this.cachedSyncPositions[index] = { lat: 0, lon: 0 };
            }
            this.cachedSyncPositions[index].lat = legPredictions.position.lat;
            this.cachedSyncPositions[index].lon = legPredictions.position.lon;
            this.cachedSyncPacket.planPredictions[index].position = this.cachedSyncPositions[index];
        }
        Object.assign(this.cachedSyncPacket.destinationPredictions, this.destinationPredictions);
        if (!this.cachedSyncPositions[Number.MAX_SAFE_INTEGER]) {
            this.cachedSyncPositions[Number.MAX_SAFE_INTEGER] = { lat: 0, lon: 0 };
        }
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lat = this.destinationPredictions.position.lat;
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lon = this.destinationPredictions.position.lon;
        this.cachedSyncPacket.destinationPredictions.position = this.cachedSyncPositions[Number.MAX_SAFE_INTEGER];
        for (const [id] of this.trackedFacilityEntries) {
            const predictions = this.trackedFacilityEntryPredictions.get(id);
            if (predictions) {
                if (!this.cachedSyncPacket.trackedFacilityPredictions[id]) {
                    this.cachedSyncPacket.trackedFacilityPredictions[id] = {};
                }
                Object.assign(this.cachedSyncPacket.trackedFacilityPredictions[id], predictions);
                if (!this.cachedSyncFacilityPositions[id]) {
                    this.cachedSyncFacilityPositions[id] = { lat: 0, lon: 0 };
                }
                this.cachedSyncFacilityPositions[id].lat = predictions.position.lat;
                this.cachedSyncFacilityPositions[id].lon = predictions.position.lon;
                this.cachedSyncPacket.trackedFacilityPredictions[id].position = this.cachedSyncFacilityPositions[id];
            }
            else {
                this.cachedSyncPacket.trackedFacilityPredictions[id] = null;
            }
        }
        this.syncPub.pub('boeing_predictions_sync', this.cachedSyncPacket, true);
    }
    /**
     * Updates a tracked facility entry's predictions based on the predictions of a given leg index
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     * @param legIndex the leg index
     */
    updateTrackedFacilityPredictionsAfterLeg(id, entry, legIndex) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        const legPredictions = this.planPredictions.get(legIndex);
        if (!legPredictions || !legPredictions.valid) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        this.trackFacilityLastUpdates.set(entry, this.realTimeValue.get());
        const distance = legPredictions.position.distance(facilityPredictions.position);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(legPredictions.position, facilityPredictions.position, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions, legPredictions.estimatedTimeOfArrival, legPredictions.fob);
    }
    /**
     * Updates a tracked facility entry's predictions based on PPOS
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     */
    updateTrackedFacilityPredictionsFromPpos(id, entry) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        const ppos = this.pposValue.get();
        const distance = GeoPoint.distance(facility.lat, facility.lon, ppos.lat, ppos.long);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions);
    }
    /**
     * Linearly predicts over a distance with fixed parameters
     *
     * @param startLla the position to predict at
     * @param endLla the position to predict at
     * @param distance the distance, in metres, over which to predict
     * @param speed the speed, in knots CAS or mach number, to predict at
     * @param speedIsMach whether {@link speed} is a mach number
     * @param altitude the altitude, in metres, to predict at
     * @param oatTemperature the outside air temperature, in Celsius, to predict at
     * @param oatAltitude the altitude of measure of {@link oatTemperature}
     * @param wind the wind vector to predict with
     * @param out the predictions object to hold the results
     * @param startingTime the starting time, or the current time if not provided
     * @param startingFob the starting fob, or the current fob if not provided
     */
    predictLinearly(startLla, endLla, distance, speed, speedIsMach, altitude, oatTemperature, oatAltitude, wind, out, startingTime, startingFob) {
        var _a;
        const unixTimestamp = startingTime !== null && startingTime !== void 0 ? startingTime : (this.simTimeValue.get() / 1000);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.METER);
        const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.METER);
        let predictionFuelFlow;
        const predictionOatIsaDev = oatTemperature - AeroMath.isaTemperature(oatAltitude);
        let predictionTrueAirspeed;
        if (speedIsMach) {
            predictionTrueAirspeed = AeroMath.machToTasIsa(speed, altitude, predictionOatIsaDev);
        }
        else {
            const predictionCasMps = UnitType.MPS.convertFrom(speed, UnitType.KNOT);
            predictionTrueAirspeed = AeroMath.casToTasIsa(predictionCasMps, altitude, predictionOatIsaDev);
        }
        const predictionTrueAirSpeedKnots = UnitType.KNOT.convertFrom(predictionTrueAirspeed, UnitType.MPS);
        const currentWeight = ((_a = this.performancePlanRepository.getActivePlan().manualZfw.get()) !== null && _a !== void 0 ? _a : 0) + this.fobValue.get();
        predictionFuelFlow = this.getInstantaneousFuelFlowIsa(altitude, predictionTrueAirspeed, predictionOatIsaDev, currentWeight, 0);
        // Cache great circle between positions
        this.geoCircleCache[0].setAsGreatCircle(startLla, endLla);
        let windKnots = FlightPathUtils.projectVelocityToCircle(wind.speed, startLla, wind.trueDegrees ? wind.direction : MagVar.magneticToTrue(wind.direction, startLla), this.geoCircleCache[0]);
        if (!Number.isFinite(windKnots)) {
            windKnots = 0;
        }
        const predictionGroundSpeed = predictionTrueAirSpeedKnots + windKnots;
        const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
        if (predictionFuelFlow === undefined) {
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            predictionFuelFlow = fuelFlowPph / 3600;
        }
        const currentFob = startingFob !== null && startingFob !== void 0 ? startingFob : this.fobValue.get();
        out.valid = true;
        out.position.set(endLla);
        out.distance = distanceMetres;
        out.estimatedTimeOfArrival = unixTimestamp + durationSeconds;
        out.fob = currentFob - (durationSeconds * predictionFuelFlow);
        out.altitude = altitude;
        out.speed = speed;
        out.isSpeedMach = speedIsMach;
        out.duration = durationSeconds;
    }
    /**
     * Predicts performance linearly, with current conditions
     *
     * @param startLla the start point of the predictions
     * @param endLla the end point of the predictions
     * @param out the predictions object to hold the results
     */
    predictLinearlyWithCurrentConditions(startLla, endLla, out) {
        const distance = GeoPoint.distance(startLla, endLla);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        const speed = Math.max(MIN_PREDICTIONS_IAS, this.casValue.get());
        const altitude = this.indicatedAltValue.get();
        const altitudeMetres = UnitType.METER.convertFrom(altitude, UnitType.FOOT);
        const oat = this.oatValue.get();
        const wind = {
            speed: this.ambientWindMagnitudeValue.get(),
            direction: this.ambientWindDirectionValue.get(),
            trueDegrees: true,
        };
        this.predictLinearly(startLla, endLla, distanceMetres, speed, false, altitudeMetres, oat, altitudeMetres, wind, out);
    }
    /**
     * Offsets the present position along a vectors leg
     *
     * @param vectorsLeg the vectors leg
     * @param distanceToAdd the distance, in nautical miles, to offset by
     * @param out where the resulting position will be stored
     */
    offsetPposAlongVectorsLeg(vectorsLeg, distanceToAdd, out) {
        var _a;
        const distanceAlong = this.activeLegDistanceAlongValue.get();
        const distanceAlongGa = UnitType.GA_RADIAN.convertFrom(Math.max(0, distanceAlong) + distanceToAdd, UnitType.NMILE);
        if (((_a = vectorsLeg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) === undefined || vectorsLeg.calculated.startLon === undefined || vectorsLeg.calculated.initialDtk === undefined) {
            return;
        }
        this.geoPointCache[1].set(vectorsLeg.calculated.startLat, vectorsLeg.calculated.startLon);
        this.geoCircleCache[1].setAsGreatCircle(this.geoPointCache[1], vectorsLeg.calculated.initialDtk + vectorsLeg.calculated.courseMagVar);
        this.geoCircleCache[1].offsetDistanceAlong(this.geoPointCache[1], distanceAlongGa, out);
    }
    /**
     * Gets the predicited ground speed at the end of a vertical leg.
     * @param verticalLeg The vertical leg to get the predicted ground speed for.
     * @returns The predicted grouns speed, or undefined if one could not be determined.
     */
    getPredictedGroundSpeedAtEndOfLeg(verticalLeg) {
        if (verticalLeg.vectors.length === 0) {
            return undefined;
        }
        const lastVector = this.getVerticalVectorForPredictions(verticalLeg);
        return lastVector.gs;
    }
    /**
     * Returns the total distance of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDistance(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
        }
        return distance;
    }
    /**
     * Returns the total duration of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDuration(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.duration;
        }
        return distance;
    }
    /**
     * Returns the vertical path vector of a vertical leg that should be used for predictions, or the last vector if none are eligible
     *
     * **Note:** this function assumes the leg contains at least one vector
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a {@link VerticalFlightPathVector}
     */
    getVerticalVectorForPredictions(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return verticalLeg.vectors[verticalLeg.vectors.length - 1];
        }
        return verticalLeg.vectors[lastVectorIndex];
    }
    /**
     * Returns the index of the last vertical path vector that is contained within the lateral path of a leg
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a number, or -1 if no eligible vectors found
     */
    getLastVerticalVectorIndexAlongLegPath(verticalLeg) {
        for (let i = verticalLeg.vectors.length - 1; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            if (vector.startDistanceToLegEnd >= 0) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Calculates the instantaneous fuel flow for given parameters at ISA conditions
     *
     * @param altitude the altitude, in metres
     * @param tas the true airspeed, in metres per second
     * @param isaDev the ISA temperature deviation, in degrees Celsius
     * @param weight the weight, in pounds
     * @param flapsIndex The flaps index to use, or zero for a clean configuration.
     *
     * @returns the fuel flow, in pounds per second
     */
    getInstantaneousFuelFlowIsa(altitude, tas, isaDev, weight, flapsIndex) {
        const weightForce = UnitType.NEWTON.convertFrom(weight, UnitType.POUND_FORCE);
        const density = AeroMath.isaDensity(altitude, isaDev);
        const cl = AeroMath.liftCoefficient(weightForce, this.perfProvider.getWingArea(), density, tas);
        const thrust = this.perfProvider.getLevelFlightRequiredThrust(weight, cl, flapsIndex);
        const mach = AeroMath.tasToMachIsa(tas, altitude, AeroMath.soundSpeedIsa(altitude, isaDev));
        const grossThrust = this.perfProvider.estimateGrossThrustFromNetThrust(thrust, mach, AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + isaDev);
        return this.perfProvider.getEngineFuelFlow(grossThrust) / 3600;
    }
    /**
     * Returns the predictions object for a tracked facility entry, creating a new empty and invalid object if none is present
     *
     * @param id the unique id for the tracked facility entry
     * @param entry the tracked facility entry
     *
     * @returns a {@link Predictions} object
     */
    getTrackedFacilityPredictions(id, entry) {
        var _a;
        const predictions = this.trackedFacilityEntryPredictions.get(id);
        if (!predictions) {
            const emptyPredictions = {
                ident: (_a = ICAO.getIdent(entry.facIcao)) !== null && _a !== void 0 ? _a : '',
                position: new GeoPoint(NaN, NaN),
                valid: false,
                distance: NaN,
                estimatedTimeOfArrival: NaN,
                fob: NaN,
                altitude: NaN,
                groundSpeed: NaN,
                speed: NaN,
                isSpeedMach: false,
                duration: NaN,
            };
            this.trackedFacilityEntryPredictions.set(id, emptyPredictions);
            return emptyPredictions;
        }
        return predictions;
    }
    /**
     * Updates the destination prediction
     *
     * @param computeAdvancedPredictions whether to computer advanced predictions, or just distance
     */
    updateDestinationPredictions(computeAdvancedPredictions) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let mapIndex = -1;
        if (plan.length > 0) {
            for (let i = plan.length - 1; i > 0; i--) {
                const planLeg = plan.tryGetLeg(i);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    mapIndex = i;
                }
            }
        }
        // Use the MAP index if it is available
        if (mapIndex !== -1) {
            const mapLegPredictions = this.planPredictions.get(mapIndex);
            if (mapLegPredictions && mapLegPredictions.valid) {
                this.destinationPredictions.valid = true;
                Object.assign(this.destinationPredictions, mapLegPredictions);
                return;
            }
        }
        // Otherwise, predict using the prediction at the last non-missed-approach plan leg + great circle direct
        // distance to the destination airport reference point
        if (plan.length > 0 && plan.destinationAirport) {
            let lastNonMissedApproachLegIndex = -1;
            for (let i = plan.length - 1; i > 0; i--) {
                const leg = plan.getLeg(i);
                if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
                    lastNonMissedApproachLegIndex = i;
                    break;
                }
            }
            if (lastNonMissedApproachLegIndex !== -1) {
                const backwardsIterator = this.iteratePredictionsReverse(lastNonMissedApproachLegIndex);
                let lastLegPredictions;
                let prevLastLegPredictions;
                for (const predictions of backwardsIterator) {
                    if (!prevLastLegPredictions && lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        prevLastLegPredictions = predictions;
                        break;
                    }
                    if (!lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        lastLegPredictions = predictions;
                    }
                }
                if (prevLastLegPredictions && lastLegPredictions) {
                    this.destinationPredictions.valid = true;
                    Object.assign(this.destinationPredictions, lastLegPredictions);
                    const airportFacility = this.resolvedFacilities.get(plan.destinationAirport);
                    if (!airportFacility) {
                        this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                        this.destinationPredictions.valid = false;
                        return;
                    }
                    const distance = lastLegPredictions.position.distance(airportFacility);
                    const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    if (Math.abs(prevLastLegPredictions.distance - lastLegPredictions.distance) > Number.EPSILON) {
                        BoeingFlightPlanPredictionsProvider.extrapolatePrediction(prevLastLegPredictions, lastLegPredictions, distanceMetres, this.destinationPredictions);
                    }
                    else {
                        this.predictLinearly(lastLegPredictions.position, this.geoPointCache[0].set(airportFacility.lat, airportFacility.lon), distanceMetres, UnitType.MPS.convertFrom(MIN_PREDICTIONS_IAS, UnitType.KNOT), false, lastLegPredictions.altitude, 15, 0, NULL_WIND_ENTRY, this.destinationPredictions);
                    }
                    return;
                }
            }
        }
        // In the worst case scenario, predict the great circle direct distance from PPOS to the destination airport reference point
        if (plan.destinationAirport) {
            const facility = this.resolvedFacilities.get(plan.destinationAirport);
            if (!facility) {
                this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                this.destinationPredictions.valid = false;
                return;
            }
            const ppos = this.pposValue.get();
            this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, this.destinationPredictions);
            if (!computeAdvancedPredictions) {
                this.destinationPredictions.estimatedTimeOfArrival = NaN;
                this.destinationPredictions.fob = NaN;
                this.destinationPredictions.altitude = NaN;
                this.destinationPredictions.speed = NaN;
                this.destinationPredictions.isSpeedMach = false;
                this.destinationPredictions.duration = NaN;
            }
            return;
        }
        // Otherwise mark the destination predictions as invalid
        this.destinationPredictions.valid = false;
    }
    /**
     * Invalidates all tracked facility predictions
     */
    invalidateAllTrackedFacilities() {
        for (const [, predictions] of this.trackedFacilityEntryPredictions.entries()) {
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Invalidates all tracked facility predictions attached to a given position
     *
     * @param position the position
     */
    invalidateTrackedFacilitiesForPosition(position) {
        const entries = this.getTrackedFacilityEntriesForPosition(position);
        for (const [entry] of entries) {
            const predictions = this.trackedFacilityEntryPredictions.get(entry);
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Returns all facility tracking entries for a given position
     *
     * @param position the position
     *
     * @returns an array of {@link FacilityPredictionsTrackingEntry} objects
     */
    getTrackedFacilityEntriesForPosition(position) {
        const indices = [];
        for (const mapEntry of this.trackedFacilityEntries.entries()) {
            const [, entry] = mapEntry;
            if (entry.startAfterFlightPlanLeg === position) {
                indices.push(mapEntry);
            }
        }
        return indices;
    }
    /** @inheritDoc */
    *iteratePredictions(startGlobalLegIndex = 0) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = startGlobalLegIndex; i < plan.length; i++) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    *iteratePredictionsReverse(startGlobalLegIndex = this.flightPlanner.getFlightPlan(this.planIndex).length - 1) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = Math.min(plan.length - 1, startGlobalLegIndex); i > 0; i--) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    getPredictionsForLeg(globalLegIndex) {
        return this.planPredictions.get(globalLegIndex);
    }
    /** @inheritDoc */
    getDestinationPredictions() {
        return this.destinationPredictions;
    }
    /** @inheritDoc */
    getPredictionsForTrackedFacility(id) {
        var _a;
        return (_a = this.trackedFacilityEntryPredictions.get(id)) !== null && _a !== void 0 ? _a : undefined;
    }
    /** @inheritDoc */
    startTrackingFacility(id, entry) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_start_tracking_facility', { id, entry }, true);
            return;
        }
        this.trackedFacilityEntries.set(id, entry);
        this.facLoader.getFacility(ICAO.getFacilityType(entry.facIcao), entry.facIcao).then((facility) => {
            this.resolvedFacilities.set(entry.facIcao, facility);
            this.requestPredictionsUpdate();
        });
    }
    /** @inheritDoc */
    stopTrackingFacility(id) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_stop_tracking_facility', id, true);
            return true;
        }
        return this.trackedFacilityEntries.delete(id) && this.trackedFacilityEntryPredictions.delete(id);
    }
    /** @inheritDoc */
    getPredictionsForTime(time, predictActiveLeg = false) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('estimatedTimeOfArrival', time, 1, predictActiveLeg);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const ratio = (time - predictionsBefore.estimatedTimeOfArrival) / (predictionsAfter.estimatedTimeOfArrival - predictionsBefore.estimatedTimeOfArrival);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, ratio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForAltitude(altitude, predictActiveLeg = false) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let startAltitude;
        let crossingDirection = 1;
        for (let i = plan.activeLateralLeg; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            const isActiveLeg = i === plan.activeLateralLeg;
            if (isActiveLeg && predictActiveLeg) {
                startAltitude = this.pposPrediction.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            else if (startAltitude === undefined && predictions.valid) {
                startAltitude = predictions.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            if (crossingDirection > 0 && predictions.altitude > altitude) {
                predictionsBefore = isActiveLeg && predictActiveLeg ? this.pposPrediction : this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
            if (crossingDirection < 0 && predictions.altitude < altitude) {
                predictionsBefore = isActiveLeg && predictActiveLeg ? this.pposPrediction : this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return undefined;
        }
        const altitudeRatio = Math.abs(altitude - predictionsBefore.altitude) / Math.abs(predictionsAfter.altitude - predictionsBefore.altitude);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, altitudeRatio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForDistance(distance, predictActiveLeg = false) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('distance', distance, 1, predictActiveLeg);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const distanceRatio = (distance - predictionsBefore.distance) / (predictionsAfter.distance - predictionsBefore.distance);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, distanceRatio, out);
        return out;
    }
    /**
     * Gets the bounding (previous and next) leg predictions that surround a given value of a property
     *
     * @param discriminant the property to evaluate
     * @param value the value (the value the previous prediction must be below, and the next prediction above)
     * @param progression the progression direction: if -1, inverts the example conditions of the {@link value} param
     * @param predictActiveLeg Whether to use the current aircraft state to predict the active leg.
     * Defaults to false.
     * @returns a tuple of {@link Predictions} objects, or null if none found
     */
    getBoundingLegPredictions(discriminant, value, progression, predictActiveLeg = false) {
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = plan.activeLateralLeg; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            if (progression > 0 ? predictions[discriminant] < value : predictions[discriminant] > value) {
                predictionsBefore = predictions;
                continue;
            }
            if (progression > 0 ? predictions[discriminant] > value : predictions[discriminant] < value) {
                predictionsAfter = predictions;
                if (i === plan.activeLateralLeg && predictActiveLeg) {
                    predictionsBefore = this.pposPrediction;
                }
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return null;
        }
        return [predictionsBefore, predictionsAfter];
    }
    /**
     * Loads a facility and schedules a predictions update
     *
     * @param facilityIcao the facility ICAO
     */
    loadFacilityAndScheduleUpdate(facilityIcao) {
        this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao).then((loadedFac) => {
            this.resolvedFacilities.set(facilityIcao, loadedFac);
            this.requestPredictionsUpdate();
        });
    }
    /**
     * Linearly interpolates two prediction objects
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param ratio the ratio to interpolate at
     * @param out the output value object
     */
    static linearlyInterpolatePredictions(predictionsA, predictionsB, ratio, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsA.distance + (ratio * (predictionsB.distance - predictionsA.distance));
            out.estimatedTimeOfArrival = predictionsA.estimatedTimeOfArrival + (ratio * (predictionsB.estimatedTimeOfArrival - predictionsA.estimatedTimeOfArrival));
            out.fob = predictionsA.fob + (ratio * (predictionsB.fob - predictionsA.fob));
            out.altitude = predictionsA.altitude + (ratio * (predictionsB.altitude - predictionsA.altitude));
            out.speed = predictionsA.speed + (ratio * (predictionsB.speed - predictionsA.speed));
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
    /**
     * Linearly extrapolates two prediction objects into another prediction given an additional distance flown
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param additionalDistance the additional distance to extrapolate to
     * @param out the output value object
     */
    static extrapolatePrediction(predictionsA, predictionsB, additionalDistance, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsB.distance + additionalDistance;
            out.estimatedTimeOfArrival = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival);
            out.fob = MathUtils.lerp(out.estimatedTimeOfArrival, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival, predictionsA.fob, predictionsB.fob);
            out.altitude = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.altitude, predictionsB.altitude);
            out.speed = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.speed, predictionsB.speed);
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Renders 2 elements, both with the passed class, and the first element with the outlineClass.
 * Saves you from having to write out 2 elements everytime you want an outline in svg.
 */
class OutlinedElement extends DisplayComponent {
    /** @inheritdoc*/
    render() {
        const _a = this.props, { tag, className, outlineClass } = _a, other = __rest(_a, ["tag", "className", "outlineClass"]);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const OutlinedTag = tag;
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(OutlinedTag, Object.assign({ class: (className !== null && className !== void 0 ? className : '') + ' ' + (outlineClass !== null && outlineClass !== void 0 ? outlineClass : '') }, other)),
            FSComponent.buildComponent(OutlinedTag, Object.assign({ class: className !== null && className !== void 0 ? className : '' }, other))));
    }
}

/** The CurrentHeadingTriangle component. */
class CurrentHeadingTriangle extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.currentHeadingRotation.sub(hdg => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${hdg * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /**
     * Builds a current heading triangle element.
     * @param compassRadius The compass radius.
     * @param ref The ref to use.
     * @param canvasScale The canvas scale to use, defaults to 1.
     * @param svgScale the svg scale to use, defaults to 1.
     * @returns the heading triangle svg element.
     */
    static build(compassRadius, ref, canvasScale = 1, svgScale = 1) {
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: ref, class: "current-heading-triangle", viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * canvasScale, height: sizeUnscaled * canvasScale, style: `position: absolute; transform: translateY(${compassRadius * -1}px)` },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M -13 -26 l 13 26 l 13 -26 z", "vector-effect": "non-scaling-stroke", transform: `scale(${svgScale})` })));
    }
    /** @inheritdoc */
    render() {
        return CurrentHeadingTriangle.build(this.props.compassRadius, this.svgRef, this.props.ndDataProvider.canvasScale, this.props.svgScale);
    }
}

/** The SelectedHeadingBug component. */
class SelectedHeadingBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isInertialHeadingDataValid, selHdgOrTrk]) => {
            const isVisible = isInertialHeadingDataValid && selHdgOrTrk === 'heading';
            return !isVisible;
        }, this.props.ndDataProvider.isInertialHeadingDataValid, this.props.ndDataProvider.selHdgOrTrk);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /**
     * Builds a selected heading bug element.
     * @param ref The ref to use.
     * @param canvasScale The canvas scale to use, defaults to 1.
     * @param svgScale the svg scale to use, defaults to 1.
     * @param isHidden Whether bug should be hidden or not. Defaults to false.
     * @returns the selected heading bug svg element.
     */
    static build(ref, canvasScale = 1, svgScale = 1, isHidden) {
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: ref, class: {
                'selected-heading-bug': true,
                'hidden': isHidden !== null && isHidden !== void 0 ? isHidden : false,
            }, viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * canvasScale, height: sizeUnscaled * canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M 0 0 l -23 0 l 0 -18 l 10 0 l 10 18 l 6 0 l 10 -18 l 10 0 l 0 18 z", stroke: BoeingColors.magenta, "vector-effect": "non-scaling-stroke", transform: `scale(${svgScale})` })));
    }
    /** @inheritdoc */
    render() {
        return SelectedHeadingBug.build(this.svgRef, this.props.ndDataProvider.canvasScale, this.props.svgScale, this.isHidden);
    }
}

/**
 * A Boeing PFD attitude indicator airplane symbol.
 */
class PfdAirplaneSymbol extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.style = ObjectSubject.create({
            display: '',
            position: 'absolute',
            left: '0px',
            top: '0px',
            transform: 'translate(-50%, -50%)',
            overflow: 'visible'
        });
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.style.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.updatePosition();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updatePosition();
        }
    }
    /**
     * Updates this symbol's position.
     */
    updatePosition() {
        const offsetCenter = this.props.projection.getOffsetCenterProjected();
        this.style.set('left', `${offsetCenter[0]}px`);
        this.style.set('top', `${offsetCenter[1]}px`);
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("svg", { viewBox: '-192 -30 384 60', preserveAspectRatio: 'none', class: 'pfd-airplane-symbol', style: this.style },
                FSComponent.buildComponent("path", { d: 'M -192 -7 l 101 0 l 0 37 l -14 0 l 0 -23 l -87 0 z M 192 -7 l -101 0 l 0 37 l 14 0 l 0 -23 l 87 0 z', class: 'pfd-airplane-symbol-wings shadow', "stroke-linejoin": 'round' }),
                FSComponent.buildComponent("path", { d: 'M -192 -7 l 101 0 l 0 37 l -14 0 l 0 -23 l -87 0 z M 192 -7 l -101 0 l 0 37 l 14 0 l 0 -23 l 87 0 z', class: 'pfd-airplane-symbol-wings', "stroke-linejoin": 'round' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/**
 * A Boeing PFD artificial horizon. Displays sky and ground boxes.
 */
class PfdArtificialHorizon extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.horizonLineConformalBounds, true);
        this.pitchResolution = 0; // pixels per degree
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.windowTransform = new Transform2D();
        this.windowTransformInverse = new Transform2D();
        this.horizonProjected = Vec2Math.create();
        this.horizonOffset = Vec2Math.create();
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.canvasLayerRef.instance.setVisible(isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.conformalBoundsSub = this.conformalBounds.sub(() => {
            this.needUpdate = true;
        });
        this.updatePitchResolution();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        this.canvasLayerRef.instance.onProjectionChanged(projection, changeFlags);
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.PitchScaleFactor)) {
            this.updatePitchResolution();
        }
        this.needUpdate = true;
    }
    /**
     * Updates the pitch resolution used to draw this horizon.
     */
    updatePitchResolution() {
        this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov() * this.props.projection.getPitchScaleFactor();
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        // Approximate translation due to pitch using a constant pitch resolution (pixels per degree of pitch) derived
        // from the projection's current field of view. The error of this approximation increases with the absolute
        // deviation of the pitch angle from 0 degrees. We do this instead of simply projecting the true horizon line
        // because we need to keep the line in sync with the pitch ladder, which uses the same approximation.
        const center = this.props.projection.getOffsetCenterProjected();
        const roll = this.props.projection.getRoll();
        Vec2Math.set(0, 0, this.horizonProjected);
        this.windowTransform
            .toTranslation(0, this.pitchResolution * this.props.projection.getPitch())
            .addRotation(-roll * Avionics.Utils.DEG2RAD)
            .addTranslation(center[0], center[1])
            .apply(this.horizonProjected, this.horizonProjected);
        this.updateOffset();
        this.drawHorizonRects();
    }
    /**
     * Updates the offset to apply to this horizon line's projection to keep it within the conformal bounds.
     */
    updateOffset() {
        const bounds = this.conformalBounds.get();
        if (this.props.projection.isInProjectedBounds(this.horizonProjected, bounds)) {
            // The horizon line is within the conformal bounds.
            Vec2Math.set(0, 0, this.horizonOffset);
        }
        else {
            // The horizon line is not within the conformal bounds. Find the smallest offset toward the center of the
            // projection that brings it within the conformal bounds.
            const center = this.props.projection.getOffsetCenterProjected();
            const conformalX = this.horizonProjected[0];
            const conformalY = this.horizonProjected[1];
            let displayX = conformalX;
            let displayY = conformalY;
            if (displayX < bounds[0]) {
                displayY = MathUtils.lerp(bounds[0], center[0], displayX, center[1], displayY);
                displayX = bounds[0];
            }
            else if (displayX > bounds[2]) {
                displayY = MathUtils.lerp(bounds[2], center[0], displayX, center[1], displayY);
                displayX = bounds[2];
            }
            if (displayY < bounds[1]) {
                displayX = MathUtils.lerp(bounds[1], center[1], displayY, center[0], displayX);
                displayY = bounds[1];
            }
            else if (displayY > bounds[3]) {
                displayX = MathUtils.lerp(bounds[3], center[1], displayY, center[0], displayX);
                displayY = bounds[3];
            }
            Vec2Math.set(displayX - conformalX, displayY - conformalY, this.horizonOffset);
        }
    }
    /**
     * Draws the horizon rects to the canvas.
     */
    drawHorizonRects() {
        const context = this.canvasLayerRef.instance.display.context;
        const projectedSize = this.props.projection.getProjectedSize();
        context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
        // windowTransform applies a transformation to move a horizon centered at (0, 0) to its conformal projected
        // position and rotation. Before we use it to draw the rects we need to add the offset to bring the horizon within
        // the conformal bounds.
        const transform = this.windowTransform
            .addTranslation(this.horizonOffset[0], this.horizonOffset[1]);
        const inverse = this.windowTransformInverse
            .set(this.windowTransform)
            .invert();
        const windowUl = inverse.apply(Vec2Math.set(0, 0, this.vec2Cache[0]), this.vec2Cache[0]);
        const windowUr = inverse.apply(Vec2Math.set(projectedSize[0], 0, this.vec2Cache[1]), this.vec2Cache[1]);
        const windowLl = inverse.apply(Vec2Math.set(0, projectedSize[1], this.vec2Cache[2]), this.vec2Cache[2]);
        const windowLr = inverse.apply(Vec2Math.set(projectedSize[0], projectedSize[1], this.vec2Cache[3]), this.vec2Cache[3]);
        const minX = Math.min(windowUl[0], windowUr[0], windowLl[0], windowLr[0]);
        const maxX = Math.max(windowUl[0], windowUr[0], windowLl[0], windowLr[0]);
        const minY = Math.min(windowUl[1], windowUr[1], windowLl[1], windowLr[1]);
        const maxY = Math.max(windowUl[1], windowUr[1], windowLl[1], windowLr[1]);
        if (maxY > 0) {
            context.beginPath();
            let p = transform.apply(Vec2Math.set(minX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.moveTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, maxY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(minX, maxY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            context.closePath();
            context.fillStyle = this.props.options.groundColor;
            context.fill();
        }
        if (minY < 0) {
            context.beginPath();
            let p = transform.apply(Vec2Math.set(minX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.moveTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, minY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(minX, minY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            context.closePath();
            context.fillStyle = this.props.options.skyColor;
            context.fill();
        }
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(HorizonSyncedCanvasLayer, { ref: this.canvasLayerRef, projection: this.props.projection, class: 'pfd-artificial-horizon' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.conformalBoundsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.canvasLayerRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD bank indicator. Displays a bank scale, bank pointer, and slip-skid indicator.
 */
class PfdBankIndicator extends HorizonLayer {
    constructor() {
        // NOTE: Everything in this component is referenced to a coordinate system with the horizon projection projected
        // center as the origin and axes aligned with the horizon projection.
        super(...arguments);
        this.rootStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
        });
        this.pointerTransform = CssTransformSubject.create(CssTransformBuilder.rotate3d('deg'));
        this.slipSkidTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.slipSkidTranslateScale = 0;
        this.pointerHidden = this.props.showPointer.map(SubscribableMapFunctions.not());
        this.isBankAlertActive = Subject.create(false);
        this.isSlipSkidAlertActive = Subject.create(false);
        this.needUpdateBank = false;
        this.needUpdateSlipSkid = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.rootStyle.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.turnCoordinatorBallSub = this.props.turnCoordinatorBall.sub(() => { this.needUpdateSlipSkid = true; });
        this.updateRootPosition();
        this.needUpdateBank = true;
        this.needUpdateSlipSkid = true;
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updateRootPosition();
        }
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Roll)) {
            this.needUpdateBank = true;
        }
    }
    /**
     * Updates this indicator's root container position.
     */
    updateRootPosition() {
        const offsetCenter = this.props.projection.getOffsetCenterProjected();
        this.rootStyle.set('left', `${offsetCenter[0]}px`);
        this.rootStyle.set('top', `${offsetCenter[1]}px`);
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (!this.props.showPointer.get()) {
            return;
        }
        if (this.needUpdateBank) {
            this.updatePointer();
            this.needUpdateBank = false;
        }
        if (this.needUpdateSlipSkid) {
            this.updateSlipSkid();
            this.needUpdateSlipSkid = false;
        }
    }
    /**
     * Updates the rotation of the bank pointer and slip/skid indicator.
     */
    updatePointer() {
        const bank = this.props.projection.getRoll();
        this.pointerTransform.transform.set(0, 0, 1, -bank, 0.1);
        this.pointerTransform.resolve();
        this.isBankAlertActive.set(Math.abs(bank) >= 35);
    }
    /**
     * Updates the position of the slip/skid indicator.
     */
    updateSlipSkid() {
        const ball = this.props.turnCoordinatorBall.get();
        this.slipSkidTransform.transform.set(ball * this.slipSkidTranslateScale, 0, 0, 0.1);
        this.slipSkidTransform.resolve();
        this.isSlipSkidAlertActive.set(Math.abs(ball) === 1);
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-bank-indicator': true,
                'pfd-bank-indicator-bank-alert': this.isBankAlertActive,
                'pfd-bank-indicator-slip-skid-alert': this.isSlipSkidAlertActive
            }, style: this.rootStyle },
            this.renderScale(),
            this.renderPointerContainer()));
    }
    /**
     * Renders the bank scale, which includes the bank reference pointer and the scale ticks.
     * @returns The bank scale, as a VNode.
     */
    renderScale() {
        const { radius, majorTickLength, mediumTickLength, minorTickLength } = this.props.options;
        const svgPathStream = new SvgPathStream(0.01);
        const transformPathStream = new AffineTransformPathStream(svgPathStream);
        transformPathStream.addTranslation(0, -radius);
        transformPathStream.beginPath();
        // zero-bank reference pointer
        const halfWidth = minorTickLength / MathUtils.SQRT3;
        transformPathStream.moveTo(0, 0);
        transformPathStream.lineTo(-halfWidth, -minorTickLength);
        transformPathStream.lineTo(halfWidth, -minorTickLength);
        transformPathStream.closePath();
        const pointerPath = svgPathStream.getSvgPath();
        transformPathStream.beginPath();
        // 10, 20, 45-degree ticks
        transformPathStream.addRotation(-30 * Avionics.Utils.DEG2RAD);
        for (const angle of [10, 20, 45]) {
            transformPathStream.resetTransform();
            transformPathStream.addRotation(-angle * Avionics.Utils.DEG2RAD);
            transformPathStream.moveTo(0, -radius);
            transformPathStream.lineTo(0, -radius - minorTickLength);
            transformPathStream.addRotation(2 * angle * Avionics.Utils.DEG2RAD);
            transformPathStream.moveTo(0, -radius);
            transformPathStream.lineTo(0, -radius - minorTickLength);
        }
        // 30-degree ticks
        transformPathStream.resetTransform();
        transformPathStream.addRotation(-30 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - majorTickLength);
        transformPathStream.addRotation(60 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - majorTickLength);
        // 60-degree ticks
        transformPathStream.resetTransform();
        transformPathStream.addRotation(-60 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - mediumTickLength);
        transformPathStream.addRotation(120 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - mediumTickLength);
        const ticksPath = svgPathStream.getSvgPath();
        const left = -radius * MathUtils.SQRT3 / 2;
        const top = -radius;
        const width = -left * 2;
        const height = radius / 2;
        return (FSComponent.buildComponent("svg", { viewBox: `${left.toFixed(2)} ${top.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)}`, class: 'pfd-bank-indicator-scale', style: `position: absolute; left: ${left.toFixed(2)}px; top: ${top.toFixed(2)}px; width: ${width.toFixed(2)}px; height: ${height.toFixed(2)}px; overflow: visible;` },
            FSComponent.buildComponent("path", { d: pointerPath, fill: 'none', "stroke-linejoin": 'round', class: 'pfd-bank-indicator-scale-pointer shadow' }),
            FSComponent.buildComponent("path", { d: ticksPath, fill: 'none', "stroke-linecap": 'round', class: 'pfd-bank-indicator-scale-ticks shadow' }),
            FSComponent.buildComponent("path", { d: pointerPath, "stroke-linejoin": 'round', class: 'pfd-bank-indicator-scale-pointer' }),
            FSComponent.buildComponent("path", { d: ticksPath, fill: 'none', "stroke-linecap": 'round', class: 'pfd-bank-indicator-scale-ticks' })));
    }
    /**
     * Renders the bank pointer and slip/skid indicator.
     * @returns The bank pointer and slip/skid indicator, as a VNode.
     */
    renderPointerContainer() {
        const pointerSize = this.props.options.pointerSize;
        const pointerTipRadius = this.props.options.radius - this.props.options.pointerOffset;
        const pointerHalfWidth = pointerSize[0] / 2;
        const pointerLeft = -pointerHalfWidth;
        const pointerTop = -pointerTipRadius;
        const pointerWidth = pointerHalfWidth * 2;
        const pointerHeight = pointerSize[1];
        const pointerPath = `M 0 ${-pointerTipRadius} l ${pointerLeft} ${pointerHeight} l ${pointerWidth} 0 Z`;
        const slipSkidHalfWidth = pointerHalfWidth;
        this.slipSkidTranslateScale = slipSkidHalfWidth;
        const slipSkidLeft = -slipSkidHalfWidth;
        const slipSkidTop = -pointerTipRadius + pointerHeight + Math.max(0, this.props.options.slipSkidIndicatorOffset);
        const slipSkidWidth = slipSkidHalfWidth * 2;
        const slipSkidHeight = this.props.options.slipSkidIndicatorHeight;
        const slipSkidPath = `M ${slipSkidLeft} ${slipSkidTop} l ${slipSkidWidth} 0 l 0 ${slipSkidHeight} l ${-slipSkidWidth} 0 Z`;
        return (FSComponent.buildComponent("div", { class: { 'hidden': this.pointerHidden }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px',
                'width': '0px',
                'height': '0px',
                'transform': this.pointerTransform
            } },
            FSComponent.buildComponent("svg", { viewBox: `${pointerLeft} ${pointerTop} ${pointerWidth} ${pointerHeight}`, class: 'pfd-bank-indicator-pointer shadow', style: `position: absolute; left: ${pointerLeft}px; top: ${pointerTop}px; width: ${pointerWidth}px; height: ${pointerHeight}px; overflow: visible;` },
                FSComponent.buildComponent("path", { d: pointerPath, fill: 'none', "stroke-linejoin": 'round' })),
            FSComponent.buildComponent("svg", { viewBox: `${slipSkidLeft} ${slipSkidTop} ${slipSkidWidth} ${slipSkidHeight}`, class: 'pfd-bank-indicator-slip-skid shadow', style: {
                    'position': 'absolute',
                    'left': `${slipSkidLeft}px`,
                    'top': `${slipSkidTop}px`,
                    'width': `${slipSkidWidth}px`,
                    'height': `${slipSkidHeight}px`,
                    'transform': this.slipSkidTransform,
                    'overflow': 'visible'
                } },
                FSComponent.buildComponent("path", { d: slipSkidPath, fill: 'none', "stroke-linejoin": 'round' })),
            FSComponent.buildComponent("svg", { viewBox: `${pointerLeft} ${pointerTop} ${pointerWidth} ${pointerHeight}`, class: 'pfd-bank-indicator-pointer', style: `position: absolute; left: ${pointerLeft}px; top: ${pointerTop}px; width: ${pointerWidth}px; height: ${pointerHeight}px; overflow: visible;` },
                FSComponent.buildComponent("path", { d: pointerPath, "stroke-linejoin": 'round' })),
            FSComponent.buildComponent("svg", { viewBox: `${slipSkidLeft} ${slipSkidTop} ${slipSkidWidth} ${slipSkidHeight}`, class: 'pfd-bank-indicator-slip-skid', style: {
                    'position': 'absolute',
                    'left': `${slipSkidLeft}px`,
                    'top': `${slipSkidTop}px`,
                    'width': `${slipSkidWidth}px`,
                    'height': `${slipSkidHeight}px`,
                    'transform': this.slipSkidTransform,
                    'overflow': 'visible'
                } },
                FSComponent.buildComponent("path", { d: slipSkidPath, "stroke-linejoin": 'round' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.pointerHidden.destroy();
        (_a = this.turnCoordinatorBallSub) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD flight director.
 */
class PfdFlightDirector extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.rootStyle = ObjectSubject.create({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'display': '',
        });
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.pitchTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.bankTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.pitchErrorFactor = SubscribableUtils.toSubscribable(this.props.pitchErrorFactor, true);
        this.bankErrorFactor = SubscribableUtils.toSubscribable(this.props.bankErrorFactor, true);
        this.takeoffDeviationFactor = SubscribableUtils.toSubscribable(this.props.takeoffDeviationFactor, true);
        this.isTakeoffDeviationNull = this.props.fdTakeoffDeviation.map(deviation => deviation === null);
        this.pitchBarHidden = MappedSubject.create(([show, fmaData, isFdActive]) => {
            if (!show || (fmaData && (fmaData.verticalDegraded || fmaData.verticalActive === APVerticalModes.NONE))) {
                return true;
            }
            return !isFdActive;
        }, this.props.showCommandBars, this.props.fmaData, this.props.isFdActive);
        this.bankBarHidden = MappedSubject.create(([show, fmaData, isFdActive, isTakeoffDeviationNull]) => {
            if (!show
                || (fmaData && (fmaData.lateralDegraded
                    || fmaData.lateralActive === APLateralModes.NONE
                    || (fmaData.lateralActive === APLateralModes.TO_LOC && isTakeoffDeviationNull)))) {
                return true;
            }
            return !isFdActive;
        }, this.props.showCommandBars, this.props.fmaData, this.props.isFdActive, this.isTakeoffDeviationNull);
        this.pitchErrorSmoother = new ExpSmoother(500 / Math.LN2);
        this.bankErrorSmoother = new ExpSmoother(500 / Math.LN2);
        this.takeoffDeviationSmoother = new ExpSmoother(500 / Math.LN2);
        this.isTakeoffLocModeActive = this.props.fmaData.map(fmaData => fmaData !== null && fmaData.lateralActive === APLateralModes.TO_LOC);
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.rootStyle.set('display', isVisible ? '' : 'none');
        if (!isVisible) {
            this.pitchErrorSmoother.reset();
            this.bankErrorSmoother.reset();
            this.takeoffDeviationSmoother.reset();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.pitchTransform.transform.getChild(0).set(-50, -50);
        this.bankTransform.transform.getChild(0).set(-50, -50);
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.updatePosition();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updatePosition();
        }
    }
    /**
     * Updates this symbol's position.
     */
    updatePosition() {
        const offsetCenter = this.props.projection.getOffsetCenterProjected();
        this.rootStyle.set('left', `${offsetCenter[0]}px`);
        this.rootStyle.set('top', `${offsetCenter[1]}px`);
    }
    /** @inheritdoc */
    onSleep() {
        this.pitchErrorSmoother.reset();
        this.bankErrorSmoother.reset();
        this.takeoffDeviationSmoother.reset();
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        var _a;
        if (!this.isVisible()) {
            return;
        }
        const center = this.props.projection.getOffsetCenterProjected();
        const bounds = this.conformalBounds.get();
        if (this.bankBarHidden.get()) {
            this.bankErrorSmoother.reset();
            this.takeoffDeviationSmoother.reset();
        }
        else {
            let offset;
            if (this.isTakeoffLocModeActive.get()) {
                this.bankErrorSmoother.reset();
                const deviation = this.takeoffDeviationSmoother.next(((_a = this.props.fdTakeoffDeviation.get()) !== null && _a !== void 0 ? _a : 0), elapsed);
                offset = -deviation * this.takeoffDeviationFactor.get();
            }
            else {
                this.takeoffDeviationSmoother.reset();
                const bankError = this.bankErrorSmoother.next(this.props.fdBank.get() - this.props.projection.getRoll(), elapsed);
                offset = bankError * this.bankErrorFactor.get();
            }
            const x = MathUtils.clamp(offset, bounds[0] - center[0], bounds[2] - center[0]);
            this.bankTransform.transform.getChild(1).set(x, 0, 0, 0.1, 0.1);
            this.bankTransform.resolve();
        }
        if (this.pitchBarHidden.get()) {
            this.pitchErrorSmoother.reset();
        }
        else {
            const pitchError = this.pitchErrorSmoother.next(this.props.fdPitch.get() - this.props.projection.getPitch(), elapsed);
            const y = MathUtils.clamp(-pitchError * this.pitchErrorFactor.get(), bounds[1] - center[1], bounds[3] - center[1]);
            this.pitchTransform.transform.getChild(1).set(0, y, 0, 0.1, 0.1);
            this.pitchTransform.resolve();
        }
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-fd-container', style: this.rootStyle },
            FSComponent.buildComponent("div", { class: { 'pfd-fd-command-bar': true, 'pfd-fd-command-bar-pitch': true, 'hidden': this.pitchBarHidden }, style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'transform': this.pitchTransform
                } }),
            FSComponent.buildComponent("div", { class: { 'pfd-fd-command-bar': true, 'pfd-fd-command-bar-bank': true, 'hidden': this.bankBarHidden }, style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'transform': this.bankTransform
                } }),
            FSComponent.buildComponent("svg", { viewBox: '-7 -7 14 14', class: 'pfd-fd-reference', style: 'position: absolute; left: 0px; top: 0px; transform: translate(-50%, -50%); overflow: visible;' },
                FSComponent.buildComponent("path", { d: 'M -7 -7 l 14 0 l 0 14 l -14 0 z', fill: 'none', "stroke-linejoin": 'round', class: 'pfd-fd-reference-stroke shadow' }),
                FSComponent.buildComponent("path", { d: 'M -7 -7 l 14 0 l 0 14 l -14 0 z', fill: 'none', "stroke-linejoin": 'round', class: 'pfd-fd-reference-stroke' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        this.isTakeoffDeviationNull.destroy();
        this.bankBarHidden.destroy();
        this.pitchBarHidden.destroy();
        this.isTakeoffLocModeActive.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.isFdActiveSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD flight path vector symbol.
 */
class PfdFlightPathVector extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.cssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.transform = new Transform2D();
        this.projectedPosition = Vec2Math.create();
        this.hidden = Subject.create(false);
        this.isNonConformal = Subject.create(false);
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            this.hidden.set(true);
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.cssTransform.transform.getChild(0).set(-50, -50);
        const scheduleUpdatePosition = () => { this.needUpdate = true; };
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.trackSub = this.props.track.sub(scheduleUpdatePosition);
        this.pitchSub = this.props.pitch.sub(scheduleUpdatePosition);
        this.boundsSub = this.conformalBounds.sub(scheduleUpdatePosition);
    }
    /** @inheritdoc */
    onProjectionChanged() {
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const fpvPitch = this.props.pitch.get();
        const fpvTrack = this.props.track.get();
        if (!isFinite(fpvPitch) || !isFinite(fpvTrack)) {
            this.hidden.set(true);
            this.needUpdate = false;
            return;
        }
        const projection = this.props.projection;
        const center = projection.getOffsetCenterProjected();
        const pitchResolution = projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor();
        const headingResolution = projection.getScaleFactor() / projection.getFov() * projection.getHeadingScaleFactor();
        const pitchError = fpvPitch - projection.getPitch();
        const headingError = (MathUtils.diffAngleDeg(projection.getHeading(), fpvTrack) + 180) % 360 - 180;
        Vec2Math.set(0, 0, this.projectedPosition);
        this.transform
            .toTranslation(headingError * headingResolution, -pitchError * pitchResolution)
            .addRotation(-projection.getRoll() * Avionics.Utils.DEG2RAD)
            .addTranslation(center[0], center[1])
            .apply(this.projectedPosition, this.projectedPosition);
        const conformalBounds = this.conformalBounds.get();
        const conformalX = this.projectedPosition[0];
        const conformalY = this.projectedPosition[1];
        const x = MathUtils.clamp(conformalX, conformalBounds[0], conformalBounds[2]);
        const y = MathUtils.clamp(conformalY, conformalBounds[1], conformalBounds[3]);
        this.isNonConformal.set(x !== conformalX || y !== conformalY);
        this.cssTransform.transform.getChild(1).set(x, y, 0, 0.1, 0.1);
        this.cssTransform.resolve();
        this.hidden.set(false);
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { viewBox: '-50 -26 100 52', preserveAspectRatio: 'none', class: {
                'pfd-fpv': true,
                'hidden': this.hidden,
                'pfd-fpv-nonconformal': this.isNonConformal
            }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px',
                'display': '',
                'transform': this.cssTransform,
                'overflow': 'visible'
            } },
            FSComponent.buildComponent("path", { d: 'M -14 0 a 14 14 0 1 0 28 0 a 14 14 0 1 0 -28 0 ', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-circle shadow' }),
            FSComponent.buildComponent("path", { d: 'M 0 -14 l 0 -12', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-top shadow' }),
            FSComponent.buildComponent("path", { d: 'M 14 0 l 36 0 M -14 0 l -36 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-side shadow' }),
            FSComponent.buildComponent("path", { d: 'M -14 0 a 14 14 0 1 0 28 0 a 14 14 0 1 0 -28 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-circle' }),
            FSComponent.buildComponent("path", { d: 'M 0 -14 l 0 -12', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-top' }),
            FSComponent.buildComponent("path", { d: 'M 14 0 l 36 0 M -14 0 l -36 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-side' })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.trackSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.pitchSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.boundsSub) === null || _d === void 0 ? void 0 : _d.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD horizon line.
 */
class PfdHorizonLine extends HorizonLayer {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super(...arguments);
        this.rebuildTapeFlags = this.props.showHeadingLabels !== false && this.props.options.clipYBounds
            ? 0
            : HorizonProjectionChangeType.ProjectedOffset | HorizonProjectionChangeType.ProjectedSize;
        this.majorTickLength = (_a = this.props.options.headingMajorTickLength) !== null && _a !== void 0 ? _a : 0;
        this.minorTickLength = (_b = this.props.options.headingMinorTickLength) !== null && _b !== void 0 ? _b : 0;
        this.tickStrokeWidth = (_c = this.props.options.headingTickWidth) !== null && _c !== void 0 ? _c : PfdHorizonLine.DEFAULT_TICK_STROKE_WIDTH;
        this.tickStrokeColor = (_d = this.props.options.headingTickColor) !== null && _d !== void 0 ? _d : PfdHorizonLine.DEFAULT_TICK_STROKE_COLOR;
        this.font = `${(_e = this.props.options.headingLabelFontSize) !== null && _e !== void 0 ? _e : PfdHorizonLine.DEFAULT_FONT_SIZE}px ${(_f = this.props.options.headingLabelFont) !== null && _f !== void 0 ? _f : PfdHorizonLine.DEFAULT_FONT}`;
        this.fontColor = (_g = this.props.options.headingLabelFontColor) !== null && _g !== void 0 ? _g : PfdHorizonLine.DEFAULT_FONT_COLOR;
        this.fontOutlineWidth = (_h = this.props.options.headingLabelFontOutlineWidth) !== null && _h !== void 0 ? _h : PfdHorizonLine.DEFAULT_FONT_OUTLINE_WIDTH;
        this.fontOutlineColor = (_j = this.props.options.headingLabelFontOutlineColor) !== null && _j !== void 0 ? _j : PfdHorizonLine.DEFAULT_FONT_OUTLINE_COLOR;
        this.labelOffset = (_k = this.props.options.headingLabelOffset) !== null && _k !== void 0 ? _k : 0;
        this.length = SubscribableUtils.toSubscribable(this.props.options.length, true);
        this.showHeadingLabels = this.props.showHeadingLabels === false ? false : SubscribableUtils.toSubscribable(this.props.showHeadingLabels, true);
        this.useMagneticHeading = SubscribableUtils.toSubscribable((_l = this.props.useMagneticHeading) !== null && _l !== void 0 ? _l : true, true);
        this.magVar = SubscribableUtils.toSubscribable((_m = this.props.magVar) !== null && _m !== void 0 ? _m : 0, true);
        this.headingTapeRef = FSComponent.createRef();
        this.hidden = Subject.create(false);
        this.rootCssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('deg')));
        this.lineWidth = this.length.map(length => `${length}px`);
        this.pitchResolution = 0; // pixels per degree
        this.transform = new Transform2D();
        this.projected = Vec2Math.create();
        this.tapeYOffset = 0;
        this.needUpdatePosition = true;
        this.needRebuildHeadingTape = false;
        this.needUpdateHeadingTape = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.hidden.set(!isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        if (this.showHeadingLabels !== false) {
            this.headingTapeRef.instance.onAttached();
            this.showHeadingLabelsSub = this.showHeadingLabels.sub(this.headingTapeRef.instance.setVisible.bind(this.headingTapeRef.instance), true);
            this.useMagneticHeadingSub = this.useMagneticHeading.sub(() => { this.needUpdateHeadingTape = true; });
            this.magVarSub = this.magVar.sub(() => { this.needUpdateHeadingTape || (this.needUpdateHeadingTape = this.useMagneticHeading.get()); });
            this.lengthSub = this.length.sub(() => { this.needRebuildHeadingTape = true; });
            this.needRebuildHeadingTape = true;
        }
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.updatePitchResolution();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, PfdHorizonLine.UPDATE_PITCH_RESOLUTION_FLAGS)) {
            this.updatePitchResolution();
        }
        if (this.showHeadingLabels !== false) {
            if (BitFlags.isAny(changeFlags, this.rebuildTapeFlags)) {
                this.needRebuildHeadingTape = true;
            }
            if (BitFlags.isAny(changeFlags, PfdHorizonLine.UPDATE_HEADING_FLAGS)) {
                this.needUpdateHeadingTape = true;
            }
        }
        this.needUpdatePosition = true;
    }
    /**
     * Updates the pitch resolution used by this horizon line to position itself.
     */
    updatePitchResolution() {
        this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov() * this.props.projection.getPitchScaleFactor();
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (this.needUpdatePosition) {
            this.updatePosition();
            this.needUpdatePosition = false;
        }
        if (this.showHeadingLabels !== false && this.showHeadingLabels.get()) {
            if (this.needRebuildHeadingTape) {
                this.buildHeadingTape();
                this.needRebuildHeadingTape = false;
            }
            if (this.needUpdateHeadingTape) {
                this.updateHeadingTape();
                this.needUpdateHeadingTape = false;
            }
        }
    }
    /**
     * Updates the position and rotation of this horizon line.
     */
    updatePosition() {
        // Approximate translation due to pitch using a constant pitch resolution (pixels per degree of pitch) derived
        // from the projection's current field of view. The error of this approximation increases with the absolute
        // deviation of the pitch angle from 0 degrees. We do this instead of simply projecting the true horizon line
        // because we need to keep the line in sync with the pitch ladder, which uses the same approximation.
        const roll = this.props.projection.getRoll();
        Vec2Math.set(0, 0, this.projected);
        this.transform
            .toTranslation(0, this.pitchResolution * this.props.projection.getPitch())
            .addRotation(-roll * Avionics.Utils.DEG2RAD)
            .apply(this.projected, this.projected);
        Vec2Math.add(this.projected, this.props.projection.getOffsetCenterProjected(), this.projected);
        this.rootCssTransform.transform.getChild(0).set(this.projected[0], this.projected[1], 0, 0.1, 0.1);
        this.rootCssTransform.transform.getChild(1).set(-roll);
        this.rootCssTransform.resolve();
    }
    /**
     * Updates this horizon line's heading tape.
     */
    updateHeadingTape() {
        const projection = this.props.projection;
        const trueHeading = projection.getHeading();
        const heading = this.useMagneticHeading.get() ? MagVar.trueToMagnetic(trueHeading, this.magVar.get()) : trueHeading;
        const headingResolution = projection.getScaleFactor() / projection.getFov() * projection.getHeadingScaleFactor();
        const display = this.headingTapeRef.instance.display;
        const context = display.context;
        display.clear();
        const tapeLength = this.length.get();
        const tapeXCenter = tapeLength * 0.5;
        const tapeXMin = tapeLength * -0.5;
        const tapeXMax = tapeLength * 1.5;
        const labelCount = PfdHorizonLine.TAPE_LABELS.length;
        const tickCount = labelCount * PfdHorizonLine.TAPE_TICK_FACTOR;
        const tickInterval = PfdHorizonLine.TAPE_LABEL_INTERVAL / PfdHorizonLine.TAPE_TICK_FACTOR;
        context.beginPath();
        // Ticks
        for (let i = 0; i < tickCount; i++) {
            const tickHeading = i * tickInterval;
            const tickHeadingDiff = (NavMath.diffAngle(heading, tickHeading) + 180) % 360 - 180; // -180 to 180
            const tickX = tickHeadingDiff * headingResolution + tapeXCenter;
            if (tickX >= tapeXMin && tickX <= tapeXMax) {
                const tickLength = i % PfdHorizonLine.TAPE_TICK_FACTOR === 0 ? this.majorTickLength : this.minorTickLength;
                context.moveTo(tickX, this.tapeYOffset);
                context.lineTo(tickX, this.tapeYOffset - tickLength);
            }
        }
        this.strokePath(context, this.tickStrokeWidth, this.tickStrokeColor);
        // Labels
        for (let i = 0; i < labelCount; i++) {
            const labelHeading = i * PfdHorizonLine.TAPE_LABEL_INTERVAL;
            const labelHeadingDiff = (NavMath.diffAngle(heading, labelHeading) + 180) % 360 - 180; // -180 to 180
            const headingX = labelHeadingDiff * headingResolution + tapeXCenter;
            if (headingX >= tapeXMin && headingX <= tapeXMax) {
                context.rotate(0.001); // Need to apply some rotation to activate sub-pixel text rendering.
                context.translate(headingX, this.tapeYOffset + this.labelOffset);
                if (this.fontOutlineWidth > 0) {
                    context.lineWidth = this.fontOutlineWidth * 2;
                    context.strokeStyle = this.fontOutlineColor;
                    context.strokeText(PfdHorizonLine.TAPE_LABELS[i], 0, 0);
                }
                context.fillText(PfdHorizonLine.TAPE_LABELS[i], 0, 0);
                context.resetTransform();
            }
        }
    }
    /**
     * Strokes a path on a canvas.
     * @param context The canvas rendering context with which to stroke the path.
     * @param strokeWidth The width of the stroke.
     * @param strokeStyle The style of the stroke.
     * @param outlineWidth The outline width of the stroke. Defaults to `0`.
     * @param outlineStyle The outline style of the stroke. Required to draw an outline.
     */
    strokePath(context, strokeWidth, strokeStyle, outlineWidth = 0, outlineStyle) {
        if (outlineWidth > 0 && outlineStyle !== undefined) {
            context.lineWidth = strokeWidth + 2 * outlineWidth;
            context.strokeStyle = outlineStyle;
            context.stroke();
        }
        context.lineWidth = strokeWidth;
        context.strokeStyle = strokeStyle;
        context.stroke();
    }
    /**
     * Builds the ticks and labels for this horizon line's heading tape.
     */
    buildHeadingTape() {
        const length = this.length.get();
        let height;
        let top;
        if (this.props.options.clipYBounds) {
            height = this.props.options.clipYBounds[1] - this.props.options.clipYBounds[0];
            top = this.props.options.clipYBounds[0];
        }
        else {
            const projection = this.props.projection;
            height = projection.getProjectedSize()[1];
            top = -projection.getOffsetCenterProjected()[1];
        }
        this.headingTapeRef.instance.setWidth(length);
        this.headingTapeRef.instance.setHeight(height);
        this.headingTapeRef.instance.display.canvas.style.left = `${-length / 2}px`;
        this.headingTapeRef.instance.display.canvas.style.top = `${top}px`;
        this.headingTapeRef.instance.display.context.font = this.font;
        this.headingTapeRef.instance.display.context.textAlign = 'center';
        this.headingTapeRef.instance.display.context.textBaseline = 'top';
        this.headingTapeRef.instance.display.context.fillStyle = this.fontColor;
        this.headingTapeRef.instance.display.context.lineCap = 'round';
        this.tapeYOffset = -top;
        this.needUpdateHeadingTape = true;
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'pfd-horizon-line-container': true, 'hidden': this.hidden }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px;',
                'transform': this.rootCssTransform
            } },
            FSComponent.buildComponent("div", { class: 'pfd-horizon-line', style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px;',
                    'width': this.lineWidth,
                    'transform': 'translate(-50%, -50%)'
                } }),
            this.showHeadingLabels !== false && (FSComponent.buildComponent(HorizonCanvasLayer, { ref: this.headingTapeRef, projection: this.props.projection, class: 'pfd-horizon-line-hdg-tape' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f;
        this.lineWidth.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.showHeadingLabelsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.useMagneticHeadingSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.magVarSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.lengthSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.headingTapeRef.getOrDefault()) === null || _f === void 0 ? void 0 : _f.destroy();
        super.destroy();
    }
}
PfdHorizonLine.TAPE_LABEL_INTERVAL = 10; // degrees per label
PfdHorizonLine.TAPE_TICK_FACTOR = 2; // number of ticks per label
PfdHorizonLine.TAPE_LABELS = ArrayUtils.create(Math.floor(360 / PfdHorizonLine.TAPE_LABEL_INTERVAL), index => {
    const rounded = Math.round(index * PfdHorizonLine.TAPE_LABEL_INTERVAL / 10);
    return rounded === 0 ? '36' : rounded.toString().padStart(2, '0');
});
PfdHorizonLine.UPDATE_PITCH_RESOLUTION_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.PitchScaleFactor;
PfdHorizonLine.UPDATE_HEADING_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.HeadingScaleFactor
    | HorizonProjectionChangeType.Heading;
PfdHorizonLine.DEFAULT_TICK_STROKE_WIDTH = 1; // pixels
PfdHorizonLine.DEFAULT_TICK_STROKE_COLOR = 'white';
PfdHorizonLine.DEFAULT_FONT = 'sans-serif';
PfdHorizonLine.DEFAULT_FONT_SIZE = 10;
PfdHorizonLine.DEFAULT_FONT_COLOR = 'white';
PfdHorizonLine.DEFAULT_FONT_OUTLINE_WIDTH = 1;
PfdHorizonLine.DEFAULT_FONT_OUTLINE_COLOR = 'black';

/**
 * A Boeing PFD pitch ladder.
 */
class PfdPitchLadder extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.rootStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'overflow': 'hidden'
        });
        this.transform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('deg'), CssTransformBuilder.translateY('px')));
        this.clipBounds = SubscribableUtils.toSubscribable(this.props.clipBounds, true);
        this.pitchResolution = 0; // pixels per degree
        this.needUpdateClip = true;
        this.needRebuildLadder = true;
        this.needReposition = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.rootStyle.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.clipBoundsSub = this.clipBounds.sub(() => {
            this.needUpdateClip = true;
        });
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.PitchScaleFactor)) {
            this.needRebuildLadder = true;
        }
        this.needReposition = true;
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (this.needUpdateClip) {
            this.updateClip();
            this.needUpdateClip = false;
        }
        if (this.needRebuildLadder) {
            this.rebuildLadder();
            this.needRebuildLadder = false;
        }
        if (this.needReposition) {
            this.repositionLadder();
            this.needReposition = false;
        }
    }
    /**
     * Updates this ladder's clipping boundaries.
     */
    updateClip() {
        const bounds = this.clipBounds.get();
        this.rootStyle.set('left', `${bounds[0]}px`);
        this.rootStyle.set('top', `${bounds[1]}px`);
        this.rootStyle.set('width', `${bounds[2] - bounds[0]}px`);
        this.rootStyle.set('height', `${bounds[3] - bounds[1]}px`);
        // After we update the clip bounds we need to update the positioning of the ladder, because the ladder is
        // positioned relative to the clip bounds.
        this.needReposition = true;
    }
    /**
     * Repositions this ladder based on the current pitch and bank.
     */
    repositionLadder() {
        const center = this.props.projection.getOffsetCenterProjected();
        const bounds = this.clipBounds.get();
        const pitchOffset = this.props.projection.getPitch() * this.pitchResolution;
        const x = center[0] - bounds[0];
        const y = center[1] - bounds[1];
        this.transform.transform.getChild(0).set(x, y, 0, 0.1, 0.1);
        this.transform.transform.getChild(1).set(-this.props.projection.getRoll());
        this.transform.transform.getChild(2).set(pitchOffset, 0.1);
        this.transform.resolve();
    }
    /**
     * Rebuilds this ladder.
     */
    rebuildLadder() {
        var _a, _b;
        this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov() * this.props.projection.getPitchScaleFactor();
        const options = this.props.options;
        this.svgRef.instance.innerHTML = '';
        const minorFactor = options.minorLineFactor * options.mediumLineFactor;
        const minorIncrement = options.majorLineIncrement / minorFactor;
        const len = Math.floor(90 / minorIncrement);
        for (let i = 1; i <= len; i++) {
            const pitch = i * minorIncrement;
            const y = pitch * this.pitchResolution;
            let lineLength;
            let showNumber = false;
            if (i % minorFactor === 0) {
                // major line
                lineLength = options.majorLineLength;
                showNumber = options.majorLineShowLabel;
            }
            else if (i % options.minorLineFactor === 0 && (options.mediumLineMaxPitch === undefined || pitch <= options.mediumLineMaxPitch)) {
                // medium line
                lineLength = options.mediumLineLength;
                showNumber = (_a = options.mediumLineShowLabel) !== null && _a !== void 0 ? _a : false;
            }
            else if (options.minorLineMaxPitch === undefined || pitch <= options.minorLineMaxPitch) {
                // minor line
                lineLength = options.minorLineLength;
                showNumber = (_b = options.minorLineShowLabel) !== null && _b !== void 0 ? _b : false;
            }
            if (lineLength !== undefined) {
                if (lineLength > 0) {
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: -y, x2: lineLength / 2, y2: -y, class: "pfd-pitch-ladder-line shadow" }, "."), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: -y, x2: lineLength / 2, y2: -y, class: "pfd-pitch-ladder-line" }, "."), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: y, x2: lineLength / 2, y2: y, class: "pfd-pitch-ladder-line shadow" }, "."), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: y, x2: lineLength / 2, y2: y, class: "pfd-pitch-ladder-line" }, "."), this.svgRef.instance);
                }
                if (showNumber) {
                    const pitchText = pitch.toString();
                    const leftAnchorX = -lineLength / 2 - options.labelMargin;
                    const rightAnchorX = lineLength / 2 + options.labelMargin;
                    FSComponent.render(FSComponent.buildComponent("text", { x: leftAnchorX, y: -y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("text", { x: rightAnchorX, y: -y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("text", { x: leftAnchorX, y: y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("text", { x: rightAnchorX, y: y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                }
            }
        }
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-pitch-ladder-container', style: this.rootStyle },
            FSComponent.buildComponent("svg", { ref: this.svgRef, class: 'pfd-pitch-ladder', style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'transform': this.transform,
                    'transform-origin': '0px 0px',
                    'stroke-linecap': 'round',
                    'overflow': 'visible'
                } })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.clipBoundsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD pitch limit indicator.
 */
class PfdPitchLimitIndicator extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.cssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.hidden = Subject.create(false);
        this.isNonConformal = Subject.create(false);
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.hidden.set(!isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.cssTransform.transform.getChild(0).set(-50, -50);
        const scheduleUpdatePosition = () => { this.needUpdate = true; };
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.aoaSub = this.props.aoa.sub(scheduleUpdatePosition);
        this.aoaLimitSub = this.props.aoaLimit.sub(scheduleUpdatePosition);
        this.boundsSub = this.conformalBounds.sub(scheduleUpdatePosition);
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, PfdPitchLimitIndicator.UPDATE_FLAGS)) {
            this.needUpdate = true;
        }
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const projection = this.props.projection;
        const center = projection.getOffsetCenterProjected();
        const pitchResolution = projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor();
        const conformalBounds = this.conformalBounds.get();
        const aoaMargin = Math.min(this.props.aoaLimit.get() - this.props.aoa.get(), this.props.options.maxPitch - projection.getPitch());
        const conformalY = center[1] - aoaMargin * pitchResolution;
        const x = center[0];
        const y = MathUtils.clamp(conformalY, conformalBounds[0], conformalBounds[1]);
        this.isNonConformal.set(y !== conformalY);
        this.cssTransform.transform.getChild(1).set(x, y, 0, 0.1, 0.1);
        this.cssTransform.resolve();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { viewBox: '-120 -19 240 38', preserveAspectRatio: 'none', class: {
                'pfd-pitch-limit': true,
                'hidden': this.hidden,
                'pfd-pitch-limit-nonconformal': this.isNonConformal
            }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px',
                'display': '',
                'transform': this.cssTransform,
                'overflow': 'visible'
            } },
            FSComponent.buildComponent("path", { d: 'M -120 0 h 40 v 12.6 M 120 0 h -40 v 12.6', "stroke-linecap": "round", "stroke-linejoin": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thick shadow' }),
            FSComponent.buildComponent("path", { d: 'M -120 -18.9 l 9.7196 18.9 m 10.4139 0 l -10.4139 -18.9 m 20.8278 18.9 l -10.4139 -18.9 M 120 -18.9 l -9.7196 18.9 m -9.7197 0 l 9.7197 -18.9 m -19.4393 18.9 l 9.7196 -18.9', "stroke-linecap": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thin shadow' }),
            FSComponent.buildComponent("path", { d: 'M -120 0 h 40 v 12.6 M 120 0 h -40 v 12.6', "stroke-linecap": "round", "stroke-linejoin": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thick' }),
            FSComponent.buildComponent("path", { d: 'M -120 -18.9 l 9.7196 18.9 m 10.4139 0 l -10.4139 -18.9 m 20.8278 18.9 l -10.4139 -18.9 M 120 -18.9 l -9.7196 18.9 m -9.7197 0 l 9.7197 -18.9 m -19.4393 18.9 l 9.7196 -18.9', "stroke-linecap": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thin' })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.aoaSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.aoaLimitSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.boundsSub) === null || _d === void 0 ? void 0 : _d.destroy();
        super.destroy();
    }
}
PfdPitchLimitIndicator.UPDATE_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.PitchScaleFactor
    | HorizonProjectionChangeType.OffsetCenterProjected
    | HorizonProjectionChangeType.Pitch;

/**
 * A Boeing PFD selected flight path angle symbol.
 */
class PfdSelectedFlightPathAngle extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.clipBounds = SubscribableUtils.toSubscribable(this.props.clipBounds, true);
        this.rootStyle = ObjectSubject.create({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'overflow': 'hidden'
        });
        this.cssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.hidden = Subject.create(false);
        this.needUpdateClipBounds = true;
        this.needUpdatePosition = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.hidden.set(!isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.cssTransform.transform.getChild(0).set(-50, -50);
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.angleSub = this.props.angle.sub(() => { this.needUpdatePosition = true; });
        this.clipBoundsSub = this.clipBounds.sub(() => { this.needUpdateClipBounds = true; });
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, PfdSelectedFlightPathAngle.UPDATE_FLAGS)) {
            this.needUpdatePosition = true;
        }
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (this.needUpdateClipBounds) {
            this.updateClipBounds();
            this.needUpdateClipBounds = false;
        }
        if (this.needUpdatePosition) {
            this.updatePosition();
            this.needUpdatePosition = false;
        }
    }
    /**
     * Updates this symbol's clipping boundaries.
     */
    updateClipBounds() {
        const bounds = this.clipBounds.get();
        this.rootStyle.set('left', `${bounds[0]}px`);
        this.rootStyle.set('top', `${bounds[1]}px`);
        this.rootStyle.set('width', `${bounds[2] - bounds[0]}px`);
        this.rootStyle.set('height', `${bounds[3] - bounds[1]}px`);
        // After we update the clipping boundaries, we need to also update the position of the symbol because it is
        // defined relative to the clipping boundaries.
        this.needUpdatePosition = true;
    }
    /**
     * Updates this symbol's position.
     */
    updatePosition() {
        const bounds = this.clipBounds.get();
        const projection = this.props.projection;
        const center = projection.getOffsetCenterProjected();
        const pitchResolution = projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor();
        const pitchError = this.props.angle.get() - projection.getPitch();
        const x = center[0] - bounds[0];
        const y = center[1] - bounds[1] - pitchError * pitchResolution;
        this.cssTransform.transform.getChild(1).set(x, y, 0, 0.1, 0.1);
        this.cssTransform.resolve();
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'hidden': this.hidden }, style: this.rootStyle },
            FSComponent.buildComponent("svg", { viewBox: '-64 -4 128 8', preserveAspectRatio: 'none', class: 'pfd-sel-fpa', style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'display': '',
                    'transform': this.cssTransform,
                    'overflow': 'visible'
                } },
                FSComponent.buildComponent("path", { d: 'M -64 -4 l 28 0 m -28 8 l 28 0 m 72 0 l 28 0 m -28 -8 l 28 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-sel-fpa-stroke shadow' }),
                FSComponent.buildComponent("path", { d: 'M -64 -4 l 28 0 m -28 8 l 28 0 m 72 0 l 28 0 m -28 -8 l 28 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-sel-fpa-stroke' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.angleSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.clipBoundsSub) === null || _c === void 0 ? void 0 : _c.destroy();
        super.destroy();
    }
}
PfdSelectedFlightPathAngle.UPDATE_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.PitchScaleFactor
    | HorizonProjectionChangeType.OffsetCenterProjected
    | HorizonProjectionChangeType.Pitch;

/**
 * A PFD TCAS-II resolution advisory pitch cue layer.
 */
class PfdTcasRaPitchCueLayer extends HorizonLayer {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.clipBounds = SubscribableUtils.toSubscribable(this.props.clipBounds, true);
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.rootStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'overflow': 'hidden'
        });
        this.clipCenterX = Subject.create('');
        this.clipCenterY = Subject.create('');
        this.noflyAboveHidden = Subject.create(false);
        this.noflyAboveTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.rotate('deg'), CssTransformBuilder.translate3d('px'), CssTransformBuilder.translate('%')));
        this.noflyBelowHidden = Subject.create(false);
        this.noflyBelowTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.rotate('deg'), CssTransformBuilder.translate3d('px'), CssTransformBuilder.translate('%')));
        this.tasSmoother = new ExpSmoother((_a = this.props.tasSmoothingTau) !== null && _a !== void 0 ? _a : 2000 / Math.LN2);
        this.pitchSmoother = new ExpSmoother((_b = this.props.pitchSmoothingTau) !== null && _b !== void 0 ? _b : 2000 / Math.LN2);
        this.smoothedTas = Subject.create(0);
        this.smoothedPitch = Subject.create(0);
        this.needUpdateClipBounds = false;
        this.needUpdateNoflyAbove = false;
        this.needUpdateNoflyBelow = false;
        this.pauseable = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        if (isVisible) {
            this.rootStyle.set('display', '');
            for (const pauseable of this.pauseable) {
                pauseable.resume();
            }
            this.checkNeedUpdateCues();
        }
        else {
            this.rootStyle.set('display', 'none');
            for (const pauseable of this.pauseable) {
                pauseable.pause();
            }
            this.tasSmoother.reset();
            this.pitchSmoother.reset();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.noflyAboveTransform.transform.getChild(2).set(-50, -100);
        this.noflyBelowTransform.transform.getChild(2).set(-50, 0);
        this.clipBoundsSub = this.clipBounds.sub(() => { this.needUpdateClipBounds = true; });
        const checkNeedUpdateCues = this.checkNeedUpdateCues.bind(this);
        const paused = !this.isVisible();
        this.pauseable.push(this.props.dataProvider.raMaxVs.sub(() => { this.needUpdateNoflyAbove = true; }, false, paused), this.props.dataProvider.raMinVs.sub(() => { this.needUpdateNoflyBelow = true; }, false, paused), this.smoothedTas.sub(checkNeedUpdateCues, false, paused), this.smoothedPitch.sub(checkNeedUpdateCues, false, paused), this.conformalBounds.sub(() => {
            this.needUpdateNoflyAbove = true;
            this.needUpdateNoflyBelow = true;
        }, false, paused));
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.needUpdateClipBounds = true;
        this.needUpdateNoflyAbove = true;
        this.needUpdateNoflyBelow = true;
    }
    /**
     * Checks whether any of this layer's cues are visible, and if so, marks them to be updated.
     */
    checkNeedUpdateCues() {
        this.needUpdateNoflyAbove || (this.needUpdateNoflyAbove = this.props.dataProvider.raMaxVs.get() !== null);
        this.needUpdateNoflyBelow || (this.needUpdateNoflyBelow = this.props.dataProvider.raMinVs.get() !== null);
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        this.needUpdateClipBounds || (this.needUpdateClipBounds = BitFlags.isAny(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected));
        if (BitFlags.isAny(changeFlags, ~HorizonProjectionChangeType.Position)) {
            this.checkNeedUpdateCues();
        }
    }
    /** @inheritdoc */
    onSleep() {
        this.tasSmoother.reset();
        this.pitchSmoother.reset();
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.updateSmoothedValues(elapsed);
        if (this.needUpdateClipBounds) {
            this.updateClipBounds();
            this.needUpdateClipBounds = false;
        }
        if (this.needUpdateNoflyAbove) {
            this.updateNoflyCue(1, this.props.dataProvider.raMaxVs.get(), this.noflyAboveHidden, this.noflyAboveTransform);
            this.needUpdateNoflyAbove = false;
        }
        if (this.needUpdateNoflyBelow) {
            this.updateNoflyCue(-1, this.props.dataProvider.raMinVs.get(), this.noflyBelowHidden, this.noflyBelowTransform);
            this.needUpdateNoflyBelow = false;
        }
    }
    /**
     * Updates this layer's smoothed true airspeed and pitch values.
     * @param elapsed The elapsed time since the last update, in milliseconds.
     */
    updateSmoothedValues(elapsed) {
        const tas = this.props.tas.get();
        const dt = elapsed * this.props.simRate.get();
        if (dt > 0) {
            this.smoothedTas.set(this.tasSmoother.next(tas, dt));
            this.smoothedPitch.set(this.pitchSmoother.next(this.props.projection.getPitch(), dt));
        }
        else {
            this.smoothedTas.set(this.tasSmoother.reset(tas));
            this.smoothedPitch.set(this.pitchSmoother.reset(this.props.projection.getPitch()));
        }
    }
    /**
     * Updates this layer's clipping bounds.
     */
    updateClipBounds() {
        const center = this.props.projection.getOffsetCenterProjected();
        const bounds = this.clipBounds.get();
        const width = bounds[2] - bounds[0];
        const height = bounds[3] - bounds[1];
        this.rootStyle.set('left', `${center[0] + bounds[0]}px`);
        this.rootStyle.set('top', `${center[1] + bounds[1]}px`);
        this.rootStyle.set('width', `${width}px`);
        this.rootStyle.set('height', `${height}px`);
        this.clipCenterX.set(`${width / 2}px`);
        this.clipCenterY.set(`${height / 2}px`);
        this.checkNeedUpdateCues();
    }
    /**
     * Updates one of this layer's no-fly pitch cues.
     * @param direction The direction of the no-fly cue: +1 for above and -1 for below.
     * @param vsLimit The vertical speed limit, in feet per minute, commanded by the currently active resolution
     * advisory, or `null` if there is no such limit.
     * @param hidden The hidden state of the no-fly cue.
     * @param transform The CSS transform of the no-fly cue.
     */
    updateNoflyCue(direction, vsLimit, hidden, transform) {
        const currentTas = this.smoothedTas.get();
        if (currentTas < 1 || vsLimit === null) {
            hidden.set(true);
            return;
        }
        const currentVs = this.props.verticalSpeed.get();
        const projection = this.props.projection;
        const angularResolution = projection.getScaleFactor() / projection.getFov();
        const roll = projection.getRoll();
        const rotation = (-roll + 540) % 360 - 180; // -180 to 180
        const conformalBounds = this.conformalBounds.get();
        let minPitchOffsetPx;
        let maxPitchOffsetPx;
        if (direction === 1) {
            minPitchOffsetPx = -Infinity;
            if (rotation >= 90) {
                maxPitchOffsetPx = MathUtils.lerp(rotation, 90, 180, -conformalBounds[0], -conformalBounds[1]);
            }
            else if (rotation >= 0) {
                maxPitchOffsetPx = MathUtils.lerp(rotation, 0, 90, conformalBounds[3], -conformalBounds[0]);
            }
            else if (rotation >= -90) {
                maxPitchOffsetPx = MathUtils.lerp(rotation, -90, 0, conformalBounds[2], conformalBounds[3]);
            }
            else {
                maxPitchOffsetPx = MathUtils.lerp(rotation, -180, -90, -conformalBounds[1], conformalBounds[2]);
            }
        }
        else {
            maxPitchOffsetPx = Infinity;
            if (rotation >= 90) {
                minPitchOffsetPx = MathUtils.lerp(rotation, 90, 180, -conformalBounds[2], -conformalBounds[3]);
            }
            else if (rotation >= 0) {
                minPitchOffsetPx = MathUtils.lerp(rotation, 0, 90, conformalBounds[1], -conformalBounds[2]);
            }
            else if (rotation >= -90) {
                minPitchOffsetPx = MathUtils.lerp(rotation, -90, 0, conformalBounds[0], conformalBounds[1]);
            }
            else {
                minPitchOffsetPx = MathUtils.lerp(rotation, -180, -90, -conformalBounds[3], conformalBounds[0]);
            }
        }
        const deltaVs = vsLimit - currentVs;
        const deltaPitch = Math.asin(MathUtils.clamp(deltaVs / UnitType.KNOT.convertTo(currentTas, UnitType.FPM), -1, 1)) * Avionics.Utils.RAD2DEG;
        const pitchOffsetPx = MathUtils.clamp((this.smoothedPitch.get() - projection.getPitch() + deltaPitch) * -angularResolution, minPitchOffsetPx, maxPitchOffsetPx);
        transform.transform.getChild(0).set(rotation, 0.1);
        transform.transform.getChild(1).set(0, pitchOffsetPx, 0, 0.1, 0.1);
        transform.resolve();
        hidden.set(false);
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-tcas-ra-pitch', style: this.rootStyle },
            this.renderNoflyPitchCue('above', this.noflyAboveHidden, this.noflyAboveTransform),
            this.renderNoflyPitchCue('below', this.noflyBelowHidden, this.noflyBelowTransform)));
    }
    /**
     * Renders a no-fly pitch cue.
     * @param direction The direction of the cue.
     * @param hidden The hidden state of the cue.
     * @param transform The CSS transform of the cue.
     * @returns A no-fly pitch cue, as a VNode.
     */
    renderNoflyPitchCue(direction, hidden, transform) {
        const { noflyCueHeight: height, noflyCueClosedWidth: closedWidth, noflyCueOpenWidth: openWidth, cueStrokeWidth: strokeWidth, cueOutlineWidth: outlineWidth } = this.props.options;
        const halfStrokeWidth = strokeWidth / 2;
        const sign = direction === 'above' ? 1 : -1;
        const path = `M ${-openWidth / 2} ${-height * sign} L ${-closedWidth / 2} ${-halfStrokeWidth * sign} L ${closedWidth / 2} ${-halfStrokeWidth * sign} L ${openWidth / 2} ${-height * sign}`;
        const svgWidth = Math.ceil(Math.max(closedWidth, openWidth));
        const svgHeight = Math.ceil(height);
        const viewBoxTop = direction === 'above' ? -svgHeight : 0;
        return (FSComponent.buildComponent("svg", { viewBox: `${-svgWidth / 2} ${viewBoxTop} ${svgWidth} ${svgHeight}`, class: {
                'pfd-tcas-ra-pitch-nofly': true,
                [`pfd-tcas-ra-pitch-nofly-${direction}`]: true,
                'hidden': hidden
            }, style: {
                'position': 'absolute',
                'left': this.clipCenterX,
                'top': this.clipCenterY,
                'width': `${svgWidth}px`,
                'height': `${svgHeight}px`,
                'transform': transform,
                'transform-origin': '0px 0px',
                'overflow': 'visible'
            } },
            FSComponent.buildComponent("path", { d: path, class: 'pfd-tcas-ra-pitch-nofly-stroke shadow', fill: 'none', "stroke-width": strokeWidth + outlineWidth / 2, "stroke-linecap": 'round' }),
            FSComponent.buildComponent("path", { d: path, class: 'pfd-tcas-ra-pitch-nofly-stroke', fill: 'none', "stroke-width": strokeWidth, "stroke-linecap": 'round' })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.clipBoundsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD horizon display.
 */
class PfdHorizonDisplay extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.horizonRef = FSComponent.createRef();
        this.projectionParams = {
            heading: 0,
            pitch: 0,
            roll: 0,
            pitchScaleFactor: 1
        };
        this.adcAirspeedSelectorIndex = SubscribableUtils.toSubscribable(this.props.adcAirspeedSelectorIndex, true);
        this.adcAirspeedIndex = ConsumerSubject.create(null, -1);
        this.adcAltitudeSelectorIndex = SubscribableUtils.toSubscribable(this.props.adcAirspeedSelectorIndex, true);
        this.adcAltitudeIndex = ConsumerSubject.create(null, -1);
        this.irsSelectorIndex = SubscribableUtils.toSubscribable(this.props.irsSelectorIndex, true);
        this.irsIndex = ConsumerSubject.create(null, -1);
        this.heading = ConsumerSubject.create(null, 0).pause();
        this.pitch = ConsumerSubject.create(null, 0).pause();
        this.roll = ConsumerSubject.create(null, 0).pause();
        this.paramSubjects = [
            this.heading,
            this.pitch,
            this.roll
        ];
        this.isAirspeedDataValid = ConsumerSubject.create(null, true).pause();
        this.isAltitudeDataValid = ConsumerSubject.create(null, true).pause();
        this.isHeadingDataValid = ConsumerSubject.create(null, true).pause();
        this.isAttitudeDataValid = ConsumerSubject.create(null, true).pause();
        this.isInertialDataValid = ConsumerSubject.create(null, true).pause();
        this.simTime = ConsumerValue.create(null, 0);
        this.simRate = ConsumerSubject.create(null, 1);
        this.isOnGround = ConsumerSubject.create(null, false);
        this.verticalSpeed = ConsumerSubject.create(null, 0).pause();
        this.tas = ConsumerSubject.create(null, 0).pause();
        this.turnCoordinatorBall = ConsumerSubject.create(null, 0);
        this.magVar = ConsumerSubject.create(null, 0).pause();
        this.track = ConsumerValue.create(null, 0);
        this.gs = ConsumerValue.create(null, 0);
        this.inertialVs = ConsumerValue.create(null, 0);
        this.accel = ConsumerValue.create(null, 0);
        this.flapsPosition = ConsumerSubject.create(null, 0);
        this.fmaData = ConsumerSubject.create(null, null);
        this.fmsOperatingPhase = ConsumerValue.create(null, FmsOperatingPhase.PREFLIGHT);
        this.isFdActive = ConsumerSubject.create(null, false);
        this.fdPitch = Subject.create(0);
        this.fdBank = Subject.create(0);
        this.fdTakeoffDeviation = ConsumerSubject.create(null, null);
        this.fdPitchErrorFactor = Subject.create(0);
        this.fdBankErrorFactor = Subject.create(0);
        this.fdTakeoffDeviationFactor = Subject.create(0);
        this.showTcasRaPitchCueLayer = MappedSubject.create(SubscribableMapFunctions.and(), this.isAttitudeDataValid, this.isAirspeedDataValid, this.isAltitudeDataValid).pause();
        this.tcasRaPitchCueDefaultBounds = this.props.tcasRaPitchCueClipBounds === undefined || this.props.tcasRaPitchCueConformalBounds === undefined
            ? VecNSubject.create(VecNMath.create(4))
            : undefined;
        this.fpvComputer = new FlightPathVectorComputer(500 / Math.LN2, 500 / Math.LN2, 500 / Math.LN2, 500 / Math.LN2);
        this.showFpv = MappedSubject.create(SubscribableMapFunctions.and(), this.props.showFpv, this.isInertialDataValid).pause();
        this.showSelectedFpa = this.props.showSelectedFpa === false
            ? undefined
            : MappedSubject.create(([show, fmaData, isAttitudeDataValid]) => {
                return show
                    && isAttitudeDataValid
                    && fmaData !== null
                    && (fmaData.verticalActive === APVerticalModes.FPA || fmaData.verticalArmed === APVerticalModes.FPA);
            }, SubscribableUtils.toSubscribable(this.props.showSelectedFpa, true), this.fmaData, this.isAttitudeDataValid).pause();
        this.selectedFpa = this.showSelectedFpa ? ConsumerSubject.create(null, 0).pause() : undefined;
        this.selectedFpaDefaultClipBounds = this.showSelectedFpa && this.props.selectedFpaClipBounds === undefined
            ? VecNSubject.create(VecNMath.create(4))
            : undefined;
        this.selectedFpaClipBounds = this.showSelectedFpa ? ((_a = this.props.selectedFpaClipBounds) !== null && _a !== void 0 ? _a : this.selectedFpaDefaultClipBounds) : undefined;
        this.aoa = Subject.create(0);
        this.aoaLimit = ConsumerSubject.create(null, 0).pause();
        this.showPitchLimit = Subject.create(false);
        this.aoaTransitionState = undefined;
        this.fdFlagHidden = this.props.showFdFailureFlagWhenAttFail ? this.isAttitudeDataValid : Subject.create(true);
        this.fpvFlagHidden = MappedSubject.create(([show, isDataValid]) => !show || isDataValid, this.props.showFpv, this.isInertialDataValid).pause();
        this.updateFreq = SubscribableUtils.toSubscribable(this.props.updateFreq, true);
        this.lastUpdateTime = undefined;
        this.lastUpdateSimTime = undefined;
        this.isAlive = true;
        this.isAwake = false;
        this.pauseable = [
            this.isAirspeedDataValid,
            this.isAltitudeDataValid,
            this.isAttitudeDataValid,
            this.isHeadingDataValid,
            this.isInertialDataValid,
            this.verticalSpeed,
            this.tas,
            this.magVar,
            this.showTcasRaPitchCueLayer,
            this.showFpv,
            this.showSelectedFpa,
            this.selectedFpa,
            this.aoaLimit,
            this.fpvFlagHidden
        ];
        this.updateCycleHandler = this.onUpdated.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a, _b;
        if (!this.isAwake) {
            this.horizonRef.instance.sleep();
        }
        const sub = this.props.bus.getSubscriber();
        this.headingSub = this.heading.sub(heading => {
            this.projectionParams.heading = heading;
        }, true);
        this.pitchSub = this.pitch.sub(pitch => {
            this.projectionParams.pitch = -pitch;
        }, true);
        this.rollSub = this.roll.sub(roll => {
            this.projectionParams.roll = -roll;
        }, true);
        this.isAttitudeDataValid.sub(isValid => {
            var _a, _b, _c, _d, _e, _f;
            if (isValid) {
                (_a = this.headingSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                (_b = this.pitchSub) === null || _b === void 0 ? void 0 : _b.resume(true);
                (_c = this.rollSub) === null || _c === void 0 ? void 0 : _c.resume(true);
            }
            else {
                (_d = this.headingSub) === null || _d === void 0 ? void 0 : _d.pause();
                (_e = this.pitchSub) === null || _e === void 0 ? void 0 : _e.pause();
                (_f = this.rollSub) === null || _f === void 0 ? void 0 : _f.pause();
                this.projectionParams.heading = 0;
                this.projectionParams.pitch = 0;
                this.projectionParams.roll = 0;
            }
        }, true);
        this.adcAirspeedSelectorIndexSub = this.adcAirspeedSelectorIndex.sub(index => {
            this.adcAirspeedIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
            this.isAirspeedDataValid.setConsumer(sub.on(`adc_selector_speed_data_valid_${index}`));
        }, true);
        this.adcAirspeedIndex.sub(index => {
            if (index < 0) {
                this.tas.setConsumer(null);
            }
            else {
                this.tas.setConsumer(sub.on(`adc_tas_${index}`));
            }
        }, true);
        this.adcAltitudeSelectorIndexSub = this.adcAltitudeSelectorIndex.sub(index => {
            this.adcAltitudeIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
            this.isAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
        }, true);
        this.adcAltitudeIndex.sub(index => {
            if (index < 0) {
                this.verticalSpeed.setConsumer(null);
            }
            else {
                this.verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
            }
        }, true);
        this.irsSelectorIndexSub = this.irsSelectorIndex.sub(index => {
            this.irsIndex.setConsumer(sub.on(`irs_selector_selected_index_${index}`));
            this.isHeadingDataValid.setConsumer(sub.on(`irs_selector_heading_data_valid_${index}`));
            this.isAttitudeDataValid.setConsumer(sub.on(`irs_selector_attitude_data_valid_${index}`));
            this.isInertialDataValid.setConsumer(sub.on(`irs_selector_inertial_data_valid_${index}`));
        }, true);
        this.irsIndex.sub(index => {
            if (index < 0) {
                this.heading.setConsumer(null);
                this.pitch.setConsumer(null);
                this.roll.setConsumer(null);
                this.turnCoordinatorBall.setConsumer(null);
                this.track.setConsumer(null);
                this.gs.setConsumer(null);
                this.inertialVs.setConsumer(null);
                this.accel.setConsumer(null);
            }
            else {
                this.heading.setConsumer(sub.on(`irs_hdg_deg_true_${index}`));
                this.pitch.setConsumer(sub.on(`irs_pitch_deg_${index}`));
                this.roll.setConsumer(sub.on(`irs_roll_deg_${index}`));
                this.turnCoordinatorBall.setConsumer(sub.on(`irs_turn_coordinator_ball_${index}`));
                this.track.setConsumer(sub.on(`irs_track_deg_true_${index}`));
                this.gs.setConsumer(sub.on(`irs_ground_speed_${index}`));
                this.inertialVs.setConsumer(sub.on(`irs_inertial_vertical_speed_${index}`));
                this.accel.setConsumer(sub.on(`irs_inertial_track_acceleration_${index}`));
            }
        }, true);
        this.simTime.setConsumer(sub.on('simTime'));
        this.simRate.setConsumer(sub.on('simRate'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.magVar.setConsumer(sub.on('magvar'));
        this.flapsPosition.setConsumer(sub.on('flap_computer_interpolated_position'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this.isFdActive.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.fdPitchSub = sub.on('fd_target_pitch').handle(pitch => { this.fdPitch.set(-pitch); });
        this.fdBankSub = sub.on('fd_target_bank').handle(bank => { this.fdBank.set(-bank); });
        this.fdTakeoffDeviation.setConsumer(sub.on('fd_takeoff_deviation'));
        (_a = this.selectedFpa) === null || _a === void 0 ? void 0 : _a.setConsumer(sub.on('ap_fpa_selected'));
        this.aoaLimit.setConsumer(sub.on('speedlimit_min_speed_aoa'));
        const projection = this.horizonRef.instance.projection;
        this.updateFdPitchErrorFactor(projection);
        this.updateFdBankErrorFactor(projection);
        this.selectedFpaDefaultClipBounds && this.updateSelectedFpaDefaultClipBounds(projection, this.selectedFpaDefaultClipBounds);
        this.tcasRaPitchCueDefaultBounds && this.updateTcasRaPitchCueDefaultBounds(projection, this.tcasRaPitchCueDefaultBounds);
        this.updateFreqSub = (_b = this.updateFreq) === null || _b === void 0 ? void 0 : _b.sub(freq => {
            var _a;
            (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.updateCycleSub = sub
                .on('realTime')
                .atFrequency(freq)
                .handle(this.updateCycleHandler);
        }, true);
    }
    /**
     * Wakes this horizon display. While awake, this display will be updated.
     * @throws Error if this horizon display has been destroyed.
     */
    wake() {
        var _a;
        if (!this.isAlive) {
            throw new Error('PfdHorizonDisplay: cannot wake a dead display');
        }
        if (this.isAwake) {
            return;
        }
        this.isAwake = true;
        for (const subject of this.paramSubjects) {
            subject.resume();
        }
        for (const pauseable of this.pauseable) {
            pauseable === null || pauseable === void 0 ? void 0 : pauseable.resume();
        }
        (_a = this.horizonRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.wake();
    }
    /**
     * Puts this horizon display to sleep. While asleep, this display will not be updated.
     * @throws Error if this horizon display has been destroyed.
     */
    sleep() {
        var _a;
        if (!this.isAlive) {
            throw new Error('PfdHorizonDisplay: cannot sleep a dead display');
        }
        if (!this.isAwake) {
            return;
        }
        this.isAwake = false;
        for (const subject of this.paramSubjects) {
            subject.pause();
        }
        for (const pauseable of this.pauseable) {
            pauseable === null || pauseable === void 0 ? void 0 : pauseable.pause();
        }
        (_a = this.horizonRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.sleep();
        this.fpvComputer.reset();
        this.aoaTransitionState = undefined;
    }
    /**
     * Responds to when this display's horizon projection changes.
     * @param projection This display's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.PitchScaleFactor)) {
            this.updateFdPitchErrorFactor(projection);
        }
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.HeadingScaleFactor)) {
            this.updateFdBankErrorFactor(projection);
        }
        if (this.selectedFpaDefaultClipBounds && BitFlags.isAny(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
            this.updateSelectedFpaDefaultClipBounds(projection, this.selectedFpaDefaultClipBounds);
        }
        if (this.tcasRaPitchCueDefaultBounds && BitFlags.isAny(changeFlags, HorizonProjectionChangeType.ProjectedSize | HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updateTcasRaPitchCueDefaultBounds(projection, this.tcasRaPitchCueDefaultBounds);
        }
    }
    /**
     * Updates the pitch error factor of this display's flight director command bars.
     * @param projection This display's horizon projection.
     */
    updateFdPitchErrorFactor(projection) {
        this.fdPitchErrorFactor.set(projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor());
    }
    /**
     * Updates the bank error and takeoff deviation factors of this display's flight director command bars.
     * @param projection This display's horizon projection.
     */
    updateFdBankErrorFactor(projection) {
        const headingResolution = projection.getScaleFactor() / projection.getFov() * projection.getHeadingScaleFactor();
        this.fdBankErrorFactor.set(headingResolution * 0.5);
        this.fdTakeoffDeviationFactor.set(headingResolution * 0.5);
    }
    /**
     * Updates the default clipping boundaries for this display's selected flight path angle symbol.
     * @param projection This display's horizon projection.
     * @param bounds The default clipping boundaries for this display's selected flight path angle symbol.
     */
    updateSelectedFpaDefaultClipBounds(projection, bounds) {
        const size = projection.getProjectedSize();
        bounds.set(0, 0, size[0], size[1]);
    }
    /**
     * Updates the default boundaries for this display's TCAS resolution advisory pitch cue layer.
     * @param projection This display's horizon projection.
     * @param bounds The default boundaries for this display's TCAS resolution advisory pitch cue layer.
     */
    updateTcasRaPitchCueDefaultBounds(projection, bounds) {
        const size = projection.getProjectedSize();
        const center = projection.getOffsetCenterProjected();
        bounds.set(-center[0], -center[1], size[0] - center[0], size[1] - center[1]);
    }
    /**
     * This method is called every update cycle.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    onUpdated(time) {
        var _a, _b;
        const dt = time - ((_a = this.lastUpdateTime) !== null && _a !== void 0 ? _a : time);
        this.lastUpdateTime = time;
        const simTime = this.simTime.get();
        const simDt = Math.max(0, simTime - ((_b = this.lastUpdateSimTime) !== null && _b !== void 0 ? _b : simTime));
        this.lastUpdateSimTime = simTime;
        this.doUpdate(time, dt, simTime, simDt);
        this.doWakingUpdate(time, dt);
    }
    /**
     * Perform update tasks that are run when the display is either awake or asleep.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     * @param dt The elapsed real time since the last update, in milliseconds.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param simDt The elapsed sim time since the last update, in milliseconds.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    doUpdate(time, dt, simTime, simDt) {
        // noop
    }
    /**
     * Performs update tasks that are only run when the display is awake.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     * @param dt The elapsed real time since the last update, in milliseconds.
     */
    doWakingUpdate(time, dt) {
        const projection = this.horizonRef.instance.projection;
        projection.set(this.projectionParams);
        if (this.isInertialDataValid.get()) {
            this.fpvComputer.update(projection.getHeading(), this.track.get(), this.gs.get(), this.inertialVs.get(), UnitType.MPS_PER_SEC.convertTo(this.accel.get(), UnitType.KNOT_PER_SEC), dt);
        }
        else {
            this.fpvComputer.reset();
        }
        if (this.isOnGround.get()) {
            if (this.aoaTransitionState === undefined) {
                this.aoaTransitionState = 0;
            }
            else {
                this.aoaTransitionState = Math.max(0, this.aoaTransitionState - dt / 1000);
            }
        }
        else {
            if (this.aoaTransitionState === undefined) {
                this.aoaTransitionState = 1;
            }
            else {
                this.aoaTransitionState = Math.min(1, this.aoaTransitionState + dt / 1000);
            }
        }
        // The sim's reported AoA on the ground can be weird sometimes, so we force the AoA to be equal to pitch while on
        // the ground (remember that sim pitch is positive-down). During the transition between on-ground and in-air, we
        // will blend the pitch and AoA for continuity.
        const aoa = MathUtils.lerp(this.aoaTransitionState, 0, 1, -this.pitch.get(), this.props.aoaDataProvider.aoa.get());
        this.aoa.set(aoa);
        // Show the pitch limit indicator when attitude data is valid, flaps are out of up, or when the limit is less than
        // 5 degrees above the current airplane pitch.
        this.showPitchLimit.set(this.isAttitudeDataValid.get()
            && (this.flapsPosition.get() > 0
                || aoa - this.aoaLimit.get() >= -5));
        this.horizonRef.instance.update(time);
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        const projection = new HorizonProjection(100, 100, 30);
        projection.onChange(this.onProjectionChanged.bind(this));
        return (FSComponent.buildComponent(HorizonComponent, { ref: this.horizonRef, projection: projection, projectedSize: this.props.projectedSize, fov: this.props.fov, fovEndpoints: this.props.fovEndpoints, projectedOffset: this.props.projectedOffset, class: 'pfd-horizon-display' },
            FSComponent.buildComponent(PfdArtificialHorizon, { projection: projection, show: this.isAttitudeDataValid, horizonLineConformalBounds: this.props.horizonLineConformalBounds, options: this.props.artificialHorizonOptions }),
            FSComponent.buildComponent(PfdPitchLadder, { projection: projection, show: this.isAttitudeDataValid, clipBounds: this.props.pitchLadderClipBounds, options: this.props.pitchLadderOptions }),
            FSComponent.buildComponent(PfdHorizonLine, { projection: projection, show: this.isAttitudeDataValid, showHeadingLabels: this.props.horizonLineSupportHeadingLabels ? this.showFpv : false, useMagneticHeading: true, magVar: this.magVar, options: this.props.horizonLineOptions }),
            FSComponent.buildComponent(PfdTcasRaPitchCueLayer, { projection: projection, show: this.showTcasRaPitchCueLayer, dataProvider: this.props.tcasRaCommandDataProvider, verticalSpeed: this.verticalSpeed, tas: this.tas, simRate: this.simRate, clipBounds: ((_a = this.props.tcasRaPitchCueClipBounds) !== null && _a !== void 0 ? _a : this.tcasRaPitchCueDefaultBounds), conformalBounds: ((_b = this.props.tcasRaPitchCueConformalBounds) !== null && _b !== void 0 ? _b : this.tcasRaPitchCueDefaultBounds), options: this.props.tcasRaPitchCueOptions }),
            FSComponent.buildComponent(PfdBankIndicator, { projection: projection, turnCoordinatorBall: this.turnCoordinatorBall, showPointer: this.isAttitudeDataValid, options: this.props.bankIndicatorOptions }),
            this.showSelectedFpa !== undefined && this.selectedFpa !== undefined && this.selectedFpaClipBounds !== undefined && (FSComponent.buildComponent(PfdSelectedFlightPathAngle, { projection: projection, show: this.showSelectedFpa, angle: this.selectedFpa, clipBounds: this.selectedFpaClipBounds })),
            FSComponent.buildComponent(PfdFlightPathVector, { projection: projection, show: this.showFpv, track: this.fpvComputer.fpTrack, pitch: this.fpvComputer.fpPitch, conformalBounds: this.props.fpvConformalBounds }),
            FSComponent.buildComponent("div", { class: { 'pfd-horizon-failure-flag': true, 'pfd-horizon-fpv-flag': true, 'hidden': this.fpvFlagHidden } }, "FPV"),
            FSComponent.buildComponent(PfdAirplaneSymbol, { projection: projection, show: Subject.create(true) }),
            FSComponent.buildComponent(PfdPitchLimitIndicator, { projection: projection, show: this.showPitchLimit, aoa: this.aoa, aoaLimit: this.aoaLimit, conformalBounds: this.props.pitchLimitConformalBounds, options: this.props.pitchLimitOptions }),
            FSComponent.buildComponent(PfdFlightDirector, { projection: projection, show: Subject.create(true), showCommandBars: this.isAttitudeDataValid, fmaData: this.fmaData, isFdActive: this.isFdActive, fdPitch: this.fdPitch, fdBank: this.fdBank, fdTakeoffDeviation: this.fdTakeoffDeviation, pitchErrorFactor: this.fdPitchErrorFactor, bankErrorFactor: this.fdBankErrorFactor, takeoffDeviationFactor: this.fdTakeoffDeviationFactor, conformalBounds: this.props.fdConformalBounds }),
            FSComponent.buildComponent("div", { class: { 'pfd-horizon-failure-flag': true, 'pfd-horizon-att-flag': true, 'hidden': this.isAttitudeDataValid } }, "ATT"),
            FSComponent.buildComponent("div", { class: { 'pfd-horizon-failure-flag': true, 'pfd-horizon-fd-flag': true, 'hidden': this.fdFlagHidden } }, "FD")));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.isAlive = false;
        this.paramSubjects.forEach(subject => { subject.destroy(); });
        this.adcAirspeedIndex.destroy();
        this.adcAltitudeIndex.destroy();
        this.irsIndex.destroy();
        this.isAirspeedDataValid.destroy();
        this.isAltitudeDataValid.destroy();
        this.isHeadingDataValid.destroy();
        this.isAttitudeDataValid.destroy();
        this.isInertialDataValid.destroy();
        this.simTime.destroy();
        this.simRate.destroy();
        this.isOnGround.destroy();
        this.verticalSpeed.destroy();
        this.tas.destroy();
        this.turnCoordinatorBall.destroy();
        this.magVar.destroy();
        this.track.destroy();
        this.gs.destroy();
        this.inertialVs.destroy();
        this.accel.destroy();
        this.flapsPosition.destroy();
        this.fmaData.destroy();
        this.fmsOperatingPhase.destroy();
        this.isFdActive.destroy();
        this.fdTakeoffDeviation.destroy();
        this.showFpv.destroy();
        (_a = this.showSelectedFpa) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.selectedFpa) === null || _b === void 0 ? void 0 : _b.destroy();
        this.fpvFlagHidden.destroy();
        (_c = this.adcAirspeedSelectorIndexSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.adcAltitudeSelectorIndexSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.irsSelectorIndexSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.updateFreqSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.updateCycleSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.fdPitchSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.fdBankSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.horizonRef.getOrDefault()) === null || _k === void 0 ? void 0 : _k.destroy();
        super.destroy();
    }
}

/**
 * A default implementation of {@link FlapRetractionDataProvider}.
 */
class DefaultFlapRetractionDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this._isFirstFlapRetractionStarted = Subject.create(false);
        /** @inheritdoc */
        this.isFirstFlapRetractionStarted = this._isFirstFlapRetractionStarted;
        this.flapsPosition = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.firstFlapsRetractionArmedPosition = 0;
        this.pauseable = [
            this.flapsPosition,
            this.isOnGround
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultFlapRetractionDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.flapsPosition.setConsumer(sub.on('flap_computer_interpolated_position'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultFlapRetractionDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultFlapRetractionDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /**
     * Executes this data provider's periodic updates.
     */
    update() {
        const flapsPosition = this.flapsPosition.get();
        if (this.isOnGround.get()) {
            this.firstFlapsRetractionArmedPosition = flapsPosition;
            this._isFirstFlapRetractionStarted.set(false);
        }
        else if (!this._isFirstFlapRetractionStarted.get()) {
            this._isFirstFlapRetractionStarted.set(flapsPosition === 0 || (flapsPosition < this.firstFlapsRetractionArmedPosition));
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * FMS positioning system data modes.
 */
var FmsPositionMode;
(function (FmsPositionMode) {
    /** No position data is available. */
    FmsPositionMode["None"] = "None";
    /** Position data is sourced from GPS. */
    FmsPositionMode["Gps"] = "Gps";
    /** Position data is sourced from DME/DME. */
    FmsPositionMode["Dme"] = "Dme";
    /** Position data is sourced from HNS (hybrid inertial navigation). */
    FmsPositionMode["Hns"] = "Hns";
    /** Position data is sourced from dead reckoning. */
    FmsPositionMode["DeadReckoning"] = "DeadReckoning";
    /** Position data is sourced from dead reckoning and more than 20 minutes have elapsed since the last accurate position fix. */
    FmsPositionMode["DeadReckoningExpired"] = "DeadReckoningExpired";
})(FmsPositionMode || (FmsPositionMode = {}));
/**
 * A Boeing FMS geo-positioning system.
 */
class FmsPositionSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an FMS geo-positioning system.
     * @param index The index of the FMS geo-positioning system.
     * @param bus An instance of the event bus.
     * @param gpsReceiverIndex The index of the GPS receiver used by this system. No GPS data will be used if the index
     * is negative.
     * @param adcIndex The index of the ADC used by this system in dead reckoning mode to obtain airspeed data.
     * @param ahrsIndex The index of the AHRS used by this system in dead reckoning mode to obtain heading data.
     * @param hnsIndex The index of the HNS used by this system. No HNS data will be used if the index is negative.
     * Defaults to `-1`.
     * @param dmeIndex The index of the DME/DME navigation system used by this system. No DME/DME data will be used if
     * the index is negative. Defaults to `-1`.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsReceiverIndex, adcIndex, ahrsIndex, hnsIndex, dmeIndex, powerSource) {
        super(index, bus, `fms_pos_state_${index}`);
        this.initializationTime = 0;
        this.gnssDataSourceTopicMap = {
            [`fms_pos_gps-position_${this.index}`]: 'gps-position',
            [`fms_pos_ground_speed_${this.index}`]: 'ground_speed',
            [`fms_pos_track_deg_true_${this.index}`]: 'track_deg_true',
            [`fms_pos_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.modeTopic = `fms_pos_mode_${this.index}`;
        this.gpsIndexTopic = `fms_pos_gps_index_${this.index}`;
        this.hnsIndexTopic = `fms_pos_hns_index_${this.index}`;
        this.iruAnpTopic = `fms_pos_iru_anp_${this.index}`;
        this.gpsAnpTopic = `fms_pos_gps_anp_${this.index}`;
        this.radioAnpTopic = `fms_pos_radio_anp_${this.index}`;
        this.anpTopic = `fms_pos_anp_${this.index}`;
        this.verticalAnpTopic = `fms_pos_vertical_anp_${this.index}`;
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0);
        this.gpsStateSource = ConsumerSubject.create(null, GPSSystemState.Searching);
        this.gpsState = Subject.create(GPSSystemState.Searching);
        this.gpsPdop = ConsumerSubject.create(null, -1);
        this.gpsGroundSpeed = ConsumerSubject.create(null, -1);
        this.adcSystemState = ConsumerSubject.create(null, null);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.pitch = 0;
        /** filtered pitch rate in degrees per second */
        this.pitchRate = Subject.create(0);
        this.verticalAnp = MappedSubject.create(([zp, pitchRate]) => MathUtils.round(MathUtils.clamp(2.6 * zp ** 3 * Math.pow(10, -12) + 49, 49, 169) + 6 * Math.abs(pitchRate)), this.pressureAlt, this.pitchRate);
        this.mode = FmsPositionMode.None;
        this.lastFixTime = undefined;
        this.gpsIndex = SubscribableUtils.toSubscribable(gpsReceiverIndex, true);
        this.hnsIndex = SubscribableUtils.toSubscribable(-1, true);
        this.dmeIndex = SubscribableUtils.toSubscribable(-1, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        this.ahrsIndex = SubscribableUtils.toSubscribable(ahrsIndex, true);
        this.publisher.pub(this.modeTopic, this.mode, false, true);
        this.publisher.pub(this.iruAnpTopic, -1, false, true);
        this.publisher.pub(this.gpsAnpTopic, -1, false, true);
        this.publisher.pub(this.radioAnpTopic, -1, false, true);
        this.publisher.pub(this.anpTopic, -1, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.gnssDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onGnssTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.gnssDataSourceTopicMap) {
                this.onGnssTopicSubscribed(topic);
            }
        });
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.gpsIndex.sub(index => this.publisher.pub(this.gpsIndexTopic, index, false, true), !paused, paused));
        this.dataSubs.push(this.hnsIndex.sub(index => this.publisher.pub(this.hnsIndexTopic, index, false, true), !paused, paused));
        const gpsStatePipe = this.gpsStateSource.pipe(this.gpsState, true);
        this.gpsIndex.sub(index => {
            if (index < 0) {
                this.gpsStateSource.setConsumer(null);
                gpsStatePipe.pause();
                this.gpsState.set(GPSSystemState.Searching);
            }
            else {
                this.gpsStateSource.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_state_changed_${index}`));
                gpsStatePipe.resume(true);
            }
        }, true);
        this.dataSubs.push(this.gpsPdop.sub(this.updateAnp.bind(this), !paused, paused));
        this.verticalAnpSub = this.verticalAnp.sub((verAnp) => this.publisher.pub(this.verticalAnpTopic, verAnp, false, true));
        this.dataSubs.push(this.dataSourceSubscriber.on('actual_pitch_deg').atFrequency(5).handle((pitch) => {
            this.pitchRate.set(0.8 * this.pitchRate.get() + 0.2 * 5 * (pitch - this.pitch));
            this.pitch = pitch;
        }));
        this.adcSystemState.sub(this.updateAdcSystemState.bind(this));
        this.dataSubs.push(this.gpsIndex.sub((index) => this.gpsPdop.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_pdop_${index}`)), !paused, paused));
        this.gpsGroundSpeed.setConsumer(this.dataSourceSubscriber.on('ground_speed').withPrecision(0));
        this.dataSubs.push(this.adcIndex.sub((index) => this.pressureAlt.setConsumer(this.dataSourceSubscriber.on(`adc_pressure_alt_${index}`).withPrecision(-2)), !paused, paused));
        this.dataSubs.push(this.adcIndex.sub((index) => this.adcSystemState.setConsumer(this.dataSourceSubscriber.on(`adc_state_${index}`)), !paused, paused));
    }
    /**
     * Responds to when someone first subscribes to one of this system's GNSS-sourced data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onGnssTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.gnssDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.setMode(FmsPositionMode.None);
            this.lastFixTime = undefined;
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.updateMode();
        }
    }
    /**
     * Updates this system's data mode.
     */
    updateMode() {
        const gpsState = this.gpsState.get();
        if (gpsState === GPSSystemState.SolutionAcquired || gpsState === GPSSystemState.DiffSolutionAcquired) {
            this.setMode(FmsPositionMode.Gps);
            this.lastFixTime = this.simTime.get();
        }
        else if (this.lastFixTime !== undefined) {
            if (this.simTime.get() - this.lastFixTime > FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME) {
                this.setMode(FmsPositionMode.DeadReckoningExpired);
            }
            else {
                this.setMode(FmsPositionMode.DeadReckoning);
            }
        }
        else {
            this.setMode(FmsPositionMode.None);
        }
    }
    /**
     * Sets this system's data mode, and publishes the new value to the event bus if it differs from the current value.
     * @param mode The new data mode.
     */
    setMode(mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this.publisher.pub(this.modeTopic, this.mode, false, true);
    }
    /** Update the ANP from data sources */
    updateAnp() {
        // The Boeing ANP includes navigation system error (aka position uncertainty),
        // but excludes Flight Technical Error (this is shown on the EFIS as a function of ANP and RNP),
        // and excludes path computation error as this is assumed negligable
        // https://www.boeing.com/commercial/aeromagazine/aero_16/navigation_story.html
        const pdop = this.gpsPdop.get();
        if (pdop >= 0) {
            const anp = FmsPositionSystem.ANP(pdop);
            this.publisher.pub(this.gpsAnpTopic, anp, false, true);
            this.publisher.pub(this.anpTopic, anp, false, true);
        }
        else {
            this.publisher.pub(this.gpsAnpTopic, pdop, false, true);
            this.publisher.pub(this.anpTopic, pdop, false, true);
        }
        // TODO IRU and radio position
    }
    /**
     * Updates the ADC derived values when the ADC system state changes
     * @param state ADC system state event
     */
    updateAdcSystemState(state) {
        var _a, _b;
        if ((state === null || state === void 0 ? void 0 : state.current) === AvionicsSystemState.On) {
            (_a = this.verticalAnpSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        }
        else {
            (_b = this.verticalAnpSub) === null || _b === void 0 ? void 0 : _b.pause();
            this.publisher.pub(this.verticalAnpTopic, -1, false, true);
        }
    }
}
FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME = UnitType.MINUTE.convertTo(20, UnitType.MILLISECOND);
/** Calculates the ANP as the circle radius where the airplane position is estimated to be within 95% of the time.
 * Uses the statistic formula of estimating a 95% confidence interval with a (hypothetical) sample size of 1.
 * @param pdop The geometric dilution of precision computation (GDOP).
 * @returns The estimated ANP.
 */
FmsPositionSystem.ANP = (pdop) => {
    /** In meters. Used for calculating the ANP. Sets at 222 under the assumption that airplane cruises at 800 km/h,
     * hence if gps position is updated every second, the deviation would be 222 m/s.
     * Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR = 222;
    /** In meters. Used for calculating the ANP. Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const ESTIMATED_NUMERICAL_ERROR = 200;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL = 1.96;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const HYPOTHETICAL_SAMPLE_SIZE = 1;
    const STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS = () => {
        return Math.sqrt((pdop * STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR) ^ 2 + ESTIMATED_NUMERICAL_ERROR ^ 2);
    };
    const anpMeter = Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL * STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS() / Math.sqrt(HYPOTHETICAL_SAMPLE_SIZE);
    return MathUtils.round(UnitType.NMILE.convertFrom(anpMeter, UnitType.METER), 0.01);
};

/**
 * A controller that listens to H Events sent for Minimums Indications.
 * Sends Key Events to MinimumsManager.
 */
class BoeingMinimumsStateController {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param minimumsModeSub Minimums mode subscribable.
     */
    constructor(bus, minimumsModeSub) {
        this.bus = bus;
        this.minimumsModeSub = minimumsModeSub;
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.bus);
        this.minsPub = this.bus.getPublisher();
        this.alertSub = this.bus.getSubscriber();
        this.isAlerting = ConsumerSubject.create(this.alertSub.on('minimums_alert').whenChanged(), false);
        /** The minimums mode that is set in the cockpit. Can only be RA or BARO */
        this.cockpitSetMinsMode = MinimumsMode.OFF;
        this.minimumsIsOn = Subject.create(false);
        this.currentRadioMinimumsValue = 0;
        this.currentBaroMinimumsValue = 0;
        this.setSimVarTopic = 'set_decision_altitude_feet';
        this.lastTimeKnobUsed = null;
        this.knobHits = 0;
        this.knobIncrementValue = 10;
        this.init();
    }
    /**
     * Initializes this controller. Once initialized, this will continuously listen to H Events that interact with the minimums,
     * and send MinimumsControllerEvent-s to MinimumsManager until destroyed.
     */
    init() {
        const efisEventSub = this.bus.getSubscriber();
        const minsSub = this.bus.getSubscriber();
        const decisionHeightSub = ConsumerSubject.create(minsSub.on('decision_height_feet').whenChanged(), 0);
        const decisionAltitudeSub = ConsumerSubject.create(minsSub.on('decision_altitude_feet').whenChanged(), 0);
        this.minimumsModeSub.sub((mode) => {
            this.cockpitSetMinsMode = mode === 0 ? MinimumsMode.RA : MinimumsMode.BARO;
            this.setSimVarTopic = this.cockpitSetMinsMode === MinimumsMode.RA ? 'set_decision_height_feet' : 'set_decision_altitude_feet';
            this.setMinsModeSetting();
            this.setMinsValueSetting();
            // Re-sync minimums value after mode is changed
            const minimumsValue = this.cockpitSetMinsMode === MinimumsMode.RA ? this.currentRadioMinimumsValue : this.currentBaroMinimumsValue;
            this.minsPub.pub(this.setSimVarTopic, minimumsValue);
        }, true);
        decisionHeightSub.sub((dh) => {
            this.currentRadioMinimumsValue = dh;
            this.cockpitUserSettings.getSetting('decisionHeightFeet').set(dh);
        }, true);
        decisionAltitudeSub.sub((da) => {
            this.currentBaroMinimumsValue = da;
            this.cockpitUserSettings.getSetting('decisionAltitudeFeet').set(da);
        }, true);
        this.minimumsIsOn.sub(() => this.setMinsModeSetting(), true);
        efisEventSub.on('EFIS.MINS_INC').handle(() => { this.handleMinsChangeEvent(true); });
        efisEventSub.on('EFIS.MINS_DEC').handle(() => { this.handleMinsChangeEvent(false); });
        efisEventSub.on('EFIS.MINS_PRESS').handle(() => { this.handleMinsPressEvent(); });
        this.cockpitUserSettings.getSetting('minimumsMode').sub(mode => {
            SimVar.SetSimVarValue('L:WT_BOEING_MINIMUMS_MODE', SimVarValueType.Number, mode);
        }, true);
    }
    /**
     * Handles the minimums increase and decrease events.
     * @param isIncrease Whether the minimums should be increased or decreased.
     */
    handleMinsChangeEvent(isIncrease) {
        this.minimumsIsOn.set(true);
        this.adjustKnobVelocity();
        const direction = isIncrease ? 'up' : 'down';
        const baseValue = this.cockpitSetMinsMode === MinimumsMode.RA
            ? this.currentRadioMinimumsValue
            : this.currentBaroMinimumsValue;
        const nextMinimumsValue = MathUtils.clamp(baseValue + this.knobIncrementValue * (direction === 'up' ? 1 : -1), 0, 99999);
        this.minsPub.pub(this.setSimVarTopic, nextMinimumsValue);
    }
    /** Handles the Minimums Press (reset) event.
     * Only reset / turn off minimums indicator when it is not in ALERTING state.
     */
    handleMinsPressEvent() {
        if (!this.isAlerting.get()) {
            this.minimumsIsOn.set(false);
            this.minsPub.pub('set_decision_height_feet', 0);
            this.minsPub.pub('set_decision_altitude_feet', 0);
        }
    }
    /** Set minimums mode setting in CockpitUserSettings. */
    setMinsModeSetting() {
        this.cockpitUserSettings.getSetting('minimumsMode').set(this.minimumsIsOn.get() ? this.cockpitSetMinsMode : MinimumsMode.OFF);
    }
    /** Sets minimums value setting in CockpitUserSettings. */
    setMinsValueSetting() {
        if (this.cockpitSetMinsMode === MinimumsMode.RA) {
            this.cockpitUserSettings.getSetting('decisionHeightFeet').set(this.currentRadioMinimumsValue);
        }
        else {
            this.cockpitUserSettings.getSetting('decisionAltitudeFeet').set(this.currentBaroMinimumsValue);
        }
    }
    /**
     * Increase knob velocity according to frequency of use.
     */
    adjustKnobVelocity() {
        if (!this.lastTimeKnobUsed) {
            this.lastTimeKnobUsed = Date.now();
        }
        else {
            if (Date.now() - this.lastTimeKnobUsed < 300) {
                if (this.knobHits < 5) {
                    this.knobIncrementValue = 1;
                }
                else if (this.knobHits <= 10) {
                    this.knobIncrementValue = 10;
                }
                else {
                    this.knobIncrementValue = 100;
                }
                this.knobHits++;
            }
            else {
                this.knobIncrementValue = 1;
                this.knobHits = 0;
            }
            this.lastTimeKnobUsed = Date.now();
        }
    }
}

/**
 * A Boeing ADC system.
 */
class AdcSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an ADC system.
     * @param index The index of the ADC.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
     * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, altimeterIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.altimeterIndex = altimeterIndex;
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_indicated_alt_${this.index}`]: `indicated_alt_${this.altimeterIndex}`,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: `altimeter_baro_setting_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: `altimeter_baro_preselect_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: `altimeter_baro_preselect_mb_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: `altimeter_baro_preselect_raw_${this.altimeterIndex}`,
            [`adc_altimeter_baro_is_std_${this.index}`]: `altimeter_baro_is_std_${this.altimeterIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number',
            [`adc_pressure_alt_${this.index}`]: 'pressure_alt',
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed',
            [`adc_ambient_density_${this.index}`]: 'ambient_density',
            [`adc_ambient_temp_c_${this.index}`]: 'ambient_temp_c',
            [`adc_ambient_pressure_inhg_${this.index}`]: 'ambient_pressure_inhg',
            [`adc_isa_temp_c_${this.index}`]: 'isa_temp_c',
            [`adc_ram_air_temp_c_${this.index}`]: 'ram_air_temp_c'
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, true, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing ADC data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.dataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.speedDataValidTopic, true, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.speedDataValidTopic, false, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, false, false, true);
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best ADC from a set of candidates based on the current states of all systems. System state
 * desiribility depends on whether it is providing valid airspeed and altitude data.
 */
class AdcSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the ADC systems from which to select.
     * @param systemPriorities The priorities for selecting individual ADC systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of ADC system indexes or a map of
     * ADC system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     * @param dataBias Whether to bias system desirability toward valid airspeed data, valid altitude data, or neither.
     * Defaults to `'none'`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities, dataBias) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isSpeedDataValid = Subject.create(false);
        this.isAltitudeDataValid = Subject.create(false);
        this.adcEntries = new Map();
        this.adcOrder = [];
        this.adcComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        switch (dataBias) {
            case 'airspeed':
                this.adcStateComparator = (a, b) => (Number(b[0]) * 1.5 + Number(b[1])) - (Number(a[0]) * 1.5 + Number(a[1]));
                break;
            case 'airspeed-only':
                this.adcStateComparator = (a, b) => Number(b[0]) - Number(a[0]);
                break;
            case 'altitude':
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1]) * 1.5) - (Number(a[0]) + Number(a[1]) * 1.5);
                break;
            case 'altitude-only':
                this.adcStateComparator = (a, b) => Number(b[1]) - Number(a[1]);
                break;
            default:
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1])) - (Number(a[0]) + Number(a[1]));
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `adc_selector_selected_index_${index}`), true);
        this.isSpeedDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_speed_data_valid_${index}`), true);
        this.isAltitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_altitude_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('AdcSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.adcEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`adc_speed_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`adc_altitude_data_valid_${key}`), false),
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.adcEntries.set(key, entry);
                // When there is a change in an ADC state, we don't reselect immediately because the ADC could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.adcEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the ADC with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.adcEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.adcEntries.size === 1) {
            const entry = this.adcEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.adcOrder.length = 0;
            for (const index of this.adcEntries.keys()) {
                this.adcOrder.push(index);
            }
            this.adcOrder.sort(this.adcComparator);
            bestIndex = -1;
            for (let i = 0; i < this.adcOrder.length; i++) {
                const index = this.adcOrder[i];
                const state = this.adcEntries.get(index).state.get();
                if (!bestState || this.adcStateComparator(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isSpeedDataValid.set(bestState[0]);
            this.isAltitudeDataValid.set(bestState[1]);
        }
        else {
            this.isSpeedDataValid.set(false);
            this.isAltitudeDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.adcEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}

/**
 * A Boeing angle of attack computer system.
 */
class AoaSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `aoa_state_${index}`);
        this.initializationTime = 15000;
        this.simVarPublisher = new SimVarPublisher(new Map([
            [`aoa_load_factor_${this.index}`, { name: 'SEMIBODY LOADFACTOR Y', type: SimVarValueType.Number }]
        ]), this.bus);
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.isAoaSubbed = false;
        this.isStallAoaSubbed = false;
        this.isZeroLiftAoaSubbed = false;
        this.normAoaTopic = `aoa_norm_aoa_${this.index}`;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    startDataPublish() {
        const topics = [
            `aoa_aoa_${this.index}`,
            `aoa_stall_aoa_${this.index}`,
            `aoa_zero_lift_aoa_${this.index}`,
            `aoa_norm_aoa_${this.index}`
        ];
        for (const topic of topics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
        this.simVarPublisher.startPublish();
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        let shouldSubAoa = false;
        let shouldSubStallAoa = false;
        let shouldSubZeroLiftAoa = false;
        switch (topic) {
            case `aoa_aoa_${this.index}`:
                shouldSubAoa = true;
                break;
            case `aoa_stall_aoa_${this.index}`:
                shouldSubStallAoa = true;
                break;
            case `aoa_zero_lift_aoa_${this.index}`:
                shouldSubZeroLiftAoa = true;
                break;
            case `aoa_norm_aoa_${this.index}`:
                shouldSubAoa = true;
                shouldSubStallAoa = true;
                shouldSubZeroLiftAoa = true;
                break;
        }
        if (shouldSubAoa && !this.isAoaSubbed) {
            this.isAoaSubbed = true;
            const pubTopic = `aoa_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('aoa').handle(val => {
                this.aoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubStallAoa && !this.isStallAoaSubbed) {
            this.isStallAoaSubbed = true;
            const pubTopic = `aoa_stall_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('stall_aoa').handle(val => {
                this.stallAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubZeroLiftAoa && !this.isZeroLiftAoaSubbed) {
            this.isZeroLiftAoaSubbed = true;
            const pubTopic = `aoa_zero_lift_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('zero_lift_aoa').handle(val => {
                this.zeroLiftAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.Failed
            || this._state === AvionicsSystemState.Off
            || this.aoa === undefined
            || this.stallAoa === undefined
            || this.zeroLiftAoa === undefined) {
            return;
        }
        this.publisher.pub(this.normAoaTopic, (this.aoa - this.zeroLiftAoa) / (this.stallAoa - this.zeroLiftAoa), false, true);
        this.simVarPublisher.onUpdate();
    }
}

/**
 * A publisher that publishes Boeing Game Units events.
 */
class BoeingGameUnitsPublisher extends GameVarPublisher {
    /**
     * Creates an instance of the BoeingGameUnitsPublisher.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        super(BoeingGameUnitsPublisher.gamevars, bus);
    }
}
BoeingGameUnitsPublisher.gamevars = new Map([
    ['game_units_metric', { name: 'GAME UNIT IS METRIC', type: SimVarValueType.Bool }],
]);

/**
 * Automatically selects the best GPS receiver from a set of candidates based on the current states of all receivers.
 * Receivers that have computed a 3D position solution with differential corrections are favored over those that have
 * computed a 3D solution without corrections, and either of these are favored over those that have not computed any
 * position solution.
 */
class GpsReceiverSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param enabledReceiverIndexes The indexes of the GPS receivers from which to select.
     * @param preferredReceiverIndex The index of this selector's preferred GPS receiver, or `-1` if there is no such
     * receiver. This selector is guaranteed to select the preferred GPS receiver if its state is at least as desirable
     * as the state of all other receivers from which to select. Defaults to `-1`.
     */
    constructor(bus, enabledReceiverIndexes, preferredReceiverIndex) {
        this.bus = bus;
        this._selectedIndex = Subject.create(-1);
        this.selectedIndex = this._selectedIndex;
        this.gpsStates = new Map();
        this.isAlive = true;
        this.isInit = false;
        this.enabledReceiverIndexes = 'isSubscribableSet' in enabledReceiverIndexes ? enabledReceiverIndexes : SetSubject.create(enabledReceiverIndexes);
        this.preferredReceiverIndex = SubscribableUtils.toSubscribable(preferredReceiverIndex !== null && preferredReceiverIndex !== void 0 ? preferredReceiverIndex : -1, true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best GPS receiver among
     * its candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('GpsReceiverSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const selectIndex = this.selectIndex.bind(this);
        this.enabledReceiverIndexesSub = this.enabledReceiverIndexes.sub((set, type, key) => {
            var _a;
            (_a = this.gpsStates.get(key)) === null || _a === void 0 ? void 0 : _a.destroy();
            if (type === SubscribableSetEventType.Added) {
                const gpsState = ConsumerSubject.create(sub.on(`gps_rec_gps_system_state_changed_${key}`), GPSSystemState.Acquiring);
                this.gpsStates.set(key, gpsState);
                gpsState.sub(selectIndex);
            }
            else {
                this.gpsStates.delete(key);
            }
            selectIndex();
        }, true);
        this.preferredReceiverIndexSub = this.preferredReceiverIndex.sub(selectIndex);
    }
    /**
     * Selects the index of the GPS receiver with the most desirable state.
     */
    selectIndex() {
        var _a, _b;
        if (this.gpsStates.size === 0) {
            this._selectedIndex.set(-1);
            return;
        }
        if (this.gpsStates.size === 1) {
            this._selectedIndex.set(this.gpsStates.keys().next().value);
            return;
        }
        let bestIndex = this._selectedIndex.get();
        let bestState = (_a = this.gpsStates.get(bestIndex)) === null || _a === void 0 ? void 0 : _a.get();
        for (const index of this.gpsStates.keys()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const state = this.gpsStates.get(index).get();
            if (bestIndex < 0 || !bestState || GpsReceiverSelector.compareGpsState(state, bestState) < 0) {
                bestIndex = index;
                bestState = state;
            }
        }
        const preferredIndex = this.preferredReceiverIndex.get();
        if (preferredIndex >= 0) {
            const preferredIndexState = (_b = this.gpsStates.get(preferredIndex)) === null || _b === void 0 ? void 0 : _b.get();
            if (preferredIndexState !== undefined && GpsReceiverSelector.compareGpsState(preferredIndexState, bestState) <= 0) {
                bestIndex = preferredIndex;
            }
        }
        this._selectedIndex.set(bestIndex);
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        for (const state of this.gpsStates.values()) {
            state.destroy();
        }
        (_a = this.enabledReceiverIndexesSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.preferredReceiverIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    /**
     * Compares two GPS system states and returns a number whose sign indicates which one is more desirable.
     * @param a The first GPS system state to compare.
     * @param b The second GPS system state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareGpsState(a, b) {
        return GpsReceiverSelector.GPS_STATE_PRIORITIES[a] - GpsReceiverSelector.GPS_STATE_PRIORITIES[b];
    }
}
GpsReceiverSelector.GPS_STATE_PRIORITIES = {
    [GPSSystemState.DiffSolutionAcquired]: 0,
    [GPSSystemState.SolutionAcquired]: 1,
    [GPSSystemState.Acquiring]: 2,
    [GPSSystemState.Searching]: 2
};

/**
 * A Garmin GPS receiver system.
 */
class GpsReceiverSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a GPS receiver system.
     * @param index The index of the GPS receiver.
     * @param bus An instance of the event bus.
     * @param gpsSatComputer This system's GPS computer system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsSatComputer, powerSource) {
        super(index, bus, `gps_rec_state_${index}`);
        this.gpsSatComputer = gpsSatComputer;
        this.initializationTime = 0;
        this.cachedDataSourceTopicMap = {
            [`gps_rec_gps_system_state_changed_${this.index}`]: `gps_system_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_sbas_state_changed_${this.index}`]: `gps_system_sbas_state_changed_${this.gpsSatComputer.index}`
        };
        this.uncachedDataSourceTopicMap = {
            [`gps_rec_gps_sat_state_changed_${this.index}`]: `gps_sat_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_sat_pos_calculated_${this.index}`]: `gps_sat_pos_calculated_${this.gpsSatComputer.index}`
        };
        this.dopDataSourceTopicMap = {
            [`gps_rec_gps_system_pdop_${this.index}`]: `gps_system_pdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_hdop_${this.index}`]: `gps_system_hdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_vdop_${this.index}`]: `gps_system_vdop_${this.gpsSatComputer.index}`
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.dopSources = [];
        this.sbasState = ConsumerSubject.create(null, GPSSystemSBASState.Disabled);
        gpsSatComputer.init();
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        else if (gpsSatComputer.syncRole !== 'replica') {
            // If our power source is undefined, then the system is always considered to be in the on state. Therefore we
            // will force the GPS to immediately acquire and use all the satellites it can since a system that is always on
            // never needs to initialize.
            gpsSatComputer.acquireAndUseSatellites();
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.cachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.cachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }));
        }
        for (const topic of Object.keys(this.uncachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.uncachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, false);
            }));
        }
        // Garmin seems to halve DOP values when SBAS is active. It could be a trainer-specific behavior, but in the
        // absence of any other information, we will implement it here.
        this.sbasState.setConsumer(this.dataSourceSubscriber.on(`gps_system_sbas_state_changed_${this.gpsSatComputer.index}`));
        for (const topic of Object.keys(this.dopDataSourceTopicMap)) {
            const dopSource = ConsumerSubject.create(this.dataSourceSubscriber.on(this.dopDataSourceTopicMap[topic]), -1);
            this.dopSources.push(dopSource);
            const processedDop = MappedSubject.create(([dop, sbasState]) => dop <= 0 ? dop : dop * (sbasState === GPSSystemSBASState.Active ? 0.5 : 1), dopSource, this.sbasState);
            this.dataSubs.push(processedDop.sub(dop => {
                this.publisher.pub(topic, dop, false, false);
            }, true));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        // If this is the first time we are setting our state and the state is on, then we assume that the system was on at
        // flight load, in which case we will force the GPS to immediately acquire and use all the satellites it can so
        // that we don't force people to wait for satellite acquisition when loading onto the runway/in the air.
        if (previousState === undefined && currentState === AvionicsSystemState.On && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.acquireAndUseSatellites();
        }
        // Reset the GPS sat computer if the system is not operating and its receiver is not a replica (a replica receiver
        // will get the reset command from its primary).
        if ((currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.reset();
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.gpsSatComputer.onUpdate();
        }
    }
}

/**
 * IRS operating modes.
 */
var IrsSystemOperatingMode;
(function (IrsSystemOperatingMode) {
    /** The IRS is not operating. */
    IrsSystemOperatingMode["Off"] = "Off";
    /** The IRS is in Standby mode. No data are available. */
    IrsSystemOperatingMode["Standby"] = "Standby";
    /** The IRS is performing a full alignment. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlign"] = "FullAlign";
    /** The IRS has completed a full alignment but is awaiting a position input. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlignPositionPending"] = "FullAlignPositionPending";
    /** The IRS is in Navigation mode. All data are available. */
    IrsSystemOperatingMode["Navigation"] = "Navigation";
    /** The IRS is performing a realignment. All data are available. */
    IrsSystemOperatingMode["Realign"] = "Realign";
    /** The IRS is performing an attitude alignment. No data are available. */
    IrsSystemOperatingMode["AttitudeAlign"] = "AttitudeAlign";
    /** The IRS is in Attitude mode. Attitude and heading data are available. */
    IrsSystemOperatingMode["Attitude"] = "Attitude";
})(IrsSystemOperatingMode || (IrsSystemOperatingMode = {}));
/**
 * IRS system operating mode setting commands.
 */
var IrsSystemOperatingModeSetting;
(function (IrsSystemOperatingModeSetting) {
    /** Forces the IRS into Off mode. */
    IrsSystemOperatingModeSetting["Off"] = "Off";
    /** Commands Navigation mode. The IRS will perform a full alignment (if required), then enter Navigation mode. */
    IrsSystemOperatingModeSetting["Navigation"] = "Navigation";
    /**
     * Arms IRS realignment. If the IRS is in Navigation mode, then the next time Navigation mode is selected and the
     * airplane is on the ground and not moving, it will attempt an realignment.
     */
    IrsSystemOperatingModeSetting["Align"] = "Align";
    /** Commands Attitude mode. The IRS will perform an attitude alignment (if required), then enter Attitude mode. */
    IrsSystemOperatingModeSetting["Attitude"] = "Attitude";
})(IrsSystemOperatingModeSetting || (IrsSystemOperatingModeSetting = {}));
/**
 * A Boeing inertial reference system (IRS). Provides attitude, heading, and inertial (position, velocity,
 * acceleration) data.
 */
class IrsSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an IRS system.
     * @param index The index of the IRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this IRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this IRS derives its data.
     * @param supportInFlightAlign Whether this IRS supports full alignment while in flight. In-flight full alignment
     * requires position input from GPS receivers.
     * @param operatingModeSetting The operating mode setting commanded for this IRS.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     * @param gpsReceiverIndexes The indexes of the GPS receiver systems from which the IRS receives position input data.
     * If no indexes are supplied, then the IRS will not automatically initialize its position from GPS and will require
     * manual position input during alignment.
     * @param attitudeAlignDuration The duration, in milliseconds, required for this IRS to complete attitude alignment.
     * Defaults to 30000 milliseconds.
     * @param fullAlignDuration The duration, in milliseconds, required for this IRS to complete a full alignment. If not
     * defined, full alignment duration will be simulated based on the airplane's current latitude.
     * @param realignDuration The duration, in milliseconds, required for this IRS to complete realignment. Defaults to
     * 30000 milliseconds.
     */
    constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, supportInFlightAlign, operatingModeSetting, powerSource, gpsReceiverIndexes, attitudeAlignDuration, fullAlignDuration, realignDuration) {
        var _a;
        super(index, bus, `irs_state_${index}`);
        this.attitudeIndicatorIndex = attitudeIndicatorIndex;
        this.directionIndicatorIndex = directionIndicatorIndex;
        this.supportInFlightAlign = supportInFlightAlign;
        this.operatingModeSetting = operatingModeSetting;
        this.powerSource = powerSource;
        this.initializationTime = 0;
        this.simulatedFullAlignDuration = Subject.create(0);
        this.operatingModeTopic = `irs_operating_mode_${this.index}`;
        this.headingDataValidTopic = `irs_heading_data_valid_${this.index}`;
        this.attitudeDataValidTopic = `irs_attitude_data_valid_${this.index}`;
        this.inertialDataValidTopic = `irs_inertial_data_valid_${this.index}`;
        this.positionDataValidTopic = `irs_position_data_valid_${this.index}`;
        this.acceptingPositionTopic = `irs_is_accepting_position_${this.index}`;
        this.requestingPositionTopic = `irs_is_requesting_position_${this.index}`;
        this.fullAlignTimeTopic = `irs_full_align_time_remaining_${this.index}`;
        this.attitudeAlignTimeTopic = `irs_att_align_time_remaining_${this.index}`;
        this.operatingMode = IrsSystemOperatingMode.Navigation;
        this.isHeadingDataValid = true;
        this.isAttitudeDataValid = true;
        this.isInertialDataValid = true;
        this.isInertialHeadingDataValid = true;
        this.isPositionDataValid = true;
        this.isPositionInit = Subject.create(true);
        // When true, the next time isAcceptingPosition becomes true, isPositionInit will automatically be set to true
        this.autoPositionInit = false;
        this.isAcceptingPosition = Subject.create(false);
        this.isRealignArmed = false;
        this.attitudeAlignTime = 0;
        this.fullAlignTime = 0;
        this.realignTime = 0;
        this.publishedFullAlignTimeRemaining = undefined;
        this.publishedAttitudeAlignTimeRemaining = undefined;
        this.lastUpdateSimTime = undefined;
        this.simTime = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.speed = ConsumerValue.create(null, 0);
        this.position = ConsumerValue.create(null, new LatLongAlt(0, 0, 0));
        this.headingDataSourceTopicMap = {
            [`irs_hdg_deg_${this.index}`]: `hdg_deg_${this.directionIndicatorIndex}`,
            [`irs_hdg_deg_true_${this.index}`]: `hdg_deg_true_${this.directionIndicatorIndex}`
        };
        this.attitudeDataSourceTopicMap = {
            [`irs_delta_heading_rate_${this.index}`]: `delta_heading_rate_${this.attitudeIndicatorIndex}`,
            [`irs_pitch_deg_${this.index}`]: `pitch_deg_${this.attitudeIndicatorIndex}`,
            [`irs_roll_deg_${this.index}`]: `roll_deg_${this.attitudeIndicatorIndex}`,
            [`irs_turn_coordinator_ball_${this.index}`]: 'turn_coordinator_ball'
        };
        this.inertialDataSourceTopicMap = {
            [`irs_inertial_speed_${this.index}`]: 'inertial_speed',
            [`irs_inertial_vertical_speed_${this.index}`]: 'inertial_vertical_speed',
            [`irs_inertial_acceleration_${this.index}`]: 'inertial_acceleration',
            [`irs_inertial_track_acceleration_${this.index}`]: 'inertial_track_acceleration',
            [`irs_ground_speed_${this.index}`]: 'ground_speed'
        };
        this.inertialHeadingDataSourceTopicMap = {
            [`irs_track_deg_true_${this.index}`]: 'track_deg_true',
            [`irs_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.positionDataSourceTopicMap = {
            [`irs_gps-position_${this.index}`]: 'gps-position',
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.headingDataSubs = [];
        this.attitudeDataSubs = [];
        this.inertialDataSubs = [];
        this.inertialHeadingDataSubs = [];
        this.positionDataSubs = [];
        this.overrideAttitudeAlignDuration = SubscribableUtils.toSubscribable(attitudeAlignDuration, true);
        this.overrideFullAlignDuration = SubscribableUtils.toSubscribable(fullAlignDuration, true);
        this.overrideRealignDuration = SubscribableUtils.toSubscribable(realignDuration, true);
        this.attitudeAlignDuration = this.overrideAttitudeAlignDuration.map(duration => duration === undefined ? IrsSystem.ATTITUDE_ALIGN_DURATION : duration);
        this.fullAlignDuration = MappedSubject.create(([simulated, override, attitudeAlign]) => Math.max(override === undefined ? simulated : override, attitudeAlign), this.simulatedFullAlignDuration, this.overrideFullAlignDuration, this.attitudeAlignDuration);
        this.realignDuration = this.overrideRealignDuration.map(duration => duration === undefined ? IrsSystem.REALIGN_DURATION : duration);
        if (this.powerSource !== undefined) {
            this.connectToPower(this.powerSource);
        }
        // Initialize some cached topics.
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid);
        this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid);
        this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid);
        this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid);
        this.publishFullAlignTimeRemaining(null);
        this.publishAttitudeAlignTimeRemaining(null);
        // Set up automatic position initialization from GPS.
        const gpsReceiverIndexArray = Array.from(new Set(gpsReceiverIndexes)); // Ensure no duplicates
        if (gpsReceiverIndexArray.length > 0) {
            const gpsSub = bus.getSubscriber();
            this.isGpsAvailable = MappedSubject.create(states => states.includes(GPSSystemState.SolutionAcquired) || states.includes(GPSSystemState.DiffSolutionAcquired), ...gpsReceiverIndexArray.map(gpsReceiverIndex => ConsumerSubject.create(gpsSub.on(`gps_rec_gps_system_state_changed_${gpsReceiverIndex}`), GPSSystemState.Searching)));
            this.gpsPositionSub = this.isGpsAvailable.sub(isAvail => {
                if (isAvail) {
                    this.isPositionInit.set(true);
                }
            }, false, true);
        }
        const sub = bus.getSubscriber();
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.speed.setConsumer(sub.on('inertial_speed'));
        this.position.setConsumer(sub.on('gps-position'));
        this.setPositionSub = sub.on(`irs_set_position_${index}`).handle(() => {
            this.isPositionInit.set(true);
        }, true);
        this.autoSetPositionSub = sub.on('hEvent').handle(hEvent => {
            if (hEvent === 'WT_AUTO_SET_IRS_POS') {
                if (this.isAcceptingPosition.get()) {
                    this.isPositionInit.set(true);
                }
                else {
                    this.autoPositionInit = true;
                }
            }
        });
        this.isAcceptingPosition.sub(val => {
            var _a, _b;
            if (val) {
                this.setPositionSub.resume();
                (_a = this.gpsPositionSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                if (this.autoPositionInit) {
                    this.isPositionInit.set(true);
                    this.autoPositionInit = false;
                }
            }
            else {
                this.setPositionSub.pause();
                (_b = this.gpsPositionSub) === null || _b === void 0 ? void 0 : _b.pause();
            }
            this.publisher.pub(this.acceptingPositionTopic, val);
        }, true);
        // Request manual position input when the system is accepting position inputs, has not received a position input
        // yet, and GPS position is not available.
        this.isRequestingPosition = MappedSubject.create(([isAccepting, isInit, isGpsAvail]) => isAccepting && !isInit && !isGpsAvail, this.isAcceptingPosition, this.isPositionInit, (_a = this.isGpsAvailable) !== null && _a !== void 0 ? _a : Subject.create(false));
        this.isPositionInit.sub(isInit => {
            SimVar.SetSimVarValue(`L:WT_IRS_POS_SET_${this.index}`, SimVarValueType.Bool, isInit);
        }, true);
        this.isRequestingPosition.sub(val => { this.publisher.pub(this.requestingPositionTopic, val); }, true);
        this.startDataPublish();
    }
    /**
     * Starts publishing IRS data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.headingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.attitudeDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onAttitudeTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialHeadingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.positionDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onPositionTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.headingDataSourceTopicMap) {
                this.onHeadingTopicSubscribed(topic);
            }
            else if (topic in this.attitudeDataSourceTopicMap) {
                this.onAttitudeTopicSubscribed(topic);
            }
            else if (topic in this.inertialDataSourceTopicMap) {
                this.onInertialTopicSubscribed(topic);
            }
            else if (topic in this.inertialHeadingDataSourceTopicMap) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
            else if (topic in this.positionDataSourceTopicMap) {
                this.onPositionTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onHeadingTopicSubscribed(topic) {
        this.headingDataSubs.push(this.dataSourceSubscriber.on(this.headingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onAttitudeTopicSubscribed(topic) {
        this.attitudeDataSubs.push(this.dataSourceSubscriber.on(this.attitudeDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isAttitudeDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialTopicSubscribed(topic) {
        this.inertialDataSubs.push(this.dataSourceSubscriber.on(this.inertialDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial/heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialHeadingTopicSubscribed(topic) {
        this.inertialHeadingDataSubs.push(this.dataSourceSubscriber.on(this.inertialHeadingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid || !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onPositionTopicSubscribed(topic) {
        this.positionDataSubs.push(this.dataSourceSubscriber.on(this.positionDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isPositionDataValid));
    }
    /**
     * Publishes the time remaining for full alignment to complete.
     * @param time The time to publish, in seconds, or `null` if full alignment is not in process.
     */
    publishFullAlignTimeRemaining(time) {
        if (time === this.publishedFullAlignTimeRemaining) {
            return;
        }
        this.publishedFullAlignTimeRemaining = time;
        this.publisher.pub(this.fullAlignTimeTopic, time, false, true);
    }
    /**
     * Publishes the time remaining for attitude alignment to complete.
     * @param time The time to publish, in seconds, or `null` if attitude alignment is not in process.
     */
    publishAttitudeAlignTimeRemaining(time) {
        if (time === this.publishedAttitudeAlignTimeRemaining) {
            return;
        }
        this.publishedAttitudeAlignTimeRemaining = time;
        this.publisher.pub(this.attitudeAlignTimeTopic, time, false, true);
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        this.isPowered = isPowered;
        this.setState(isPowered ? AvionicsSystemState.On : AvionicsSystemState.Off);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Off) {
            this.setOperatingMode(IrsSystemOperatingMode.Off);
        }
    }
    /**
     * Sets this system's operating mode.
     * @param mode The operating mode to set.
     */
    setOperatingMode(mode) {
        if (this.operatingMode === mode) {
            return;
        }
        this.operatingMode = mode;
        let resetRealignTime = true;
        let disarmRealign = true;
        switch (mode) {
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                this.fullAlignTime = 0;
                this.attitudeAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.publishAttitudeAlignTimeRemaining(null);
            // fallthrough
            case IrsSystemOperatingMode.AttitudeAlign:
                this.fullAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.publishFullAlignTimeRemaining(0);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Navigation:
                disarmRealign = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Realign:
                this.isAcceptingPosition.set(true);
                resetRealignTime = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
        }
        if (resetRealignTime) {
            this.realignTime = 0;
        }
        if (disarmRealign) {
            this.isRealignArmed = false;
        }
        this.isRealignArmed = false;
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.updateHeadingDataState();
        this.updateAttitudeDataState();
        this.updateInertialDataState();
        this.updateInertialHeadingDataState();
        this.updatePositionDataState();
    }
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    updateHeadingDataState() {
        // TODO: Heading data requires manual heading input in Attitude mode if the IRS does not have an AHRU component.
        let isHeadingDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isHeadingDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isHeadingDataValid = false;
                break;
            default:
                isHeadingDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isHeadingDataValid !== this.isHeadingDataValid) {
            this.isHeadingDataValid = isHeadingDataValid;
            if (isHeadingDataValid) {
                for (const sub of this.headingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.headingDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    updateAttitudeDataState() {
        let isAttitudeDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isAttitudeDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isAttitudeDataValid = false;
                break;
            default:
                isAttitudeDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isAttitudeDataValid !== this.isAttitudeDataValid) {
            this.isAttitudeDataValid = isAttitudeDataValid;
            if (isAttitudeDataValid) {
                for (const sub of this.attitudeDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.attitudeDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial data. If inertial data is valid, this system will start
     * publishing inertial data. If inertial data is invalid, this system will stop publishing inertial data.
     */
    updateInertialDataState() {
        const isInertialDataValid = this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign;
        if (isInertialDataValid !== this.isInertialDataValid) {
            this.isInertialDataValid = isInertialDataValid;
            if (isInertialDataValid) {
                for (const sub of this.inertialDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial/heading data. If inertial/heading data is valid, this system
     * will start publishing inertial/heading data. If inertial/heading data is invalid, this system will stop publishing
     * inertial/heading data.
     */
    updateInertialHeadingDataState() {
        const isInertialHeadingDataValid = this.isHeadingDataValid && this.isInertialDataValid;
        if (isInertialHeadingDataValid !== this.isInertialHeadingDataValid) {
            this.isInertialHeadingDataValid = isInertialHeadingDataValid;
            if (isInertialHeadingDataValid) {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.pause();
                }
            }
        }
    }
    /**
     * Updates the validity state of this system's position data. If position data is valid, this system will start
     * publishing position data. If position data is invalid, this system will stop publishing position data.
     */
    updatePositionDataState() {
        const isPositionDataValid = this.isInertialDataValid;
        if (isPositionDataValid !== this.isPositionDataValid) {
            this.isPositionDataValid = isPositionDataValid;
            if (isPositionDataValid) {
                for (const sub of this.positionDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.positionDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.state === AvionicsSystemState.Off) {
            return;
        }
        const simTime = this.simTime.get();
        const dt = this.lastUpdateSimTime === undefined ? 0 : Math.max(0, simTime - this.lastUpdateSimTime);
        this.lastUpdateSimTime = simTime;
        this.updateSimulatedFullAlignDuration();
        const modeSetting = this.operatingModeSetting.get();
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Off:
                this.updateOff(modeSetting);
                break;
            case IrsSystemOperatingMode.Standby:
                this.updateStandby(modeSetting);
                break;
            case IrsSystemOperatingMode.FullAlign:
                this.updateFullAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.updateFullAlignPositionPending(modeSetting);
                break;
            case IrsSystemOperatingMode.Navigation:
                this.updateNavigation(modeSetting);
                break;
            case IrsSystemOperatingMode.Realign:
                this.updateRealign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.AttitudeAlign:
                this.updateAttitudeAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.updateAttitude(modeSetting);
                break;
        }
    }
    /**
     * Updates the simulated time required to complete a full alignment.
     */
    updateSimulatedFullAlignDuration() {
        // 5 min at equator, 17 min at 70 degrees latitude
        this.simulatedFullAlignDuration.set(MathUtils.lerp(Math.cos(this.position.get().lat * Avionics.Utils.DEG2RAD), 1, 0.342, 300e3, 1020e3, true, true));
    }
    /**
     * Attempts to start a new full or attitude alignment cycle.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @returns Whether a new alignment cycle was started.
     */
    tryStartFreshAlign(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isOnGround.get()) {
                    if (this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                        return true;
                    }
                }
                else if (this.supportInFlightAlign && this.isGpsAvailable && this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
                    this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                    return true;
                }
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                return true;
        }
        return false;
    }
    /**
     * Updates this system while it is in the Off operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateOff(modeSetting) {
        if (this.tryStartFreshAlign(modeSetting)) {
            return;
        }
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                break;
            default:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
        }
    }
    /**
     * Updates this system while it is in the Standby operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateStandby(modeSetting) {
        this.tryStartFreshAlign(modeSetting);
    }
    /**
     * Updates this system while it is in the FullAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateFullAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                if (this.attitudeAlignTime >= IrsSystem.ATTITUDE_ALIGN_DURATION) {
                    this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                }
                else {
                    this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                }
                return;
        }
        let isInFlightAlign = false;
        if (this.isOnGround.get()) {
            this.isAcceptingPosition.set(true);
            if (this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
                this.fullAlignTime = 0;
            }
        }
        else if (!this.supportInFlightAlign || !this.isGpsAvailable || !this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
            this.setOperatingMode(IrsSystemOperatingMode.Standby);
            return;
        }
        else {
            this.isAcceptingPosition.set(false);
            isInFlightAlign = true;
        }
        this.attitudeAlignTime += dt;
        this.fullAlignTime += dt;
        const fullAlignDuration = this.fullAlignDuration.get();
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration
            && (!this.isAttitudeDataValid || !this.isHeadingDataValid)) {
            this.updateAttitudeDataState();
            this.updateHeadingDataState();
        }
        if (this.fullAlignTime >= fullAlignDuration) {
            if (this.isPositionInit.get() || isInFlightAlign) {
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            }
            else {
                this.setOperatingMode(IrsSystemOperatingMode.FullAlignPositionPending);
            }
        }
        else {
            if (this.attitudeAlignTime >= attitudeAlignDuration) {
                this.publishAttitudeAlignTimeRemaining(null);
            }
            else {
                this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
            }
            this.publishFullAlignTimeRemaining((fullAlignDuration - this.fullAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the FullAlignPositionPending operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateFullAlignPositionPending(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        if (this.isPositionInit.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the Navigation operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateNavigation(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.isAcceptingPosition.set(true);
                this.isRealignArmed = true;
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isRealignArmed) {
                    // Realignment requires the airplane be on the ground and not moving.
                    if (this.isOnGround.get() && this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.Realign);
                        return;
                    }
                    else {
                        this.isRealignArmed = false;
                    }
                }
                this.isAcceptingPosition.set(false);
                break;
        }
    }
    /**
     * Updates this system while it is in the Realign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateRealign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        // Realignment requires the airplane be on the ground and not moving.
        if (!this.isOnGround.get() || this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            return;
        }
        this.realignTime += dt;
        if (this.realignTime >= this.realignDuration.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the AttitudeAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateAttitudeAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                return;
        }
        this.attitudeAlignTime += dt;
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration) {
            this.setOperatingMode(IrsSystemOperatingMode.Attitude);
        }
        else {
            this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the Attitude operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateAttitude(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                break;
        }
    }
}
IrsSystem.ATTITUDE_ALIGN_DURATION = 30000; // milliseconds
IrsSystem.REALIGN_DURATION = 30000; // milliseconds
IrsSystem.ALIGN_SPEED_THRESHOLD = 1; // meters per second

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best IRS from a set of candidates based on the current states of all systems. System state
 * desiribility is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class IrsSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the IRS systems from which to select.
     * @param systemPriorities The priorities for selecting individual IRS systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of IRS system indexes or a map of
     * IRS system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isAttitudeDataValid = Subject.create(false);
        this.isHeadingDataValid = Subject.create(false);
        this.isInertialDataValid = Subject.create(false);
        this.isInertialHeadingDataValid = Subject.create(false);
        this.isPositionDataValid = Subject.create(false);
        this.irsEntries = new Map();
        this.irsOrder = [];
        this.irsComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `irs_selector_selected_index_${index}`), true);
        this.isAttitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_attitude_data_valid_${index}`), true);
        this.isHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_heading_data_valid_${index}`), true);
        this.isInertialDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_data_valid_${index}`), true);
        this.isInertialHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_heading_data_valid_${index}`), true);
        this.isPositionDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_position_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.irsEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`irs_attitude_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_heading_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_inertial_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_position_data_valid_${key}`), false)
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.irsEntries.set(key, entry);
                // When there is a change in an IRS state, we don't reselect immediately because the IRS could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.irsEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the IRS with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.irsEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.irsEntries.size === 1) {
            const entry = this.irsEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.irsOrder.length = 0;
            for (const index of this.irsEntries.keys()) {
                this.irsOrder.push(index);
            }
            this.irsOrder.sort(this.irsComparator);
            bestIndex = -1;
            for (let i = 0; i < this.irsOrder.length; i++) {
                const index = this.irsOrder[i];
                const state = this.irsEntries.get(index).state.get();
                if (!bestState || IrsSystemSelector.compareIrsState(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isAttitudeDataValid.set(bestState[0]);
            this.isHeadingDataValid.set(bestState[1]);
            this.isInertialDataValid.set(bestState[2]);
            this.isInertialHeadingDataValid.set(bestState[1] && bestState[2]);
            this.isPositionDataValid.set(bestState[3]);
        }
        else {
            this.isAttitudeDataValid.set(false);
            this.isHeadingDataValid.set(false);
            this.isInertialDataValid.set(false);
            this.isInertialHeadingDataValid.set(false);
            this.isPositionDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.irsEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    /**
     * Compares two IRS states and returns a number whose sign indicates which one is more desirable.
     * @param a The first IRS state to compare.
     * @param b The second IRS state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareIrsState(a, b) {
        // The data validity flags within the state array are ordered such that a false flag cannot precede a true flag,
        // so we can exploit this fact.
        return b.lastIndexOf(true) - a.lastIndexOf(true);
    }
}

/**
 * The GMU44 magnetometer system.
 */
class MagnetometerSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the MagnetometerSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `magnetometer_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.initializationTime = 5000;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
}

/**
 * The Radio Altimeter system.
 */
class RASystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the RASystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param radioAltOffset The radio altimeter offset.
     * @param powerSource The power source.
     */
    constructor(index, bus, radioAltOffset, powerSource) {
        super(index, bus, `ra_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.radioAltOffset = radioAltOffset;
        this.powerSource = powerSource;
        this.initializationTime = 7000;
        const radioAltTopic = `ra_radio_alt_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's radar altitude data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `ra_radio_alt_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.radioAltSub = this.bus.getSubscriber().on('radio_alt').atFrequency(3).handle(val => {
            this.publisher.pub(topic, val + this.radioAltOffset);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.radioAltSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.radioAltSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

/**
 * A publisher of Boeing airplane speed limits.
 *
 * The publisher requires a functioning `AdcSystem` and `AoaSystem` and that the topics defined by
 * `ControlSurfacesEvents` and `FlapComputerEvents` are published to the event bus.
 */
class SpeedLimitPublisher extends BasePublisher {
    /**
     * Creates a new instance of SpeedLimitPublisher.
     * @param bus The event bus to which to publish.
     * @param speedProvider A provider of airplane reference speed data.
     * @param aoaIndex The index of the AoA system that is the source of this publisher's data.
     * @param adcIndex The index of the ADC system that is the source of this publisher's data.
     * @param stickShakerNormAoa The normalized angle of attack at which the stick shaker activates. Defaults to 0.95.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, speedProvider, aoaIndex, adcIndex, stickShakerNormAoa = 0.95, pacer) {
        super(bus, pacer);
        this.speedProvider = speedProvider;
        this.stickShakerNormAoa = stickShakerNormAoa;
        this.isOnGround = ConsumerValue.create(null, false).pause();
        this.zeroLiftAoa = ConsumerValue.create(null, 0).pause();
        this.stallAoa = ConsumerValue.create(null, 0).pause();
        this.normAoa = ConsumerValue.create(null, 0).pause();
        this.ias = ConsumerValue.create(null, 0).pause();
        this.pressureAltitude = ConsumerValue.create(null, 0).pause();
        this.machToKiasFactorSource = ConsumerValue.create(null, 1).pause();
        this.machToKiasFactorSmoother = new ExpSmoother(SpeedLimitPublisher.MACH_KIAS_SMOOTHING_TAU);
        this.aoaCoefSmoother = new ExpSmoother(SpeedLimitPublisher.AOA_COEF_SMOOTHING_TAU);
        this.loadFactorSource = ConsumerValue.create(null, 1).pause();
        this.loadFactorSmoother = new ExpSmoother(SpeedLimitPublisher.LOAD_FACTOR_SMOOTHING_TAU);
        this.gearPosition = ConsumerValue.create(null, 0).pause();
        this.flapSpeedLimit = ConsumerValue.create(null, 0).pause();
        this.aoaSystemState = ConsumerValue.create(null, undefined).pause();
        this.adcSystemState = ConsumerValue.create(null, undefined).pause();
        this.pauseable = [
            this.isOnGround,
            this.zeroLiftAoa,
            this.stallAoa,
            this.normAoa,
            this.ias,
            this.pressureAltitude,
            this.machToKiasFactorSource,
            this.loadFactorSource,
            this.gearPosition,
            this.flapSpeedLimit,
            this.aoaSystemState,
            this.adcSystemState
        ];
        this.isAltBelow20k = false;
        this.lastUpdateTime = undefined;
        this.aoaIndex = SubscribableUtils.toSubscribable(aoaIndex, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        const sub = bus.getSubscriber();
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.aoaIndex.sub(index => {
            this.zeroLiftAoa.setConsumer(sub.on(`aoa_zero_lift_aoa_${index}`));
            this.stallAoa.setConsumer(sub.on(`aoa_stall_aoa_${index}`));
            this.normAoa.setConsumer(sub.on(`aoa_norm_aoa_${index}`));
            this.loadFactorSource.setConsumer(sub.on(`aoa_load_factor_${index}`));
            this.aoaSystemState.setConsumer(sub.on(`aoa_state_${index}`));
        }, true);
        this.adcIndex.sub(index => {
            this.ias.setConsumer(sub.on(`adc_ias_${index}`));
            this.machToKiasFactorSource.setConsumer(sub.on(`adc_mach_to_kias_factor_${index}`));
            this.pressureAltitude.setConsumer(sub.on(`adc_pressure_alt_${index}`));
            this.adcSystemState.setConsumer(sub.on(`adc_state_${index}`));
        }, true);
        this.gearPosition.setConsumer(sub.on('gear_position_2'));
        this.flapSpeedLimit.setConsumer(sub.on('flap_computer_interpolated_limit_speed'));
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        this.lastUpdateTime = undefined;
        this.machToKiasFactorSmoother.reset();
        this.aoaCoefSmoother.reset();
        this.loadFactorSmoother.reset();
        this.isAltBelow20k = false;
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        const time = Date.now();
        const dt = this.lastUpdateTime === undefined ? 0 : Math.max(0, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
        const pressureAlt = this.pressureAltitude.get();
        // ------- Maximum speed -------
        // Maximum speed is defined as the lowest of Vmo, Mmo, landing gear placard speed (if extended), and placard speed
        // for the current flaps setting.
        const vmo = this.speedProvider.getVmo(pressureAlt);
        const mmo = this.speedProvider.getMmo();
        const flapLimit = this.flapSpeedLimit.get();
        const gearLimit = this.speedProvider.getGearLimitSpeed();
        let maxIas = Math.min(vmo, mmo * this.machToKiasFactorSmoother.next(this.machToKiasFactorSource.get(), dt), flapLimit < 0 ? Infinity : flapLimit);
        if (gearLimit < maxIas) {
            const gearPosition = this.gearPosition.get();
            maxIas = MathUtils.lerp(gearPosition, 0, 1, maxIas, gearLimit);
        }
        this.publish('speedlimit_max_ias', maxIas);
        // ------- Minimum speed AoA -------
        // Minimum speed is defined as the speed at which stick shaker activation occurs.
        const minSpeedAoa = MathUtils.lerp(this.stickShakerNormAoa, 0, 1, this.zeroLiftAoa.get(), this.stallAoa.get());
        this.publish('speedlimit_min_speed_aoa', minSpeedAoa);
        if (this.isOnGround.get()
            || SpeedLimitPublisher.isSystemFailed(this.aoaSystemState.get())
            || SpeedLimitPublisher.isSystemFailed(this.adcSystemState.get())) {
            this.aoaCoefSmoother.reset();
            this.loadFactorSmoother.reset();
            this.publish('speedlimit_min_ias', null);
            this.publish('speedlimit_min_maneuver_ias', null);
            this.publish('speedlimit_stall_ias', null);
            return;
        }
        const normAoa = this.normAoa.get();
        const ias = this.ias.get();
        const iasSquared = ias * ias;
        const coef = normAoa * iasSquared;
        const aoaCoef = this.aoaCoefSmoother.next(coef, dt);
        const loadFactor = this.loadFactorSmoother.next(this.loadFactorSource.get(), dt);
        // ------- Minimum speed -------
        // Minimum speed is defined as the speed at which stick shaker activation occurs.
        const minIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, this.stickShakerNormAoa, 1);
        this.publish('speedlimit_min_ias', isFinite(minIas) ? minIas : null);
        // ------- Minimum maneuvering speed -------
        // Minimum maneuvering speed is defined as the minimum speed at which the airplane can be flown at 1.3g load factor
        // before triggering stick shaker (below 20k feet) or before encountering low speed buffet (above 20k feet).
        let minManeuverIas;
        if (pressureAlt < (this.isAltBelow20k ? 20100 : 19900)) {
            minManeuverIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, this.stickShakerNormAoa, 1.3 / loadFactor);
            this.isAltBelow20k = true;
        }
        else {
            minManeuverIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, 1, 1.3 / loadFactor);
            this.isAltBelow20k = false;
        }
        this.publish('speedlimit_min_maneuver_ias', isFinite(minManeuverIas) ? minManeuverIas : null);
        // ------- Stall speed -------
        const stallIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, 1, 1);
        this.publish('speedlimit_stall_ias', isFinite(stallIas) ? stallIas : null);
    }
    /**
     * Estimates an indicated airspeed, in knots, required to maintain a given normalized angle of attack at a specific
     * load factor.
     * @param coef The correlation coefficient between normalized angle of attack and the square of indicated airspeed,
     * such that `k = alpha * v^2`, where `k` is the coefficient, `alpha` is normalized AoA, and `v` is indicated
     * airspeed in knots.
     * @param normAoa The normalized angle of attack at which to estimate the airspeed.
     * @param loadFactorRatio The ratio of the load factor at which to estimate the airspeed to the load factor used to
     * obtain `coef`.
     * @returns The estimatd indicated airspeed, in knots, required to maintain the specified normalized angle of attack
     * at the specified load factor.
     */
    static estimateIasFromNormAoa(coef, normAoa, loadFactorRatio) {
        return Math.sqrt(coef * loadFactorRatio / normAoa);
    }
    /**
     * Checks whether an avionics system state is a failed state.
     * @param state The avionics system state to check.
     * @returns Whether the specified avionics system state is a failed state.
     */
    static isSystemFailed(state) {
        return state === undefined || (state.current !== undefined && state.current !== AvionicsSystemState.On);
    }
}
SpeedLimitPublisher.MACH_KIAS_SMOOTHING_TAU = 1000 / Math.LN2;
SpeedLimitPublisher.AOA_COEF_SMOOTHING_TAU = 2000 / Math.LN2;
SpeedLimitPublisher.LOAD_FACTOR_SMOOTHING_TAU = 2000 / Math.LN2;

// TODO Add FMS LVars to field jsdocs
/** These are the fields that should be exposed by NavSources and NavIndicators.
 * Not all fields will be used by all the different Nav Sources.
 * To add a new field, just add it to NavBaseFields,
 * then add some code to each of the different NavSources to keep that field updated.
 * Don't use this class directly.
 * Every Subject should be able to be set to null, so that when the source is set to null, all the fields cna be nulled.
 * This isn't abstract so that we can instantiate it in one place to help generate setters. */
class NavBaseFields {
    constructor() {
        /** Signal strength received from the reference. A value of zero indicates no signal. */
        this.signalStrength = Subject.create(null);
        /** Always points to the curently tuned station or next waypoint/fix.
         * NAV RADIAL, ADF RADIAL */
        this.bearing = Subject.create(null);
        /** Either points towards the next waypoint (GPS/FMS),
         * displays the course selected by the course knob (VOR),
         * or displays the fixed course of a localizer (ILS).
         * NAV OBS, L:WTAP_LNav_DTK_Mag */
        this.course = Subject.create(null);
        /** The fixed course of a localizer when available (ILS).
         * Is null when `hasLocalizer` is false.
         * Only for NAV source types.
         * NAV LOCALIZER */
        this.localizerCourse = Subject.create(null);
        /** Whether the tuned station is a localizer or not.
         * This can be true even if `hasLocalizer` is false,
         * because this can be based on the frequency alone.
         * Only for NAV source types.
         * NAV LOCALIZER. */
        this.isLocalizer = Subject.create(null);
        /** Whether the nav source is receiving a valid localizer signal.
         * Only for NAV source types.
         * NAV HAS LOCALIZER */
        this.hasLocalizer = Subject.create(null);
        /** DME, distance to the station or next waypoint.
         * Is null when source is NAV and `hasDme` is false.
         * NAV DME, ADF DISTANCE, L:WTAP_LNav_DIS */
        this.distance = Subject.create(null);
        /** Whether the source is receiving a valid DME signal.
         * Only for NAV source types.
         * NAV HAS DME */
        this.hasDme = Subject.create(null);
        /** The ICAO ident of the station or waypoint.
         * NAV IDENT, or flight plan */
        this.ident = Subject.create(null);
        /** Whether the source is receiving a nav signal.
         * Only for NAV source types.
         * NAV HAS NAV. */
        this.hasNav = Subject.create(null);
        /** The active frequency that the nav source is tuned to.
         * Only for NAV and ADF source types.
         * NAV ACTIVE FREQUENCY, ADF ACTIVE FREQUENCY. */
        this.activeFrequency = Subject.create(null);
        /** Normalized and scaled lateral deviation (-1, 1).
         * NAV CDI, L:WTAP_LNav_XTK */
        this.lateralDeviation = Subject.create(null);
        /** Normalized and scaled vertical deviation (-1, 1).
         * NAV GLIDE SLOPE ERROR, L:WTAP_VNav_Vertical_Deviation, L:WTAP_LPV_Vertical_Deviation */
        this.verticalDeviation = Subject.create(null);
        /** Whether the source is receiving glideslope information.
         * Only for NAV source types.
         * NAV HAS GLIDE SLOPE. */
        this.hasGlideSlope = Subject.create(null);
        /** TTG, estimated time remaining until aircraft reaches next fix. // TODO Implement this */
        this.timeToGo = Subject.create(null);
        /** Whether course is pointing TO or FROM the station (VOR),
         * or if the aircraft heading is within 90 degress of the desired track (GPS).
         * NAV TOFROM, // TODO FMS VAR? */
        this.toFrom = Subject.create(null);
        /** The current CDI scale, in nautical miles.
         * Only for GPS source types.
         * L:WTAP_LNav_CDI_Scale */
        this.lateralDeviationScaling = Subject.create(null);
        /** A readable string/enum that shows the name of current scaling being applied to lateral deviation.
         * Only for GPS source types.
         * L:WTAP_LNav_CDI_Scale_Label */
        this.lateralDeviationScalingLabel = Subject.create(null);
    }
}
/** Base class for NavSourceBase and NavIndicator. */
class NavBase extends NavBaseFields {
    /** Creates a Map of setters to make unsubbing and subbing easy. */
    constructor() {
        super();
        /** An automatically generated map of setters to make it easy to set, sub, and unsub,
         * getting around having to call .bind(). */
        this.setters = new Map();
        Object.keys(new NavBaseFields()).forEach((key) => {
            this.setters.set(key, this[key].set.bind(this[key]));
        });
    }
}

/* eslint-disable @typescript-eslint/ban-types */
/** Represent a navigation indicator, like a course needle or bearing pointer.
 * Can only be pointed to 1 nav source at a time.
 * Gives visual components a single thing to subscribe to, while the actual source can be easily changed. */
class NavIndicator extends NavBase {
    /** NavIndicator constructor.
     * @param navSources The possible nav sources that could be pointed to.
     * @param sourceName The initial source to use, if any.
     */
    constructor(navSources, sourceName = null) {
        super();
        this.navSources = navSources;
        this._source = Subject.create(null);
        /** The nav source that is feeding data into the indicator fields.
         * Can only be changed with the {@link setSource} function. */
        this.source = this._source;
        this.setSource(sourceName);
    }
    /** Changes the source of this indicator.
     * All subjects will be republished with the current info from the new source.
     * @param newSourceName Name of new source, if any.
     */
    setSource(newSourceName) {
        const oldSource = this.source.get();
        if (oldSource && oldSource.name === newSourceName) {
            return;
        }
        if (oldSource === null && newSourceName === null) {
            return;
        }
        const newSource = (newSourceName ? this.navSources.get(newSourceName) : null);
        if (oldSource) {
            this.setters.forEach((setter, key) => {
                oldSource[key].unsub(setter);
            });
        }
        this._source.set(newSource);
        if (newSource) {
            this.setters.forEach((setter, key) => {
                newSource[key].sub(setter, true);
            });
        }
        else {
            this.setters.forEach((setter) => {
                setter(null);
            });
        }
    }
}
/** Holds the nav indicators. */
class NavIndicators {
    /** NavIndicators constructor.
     * @param indicators The nav indicators to hold. */
    constructor(indicators = new Map()) {
        this.indicators = indicators;
    }
    /** @inheritdoc */
    init() {
        // todo
    }
    /** @inheritdoc */
    onUpdate() {
        // todo
    }
    /** Gets a nav indicator.
     * @param key The name of the indicator to get.
     * @returns The indicator.
     * @throws Error if indicator not found.
     */
    get(key) {
        const indicator = this.indicators.get(key);
        if (!indicator) {
            throw new Error('no nav indicator exists with given key: ' + key);
        }
        else {
            return indicator;
        }
    }
}

/** Base class for NavSources that are meant to be used by NavIndicators.
 * A NavSource subscribes to SimVars and updates the NavBaseFields accordingly. */
class NavSourceBase extends NavBase {
    /** The NavSourceBase constructor.
     * @param bus The event bus.
     * NavSources need to tell the publisher what to subscribe to.
     * @param name The name of the nav source. Ex: NAV1, ADF, FMS2.
     * @param index The index of the nav source. Ex: 1 for NAV1, or 2 for FMS2, or 1 for ADF.
     */
    constructor(bus, name, index) {
        super();
        this.bus = bus;
        this.name = name;
        this.index = index;
    }
}
// TODO Does this need to be an instrument?
/** Holds the available Nav Sources that NavIndicators can use. */
class NavSources {
    /** NavSources constructor.
     * @param sources The nav sources. */
    constructor(...sources) {
        this.sources = sources;
    }
    /** @inheritdoc */
    init() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // TODO
    }
    /** Gets a nav source.
     * @param name Name of source.
     * @returns The source.
     * @throws Error if name not found.
     */
    get(name) {
        const indicator = this.sources.find(x => x.name === name);
        if (!indicator) {
            throw new Error('no nav source exists with given name: ' + name);
        }
        else {
            return indicator;
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** Represents a NAV radio, subscribes to the NAV SimVars. */
class NavRadioNavSource extends NavSourceBase {
    /** @inheritdoc */
    constructor(bus, name, index) {
        super(bus, name, index);
        this.glideSlopeErrorDegrees = Subject.create(0);
        this.navCdi = Subject.create(0);
        this.navDme = Subject.create(0);
        this.navRadial = Subject.create(0);
        this.updateDistance = () => {
            this.distance.set(this.hasDme.get() ? this.navDme.get() : null);
        };
        this.updateIsLocalizer = () => {
            var _a;
            const navHasLocalizer = this.hasLocalizer.get();
            const _isLocalizerFrequency = RadioUtils.isLocalizerFrequency((_a = this.activeFrequency.get()) !== null && _a !== void 0 ? _a : 0);
            this.isLocalizer.set(navHasLocalizer || _isLocalizerFrequency);
        };
        this.updateVerticalDeviation = () => {
            this.verticalDeviation.set(this.getVerticalDeviation());
        };
        this.updateBearing = () => {
            if (!this.hasNav.get()) {
                this.bearing.set(null);
            }
            else {
                const radialDegrees = this.navRadial.get();
                const bearing = (radialDegrees + 180) % 360;
                this.bearing.set(bearing);
            }
        };
        this.updateLateralDeviation = () => {
            this.lateralDeviation.set(this.getLateralDeviation());
        };
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on(`nav_signal_${index}`).whenChanged().handle(this.signalStrength.set.bind(this.signalStrength));
        navComSubscriber.on(`nav_dme_${index}`).whenChanged().handle(this.navDme.set.bind(this.navDme));
        navComSubscriber.on(`nav_has_dme_${index}`).whenChanged().handle(this.setters.get('hasDme'));
        navComSubscriber.on(`nav_ident_${index}`).whenChanged().handle(this.setters.get('ident'));
        navComSubscriber.on(`nav_localizer_${index}`).whenChanged().handle(this.setters.get('hasLocalizer'));
        navComSubscriber.on(`nav_gs_error_${index}`).whenChanged().handle(this.glideSlopeErrorDegrees.set.bind(this.glideSlopeErrorDegrees));
        navComSubscriber.on(`nav_glideslope_${index}`).whenChanged().handle(this.setters.get('hasGlideSlope'));
        navComSubscriber.on(`nav_obs_${index}`).whenChanged().handle(this.setters.get('course'));
        navComSubscriber.on(`nav_radial_${index}`).whenChanged().handle(this.navRadial.set.bind(this.navRadial));
        navComSubscriber.on(`nav_cdi_${index}`).whenChanged().handle(this.navCdi.set.bind(this.navCdi));
        navComSubscriber.on(`nav_has_nav_${index}`).whenChanged().handle(this.setters.get('hasNav'));
        navComSubscriber.on(`nav_to_from_${index}`).whenChanged().handle(this.setters.get('toFrom'));
        navComSubscriber.on(`nav_active_frequency_${index}`).whenChanged().handle(this.setters.get('activeFrequency'));
        this.hasDme.sub(this.updateDistance);
        this.navDme.sub(this.updateDistance);
        this.hasLocalizer.sub(this.updateIsLocalizer);
        this.activeFrequency.sub(this.updateIsLocalizer);
        this.hasGlideSlope.sub(this.updateVerticalDeviation);
        this.glideSlopeErrorDegrees.sub(this.updateVerticalDeviation);
        this.navRadial.sub(this.updateBearing);
        this.hasNav.sub(this.updateBearing);
        this.navCdi.sub(this.updateLateralDeviation);
        this.hasNav.sub(this.updateLateralDeviation);
    }
    /** @inheritdoc */
    getType() {
        return NavSourceType.Nav;
    }
    /** @returns Deviation is in degrees, and standard glideslope is 1.4 degrees thick,
     * so the vdev indicator will max out when 0.7 degrees off the GS */
    getVerticalDeviation() {
        if (!this.hasGlideSlope.get()) {
            return null;
        }
        else {
            return this.glideSlopeErrorDegrees.get() / 0.7;
        }
    }
    /** @returns Deviation is in degrees, and standard glideslope is 1.4 degrees thick,
     * so the vdev indicator will max out when 0.7 degrees off the GS */
    getLateralDeviation() {
        if (!this.hasNav.get()) {
            return null;
        }
        else {
            // The NAV CDI simvar holds the deviation as a range from -127 to 127
            return this.navCdi.get() / 127;
        }
    }
}

/** Represents an ADF radio, subscribes to the ADF SimVars. */
class AdfRadioSource extends NavSourceBase {
    /** @inheritdoc */
    constructor(bus, name, index) {
        super(bus, name, index);
        this.heading = Subject.create(0);
        this.adfRadial = Subject.create(0);
        this.adfSignal = Subject.create(0);
        this.updateBearing = () => {
            if (this.adfSignal.get() === 0) {
                this.bearing.set(null);
            }
            else {
                const newBearing = this.adfRadial.get() + this.heading.get();
                this.bearing.set(newBearing);
            }
        };
        const adc = this.bus.getSubscriber();
        adc.on('hdg_deg')
            .withPrecision(2)
            .handle(this.heading.set.bind(this.heading));
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on(`adf_bearing_${index}`).withPrecision(2).handle(this.adfRadial.set.bind(this.adfRadial));
        navComSubscriber.on(`adf_signal_${index}`).withPrecision(0).handle(this.adfSignal.set.bind(this.adfSignal));
        navComSubscriber.on(`adf_active_frequency_${index}`).whenChanged().handle(this.activeFrequency.set.bind(this.activeFrequency));
        this.adfSignal.pipe(this.signalStrength);
        this.heading.sub(this.updateBearing);
        this.adfRadial.sub(this.updateBearing);
        this.adfSignal.sub(this.updateBearing);
    }
    /** @inheritdoc */
    getType() {
        return NavSourceType.Adf;
    }
}

/**
 * Handles display bindings for the waypoint alert flashing functionality
 * on the B787.
 */
class WaypointAlerter {
    /**
     * Creates an instance of the WaypointAlerter.
     * @param bus The instance of the event bus to use.
     */
    constructor(bus) {
        this.bus = bus;
        this.displayed = Subject.create(false);
        this.isFlashing = false;
        this.previousTime = 0;
        this.currentDistance = Number.POSITIVE_INFINITY;
        this.anticipationDistance = 0;
        this.isTracking = false;
        this.currentGroundSpeed = 0;
        this.isOnGround = false;
        this.nominalLegIndex = 0;
        /**
         * Animates the waypoint alert flash.
         * @param timestamp The timestamp of the frame.
         */
        this.animateFlash = (timestamp) => {
            if (this.previousTime === 0) {
                this.previousTime = timestamp;
            }
            const deltaTime = timestamp - this.previousTime;
            if (deltaTime >= 500) {
                this.displayed.set(!this.displayed.get());
                this.previousTime = timestamp - (deltaTime % 500);
            }
            if (this.isFlashing) {
                requestAnimationFrame(this.animateFlash);
            }
        };
        // const sub = bus.getSubscriber<AdcEvents & GNSSEvents & LNavEvents & WT21LNavDataEvents>();
        // sub.on('lnavdata_waypoint_distance').whenChanged().handle(d => { this.currentDistance = d; this.handleChanged(); });
        // sub.on('lnav_vector_anticipation_distance').whenChanged().handle(d => { this.anticipationDistance = d; });
        // sub.on('lnav_is_tracking').whenChanged().handle(t => { this.isTracking = t; this.handleChanged(); });
        // sub.on('ground_speed').whenChanged().handle(s => { this.currentGroundSpeed = s; this.handleChanged(); });
        // sub.on('on_ground').whenChanged().handle(s => { this.isOnGround = s; this.handleChanged(); });
        // sub.on('lnavdata_nominal_leg_index').handle(s => { this.nominalLegIndex = s; this.handleChanged(); });
    }
    /**
     * Whether or not the current flashable display elements should
     * be displayed or not.
     * @returns A subject to subscribe to the current display state.
     */
    get isDisplayed() {
        return this.displayed;
    }
    /**
     * Handles when the time to turn changes.
     */
    handleChanged() {
        const ttg = ((this.currentDistance - this.anticipationDistance) / this.currentGroundSpeed) * 3600;
        const isFlashing = !this.isOnGround && (this.nominalLegIndex > 0) && this.isTracking && isFinite(ttg) && ttg <= 5;
        if (isFlashing !== this.isFlashing) {
            this.isFlashing = isFlashing;
            this.previousTime = 0;
            this.displayed.set(true);
            if (isFlashing) {
                requestAnimationFrame(this.animateFlash);
            }
        }
    }
}

/**
 * A TCAS II implementation for the Boeing airplanes.
 */
class BoeingTCAS extends Tcas {
    constructor() {
        super(...arguments);
        this.settings = TrafficUserSettings.getManager(this.bus);
        /** All RAs are inhibited when airplane is on ground, or when airplane's radio altitude < 1100ft. */
        this.isRAsInhibited = MappedSubject.create(([radarAlt, isClimbing]) => {
            return radarAlt < (isClimbing ? 900 : 1100);
        }, this.ownAirplaneSubs.radarAltitude.map(radarAlt => Math.round(radarAlt.asUnit(UnitType.FOOT))), this.ownAirplaneSubs.verticalSpeed.map(verticalSpeed => verticalSpeed.number >= 0));
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.settings.whenSettingChanged('trafficOperatingMode').handle(mode => {
            switch (mode) {
                case TcasOperatingModeSetting.Standby:
                    this.setOperatingMode(TcasOperatingMode.Standby);
                    break;
                case TcasOperatingModeSetting.TAOnly:
                    this.setOperatingMode(TcasOperatingMode.TAOnly);
                    break;
                case TcasOperatingModeSetting.TA_RA:
                    if (this.isRAsInhibited.get()) {
                        this.setOperatingMode(TcasOperatingMode.TAOnly);
                    }
                    else {
                        this.setOperatingMode(TcasOperatingMode.TA_RA);
                    }
                    break;
            }
        });
        this.isRAsInhibited.sub(isInhibited => {
            if (this.settings.getSetting('trafficOperatingMode').value === TcasOperatingModeSetting.TA_RA) {
                this.setOperatingMode(isInhibited ? TcasOperatingMode.TAOnly : TcasOperatingMode.TA_RA);
            }
        });
    }
    /** @inheritdoc */
    createSensitivity() {
        return new TcasIISensitivity();
    }
    /** @inheritdoc */
    createIntruderEntry(contact) {
        return new DefaultTcasIntruder(contact);
    }
    /** @inheritdoc */
    updateSensitivity() {
        this.sensitivity.updateLevel(this.ownAirplaneSubs.altitude.get(), this.ownAirplaneSubs.radarAltitude.get());
    }
}

/**
 * A default implementation of {@link TcasRaCommandDataProvider}.
 */
class DefaultTcasRaCommandDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tcas The TCAS which from which this data provider sources resolution advisory commands.
     */
    constructor(bus, tcas) {
        this.bus = bus;
        this.tcas = tcas;
        this._raMinVs = Subject.create(null);
        /** @inheritdoc */
        this.raMinVs = this._raMinVs;
        this._raMaxVs = Subject.create(null);
        /** @inheritdoc */
        this.raMaxVs = this._raMaxVs;
        this._raFlyToMinVs = Subject.create(null);
        /** @inheritdoc */
        this.raFlyToMinVs = this._raFlyToMinVs;
        this._raFlyToMaxVs = Subject.create(null);
        /** @inheritdoc */
        this.raFlyToMaxVs = this._raFlyToMaxVs;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.tcasRaSubs = [];
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider has been destroyed.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultTcasRaCommandDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        const updateRaSpeeds = this.updateRaSpeeds.bind(this);
        updateRaSpeeds();
        this.tcasRaSubs.push(sub.on('tcas_ra_issued').handle(updateRaSpeeds), sub.on('tcas_ra_updated').handle(updateRaSpeeds), sub.on('tcas_ra_canceled').handle(updateRaSpeeds));
        if (paused) {
            this.pause();
        }
    }
    /**
     * Update vertical speeds commanded by TCAS resolution advisories.
     */
    updateRaSpeeds() {
        const host = this.tcas.getResolutionAdvisoryHost();
        if (host.primaryType === TcasResolutionAdvisoryType.Clear) {
            this._raMinVs.set(null);
            this._raMaxVs.set(null);
            this._raFlyToMinVs.set(null);
            this._raFlyToMaxVs.set(null);
            return;
        }
        const minVsFpm = host.minVerticalSpeed.asUnit(UnitType.FPM);
        const maxVsFpm = host.maxVerticalSpeed.asUnit(UnitType.FPM);
        if (host.secondaryType === null) {
            // Single RA
            if (BitFlags.isAll(host.primaryFlags, TcasResolutionAdvisoryFlags.UpSense)) {
                // Upward sense
                this._raMaxVs.set(null);
                this._raMinVs.set(minVsFpm > -100 && minVsFpm < 100 ? -100 : minVsFpm);
            }
            else {
                // Downward sense
                this._raMinVs.set(null);
                this._raMaxVs.set(maxVsFpm > -100 && maxVsFpm < 100 ? 100 : maxVsFpm);
            }
            if (BitFlags.isAny(host.primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                // Corrective positive
                this._raFlyToMaxVs.set(maxVsFpm);
                this._raFlyToMinVs.set(minVsFpm);
            }
            else if (host.primaryType === TcasResolutionAdvisoryType.ReduceDescent) {
                // Corrective upward negative
                this._raFlyToMinVs.set(-100);
                this._raFlyToMaxVs.set(500);
            }
            else if (host.primaryType === TcasResolutionAdvisoryType.ReduceClimb) {
                // Corrective downward negative
                this._raFlyToMinVs.set(-500);
                this._raFlyToMaxVs.set(100);
            }
            else {
                // Preventative
                this._raFlyToMinVs.set(null);
                this._raFlyToMaxVs.set(null);
            }
        }
        else {
            // Composite RA
            const minVs = minVsFpm > -100 && minVsFpm < 100 ? -100 : minVsFpm;
            const maxVs = maxVsFpm > -100 && maxVsFpm < 100 ? 100 : maxVsFpm;
            this._raMinVs.set(minVs);
            this._raMaxVs.set(maxVs);
            if (host.primaryType === TcasResolutionAdvisoryType.ReduceDescent) {
                // Corrective upward negative primary
                this._raFlyToMinVs.set(-100);
                this._raFlyToMaxVs.set(Math.min(maxVs, 500));
            }
            else if (host.primaryType === TcasResolutionAdvisoryType.ReduceClimb) {
                // Corrective downward negative primary
                this._raFlyToMinVs.set(Math.max(minVs, -500));
                this._raFlyToMaxVs.set(100);
            }
            else {
                // Preventative primary
                this._raFlyToMinVs.set(null);
                this._raFlyToMaxVs.set(null);
            }
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultTcasRaCommandDataProvider: cannot resume a dead provider');
        }
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.updateRaSpeeds();
        this.tcasRaSubs.forEach(sub => { sub.resume(); });
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultTcasRaCommandDataProvider: cannot pause a dead provider');
        }
        if (this.isPaused) {
            return;
        }
        this.tcasRaSubs.forEach(sub => { sub.pause(); });
        this.isPaused = true;
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        this.tcasRaSubs.forEach(sub => { sub.destroy(); });
    }
}

/**
 * A controller which manages the state of an altitude alert.
 */
class BoeingAltitudeAlertController {
    /**
     * Creates an instance of BoeingAltitudeAlertController.
     * @param bus The event bus.
     * @param performancePlan The active performance plan.
     * @param altimeterDataProvider A provider of altimeter data.
     */
    constructor(bus, performancePlan, altimeterDataProvider) {
        this.bus = bus;
        this.performancePlan = performancePlan;
        this.altimeterDataProvider = altimeterDataProvider;
        this.alerterState = Subject.create(AltAlertState.DISABLED);
        this.alertPublisher = this.bus.getPublisher();
        this.debounce = new DebounceTimer();
        this.inApproachLock = Subject.create(false);
        this.flapsPosition = Subject.create(0);
        this.isGearDown = Subject.create(false);
        this.isApproachMode = this.getIsApproachModeSubscribable();
        this.altitude = 0;
        this.targetAltitude = 0;
        this.isOnGround = true;
        const adc = this.bus.getSubscriber();
        const ap = this.bus.getSubscriber();
        const controlSurfaces = this.bus.getSubscriber();
        const consumer = this.bus.getSubscriber().on('fma_data');
        consumer.handle(newFmaState => {
            this.inApproachLock.set((newFmaState === null || newFmaState === void 0 ? void 0 : newFmaState.verticalActive) === APVerticalModes.GS || (newFmaState === null || newFmaState === void 0 ? void 0 : newFmaState.verticalActive) === APVerticalModes.GP);
        });
        adc.on('on_ground').whenChanged().handle((g) => {
            this.isOnGround = g;
            if (this.isOnGround) {
                this.alerterState.set(AltAlertState.DISABLED);
                this.updateAltitudeAlerter();
            }
        });
        this.altimeterDataProvider.isAdcDataFailed.sub(isDataFailed => {
            if (isDataFailed) {
                this.alerterState.set(AltAlertState.DISABLED);
                this.updateAltitudeAlerter();
            }
        });
        this.altimeterDataProvider.indicatedAltitude.map(SubscribableMapFunctions.withPrecision(10)).sub(this.updateAltitudeAlerter.bind(this));
        ap.on('ap_altitude_selected_3').whenChanged().handle((v) => {
            this.targetAltitude = Math.round(v);
            this.alerterState.set(AltAlertState.DISABLED);
            this.updateAltitudeAlerter();
        });
        controlSurfaces.on('gear_position').whenChanged().handle((v) => {
            this.isGearDown.set(v === 1);
        });
        controlSurfaces.on('flaps_handle_index').whenChanged().handle((v) => {
            this.flapsPosition.set(v);
        });
        this.alerterState.sub((v) => {
            this.alertPublisher.pub('altitude_alert', v, false, true);
            if (v === AltAlertState.DISABLED) {
                const armFn = (timeout) => {
                    this.debounce.schedule(() => {
                        if (this.canArm()) {
                            this.alerterState.set(AltAlertState.ARMED);
                            this.updateAltitudeAlerter();
                        }
                        else {
                            armFn(1000);
                        }
                    }, timeout);
                };
                armFn(3000);
            }
        }, true);
    }
    /**
     * A method called to update the altitude alerter
     * @param altitude The current altitude
     * @private
     */
    updateAltitudeAlerter(altitude) {
        if (altitude) {
            this.altitude = altitude;
        }
        if (!this.canArm()) {
            this.alerterState.set(AltAlertState.DISABLED);
        }
        const deltaAlt = Math.abs(this.targetAltitude - this.altitude);
        switch (this.alerterState.get()) {
            case AltAlertState.DISABLED:
                break;
            case AltAlertState.ARMED:
                if (deltaAlt < 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                else if (deltaAlt < 200) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt < 900) {
                    this.alerterState.set(AltAlertState.WITHIN_900);
                }
                break;
            case AltAlertState.WITHIN_200:
                if (deltaAlt <= 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                else if (deltaAlt > 200) {
                    this.alerterState.set(AltAlertState.WITHIN_900);
                }
                break;
            case AltAlertState.WITHIN_900:
                if (deltaAlt <= 200) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt > 900) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                break;
            case AltAlertState.CAPTURED:
                if (deltaAlt > 200) {
                    this.alerterState.set(AltAlertState.DEVIATION_200);
                }
                break;
            case AltAlertState.DEVIATION_200:
                if (deltaAlt <= 200 || deltaAlt > 900) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                break;
        }
    }
    /**
     * A method called to determine if we can arm the alerter
     * @returns boolean
     */
    canArm() {
        return (!this.isOnGround && !this.isApproachMode.get() && !isNaN(this.targetAltitude) && !this.altimeterDataProvider.isAdcDataFailed.get());
    }
}

/** Stores wind data associated with a flightplan */
class WindPlan {
    /**
     * Constructs a new WindPlan
     * @param options Options for the WindPlanner
     * @param numberOfLegs Number of legs to initialise the plan with (will be filled with empty data)
     */
    constructor(options, numberOfLegs = 0) {
        this.options = options;
        this.climbData = [];
        this.descentData = [];
        /** Maps global flight plan leg index to wind records */
        this.legWindData = [];
        /** Maps global flight plan leg index to temparture records */
        this.legTemperatureData = [];
        if (numberOfLegs > 0) {
            this.legWindData = Array.from({ length: numberOfLegs }, () => []);
        }
    }
    /**
     * Set wind for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.climbData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Deletes a climb wind record
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(altitude) {
        const deleteIndex = this.climbData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.climbData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the climb wind records for a flight plan
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures() {
        return this.climbData;
    }
    /**
     * Set wind for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.descentData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Deletes a descent wind record
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWind(altitude) {
        const deleteIndex = this.descentData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.descentData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the descent wind records for a flight plan
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures() {
        return this.descentData;
    }
    /**
     * Deletes the record for a leg (when the leg is deleted from the flightplan)
     * @param globalLegIndex Index of leg in entire flight plan
     */
    deleteLeg(globalLegIndex) {
        // Does not removed propagated data from other legs... may need an option for this later with other FMS types
        if (this.legWindData[globalLegIndex]) {
            this.legWindData.splice(globalLegIndex, 1);
        }
        if (this.legTemperatureData[globalLegIndex]) {
            this.legTemperatureData.splice(globalLegIndex, 1);
        }
    }
    /**
     * Inserts a new flight plan leg and propagates data from existing legs
     * @param globalLegIndex Index of leg in entire flight plan
     */
    insertLegAndPropagate(globalLegIndex) {
        this.legWindData.splice(globalLegIndex, 0, []);
        const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : 0;
        const propagationData = this.legWindData[propagationIndex];
        if (propagationData) {
            const records = propagationData.map(({ altitude, direction, speed }) => ({ altitude, direction, speed, windPropagated: true }));
            this.legWindData.splice(globalLegIndex, 0, records);
        }
        else {
            this.legWindData.splice(globalLegIndex, 0, []);
        }
        const tempData = this.legTemperatureData[propagationIndex];
        if (tempData) {
            this.legTemperatureData.splice(globalLegIndex, 0, Object.assign(Object.assign({}, tempData), { temperaturePropagated: true }));
        }
    }
    /**
     * Check if all the available leg altitudes are already used
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed() {
        if (this.legWindData.length === 0 || this.options.numberOfLegAltitudes === undefined) {
            return false;
        }
        const windData = this.legWindData[0];
        return windData.length >= this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.legWindData[globalLegIndex]) === null || _a === void 0 ? void 0 : _a.some((record) => record.windPropagated === false)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(globalLegIndex, altitude, speed, direction) {
        var _a, _b, _c, _d;
        const windData = this.legWindData[globalLegIndex];
        if (windData === undefined) {
            return false;
        }
        /** index of existing record for this altitude (same in all legs) */
        const existingRecordIndex = (_a = windData === null || windData === void 0 ? void 0 : windData.findIndex((v) => v.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (existingRecordIndex < 0 && isFinite((_b = this.options.numberOfLegAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
            if (((_c = windData === null || windData === void 0 ? void 0 : windData.length) !== null && _c !== void 0 ? _c : 0) >= ((_d = this.options.numberOfLegAltitudes) !== null && _d !== void 0 ? _d : Infinity)) {
                return false;
            }
        }
        if (existingRecordIndex >= 0 && windData) {
            const existingRecord = windData[existingRecordIndex];
            existingRecord.altitude = altitude;
            existingRecord.speed = speed;
            existingRecord.direction = direction;
            existingRecord.windPropagated = false;
            // propagate backward if needed
            if (this.findNextNonPropagatedLeg(globalLegIndex, altitude, -1) < 0) {
                this.propagateWind(0, globalLegIndex - 1, windData[existingRecordIndex], existingRecordIndex);
            }
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLeg(globalLegIndex, altitude);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateWind(globalLegIndex + 1, propagateTo, windData[existingRecordIndex], existingRecordIndex);
        }
        else {
            const newRecord = {
                altitude,
                speed,
                direction,
                windPropagated: true,
            };
            this.legWindData.forEach((r, index) => r.push(index === globalLegIndex ? Object.assign(Object.assign({}, newRecord), { windPropagated: speed === null }) : Object.assign({}, newRecord)));
        }
        return true;
    }
    /**
     * Delete an altitude from all leg wind records
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(altitude) {
        this.legWindData.forEach((leg) => {
            const idx = leg.findIndex((r) => r.altitude === altitude);
            if (idx >= 0) {
                leg.splice(idx, 1);
            }
        });
    }
    /**
     * Delete wind at a leg at a given altitude (does not delete this altitude globally)
     * @param globalLegIndex Flight plan leg index
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(globalLegIndex, altitude) {
        var _a;
        const leg = this.legWindData[globalLegIndex];
        const recordIndex = (_a = leg === null || leg === void 0 ? void 0 : leg.findIndex((r) => r.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (recordIndex >= 0 && leg) {
            const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : globalLegIndex + 1;
            const propagationData = this.legWindData[propagationIndex][recordIndex];
            if (propagationData) {
                const record = leg[recordIndex];
                Object.assign(record, propagationData);
                record.windPropagated = true;
            }
            else {
                // we must be the only leg
                this.deleteLegAltitude(altitude);
            }
        }
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(globalLegIndex, altitude, temperature) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            const tempData = this.legTemperatureData[globalLegIndex];
            tempData.altitude = altitude;
            tempData.temperature = temperature;
            tempData.temperaturePropagated = temperature === null;
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, 1);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateTemperature(globalLegIndex + 1, propagateTo, tempData);
            // propagate backward if no non-propagated legs behind
            const prevNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, -1);
            if (prevNonPropagatedLeg < 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
        }
        else {
            const tempData = { altitude, temperature, temperaturePropagated: temperature === null };
            this.legTemperatureData[globalLegIndex] = tempData;
            // no data exists, so we can propagate to all legs
            if (globalLegIndex > 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
            if (globalLegIndex < (this.legWindData.length - 1)) {
                this.propagateTemperature(globalLegIndex + 1, this.legWindData.length - 1, tempData);
            }
        }
        return true;
    }
    /**
     * Deletes a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(globalLegIndex) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            this.legTemperatureData[globalLegIndex].temperature = null;
            // TODO propagate from other leg
        }
    }
    /**
     * Gets a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     * @returns the leg temperature record if it exists, else undefined
     */
    getLegTemperature(globalLegIndex) {
        return this.legTemperatureData[globalLegIndex];
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from
     * @param recordIndex The index of the altitude record to propagate
     */
    propagateWind(fromIndex, toIndex, fromRecord, recordIndex) {
        for (let i = fromIndex; i <= toIndex; i++) {
            const record = this.legWindData[i][recordIndex];
            if (!record.windPropagated) {
                console.warn('Overwriting non-propagated wind record with propagated record at global leg', i);
                record.windPropagated = true;
            }
            record.altitude = fromRecord.altitude;
            record.direction = fromRecord.direction;
            record.speed = fromRecord.speed;
        }
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from.
     * @throws if parameters are incompatible with options
     */
    propagateTemperature(fromIndex, toIndex, fromRecord) {
        for (let i = fromIndex; i <= toIndex; i++) {
            if (this.legTemperatureData[i] === undefined) {
                this.legTemperatureData[i] = Object.assign(Object.assign({}, fromRecord), { temperaturePropagated: true });
            }
            else {
                const record = this.legTemperatureData[i];
                if (!record.temperaturePropagated) {
                    console.warn('Overwriting non-propagated temperature record with propagated record at global leg', i);
                    record.temperaturePropagated = true;
                }
                record.altitude = fromRecord.altitude;
                record.temperature = fromRecord.temperature;
            }
        }
    }
    /**
     * Find the next leg that doesn't have a propagated wind
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLeg(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legWindData.length : i >= 0); i += direction) {
            const legData = this.legWindData[i];
            if (legData.find((w) => w.altitude === altitude && !w.windPropagated)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Find the next leg that doesn't have a propagated temperature
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLegTemperature(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legTemperatureData.length : i >= 0); i += direction) {
            const legData = this.legTemperatureData[i];
            if (!legData.temperaturePropagated) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Get the wind records for a flight plan leg
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(globalLegIndex) {
        return this.legWindData[globalLegIndex];
    }
    /**
     * Get the number of legs in the plan
     * @returns the number of legs in the plan
     */
    get legLength() {
        return this.legWindData.length;
    }
    /**
     * Copy all data from another plan into this one
     * @param fromPlan the plan to copy from
     */
    copyFrom(fromPlan) {
        // TODO make this cheaper by re-using existing objects
        this.climbData = fromPlan.climbData.map((r) => (Object.assign({}, r)));
        this.descentData = fromPlan.descentData.map((r) => (Object.assign({}, r)));
        this.legWindData = fromPlan.legWindData.map((r) => r.map((v) => (Object.assign({}, v))));
        this.legTemperatureData = fromPlan.legTemperatureData.map((r) => (Object.assign({}, r)));
    }
    /**
     * Clears all leg wind and temperature data in the plan.
     */
    deleteAllClimbWindsAndTemperatures() {
        this.climbData.length = 0;
    }
    /**
     * Clears all leg wind and temperature data in the plan.
     */
    deleteAllDescentWindsAndTemperatures() {
        this.descentData.length = 0;
    }
    /**
     * Clears all leg wind and temperature data in the plan.
     */
    deleteAllLegWindsAndTemperatures() {
        this.legTemperatureData.length = 0;
        this.legWindData.forEach((r) => r.length = 0);
    }
    /**
     * Insert a climb or descent record into the array, taking care of temperature propagation and sorting
     * @param records climb or descent records
     * @param newRecord new record to insert
     */
    insertClimbDescentRecord(records, newRecord) {
        const insertAt = Math.max(0, records.findIndex((r) => r.altitude > newRecord.altitude));
        records.splice(insertAt, 0, newRecord);
        this.refreshTemperaturePropagation(records);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Refresh propagated temperature values for climb and descent from the non-propagated records
     * @param records Climb or Descent records
     */
    refreshTemperaturePropagation(records) {
        var _a;
        const anyNonPropagated = records.some((r) => r.temperaturePropagated === false);
        if (anyNonPropagated) {
            let previousAlt = null;
            let previousTemp = null;
            for (const record of records) {
                if ((_a = record.temperaturePropagated) !== null && _a !== void 0 ? _a : true) {
                    const nextHighestNonPropagated = records.find((r) => r.altitude > record.altitude && r.temperature !== null && r.temperaturePropagated === false);
                    if (nextHighestNonPropagated !== undefined && previousTemp !== null && previousAlt !== null && nextHighestNonPropagated.altitude !== previousAlt) {
                        // we have a temp above and below, interpolate isa delta between them
                        /** proportion of the higher ISA delta to take */
                        const k = (record.altitude - previousAlt) / (nextHighestNonPropagated.altitude - previousAlt);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + k * isaAbove + (1 - k) * isaBelow;
                    }
                    else if (nextHighestNonPropagated !== undefined) {
                        // we have a temp above but not below, use isaDelta directly
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaAbove;
                    }
                    else if (previousTemp !== null && previousAlt !== null) {
                        // we have a temp below but not above, use isaDelta directly
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaBelow;
                    }
                }
                else {
                    previousAlt = record.altitude;
                    previousTemp = record.temperature;
                }
            }
        }
        else {
            records.forEach((r) => r.temperature = this.isaTemperatureFeet(r.altitude));
        }
    }
}

/** Stores and manages wind plans */
class WindPlanner {
    /**
     * Constructs a WindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.plans = [];
        this.syncPublisher = this.bus.getPublisher();
        this.eventPublisher = this.bus.getPublisher();
        this.ignoreSync = false;
        const fpln = this.bus.getSubscriber();
        fpln.on('fplCreated').handle(this.onPlanCreated.bind(this));
        fpln.on('fplCopied').handle(this.onPlanCopied.bind(this));
        fpln.on('fplLoaded').handle(this.onPlanLoaded.bind(this));
        fpln.on('fplDeleted').handle(this.onPlanDeleted.bind(this));
        fpln.on('fplSegmentChange').handle(this.onSegmentChanged.bind(this));
        fpln.on('fplLegChange').handle(this.onLegChanged.bind(this));
        const sync = this.bus.getSubscriber();
        sync.on('windsync_climb_wind_deleted').handle(this.handleClimbWindDelete.bind(this));
        sync.on('windsync_climb_wind_set').handle(this.handleClimbWindSet.bind(this));
        sync.on('windsync_climb_temperature_set').handle(this.handleClimbTemperatureSet.bind(this));
        sync.on('windsync_climb_all_deleted').handle(this.handleDeleteAllClimbWindsAndTemperatures.bind(this));
        sync.on('windsync_descent_wind_deleted').handle(this.handleDescentWindDelete.bind(this));
        sync.on('windsync_descent_wind_set').handle(this.handleDescentWindSet.bind(this));
        sync.on('windsync_descent_temperature_set').handle(this.handleDescentTemperatureSet.bind(this));
        sync.on('windsync_descent_all_deleted').handle(this.handleDeleteAllDescentWindsAndTemperatures.bind(this));
        sync.on('windsync_leg_wind_deleted').handle(this.handleLegWindDelete.bind(this));
        sync.on('windsync_leg_altitude_deleted').handle(this.handleLegAltitudeDelete.bind(this));
        sync.on('windsync_leg_wind_set').handle(this.handleLegWindSet.bind(this));
        sync.on('windsync_leg_temperature_deleted').handle(this.handleLegTempDelete.bind(this));
        sync.on('windsync_leg_temperature_set').handle(this.handleLegTempSet.bind(this));
        sync.on('windsync_leg_all_deleted').handle(this.handleDeleteAllLegWindsAndTemperatures.bind(this));
    }
    /**
     * Set wind for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbWindSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a climb wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleClimbWindDelete(ev);
    }
    /**
     * Handles climb wind delete events
     * @param ev the event
     */
    handleClimbWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteClimbWindAndTemperature(ev.altitude);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbTemperatureSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the climb wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getClimbWindsAndTemperatures();
    }
    /**
     * Deletes all climb wind records
     * @param planIndex Flight Plan index
     */
    deleteAllClimbWindsAndTemperatures(planIndex) {
        const ev = {
            planIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_all_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDeleteAllClimbWindsAndTemperatures(ev);
    }
    /**
     * Handles delete all climb wind events
     * @param ev the event
     */
    handleDeleteAllClimbWindsAndTemperatures(ev) {
        const plan = this.getPlan(ev.planIndex);
        plan.deleteAllClimbWindsAndTemperatures();
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentWindSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a descent wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDescentWindDelete(ev);
    }
    /**
     * Handles descent wind delete events
     * @param ev the event
     */
    handleDescentWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteDescentWind(ev.altitude);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentTemperatureSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the descent wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getDescentWindsAndTemperatures();
    }
    /**
     * Deletes all descent wind records
     * @param planIndex Flight Plan index
     */
    deleteAllDescentWindsAndTemperatures(planIndex) {
        const ev = {
            planIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_all_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDeleteAllDescentWindsAndTemperatures(ev);
    }
    /**
     * Handles delete all descent wind events
     * @param ev the event
     */
    handleDeleteAllDescentWindsAndTemperatures(ev) {
        const plan = this.getPlan(ev.planIndex);
        plan.deleteAllDescentWindsAndTemperatures();
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(planIndex, globalLegIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegWindSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegWind(ev.globalLegIndex, ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg wind record
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(planIndex, globalLegIndex, altitude) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegWindDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegWind(ev.globalLegIndex, ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Deletes all leg wind records for a given altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_altitude_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegAltitudeDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegAltitudeDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegAltitude(ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the wind records for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegWinds(globalLegIndex);
    }
    /**
     * Deletes all leg wind records
     * @param planIndex Flight Plan index
     */
    deleteAllLegWindsAndTemperatures(planIndex) {
        const ev = {
            planIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_all_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDeleteAllLegWindsAndTemperatures(ev);
    }
    /**
     * Handles delete all leg wind events
     * @param ev the event
     */
    handleDeleteAllLegWindsAndTemperatures(ev) {
        const plan = this.getPlan(ev.planIndex);
        plan.deleteAllLegWindsAndTemperatures();
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(planIndex, globalLegIndex, altitude, temperature = null) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegTempSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegTempSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegTemperature(ev.globalLegIndex, ev.altitude, ev.temperature);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg temperature record,
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(planIndex, globalLegIndex) {
        const ev = {
            planIndex,
            globalLegIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegTempDelete(ev);
    }
    /**
     * Handles leg temperature delete events
     * @param ev the event
     */
    handleLegTempDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegTemperature(ev.globalLegIndex);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the temperature record for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns A temperature record if one exists, else undefined
     */
    getLegTemperature(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegTemperature(globalLegIndex);
    }
    /**
     * Clears all data from a wind plan.
     * Note: this will happen automatically when a flight plan is deleted.
     * @param planIndex Flight Plan index
     */
    clearPlan(planIndex) {
        this.deleteAllClimbWindsAndTemperatures(planIndex);
        this.deleteAllDescentWindsAndTemperatures(planIndex);
        this.deleteAllLegWindsAndTemperatures(planIndex);
    }
    /**
     * Handles flight plan creation events
     * @param data Event Data
     */
    onPlanCreated(data) {
        this.plans[data.planIndex] = new WindPlan(this.options);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handle flight plan copy events by copying related wind data
     * @param data Event Data
     */
    onPlanCopied(data) {
        const targetPlan = this.plans[data.targetPlanIndex];
        const fromPlan = this.plans[data.planIndex];
        if (!targetPlan || !fromPlan) {
            console.error('WindPlanner: failed to copy plan!');
            return;
        }
        targetPlan.copyFrom(fromPlan);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handles flight plan load events
     * @param data Event Data
     */
    onPlanLoaded(data) {
        const flightPlan = this.flightPlanner.getFlightPlan(data.planIndex);
        if (!flightPlan) {
            this.plans[data.planIndex] = undefined;
            return;
        }
        this.plans[data.planIndex] = new WindPlan(this.options, flightPlan.length);
    }
    /**
     * Handles flight plan deletion events
     * @param data Event Data
     */
    onPlanDeleted(data) {
        this.plans[data.planIndex] = undefined;
    }
    /**
     * Handles flight plan segment change events
     * @param data Event Data
     */
    onSegmentChanged(data) {
        var _a, _b;
        const windPlan = this.plans[data.planIndex];
        if (!windPlan) {
            return;
        }
        switch (data.type) {
            case SegmentEventType.Removed:
                for (let i = 0; i < ((_b = (_a = data.segment) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0); i++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    windPlan.deleteLeg(data.segment.offset);
                }
                break;
            case SegmentEventType.Changed:
            // fall through, airway changes don't matter to us
            case SegmentEventType.Added:
            case SegmentEventType.Inserted:
            default:
                // nothing we need to do for these as they don't add or remove legs
                return;
        }
    }
    /**
     * Handles flight plan leg change events
     * @param data Event Data
     */
    onLegChanged(data) {
        const globalLegIndex = WindPlanner.getGlobalLegIndex(this.flightPlanner.getFlightPlan(data.planIndex), data.segmentIndex, data.legIndex);
        const plan = this.plans[data.planIndex];
        if (!plan) {
            console.warn('onLegChanged, but the flightplan doesn\'t exist!');
            return;
        }
        switch (data.type) {
            case LegEventType.Added:
                plan.insertLegAndPropagate(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
            case LegEventType.Removed:
                plan.deleteLeg(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
        }
    }
    /**
     * Get a flight plan or error if it doesn't exist
     * @param planIndex Flight Plan index
     * @throws if flight plan doesn't exist
     * @returns FlightPlan
     */
    getPlan(planIndex) {
        const plan = this.plans[planIndex];
        if (plan === undefined) {
            throw new Error(`WindPlanner: wind plan ${planIndex} does not exist!`);
        }
        return plan;
    }
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
        if (segmentIndex < lateralPlan.segmentCount) {
            const segment = lateralPlan.getSegment(segmentIndex);
            return segment.offset + segmentLegIndex;
        }
        return -1;
    }
    /**
     * Check if all the available leg altitudes are already used
     * @param planIndex Flight Plan index
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed(planIndex) {
        const plan = this.getPlan(planIndex);
        return plan.areAllLegAltitudesUsed();
    }
    /**
     * Get the number of leg wind altitudes permitted
     * @returns the maximum number of leg wind altitudes, or undefined if no limit
     */
    getNumberOfLegAltitudes() {
        return this.options.numberOfLegAltitudes;
    }
    /**
     * Get the number of climb wind altitudes permitted
     * @returns the maximum number of climb wind altitudes, or undefined if no limit
     */
    getNumberOfClimbAltitudes() {
        return this.options.numberOfClimbAltitudes;
    }
    /**
     * Get the number of descent wind altitudes permitted
     * @returns the maximum number of climb wind altitudes, or undefined if no limit
     */
    getNumberOfDescentAltitudes() {
        return this.options.numberOfDescentAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.legHasNonPropagatedWind(globalLegIndex);
    }
}

// TODO consider average wind entry instead of individual winds
/** Wind Planner that interpolates live wind data along the route for a Boeing FMS */
class InterpolatingWindPlanner extends WindPlanner {
    /**
     * Constructs an InterpolatingWindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        super(bus, flightPlanner, options);
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.filteredLiveWind = Vec2Math.create();
        /** sim wind direction in degrees true */
        this.liveWindDirection = ConsumerValue.create(null, 0);
        /** sim wind speed in knots */
        this.liveWindSpeed = ConsumerValue.create(null, 0);
        /** plane altitude in feet */
        this.planeAltitude = ConsumerValue.create(null, 0);
        /** plane is on the ground */
        this.onGround = ConsumerValue.create(null, true);
        /** static/outside air temperature in degrees celsius */
        this.staticAirTemperature = ConsumerValue.create(null, 0);
        this.filteredCache = [];
        const sub = this.bus.getSubscriber();
        this.liveWindDirection.setConsumer(sub.on('ambient_wind_direction').withPrecision(0));
        this.liveWindSpeed.setConsumer(sub.on('ambient_wind_velocity').withPrecision(0));
        this.planeAltitude.setConsumer(sub.on('indicated_alt').withPrecision(-2));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.staticAirTemperature.setConsumer(sub.on('ambient_temp_c').withPrecision(0));
        sub.on('simTime').atFrequency(1).handle(this.updateLiveWind.bind(this));
    }
    /** Apply an IIR filter to the live wind */
    updateLiveWind() {
        Vec2Math.setFromPolar(this.liveWindSpeed.get(), UnitType.RADIAN.convertFrom(this.liveWindDirection.get(), UnitType.DEGREE), this.vec2Cache[0]);
        Vec2Math.multScalar(this.vec2Cache[0], 0.1, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 0.9, this.filteredLiveWind);
        Vec2Math.add(this.filteredLiveWind, this.vec2Cache[0], this.filteredLiveWind);
    }
    /**
     * Transform a cartesian wind vector to polar direction/speed
     * @param vector Cartesian wind vector or null if no vector
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    windVectorToDirectionSpeed(vector, out) {
        if (vector === null) {
            return null;
        }
        out[0] = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Vec2Math.theta(vector), UnitType.DEGREE));
        out[1] = Vec2Math.abs(vector);
        return out;
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO Does the Boeing use climb and/or descent wind if no leg winds?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.tryGetLeg(globalLegIndex);
        if (!fpLeg) {
            return null;
        }
        /** Stored in this.vec2Cache[0] */
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        /** proportion of live wind to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        Vec2Math.multScalar(forecastWind, 1 - k, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
        return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedWindAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        const wind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get the wind at a given altitude on a given leg
     * @param windPlan The wind plan to use
     * @param globalLegIndex The global index of the desired leg
     * @param altitude Altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getLegWindAtAltitude(windPlan, globalLegIndex, altitude, out) {
        const legWinds = windPlan.getLegWinds(globalLegIndex);
        if (legWinds === undefined) {
            return null;
        }
        return this.getAltitudeInterpolatedWind(legWinds, altitude, out);
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(climbWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = this.vec2Cache[0][0];
        out[1] = this.vec2Cache[0][1];
        return out;
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedClimbWind(planIndex, altitude, liveWind, out) {
        const wind = this.getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get a descent wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedDescentWind(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const desWinds = windPlan.getDescentWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(desWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = UnitType.RADIAN.convertTo(Vec2Math.theta(this.vec2Cache[0]), UnitType.DEGREE);
        out[1] = Vec2Math.abs(this.vec2Cache[0]);
        return out;
    }
    /**
     * Get the wind at a given altitude from a WindRecord, interpolated when it lies between altitudes for which wind is defined
     * Caution: clobbers first 2 elements of this.vec2Cache
     * @param winds Wind records to use
     * @param altitude Desired altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getAltitudeInterpolatedWind(winds, altitude, out) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < winds.length; i++) {
            const wind = winds[i];
            if (wind.direction !== null && wind.speed !== null) {
                this.filteredCache[index++] = wind;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredWinds = this.filteredCache;
        if (filteredWinds.length < 1) {
            return null;
        }
        if (filteredWinds.length === 1 || altitude >= filteredWinds[0].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[0].speed, UnitType.RADIAN.convertFrom(filteredWinds[0].direction, UnitType.DEGREE), out);
        }
        if (altitude <= filteredWinds[filteredWinds.length - 1].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[filteredWinds.length - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[filteredWinds.length - 1].direction, UnitType.DEGREE), out);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredWinds.length; i++) {
            if (filteredWinds[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper wind to take */
            const k = (altitude - filteredWinds[i].altitude) / (filteredWinds[i - 1].altitude - filteredWinds[i].altitude);
            const windUpper = Vec2Math.setFromPolar(filteredWinds[i - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[i - 1].direction, UnitType.DEGREE), this.vec2Cache[0]);
            const windLower = Vec2Math.setFromPolar(filteredWinds[i].speed, UnitType.RADIAN.convertFrom(filteredWinds[i].direction, UnitType.DEGREE), this.vec2Cache[1]);
            Vec2Math.multScalar(windUpper, k, this.vec2Cache[0]);
            Vec2Math.multScalar(windLower, 1 - k, this.vec2Cache[1]);
            return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
        }
        return null;
    }
    /**
     * Get the ISA delta temperature interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @returns ISA temperature delta in °C or null if no data
     */
    getInterpolatedIsaDeltaAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO use climb and/or descent temp if no leg temp?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.getLeg(globalLegIndex);
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        const legTemp = windPlan.getLegTemperature(globalLegIndex);
        if (legTemp === undefined || legTemp.temperature === null) {
            return null;
        }
        /** proportion of live data to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        const isaTemp = this.isaTemperatureFeet(altitude);
        const interpolatedTemp = k * this.staticAirTemperature.get() + (1 - k) * legTemp.temperature;
        return interpolatedTemp - isaTemp;
    }
    /**
     * Get a climb ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedClimbIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(climbWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get a descent ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedDescentIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const descentWinds = windPlan.getDescentWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(descentWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get the ISA temperature delta at a given altitude from a WindAndTemperatureRecord,
     * interpolated when it lies between altitudes for which temperature is defined
     * @param temps Wind/Temperature records to use
     * @param altitude Desired altitude in feet MSL
     * @returns An ISA delta in °C or null if unavailable
     */
    getAltitudeInterpolatedIsaDelta(temps, altitude) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < temps.length; i++) {
            const temp = temps[i];
            if (temp.temperature !== null) {
                this.filteredCache[index++] = temp;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredTemps = this.filteredCache;
        if (filteredTemps.length < 1) {
            return null;
        }
        if (filteredTemps.length === 1 || altitude >= filteredTemps[0].altitude) {
            return filteredTemps[0].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        else if (altitude <= filteredTemps[filteredTemps.length - 1].altitude) {
            return filteredTemps[filteredTemps.length - 1].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredTemps.length; i++) {
            if (filteredTemps[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper temperature to take */
            const k = (altitude - filteredTemps[i].altitude) / (filteredTemps[i - 1].altitude - filteredTemps[i].altitude);
            // we have filtered out null temps above, but the linter isn't quite smart enough to figure that out
            const upperIsaDelta = filteredTemps[i - 1].temperature - this.isaTemperatureFeet(filteredTemps[i - 1].altitude);
            const lowerIsaDelta = filteredTemps[i].temperature - this.isaTemperatureFeet(filteredTemps[i].altitude);
            return k * upperIsaDelta + (1 - k) * lowerIsaDelta;
        }
        return null;
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a distance from the aircraft
     * @param distance distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportion(distance) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        if (distance < 277800) {
            return 1 - 1 / 3 * (distance / 277800) ** 2;
        }
        return 2 / 3 * (Math.E ** (-5 * ((distance - 277800) / 1852000)));
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a height from the aircraft
     * @param height vertical distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportionHeight(height) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        // 243.045 = 6076.12 feet/NM / (17500 ft / 700 NM), the latter from FMS documentation
        return this.getLiveDataProportion(Math.abs(height) * 243.045);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Calculate the wind speed for the ECON speed calculation.
     * Before takeoff, when planning the flight, this shall be taken from the wind plan.
     * Once flying at cruise flight level, ECON speed controls the AT so we want to base the calculation
     * on the actual live wind.
     * @param planIndex Flight Plan index
     * @param cruiseAltitude Planned cruise altitude
     * @param globalLegIndex Index of active leg
     * @param distanceAlongLeg Distance along the active leg
     * @param trueHeading Heading of the aircraft, degree
     * @returns Headwind component (knots)
     */
    getHeadwindForEconSpeedCalculation(planIndex, cruiseAltitude, globalLegIndex, distanceAlongLeg, trueHeading) {
        // Retrieve planned wind (first wind along leg, if unavailble climb wind).
        let planWind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, distanceAlongLeg, this.vec2Cache[2]);
        if (planWind === null) {
            planWind = this.getInterpolatedClimbWindCartesian(planIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, true, this.vec2Cache[2]);
        }
        if (planWind === null) {
            planWind = this.vec2Cache[2];
            this.vec2Cache[2][0] = 0;
            this.vec2Cache[2][1] = 0;
        }
        // Blend gradually between planned wind and live wind using 100% live wind @(plane alt = cruiseAlt) 
        // and 100% planned wind @(alt deviates 500ft or more from cruise alt):
        const planWindProportion = Math.min(1, Math.abs(cruiseAltitude - this.planeAltitude.get()) / 500);
        Vec2Math.multScalar(planWind, planWindProportion, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 1 - planWindProportion, this.vec2Cache[1]);
        Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        // Create unit vector in heading direction:
        Vec2Math.setFromPolar(1, UnitType.RADIAN.convertFrom(trueHeading, UnitType.DEGREE), this.vec2Cache[1]);
        // The dot product returns the projected length of the wind vector onto the heading (unit) vector:
        return VecNMath.dot(this.vec2Cache[0], this.vec2Cache[1]);
    }
}
InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT = (a, b) => b.altitude - a.altitude;

/**
 * A class that handles aurals coming from panel.xml.
 */
class B78XmlAuralsConfig {
    /**
     * Ctor
     * @param inst The instrument this manager is on.
     * @param logicHost The xml logic host.
     * @param bus The event bus.
     */
    constructor(inst, logicHost, bus) {
        this.soundController = new SoundServerController(bus);
        const warnFactory = new XMLWarningFactory(inst);
        const warnings = warnFactory.parseConfig(inst.xmlConfig);
        this.warningsManager = new WarningManager(warnings, logicHost, () => { }, this.onWarningSound.bind(this));
    }
    /**
     * Start or stop playing a continuour warning sound.
     * @param warning The warning.
     * @param active Whether the warning is turning on or off.
     */
    onWarningSound(warning, active) {
        if (warning.soundId) {
            if (active) {
                this.soundController.startSound(warning.soundId);
            }
            else {
                this.soundController.stop(warning.soundId);
            }
        }
    }
}

/** The B748Square component. */
class B748Square extends DisplayComponent {
    /** @inheritdoc */
    onAfterRender() {
        // TODO do stuff
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: `b748-square ${this.props.pfdOrMfd} ${this.props.pfdOrMfd}-${this.props.instrumentIndex}` }, this.props.children));
    }
}

/** The state of the minimums controller. */
var MinimumsAlerterState;
(function (MinimumsAlerterState) {
    MinimumsAlerterState[MinimumsAlerterState["DISABLED"] = 0] = "DISABLED";
    MinimumsAlerterState[MinimumsAlerterState["ARMED"] = 1] = "ARMED";
    MinimumsAlerterState[MinimumsAlerterState["ALERTING"] = 2] = "ALERTING";
})(MinimumsAlerterState || (MinimumsAlerterState = {}));
/**
 * A controller for the minimums alert. Publishes the alert state for any minimums and radio minimums to the event bus
 * topics `minimums_alert` and `radio_minimums_alert`, respectively.
 */
class MinimumsAlertController {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.adcSub = this.bus.getSubscriber();
        this.radioAltSub = this.bus.getSubscriber();
        this.alertPublisher = this.bus.getPublisher();
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.bus);
        this.modeSetting = this.cockpitUserSettings.getSetting('minimumsMode');
        this.alertValue = MappedSubject.create(([mode, baroMins, radioMins]) => {
            switch (mode) {
                case MinimumsMode.BARO:
                    return baroMins;
                case MinimumsMode.RA:
                    return radioMins;
                default:
                    return null;
            }
        }, this.modeSetting, this.cockpitUserSettings.getSetting('decisionAltitudeFeet'), this.cockpitUserSettings.getSetting('decisionHeightFeet'));
        this.alerterState = Subject.create(MinimumsAlerterState.DISABLED);
        this.isOnGround = ConsumerSubject.create(this.adcSub.on('on_ground'), true);
        this.planeAltitude = ConsumerSubject.create(null, 0);
        this.bus = bus;
        const updateAlerterState = this.updateAlerterState.bind(this);
        this.modeSetting.sub(this.onModeChanged.bind(this));
        this.alertValue.sub(this.onMinimumsChanged.bind(this));
        this.planeAltitude.sub(updateAlerterState);
        this.isOnGround.sub(updateAlerterState);
        updateAlerterState();
        this.alerterState.sub(this.onAlerterStateChanged.bind(this), true);
    }
    /**
     * Called when the minimums mode changes.
     * @param mode The new minimums mode.
     */
    onModeChanged(mode) {
        this.alerterState.set(MinimumsAlerterState.DISABLED);
        switch (mode) {
            case MinimumsMode.BARO:
                this.planeAltitude.setConsumer(this.adcSub.on('indicated_alt'));
                break;
            case MinimumsMode.RA:
                this.planeAltitude.setConsumer(this.radioAltSub.on('ra_radio_alt_1'));
                break;
            default:
                this.planeAltitude.setConsumer(null);
        }
        this.updateAlerterState();
    }
    /**
     * Called when the minimums value changes.
     */
    onMinimumsChanged() {
        this.alerterState.set(MinimumsAlerterState.DISABLED);
        this.updateAlerterState();
    }
    /**
     * Called when the alerter state changes.
     * @param state The new alerter state.
     */
    onAlerterStateChanged(state) {
        this.alertPublisher.pub('minimums_alert', state === MinimumsAlerterState.ALERTING, false, true);
        this.alertPublisher.pub('radio_minimums_alert', state === MinimumsAlerterState.ALERTING && this.modeSetting.value === MinimumsMode.RA, false, true);
    }
    /**
     * Updates the alert state.
     */
    updateAlerterState() {
        const minimums = this.alertValue.get();
        if (minimums === null || this.isOnGround.get()) {
            this.alerterState.set(MinimumsAlerterState.DISABLED);
            return;
        }
        const altitude = this.planeAltitude.get();
        switch (this.alerterState.get()) {
            case MinimumsAlerterState.DISABLED:
                if (altitude >= minimums + 50) {
                    this.alerterState.set(MinimumsAlerterState.ARMED);
                }
                break;
            case MinimumsAlerterState.ARMED:
                if (altitude < minimums) {
                    this.alerterState.set(MinimumsAlerterState.ALERTING);
                }
                break;
            case MinimumsAlerterState.ALERTING:
                // Reset when:
                // - Plane altitude is above selected minimums (with buffer of 20 ft).
                // - When gear touches ground during landing phase.
                if (altitude >= minimums + 50) {
                    this.alerterState.set(MinimumsAlerterState.ARMED);
                }
                else if (altitude >= minimums + 20) {
                    this.alerterState.set(MinimumsAlerterState.DISABLED);
                }
                break;
        }
    }
}

const efisEventMap = {
    'Mins_INC': 'EFIS.MINS_INC',
    'Mins_DEC': 'EFIS.MINS_DEC',
    'Mins_Press': 'EFIS.MINS_PRESS',
    'AUTOPILOT_CTR': 'EFIS.ND_CTR',
    'WXR': 'EFIS.WXR',
    'STA': 'EFIS.STA',
    'WPT': 'EFIS.WPT',
    'ARPT': 'EFIS.ARPT',
    'DATA': 'EFIS.DATA',
    'POS': 'EFIS.POS',
    'TERR': 'EFIS.TERR',
    'TFC': 'EFIS.TFC',
    'FPV': 'EFIS.FPV',
    'MTRS': 'EFIS.MTRS',
};
/**
 * The publisher for EFIS panel events.
 */
class EfisEventPublisher extends BasePublisher {
    /**
     * Ctor
     * @param bus The event bus.
     * @param isMfd Whether this instance is on a MFD.
     * @param index The index of the instrument.
     */
    constructor(bus, isMfd, index) {
        super(bus);
        this.isMfd = isMfd;
        this.index = index;
        if (isMfd) {
            this.eventRegx = new RegExp(`AS01B_MFD_${this.index}_(.*)`);
        }
        else {
            // TODO: PFD events have no indexes. Fix Modelbehaviors
            this.eventRegx = /B747_8_PFD_(.*)/;
        }
        this.startPublish();
    }
    /**
     * Handles HEvents to be published as {@link EfisEvent}.
     * @param evt The hevent.
     * @returns True if the event was handled, false otherwise.
     */
    handleHEvent(evt) {
        const matches = evt.match(this.eventRegx);
        if (matches) {
            const efisEvent = efisEventMap[matches[1]];
            if (efisEvent) {
                this.publish(efisEvent, undefined, false, false);
                return true;
            }
        }
        return false;
    }
}

/**
 * Controller that handles EFIS events meant for the PFD.
 */
class EfisPfdController {
    /**
     * Ctor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.settings = CockpitUserSettings.getManager(this.bus);
        const efisSub = bus.getSubscriber();
        efisSub.on('EFIS.FPV').handle(this.handleFpvEvent.bind(this));
        efisSub.on('EFIS.MTRS').handle(this.handleMtrsEvent.bind(this));
    }
    /** Handles the FPV event for the ND. */
    handleFpvEvent() {
        const fpvEnabled = this.settings.getSetting('fpvActive');
        fpvEnabled.set(!fpvEnabled.get());
    }
    /** Handles the MTRS event for the ND. */
    handleMtrsEvent() {
        const mtrsEnabled = this.settings.getSetting('metricAltitudeDisplay');
        mtrsEnabled.set(!mtrsEnabled.get());
    }
}

/**
 * Boeing 747-8 MFD side selections.
 */
var MFD_SIDE_SELECT;
(function (MFD_SIDE_SELECT) {
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["LEFT"] = 0] = "LEFT";
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["RIGHT"] = 1] = "RIGHT";
})(MFD_SIDE_SELECT || (MFD_SIDE_SELECT = {}));
/**
 * Boeing 747 transponder modes.
 */
var B74_XPDR_MODE;
(function (B74_XPDR_MODE) {
    B74_XPDR_MODE[B74_XPDR_MODE["STBY"] = 0] = "STBY";
    B74_XPDR_MODE[B74_XPDR_MODE["ON"] = 1] = "ON";
    B74_XPDR_MODE[B74_XPDR_MODE["TA_Only"] = 2] = "TA_Only";
    B74_XPDR_MODE[B74_XPDR_MODE["TA_RA"] = 3] = "TA_RA";
})(B74_XPDR_MODE || (B74_XPDR_MODE = {}));
/**
 * Boeing 747-8 hydraulic pump states
 */
var B74_HYDRAULIC_PUMP_MODE;
(function (B74_HYDRAULIC_PUMP_MODE) {
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["OFF"] = 0] = "OFF";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["AUTO"] = 1] = "AUTO";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["ON"] = 2] = "ON";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["AUX"] = 3] = "AUX";
})(B74_HYDRAULIC_PUMP_MODE || (B74_HYDRAULIC_PUMP_MODE = {}));
/**
 * Boeing 747-8 TCAS Airspace selector modes
 */
var B74_TCAS_ATC_AIRSPACE_MODE;
(function (B74_TCAS_ATC_AIRSPACE_MODE) {
    B74_TCAS_ATC_AIRSPACE_MODE[B74_TCAS_ATC_AIRSPACE_MODE["ABV"] = 0] = "ABV";
    B74_TCAS_ATC_AIRSPACE_MODE[B74_TCAS_ATC_AIRSPACE_MODE["NORM"] = 1] = "NORM";
    B74_TCAS_ATC_AIRSPACE_MODE[B74_TCAS_ATC_AIRSPACE_MODE["BLW"] = 2] = "BLW";
})(B74_TCAS_ATC_AIRSPACE_MODE || (B74_TCAS_ATC_AIRSPACE_MODE = {}));
/**
 * Boeing 747-8 standby power knob states.
 */
var StandbyPowerKnobState;
(function (StandbyPowerKnobState) {
    StandbyPowerKnobState[StandbyPowerKnobState["Off"] = 0] = "Off";
    StandbyPowerKnobState[StandbyPowerKnobState["Auto"] = 1] = "Auto";
    StandbyPowerKnobState[StandbyPowerKnobState["Batt"] = 2] = "Batt";
})(StandbyPowerKnobState || (StandbyPowerKnobState = {}));
/**
 * Boeing 747-8 IRS knob states.
 */
var IrsKnobState;
(function (IrsKnobState) {
    IrsKnobState[IrsKnobState["Off"] = 0] = "Off";
    IrsKnobState[IrsKnobState["Align"] = 1] = "Align";
    IrsKnobState[IrsKnobState["Nav"] = 2] = "Nav";
    IrsKnobState[IrsKnobState["Att"] = 3] = "Att";
})(IrsKnobState || (IrsKnobState = {}));
/**
 * Boeing 747-8 IRS source select knob states.
 */
var IrsSourceKnobState;
(function (IrsSourceKnobState) {
    IrsSourceKnobState[IrsSourceKnobState["Left"] = 0] = "Left";
    IrsSourceKnobState[IrsSourceKnobState["Center"] = 1] = "Center";
    IrsSourceKnobState[IrsSourceKnobState["Right"] = 2] = "Right";
    IrsSourceKnobState[IrsSourceKnobState["Auto"] = 3] = "Auto";
})(IrsSourceKnobState || (IrsSourceKnobState = {}));
/**
 * Boeing 747-8 AIR DATA source select knob states.
 */
var AirDataSourceKnobState;
(function (AirDataSourceKnobState) {
    AirDataSourceKnobState[AirDataSourceKnobState["Left"] = 0] = "Left";
    AirDataSourceKnobState[AirDataSourceKnobState["Auto"] = 1] = "Auto";
    AirDataSourceKnobState[AirDataSourceKnobState["Right"] = 2] = "Right";
})(AirDataSourceKnobState || (AirDataSourceKnobState = {}));
/**
 * Boeing 747-8 wing/engine anti-ice switch states.
 */
var AntiIceSwitchState;
(function (AntiIceSwitchState) {
    AntiIceSwitchState[AntiIceSwitchState["Off"] = 0] = "Off";
    AntiIceSwitchState[AntiIceSwitchState["Auto"] = 1] = "Auto";
    AntiIceSwitchState[AntiIceSwitchState["On"] = 2] = "On";
})(AntiIceSwitchState || (AntiIceSwitchState = {}));
/**
 * A publisher for 748 Cockpit Variables or Events.
 */
class CockpitVarsPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of CockpitVarsPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['b74_minimums_mode', { name: 'L:XMLVAR_Mins_Selector_Baro', type: SimVarValueType.Number }],
            ['pilot_transmitting', { name: 'PILOT TRANSMITTING', type: SimVarValueType.Bool }],
            ['b74_xpdr_mode', { name: 'L:XMLVAR_Transponder_Mode', type: SimVarValueType.Number }],
            ['b74_stby_power_mode', { name: 'L:XMLVAR_StandbyPower_Selector', type: SimVarValueType.Number }],
            ['b74_hyd_pump', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['mfd_side_select', { name: 'L:XMLVAR_MFD_Side_#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['mfd_nd_wx_terr_contrast_1', { name: 'L:WT_MFD_1_CONTRAST', type: SimVarValueType.Number }],
            ['mfd_nd_wx_terr_contrast_2', { name: 'L:WT_MFD_2_CONTRAST', type: SimVarValueType.Number }],
            ['baro_ref_hpa', { name: 'L:XMLVAR_Baro_Selector_HPA_#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_irs_knob_state', { name: 'L:B748_IRS_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['b74_irs_source_knob_state', { name: 'L:B748_IRS_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b74_air_data_source_knob_state', { name: 'L:B748_Air_Data_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b74_ext_pwr_switch_pressed', { name: 'L:EXT_PWR_COMMANDED:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_elec_bus_1_connection_on', { name: 'L:XMLVAR_Bus1ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_2_connection_on', { name: 'L:XMLVAR_Bus2ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_3_connection_on', { name: 'L:XMLVAR_Bus3ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_4_connection_on', { name: 'L:XMLVAR_Bus4ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_emer_lights', { name: 'L:XMLVAR_EMER_LIGHTS_ARMED', type: SimVarValueType.Number }],
            ['b74_batt_to_hotbatt_connection_on', { name: 'L:XMLVAR_BattToHotBatt_Connected', type: SimVarValueType.Bool }],
            ['b74_tcas_atc_airspace_mode', { name: 'L:XMLVAR_ATC_AIRSPACE_MODE_ABV_BLW', type: SimVarValueType.Number }],
            ['b74_bleed_air_switch', { name: 'L:WT_748_BLEED_ON:#index#', type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            ['b74_air_isln_closed', { name: 'L:WT_748_AIR_ISLN_CLOSED:#index#', type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            ['b74_pack_switch', { name: 'L:WT_748_PACK_ON:#index#', type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            ['b74_apu_bleed_switch', { name: 'L:ELECTRICAL_APU_Bleed', type: SimVarValueType.Bool }],
            ['b74_trim_air_l_switch', { name: 'L:WT_748_TRIM_AIR_L', type: SimVarValueType.Bool }],
            ['b74_trim_air_r_switch', { name: 'L:WT_748_TRIM_AIR_R', type: SimVarValueType.Bool }],
            ['b74_lwr_recirc_switch', { name: 'L:WT_748_RECIRC_LWR', type: SimVarValueType.Bool }],
            ['b74_fltdeck_temp_target', { name: 'L:WT_748_FLT_DECK_TEMP', type: SimVarValueType.Number }],
            ['b74_cabin_master_temp_target', { name: 'L:WT_748_CABIN_TEMP', type: SimVarValueType.Number }],
            ['b74_aft_cargo_temp_target', { name: 'L:WT_748_CARGO_TEMP', type: SimVarValueType.Number }],
            ['b74_engine_anti_ice_switch_state', { name: 'L:B748_Engine_AntiIce_Switch_State:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['b74_wing_anti_ice_switch_state', { name: 'L:B748_Wing_AntiIce_Switch_State', type: SimVarValueType.Number }],
            ['b74_windshield_deice', { name: 'L:XMLVAR_DeiceWindshield:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_yaw_damper_switch', { name: 'L:WT_748_Yaw_Damper:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_yaw_damper_failed', { name: 'L:WT_748_Yaw_Damper_Fail:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_fuel_innerleft_xfeed_switch', { name: 'L:WT_748_FUEL_XFEED:2', type: SimVarValueType.Bool }],
            ['b74_fuel_innerright_xfeed_switch', { name: 'L:WT_748_FUEL_XFEED:3', type: SimVarValueType.Bool }],
            ['b74_fuel_main2_pump_aft_switch', { name: 'L:WT_748_FUEL_PUMP_2_AFT_ON', type: SimVarValueType.Bool }],
            ['b74_fuel_main3_pump_aft_switch', { name: 'L:WT_748_FUEL_PUMP_3_AFT_ON', type: SimVarValueType.Bool }],
            ['b74_fuel_outer_to_inner_xfer_switch', { name: 'L:WT_748_FUEL_MAIN_OUTER_TO_INNER_XFER_ON', type: SimVarValueType.Bool }],
            ['b74_fuel_reserve_xfer_switch', { name: 'L:WT_748_FUEL_MAIN_RESERVE_XFER_ON', type: SimVarValueType.Bool }],
            ['b74_beacon_light_switch', { name: 'LIGHT BEACON', type: SimVarValueType.Bool }],
            ['b74_spoilers_armed', { name: 'SPOILERS ARMED', type: SimVarValueType.Bool }],
            ['b74_apu_knob_state', { name: 'L:XMLVAR_APU_StarterKnob_Pos', type: SimVarValueType.Number }],
        ]), bus);
    }
}

/**
 * B747-8 GENX-2B67 Engine Data Utility Class.
 */
class B748EngineData {
    /**
     * Creates an instance of B787 Engine Data
     * @param bus The Event Bus.
     * @param performanceData An instance of the BoeingPerformanceDataProvider.
     */
    constructor(bus, performanceData) {
        this.performanceData = performanceData;
        this.engineCount = 4;
        // 23.2 is best guess, and matches engines.cfg
        this.IDLE_N1 = 23.2;
        // 102.9 is the highest N1 value found in perf tables.
        // (This is still a best guess as to what maximum rated thrust means, we know max rated is below redline, based on the FCOM)
        this.MAX_RATED_N1 = 102.9;
        // 106 from the GEnx cert docs.
        this.RED_LINE_N1 = 106;
        // 58 is best guess from looking at videos.
        this.IDLE_N2 = 58;
        // 118 is pulled from the GEnx cert docs.
        this.RED_LINE_N2 = 118;
        // 750 comes from the GEnx cert docs.
        this.START_LIMIT_EGT = 750;
        // 1005 comes from GEnx cert docs, EGT Max Continuous max temp C
        this.CONTINUOUS_LIMIT_EGT = 1005;
        // 1040 comes from GEnx cert docs, 30 sec max transient temp C
        // (we used the highest egt limit in that table)
        this.RED_LINE_EGT = 1040;
        this.mach = ConsumerValue.create(null, 0);
        this.sat = ConsumerValue.create(null, 0);
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.mach.setConsumer(bus.getSubscriber().on('mach_number').withPrecision(2));
        this.sat.setConsumer(bus.getSubscriber().on('ambient_temp_c').withPrecision(0));
        this.pressureAlt.setConsumer(bus.getSubscriber().on('pressure_alt').withPrecision(0));
    }
    /** @inheritdoc */
    getMaxConN1(pressureAltitude, tat) {
        return B748EngineData.max_con_n1.get(tat, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMaxConTpr(pressureAltitude, tat) {
        return -1;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getToMaxTpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getToMaxN1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTo1Tpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getTo1N1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to1_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTo2Tpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getTo2N1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to2_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClbMaxTpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClbMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.clb_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClb1Tpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClb1N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 5% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, maxClb);
        const derate = thrustScalar * 0.05 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        const deratedThrustScalar = thrustScalar - derate;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(mach, deratedThrustScalar);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClb2Tpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClb2N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 15% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, maxClb);
        const derate = thrustScalar * 0.15 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        const deratedThrustScalar = thrustScalar - derate;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(mach, deratedThrustScalar);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getGaMaxTpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getGaMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.ga_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getCruiseMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.cru_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getOptimumAltitude(aircraftWeight) {
        return Math.min(B748EngineData.alt_opt.get(aircraftWeight), 41000);
    }
    /** @inheritdoc */
    getMaximumAltitude(aircraftWeight) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(this.pressureAlt.get());
        const isaTempC = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const isaDev = this.sat.get() - isaTempC;
        return Math.min(B748EngineData.alt_max.get(aircraftWeight, isaDev), 41000);
    }
    /** @inheritdoc */
    getLongRangeCruiseMach(aircraftWeight, pressureAltitude) {
        return B748EngineData.lrc_mach.get(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getEconCruiseMach(aircraftWeight, pressureAltitude) {
        return 0.95 * this.getLongRangeCruiseMach(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTprFromN1(n1, tat, pressureAltitude) {
        return -1;
    }
    /** @inheritDoc */
    getTakeoffDeratePercentage(targetN1, maxN1) {
        const targetThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(0, targetN1);
        const maxThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(0, maxN1);
        return (maxThrustScalar - targetThrustScalar) / maxThrustScalar * 100;
    }
}
B748EngineData.to_n1_max = new LerpLookupTable([
    [89.7, 70, -2000], [90.1, 70, -1000], [90.6, 70, 0], [90.6, 70, 1000], [90.6, 70, 2000], [90.5, 70, 3000], [90.4, 70, 4000], [90.4, 70, 5000], [90.3, 70, 6000],
    [90.3, 70, 7000], [89.7, 70, 8000], [89.2, 70, 9000], [88.5, 70, 10000],
    [92.5, 60, -2000], [93, 60, -1000], [93.4, 60, 0], [93.4, 60, 1000], [93.4, 60, 2000], [93.3, 60, 3000], [93.3, 60, 4000], [93.2, 60, 5000], [93.2, 60, 6000],
    [93.2, 60, 7000], [92.6, 60, 8000], [92, 60, 9000], [91.4, 60, 10000],
    [93.9, 55, -2000], [94.4, 55, -1000], [94.8, 55, 0], [94.8, 55, 1000], [94.8, 55, 2000], [94.7, 55, 3000], [94.6, 55, 4000], [94.6, 55, 5000], [94.6, 55, 6000],
    [94.5, 55, 7000], [94, 55, 8000], [93.4, 55, 9000], [92.8, 55, 10000],
    [95.2, 50, -2000], [95.7, 50, -1000], [96.2, 50, 0], [96.1, 50, 1000], [96.1, 50, 2000], [96, 50, 3000], [96, 50, 4000], [95.9, 50, 5000], [95.9, 50, 6000],
    [95.9, 50, 7000], [95.3, 50, 8000], [94.7, 50, 9000], [94.2, 50, 10000],
    [96.5, 45, -2000], [97, 45, -1000], [97.5, 45, 0], [97.4, 45, 1000], [97.3, 45, 2000], [97.3, 45, 3000], [97.3, 45, 4000], [97.2, 45, 5000], [97.2, 45, 6000],
    [97.2, 45, 7000], [96.6, 45, 8000], [96, 45, 9000], [95.5, 45, 10000],
    [97.5, 40, -2000], [98.2, 40, -1000], [98.9, 40, 0], [98.7, 40, 1000], [98.5, 40, 2000], [98.4, 40, 3000], [98.4, 40, 4000], [98.5, 40, 5000], [98.4, 40, 6000],
    [98.4, 40, 7000], [97.9, 40, 8000], [97.3, 40, 9000], [96.7, 40, 10000],
    [97.8, 35, -2000], [98.9, 35, -1000], [99.8, 35, 0], [99.7, 35, 1000], [99.7, 35, 2000], [99.5, 35, 3000], [99.3, 35, 4000], [99.3, 35, 5000], [99.2, 35, 6000],
    [99.3, 35, 7000], [98.8, 35, 8000], [98.4, 35, 9000], [98, 35, 10000],
    [97.2, 30, -2000], [98.8, 30, -1000], [100.4, 30, 0], [100.4, 30, 1000], [100.4, 30, 2000], [100.4, 30, 3000], [100.4, 30, 4000], [100.1, 30, 5000], [100, 30, 6000],
    [99.9, 30, 7000], [99.5, 30, 8000], [99.2, 30, 9000], [98.8, 30, 10000],
    [96.4, 25, -2000], [98, 25, -1000], [99.6, 25, 0], [100.1, 25, 1000], [100.7, 25, 2000], [101.1, 25, 3000], [101.1, 25, 4000], [101.1, 25, 5000], [101.7, 25, 6000],
    [101.3, 25, 7000], [100.3, 25, 8000], [99.9, 25, 9000], [99.5, 25, 10000],
    [95.6, 20, -2000], [97.2, 20, -1000], [98.8, 20, 0], [99.3, 20, 1000], [99.9, 20, 2000], [100.5, 20, 3000], [101.1, 20, 4000], [101.8, 20, 5000], [102.2, 20, 6000],
    [102.4, 20, 7000], [102.1, 20, 8000], [101.5, 20, 9000], [100.3, 20, 10000],
    [94.8, 15, -2000], [96.3, 15, -1000], [97.9, 15, 0], [98.4, 15, 1000], [99, 15, 2000], [99.6, 15, 3000], [100.2, 15, 4000], [101, 15, 5000], [101.7, 15, 6000],
    [102.5, 15, 7000], [102.5, 15, 8000], [102.2, 15, 9000], [101.2, 15, 10000],
    [93.9, 10, -2000], [95.5, 10, -1000], [97.1, 10, 0], [97.6, 10, 1000], [98.2, 10, 2000], [98.8, 10, 3000], [99.4, 10, 4000], [100.1, 10, 5000], [100.8, 10, 6000],
    [101.6, 10, 7000], [101.8, 10, 8000], [102, 10, 9000], [102.3, 10, 10000],
    [93.1, 5, -2000], [94.7, 5, -1000], [96.2, 5, 0], [96.7, 5, 1000], [97.3, 5, 2000], [97.9, 5, 3000], [98.5, 5, 4000], [99.2, 5, 5000], [99.9, 5, 6000], [100.7, 5, 7000],
    [100.9, 5, 8000], [101.2, 5, 9000], [101.4, 5, 10000],
    [92.3, 0, -2000], [93.8, 0, -1000], [95.3, 0, 0], [95.8, 0, 1000], [96.4, 0, 2000], [97, 0, 3000], [97.6, 0, 4000], [98.3, 0, 5000], [99.1, 0, 6000], [99.8, 0, 7000],
    [100, 0, 8000], [100.3, 0, 9000], [100.6, 0, 10000],
    [90.6, -10, -2000], [92.1, -10, -1000], [93.6, -10, 0], [94.1, -10, 1000], [94.6, -10, 2000], [95.2, -10, 3000], [95.9, -10, 4000], [96.6, -10, 5000], [97.3, -10, 6000],
    [98, -10, 7000], [98.3, -10, 8000], [98.5, -10, 9000], [98.8, -10, 10000],
    [88.8, -20, -2000], [90.3, -20, -1000], [91.8, -20, 0], [92.3, -20, 1000], [92.8, -20, 2000], [93.4, -20, 3000], [94.1, -20, 4000], [94.8, -20, 5000], [95.5, -20, 6000],
    [96.3, -20, 7000], [96.5, -20, 8000], [96.7, -20, 9000], [97, -20, 10000],
    [87, -30, -2000], [88.5, -30, -1000], [89.9, -30, 0], [90.4, -30, 1000], [91, -30, 2000], [91.6, -30, 3000], [92.3, -30, 4000], [93, -30, 5000], [93.7, -30, 6000],
    [94.4, -30, 7000], [94.7, -30, 8000], [94.9, -30, 9000], [95.2, -30, 10000],
    [85.2, -40, -2000], [86.7, -40, -1000], [88.1, -40, 0], [88.6, -40, 1000], [89.1, -40, 2000], [89.8, -40, 3000], [90.5, -40, 4000], [91.2, -40, 5000], [91.9, -40, 6000],
    [92.6, -40, 7000], [92.8, -40, 8000], [93.1, -40, 9000], [93.4, -40, 10000],
    [83.4, -50, -2000], [84.8, -50, -1000], [86.2, -50, 0], [86.7, -50, 1000], [87.3, -50, 2000], [87.9, -50, 3000], [88.6, -50, 4000], [89.3, -50, 5000], [90, -50, 6000],
    [90.7, -50, 7000], [91, -50, 8000], [91.2, -50, 9000], [91.5, -50, 10000]
]);
B748EngineData.to1_n1_max = new LerpLookupTable([
    [86, 70, -2000], [86.5, 70, -1000], [86.9, 70, 0], [86.9, 70, 1000], [86.8, 70, 2000], [86.8, 70, 3000], [86.7, 70, 4000],
    [86.6, 70, 5000], [86.6, 70, 6000], [86.6, 70, 7000], [86.1, 70, 8000], [85.9, 70, 9000], [86, 70, 10000],
    [88.7, 60, -2000], [89.1, 60, -1000], [89.6, 60, 0], [89.6, 60, 1000], [89.5, 60, 2000], [89.5, 60, 3000], [89.4, 60, 4000],
    [89.3, 60, 5000], [89.3, 60, 6000], [89.3, 60, 7000], [88.8, 60, 8000], [88.2, 60, 9000], [87.6, 60, 10000],
    [90, 55, -2000], [90.5, 55, -1000], [90.9, 55, 0], [90.9, 55, 1000], [90.9, 55, 2000], [90.8, 55, 3000], [90.7, 55, 4000],
    [90.7, 55, 5000], [90.7, 55, 6000], [90.6, 55, 7000], [90.1, 55, 8000], [89.5, 55, 9000], [89, 55, 10000],
    [91.3, 50, -2000], [91.8, 50, -1000], [92.2, 50, 0], [92.1, 50, 1000], [92.1, 50, 2000], [92.1, 50, 3000], [92, 50, 4000],
    [92, 50, 5000], [92, 50, 6000], [91.9, 50, 7000], [91.4, 50, 8000], [90.8, 50, 9000], [90.3, 50, 10000],
    [92.6, 45, -2000], [93.1, 45, -1000], [93.5, 45, 0], [93.4, 45, 1000], [93.4, 45, 2000], [93.3, 45, 3000], [93.3, 45, 4000],
    [93.2, 45, 5000], [93.2, 45, 6000], [93.2, 45, 7000], [92.7, 45, 8000], [92.1, 45, 9000], [91.5, 45, 10000],
    [93.5, 40, -2000], [94.3, 40, -1000], [94.9, 40, 0], [94.7, 40, 1000], [94.5, 40, 2000], [94.5, 40, 3000], [94.5, 40, 4000],
    [94.5, 40, 5000], [94.4, 40, 6000], [94.4, 40, 7000], [93.9, 40, 8000], [93.4, 40, 9000], [92.8, 40, 10000],
    [93.9, 35, -2000], [94.8, 35, -1000], [95.6, 35, 0], [95.5, 35, 1000], [95.5, 35, 2000], [95.3, 35, 3000], [95.2, 35, 4000],
    [95.1, 35, 5000], [95.1, 35, 6000], [95.1, 35, 7000], [94.8, 35, 8000], [94.4, 35, 9000], [94, 35, 10000],
    [93.3, 30, -2000], [94.7, 30, -1000], [96.1, 30, 0], [96, 30, 1000], [96, 30, 2000], [96, 30, 3000], [96, 30, 4000],
    [95.8, 30, 5000], [95.7, 30, 6000], [95.6, 30, 7000], [95.3, 30, 8000], [95, 30, 9000], [94.7, 30, 10000],
    [92.5, 25, -2000], [93.9, 25, -1000], [95.3, 25, 0], [95.7, 25, 1000], [96.2, 25, 2000], [96.5, 25, 3000],
    [96.6, 25, 4000], [96.6, 25, 5000], [97, 25, 6000], [96.7, 25, 7000], [95.9, 25, 8000], [95.5, 25, 9000], [95.2, 25, 10000],
    [91.7, 20, -2000], [93.1, 20, -1000], [94.5, 20, 0], [94.9, 20, 1000], [95.4, 20, 2000], [95.9, 20, 3000],
    [96.3, 20, 4000], [96.8, 20, 5000], [97, 20, 6000], [97.1, 20, 7000], [97, 20, 8000], [96.6, 20, 9000], [95.7, 20, 10000],
    [90.9, 15, -2000], [92.3, 15, -1000], [93.6, 15, 0], [94.1, 15, 1000], [94.6, 15, 2000], [95.1, 15, 3000],
    [95.5, 15, 4000], [96, 15, 5000], [96.4, 15, 6000], [96.9, 15, 7000], [96.9, 15, 8000], [96.7, 15, 9000], [96.1, 15, 10000],
    [90.1, 10, -2000], [91.5, 10, -1000], [92.8, 10, 0], [93.3, 10, 1000], [93.8, 10, 2000], [94.3, 10, 3000],
    [94.7, 10, 4000], [95.1, 10, 5000], [95.6, 10, 6000], [96, 10, 7000], [96.2, 10, 8000], [96.3, 10, 9000],
    [96.5, 10, 10000], [89.3, 5, -2000], [90.7, 5, -1000], [92, 5, 0], [92.5, 5, 1000], [93, 5, 2000], [93.4, 5, 3000],
    [93.8, 5, 4000], [94.3, 5, 5000], [94.7, 5, 6000], [95.2, 5, 7000], [95.3, 5, 8000], [95.5, 5, 9000], [95.6, 5, 10000],
    [88.5, 0, -2000], [89.9, 0, -1000], [91.2, 0, 0], [91.6, 0, 1000], [92.1, 0, 2000], [92.6, 0, 3000], [93, 0, 4000],
    [93.4, 0, 5000], [93.9, 0, 6000], [94.3, 0, 7000], [94.5, 0, 8000], [94.6, 0, 9000], [94.8, 0, 10000],
    [86.9, -10, -2000], [88.2, -10, -1000], [89.5, -10, 0], [89.9, -10, 1000], [90.4, -10, 2000], [90.9, -10, 3000],
    [91.3, -10, 4000], [91.8, -10, 5000], [92.2, -10, 6000], [92.6, -10, 7000], [92.8, -10, 8000], [92.9, -10, 9000], [93.1, -10, 10000],
    [85.2, -20, -2000], [86.5, -20, -1000], [87.8, -20, 0], [88.2, -20, 1000], [88.7, -20, 2000], [89.2, -20, 3000],
    [89.6, -20, 4000], [90, -20, 5000], [90.5, -20, 6000], [90.9, -20, 7000], [91.1, -20, 8000], [91.2, -20, 9000], [91.4, -20, 10000],
    [83.5, -30, -2000], [84.8, -30, -1000], [86, -30, 0], [86.4, -30, 1000], [86.9, -30, 2000], [87.4, -30, 3000],
    [87.9, -30, 4000], [88.3, -30, 5000], [88.7, -30, 6000], [89.2, -30, 7000], [89.3, -30, 8000], [89.5, -30, 9000], [89.6, -30, 10000],
    [81.8, -40, -2000], [83, -40, -1000], [84.2, -40, 0], [84.7, -40, 1000], [85.1, -40, 2000], [85.7, -40, 3000],
    [86.1, -40, 4000], [86.5, -40, 5000], [87, -40, 6000], [87.4, -40, 7000], [87.6, -40, 8000], [87.7, -40, 9000], [87.9, -40, 10000],
    [80, -50, -2000], [81.2, -50, -1000], [82.4, -50, 0], [82.9, -50, 1000], [83.4, -50, 2000], [83.9, -50, 3000],
    [84.3, -50, 4000], [84.7, -50, 5000], [85.2, -50, 6000], [85.6, -50, 7000], [85.7, -50, 8000], [85.9, -50, 9000], [86.1, -50, 10000]
]);
B748EngineData.to2_n1_max = new LerpLookupTable([
    [85.9, 70, -2000], [85.9, 70, -1000], [85.9, 70, 0], [85.9, 70, 1000], [85.9, 70, 2000], [85.9, 70, 3000], [85.9, 70, 4000],
    [85.9, 70, 5000], [85.9, 70, 6000], [85.9, 70, 7000], [85.9, 70, 8000], [85.9, 70, 9000], [86, 70, 10000],
    [84.7, 60, -2000], [85.1, 60, -1000], [85.5, 60, 0], [85.5, 60, 1000], [85.5, 60, 2000], [85.4, 60, 3000], [85.3, 60, 4000],
    [85.3, 60, 5000], [85.3, 60, 6000], [85.2, 60, 7000], [84.7, 60, 8000], [84.7, 60, 9000], [84.7, 60, 10000],
    [85.9, 55, -2000], [86.4, 55, -1000], [86.8, 55, 0], [86.7, 55, 1000], [86.7, 55, 2000], [86.7, 55, 3000], [86.6, 55, 4000],
    [86.5, 55, 5000], [86.5, 55, 6000], [86.5, 55, 7000], [86, 55, 8000], [85.5, 55, 9000], [84.9, 55, 10000],
    [87.1, 50, -2000], [87.6, 50, -1000], [88.1, 50, 0], [88, 50, 1000], [88, 50, 2000], [87.9, 50, 3000], [87.8, 50, 4000],
    [87.8, 50, 5000], [87.8, 50, 6000], [87.8, 50, 7000], [87.2, 50, 8000], [86.7, 50, 9000], [86.1, 50, 10000],
    [88.4, 45, -2000], [88.9, 45, -1000], [89.3, 45, 0], [89.2, 45, 1000], [89.1, 45, 2000], [89.1, 45, 3000], [89.1, 45, 4000],
    [89, 45, 5000], [89, 45, 6000], [89, 45, 7000], [88.5, 45, 8000], [87.9, 45, 9000], [87.4, 45, 10000],
    [89.3, 40, -2000], [90, 40, -1000], [90.6, 40, 0], [90.4, 40, 1000], [90.2, 40, 2000], [90.2, 40, 3000], [90.2, 40, 4000],
    [90.2, 40, 5000], [90.1, 40, 6000], [90.2, 40, 7000], [89.7, 40, 8000], [89.1, 40, 9000], [88.6, 40, 10000],
    [89.6, 35, -2000], [90.5, 35, -1000], [91.2, 35, 0], [91.2, 35, 1000], [91.2, 35, 2000], [91, 35, 3000], [90.9, 35, 4000],
    [90.8, 35, 5000], [90.8, 35, 6000], [90.8, 35, 7000], [90.5, 35, 8000], [90.1, 35, 9000], [89.8, 35, 10000],
    [89.1, 30, -2000], [90.4, 30, -1000], [91.7, 30, 0], [91.7, 30, 1000], [91.7, 30, 2000], [91.7, 30, 3000],
    [91.7, 30, 4000], [91.4, 30, 5000], [91.4, 30, 6000], [91.3, 30, 7000], [91, 30, 8000], [90.7, 30, 9000], [90.4, 30, 10000],
    [88.3, 25, -2000], [89.6, 25, -1000], [90.9, 25, 0], [91.4, 25, 1000], [91.9, 25, 2000], [92.1, 25, 3000],
    [92.2, 25, 4000], [92.2, 25, 5000], [92.6, 25, 6000], [92.4, 25, 7000], [91.5, 25, 8000], [91.2, 25, 9000], [90.9, 25, 10000],
    [87.6, 20, -2000], [88.9, 20, -1000], [90.2, 20, 0], [90.6, 20, 1000], [91.1, 20, 2000], [91.6, 20, 3000],
    [91.9, 20, 4000], [92.4, 20, 5000], [92.5, 20, 6000], [92.7, 20, 7000], [92.5, 20, 8000], [92.2, 20, 9000], [91.4, 20, 10000],
    [86.8, 15, -2000], [88.1, 15, -1000], [89.4, 15, 0], [89.8, 15, 1000], [90.3, 15, 2000], [90.8, 15, 3000],
    [91.1, 15, 4000], [91.6, 15, 5000], [92, 15, 6000], [92.4, 15, 7000], [92.4, 15, 8000], [92.3, 15, 9000], [91.7, 15, 10000],
    [86.1, 10, -2000], [87.4, 10, -1000], [88.6, 10, 0], [89.1, 10, 1000], [89.5, 10, 2000], [90, 10, 3000],
    [90.4, 10, 4000], [90.8, 10, 5000], [91.2, 10, 6000], [91.6, 10, 7000], [91.7, 10, 8000], [91.8, 10, 9000], [92, 10, 10000],
    [85.3, 5, -2000], [86.6, 5, -1000], [87.8, 5, 0], [88.3, 5, 1000], [88.8, 5, 2000], [89.2, 5, 3000], [89.6, 5, 4000],
    [90, 5, 5000], [90.4, 5, 6000], [90.8, 5, 7000], [90.9, 5, 8000], [91, 5, 9000], [91.2, 5, 10000],
    [84.5, 0, -2000], [85.8, 0, -1000], [87, 0, 0], [87.5, 0, 1000], [87.9, 0, 2000], [88.4, 0, 3000],
    [88.8, 0, 4000], [89.2, 0, 5000], [89.6, 0, 6000], [90, 0, 7000], [90.1, 0, 8000], [90.2, 0, 9000], [90.4, 0, 10000],
    [83, -10, -2000], [84.2, -10, -1000], [85.4, -10, 0], [85.9, -10, 1000], [86.3, -10, 2000], [86.8, -10, 3000],
    [87.1, -10, 4000], [87.6, -10, 5000], [88, -10, 6000], [88.4, -10, 7000], [88.5, -10, 8000], [88.6, -10, 9000], [88.8, -10, 10000],
    [81.4, -20, -2000], [82.6, -20, -1000], [83.8, -20, 0], [84.2, -20, 1000], [84.7, -20, 2000], [85.1, -20, 3000],
    [85.5, -20, 4000], [85.9, -20, 5000], [86.3, -20, 6000], [86.7, -20, 7000], [86.8, -20, 8000], [87, -20, 9000], [87.1, -20, 10000],
    [79.8, -30, -2000], [81, -30, -1000], [82.1, -30, 0], [82.5, -30, 1000], [83, -30, 2000], [83.5, -30, 3000],
    [83.9, -30, 4000], [84.3, -30, 5000], [84.6, -30, 6000], [85, -30, 7000], [85.2, -30, 8000], [85.3, -30, 9000], [85.5, -30, 10000],
    [78.1, -40, -2000], [79.3, -40, -1000], [80.4, -40, 0], [80.8, -40, 1000], [81.3, -40, 2000], [81.8, -40, 3000],
    [82.2, -40, 4000], [82.6, -40, 5000], [83, -40, 6000], [83.4, -40, 7000], [83.5, -40, 8000], [83.6, -40, 9000], [83.8, -40, 10000],
    [76.4, -50, -2000], [77.6, -50, -1000], [78.7, -50, 0], [79.1, -50, 1000], [79.6, -50, 2000], [80.1, -50, 3000],
    [80.5, -50, 4000], [80.8, -50, 5000], [81.2, -50, 6000], [81.6, -50, 7000], [81.7, -50, 8000], [81.9, -50, 9000], [82, -50, 10000]
]);
B748EngineData.ga_n1_max = new LerpLookupTable([
    [85.9, 74, 0], [86.7, 74, 1000], [87.5, 74, 2000], [88.3, 74, 3000], [88.7, 74, 4000], [89.1, 74, 5000],
    [89.4, 74, 6000], [89.8, 74, 7000], [89.9, 74, 8000], [89.6, 74, 9000], [89, 74, 10000],
    [87.9, 64, 0], [88.8, 64, 1000], [89.7, 64, 2000], [90.7, 64, 3000], [91.2, 64, 4000], [91.7, 64, 5000],
    [92.1, 64, 6000], [92.5, 64, 7000], [92.7, 64, 8000], [92.4, 64, 9000], [91.8, 64, 10000],
    [88.8, 59, 0], [89.8, 59, 1000], [90.8, 59, 2000], [91.8, 59, 3000], [92.4, 59, 4000], [93, 59, 5000],
    [93.4, 59, 6000], [93.9, 59, 7000], [94.1, 59, 8000], [93.8, 59, 9000], [93.2, 59, 10000],
    [90.2, 54, 0], [90.9, 54, 1000], [91.9, 54, 2000], [92.9, 54, 3000], [93.6, 54, 4000], [94.2, 54, 5000],
    [94.6, 54, 6000], [95.1, 54, 7000], [95.4, 54, 8000], [95.1, 54, 9000], [94.5, 54, 10000],
    [91.5, 49, 0], [92.3, 49, 1000], [93.2, 49, 2000], [94.2, 49, 3000], [94.8, 49, 4000], [95.3, 49, 5000],
    [95.9, 49, 6000], [96.4, 49, 7000], [96.7, 49, 8000], [96.4, 49, 9000], [95.8, 49, 10000],
    [92.8, 44, 0], [93.6, 44, 1000], [94.5, 44, 2000], [95.4, 44, 3000], [96, 44, 4000], [96.6, 44, 5000],
    [97.1, 44, 6000], [97.6, 44, 7000], [98, 44, 8000], [97.7, 44, 9000], [97.1, 44, 10000],
    [94.2, 39, 0], [94.9, 39, 1000], [95.8, 39, 2000], [96.8, 39, 3000], [97.2, 39, 4000], [97.7, 39, 5000],
    [98.3, 39, 6000], [99, 39, 7000], [99, 39, 8000], [98.8, 39, 9000], [98.3, 39, 10000],
    [94.8, 34, 0], [95.7, 34, 1000], [96.6, 34, 2000], [97.6, 34, 3000], [98.2, 34, 4000], [98.7, 34, 5000],
    [99.2, 34, 6000], [99.7, 34, 7000], [99.9, 34, 8000], [99.5, 34, 9000], [99.2, 34, 10000],
    [94.1, 29, 0], [95.5, 29, 1000], [97, 29, 2000], [98.1, 29, 3000], [98.7, 29, 4000], [99.2, 29, 5000],
    [100.3, 29, 6000], [100.8, 29, 7000], [100.7, 29, 8000], [100.3, 29, 9000], [99.9, 29, 10000],
    [93.3, 24, 0], [94.7, 24, 1000], [96.2, 24, 2000], [97.7, 24, 3000], [98.9, 24, 4000], [100.1, 24, 5000],
    [100.9, 24, 6000], [101.7, 24, 7000], [102.2, 24, 8000], [101.6, 24, 9000], [100.7, 24, 10000],
    [92.5, 19, 0], [93.9, 19, 1000], [95.4, 19, 2000], [96.8, 19, 3000], [98, 19, 4000], [99.3, 19, 5000],
    [100.7, 19, 6000], [102.4, 19, 7000], [102.9, 19, 8000], [102.4, 19, 9000], [101.6, 19, 10000],
    [91.7, 14, 0], [93.1, 14, 1000], [94.5, 14, 2000], [96, 14, 3000], [97.2, 14, 4000], [98.5, 14, 5000],
    [99.8, 14, 6000], [101.5, 14, 7000], [102.5, 14, 8000], [102.5, 14, 9000], [102.5, 14, 10000],
    [90.8, 8, 0], [92.1, 8, 1000], [93.5, 8, 2000], [95, 8, 3000], [96.2, 8, 4000], [97.4, 8, 5000], [98.8, 8, 6000],
    [100.4, 8, 7000], [101.4, 8, 8000], [101.4, 8, 9000], [101.5, 8, 10000],
    [90, 3, 0], [91.3, 3, 1000], [92.7, 3, 2000], [94.2, 3, 3000], [95.3, 3, 4000], [96.6, 3, 5000], [97.9, 3, 6000],
    [99.6, 3, 7000], [100.5, 3, 8000], [100.5, 3, 9000], [100.7, 3, 10000],
    [88.3, -7, 0], [89.6, -7, 1000], [91, -7, 2000], [92.4, -7, 3000], [93.6, -7, 4000], [94.9, -7, 5000],
    [96.2, -7, 6000], [97.8, -7, 7000], [98.8, -7, 8000], [98.8, -7, 9000], [98.9, -7, 10000],
    [86.6, -17, 0], [87.9, -17, 1000], [89.3, -17, 2000], [90.7, -17, 3000], [91.9, -17, 4000],
    [93.2, -17, 5000], [94.5, -17, 6000], [96.1, -17, 7000], [97, -17, 8000], [97, -17, 9000], [97.1, -17, 10000],
    [84.9, -27, 0], [86.2, -27, 1000], [87.6, -27, 2000], [89, -27, 3000], [90.2, -27, 4000], [91.4, -27, 5000],
    [92.7, -27, 6000], [94.3, -27, 7000], [95.2, -27, 8000], [95.2, -27, 9000], [95.3, -27, 10000],
    [83.2, -37, 0], [84.4, -37, 1000], [85.8, -37, 2000], [87.2, -37, 3000], [88.5, -37, 4000], [89.7, -37, 5000],
    [90.9, -37, 6000], [92.5, -37, 7000], [93.4, -37, 8000], [93.4, -37, 9000], [93.5, -37, 10000],
    [81.4, -47, 0], [82.7, -47, 1000], [84, -47, 2000], [85.5, -47, 3000], [86.7, -47, 4000], [87.9, -47, 5000],
    [89.1, -47, 6000], [90.6, -47, 7000], [91.5, -47, 8000], [91.6, -47, 9000], [91.7, -47, 10000]
]);
B748EngineData.clb_n1_max = new LerpLookupTable([
    [91, 60, 0], [91.6, 60, 5000], [92.9, 60, 10000], [94.1, 60, 15000], [96.1, 60, 20000], [97.6, 60, 25000], [99.8, 60, 30000], [101.2, 60, 35000],
    [101.5, 60, 40000], [100.7, 60, 45000], [92.8, 50, 0], [93.2, 50, 5000], [93.8, 50, 10000], [93.1, 50, 15000], [94.7, 50, 20000], [96.2, 50, 25000],
    [98.3, 50, 30000], [99.7, 50, 35000], [100, 50, 40000], [99.2, 50, 45000], [94.2, 40, 0], [95, 40, 5000], [95.4, 40, 10000], [94.8, 40, 15000], [95, 40, 20000],
    [94.9, 40, 25000], [96.7, 40, 30000], [98.2, 40, 35000], [98.4, 40, 40000], [97.7, 40, 45000], [92.7, 30, 0], [95.5, 30, 5000], [97, 30, 10000], [96.4, 30, 15000],
    [96.6, 30, 20000], [96.5, 30, 25000], [95.2, 30, 30000], [96.6, 30, 35000], [96.8, 30, 40000], [96.1, 30, 45000], [91.2, 20, 0], [93.9, 20, 5000], [96.6, 20, 10000],
    [97.9, 20, 15000], [98.2, 20, 20000], [98, 20, 25000], [96.9, 20, 30000], [95.5, 20, 35000], [95.2, 20, 40000], [94.5, 20, 45000], [90.4, 15, 0], [93.1, 15, 5000],
    [95.8, 15, 10000], [97.3, 15, 15000], [99, 15, 20000], [98.9, 15, 25000], [97.8, 15, 30000], [96.5, 15, 35000], [95.9, 15, 40000], [95.2, 15, 45000], [89.6, 10, 0],
    [92.3, 10, 5000], [95, 10, 10000], [96.5, 10, 15000], [98.7, 10, 20000], [99.7, 10, 25000], [98.7, 10, 30000], [97.6, 10, 35000], [97, 10, 40000], [96.3, 10, 45000],
    [88.8, 5, 0], [91.5, 5, 5000], [94.1, 5, 10000], [95.6, 5, 15000], [97.9, 5, 20000], [99.6, 5, 25000], [99.7, 5, 30000], [98.6, 5, 35000], [98, 5, 40000], [97.3, 5, 45000],
    [88, 0, 0], [90.7, 0, 5000], [93.3, 0, 10000], [94.8, 0, 15000], [97, 0, 20000], [98.7, 0, 25000], [100.8, 0, 30000], [99.6, 0, 35000], [99, 0, 40000], [98.3, 0, 45000],
    [87.2, -5, 0], [89.8, -5, 5000], [92.4, -5, 10000], [93.9, -5, 15000], [96.1, -5, 20000], [97.8, -5, 25000], [101.1, -5, 30000], [100.8, -5, 35000], [100, -5, 40000],
    [99.3, -5, 45000], [86.4, -10, 0], [89, -10, 5000], [91.5, -10, 10000], [93, -10, 15000], [95.2, -10, 20000], [96.8, -10, 25000], [100.2, -10, 30000], [101.4, -10, 35000],
    [100.9, -10, 40000], [100.3, -10, 45000], [85.5, -15, 0], [88.1, -15, 5000], [90.7, -15, 10000], [92.1, -15, 15000], [94.3, -15, 20000], [95.9, -15, 25000],
    [99.2, -15, 30000], [101, -15, 35000], [100.9, -15, 40000], [100.8, -15, 45000], [84.7, -20, 0], [87.3, -20, 5000], [89.8, -20, 10000], [91.2, -20, 15000], [93.4, -20, 20000],
    [95, -20, 25000], [98.3, -20, 30000], [100, -20, 35000], [99.9, -20, 40000], [99.9, -20, 45000], [83.9, -25, 0], [86.4, -25, 5000], [88.9, -25, 10000], [90.3, -25, 15000],
    [92.4, -25, 20000], [94, -25, 25000], [97.3, -25, 30000], [99, -25, 35000], [98.9, -25, 40000], [98.9, -25, 45000], [83, -30, 0], [85.5, -30, 5000], [88, -30, 10000],
    [89.4, -30, 15000], [91.5, -30, 20000], [93.1, -30, 25000], [96.3, -30, 30000], [98, -30, 35000], [97.9, -30, 40000], [97.9, -30, 45000], [82.2, -35, 0], [84.7, -35, 5000],
    [87.1, -35, 10000], [88.5, -35, 15000], [90.6, -35, 20000], [92.1, -35, 25000], [95.3, -35, 30000], [97, -35, 35000], [96.9, -35, 40000], [96.8, -35, 45000], [81.3, -40, 0],
    [83.8, -40, 5000], [86.2, -40, 10000], [87.5, -40, 15000], [89.6, -40, 20000], [91.2, -40, 25000], [94.3, -40, 30000], [96, -40, 35000], [95.9, -40, 40000], [95.8, -40, 45000]
]);
B748EngineData.cru_n1_max = new LerpLookupTable([
    [91, 60, 0], [91.6, 60, 5000], [92.9, 60, 10000], [94.1, 60, 15000], [96.1, 60, 20000], [97.6, 60, 25000], [99.8, 60, 30000], [101.2, 60, 35000],
    [101.5, 60, 40000], [100.7, 60, 45000], [92.8, 50, 0], [93.2, 50, 5000], [93.8, 50, 10000], [93.1, 50, 15000], [94.7, 50, 20000], [96.2, 50, 25000],
    [98.3, 50, 30000], [99.7, 50, 35000], [100, 50, 40000], [99.2, 50, 45000], [94.2, 40, 0], [95, 40, 5000], [95.4, 40, 10000], [94.8, 40, 15000], [95, 40, 20000],
    [94.9, 40, 25000], [96.7, 40, 30000], [98.2, 40, 35000], [98.4, 40, 40000], [97.7, 40, 45000], [92.7, 30, 0], [95.5, 30, 5000], [97, 30, 10000], [96.4, 30, 15000],
    [96.6, 30, 20000], [96.5, 30, 25000], [95.2, 30, 30000], [96.6, 30, 35000], [96.8, 30, 40000], [96.1, 30, 45000], [91.2, 20, 0], [93.9, 20, 5000], [96.6, 20, 10000],
    [97.9, 20, 15000], [98.2, 20, 20000], [98, 20, 25000], [96.9, 20, 30000], [95.5, 20, 35000], [95.2, 20, 40000], [94.5, 20, 45000], [90.4, 15, 0], [93.1, 15, 5000],
    [95.8, 15, 10000], [97.3, 15, 15000], [99, 15, 20000], [98.9, 15, 25000], [97.8, 15, 30000], [96.5, 15, 35000], [95.9, 15, 40000], [95.2, 15, 45000], [89.6, 10, 0],
    [92.3, 10, 5000], [95, 10, 10000], [96.5, 10, 15000], [98.7, 10, 20000], [99.7, 10, 25000], [98.7, 10, 30000], [97.6, 10, 35000], [97, 10, 40000], [96.3, 10, 45000],
    [88.8, 5, 0], [91.5, 5, 5000], [94.1, 5, 10000], [95.6, 5, 15000], [97.9, 5, 20000], [99.6, 5, 25000], [99.7, 5, 30000], [98.6, 5, 35000], [98, 5, 40000], [97.3, 5, 45000],
    [88, 0, 0], [90.7, 0, 5000], [93.3, 0, 10000], [94.8, 0, 15000], [97, 0, 20000], [98.7, 0, 25000], [100.8, 0, 30000], [99.6, 0, 35000], [99, 0, 40000], [98.3, 0, 45000],
    [87.2, -5, 0], [89.8, -5, 5000], [92.4, -5, 10000], [93.9, -5, 15000], [96.1, -5, 20000], [97.8, -5, 25000], [101.1, -5, 30000], [100.8, -5, 35000], [100, -5, 40000],
    [99.3, -5, 45000], [86.4, -10, 0], [89, -10, 5000], [91.5, -10, 10000], [93, -10, 15000], [95.2, -10, 20000], [96.8, -10, 25000], [100.2, -10, 30000], [101.4, -10, 35000],
    [100.9, -10, 40000], [100.3, -10, 45000], [85.5, -15, 0], [88.1, -15, 5000], [90.7, -15, 10000], [92.1, -15, 15000], [94.3, -15, 20000], [95.9, -15, 25000],
    [99.2, -15, 30000], [101, -15, 35000], [100.9, -15, 40000], [100.8, -15, 45000], [84.7, -20, 0], [87.3, -20, 5000], [89.8, -20, 10000], [91.2, -20, 15000], [93.4, -20, 20000],
    [95, -20, 25000], [98.3, -20, 30000], [100, -20, 35000], [99.9, -20, 40000], [99.9, -20, 45000], [83.9, -25, 0], [86.4, -25, 5000], [88.9, -25, 10000], [90.3, -25, 15000],
    [92.4, -25, 20000], [94, -25, 25000], [97.3, -25, 30000], [99, -25, 35000], [98.9, -25, 40000], [98.9, -25, 45000], [83, -30, 0], [85.5, -30, 5000], [88, -30, 10000],
    [89.4, -30, 15000], [91.5, -30, 20000], [93.1, -30, 25000], [96.3, -30, 30000], [98, -30, 35000], [97.9, -30, 40000], [97.9, -30, 45000], [82.2, -35, 0], [84.7, -35, 5000],
    [87.1, -35, 10000], [88.5, -35, 15000], [90.6, -35, 20000], [92.1, -35, 25000], [95.3, -35, 30000], [97, -35, 35000], [96.9, -35, 40000], [96.8, -35, 45000], [81.3, -40, 0],
    [83.8, -40, 5000], [86.2, -40, 10000], [87.5, -40, 15000], [89.6, -40, 20000], [91.2, -40, 25000], [94.3, -40, 30000], [96, -40, 35000], [95.9, -40, 40000], [95.8, -40, 45000]
]);
B748EngineData.max_con_n1 = new LerpLookupTable([
    [95.8, 30, 5000], [97.2, 30, 10000], [96.7, 30, 16000], [96.8, 30, 20000], [97.3, 30, 25000], [95, 30, 29000], [94.4, 30, 33000], [93.3, 30, 37000],
    [95.4, 20, 5000], [97.7, 20, 10000], [97.9, 20, 16000], [98.4, 20, 20000], [97.3, 20, 25000], [96.8, 20, 29000], [95.4, 20, 33000], [95.8, 20, 37000],
    [93.4, 10, 5000], [96.7, 10, 10000], [98.4, 10, 16000], [99.2, 10, 20000], [99, 10, 25000], [97.8, 10, 29000], [97.3, 10, 33000], [98.1, 10, 37000],
    [92.1, 0, 5000], [95, 0, 10000], [98.1, 0, 16000], [99.4, 0, 20000], [100, 0, 25000], [100.9, 0, 29000], [99.4, 0, 33000], [99.2, 0, 37000],
    [90.4, -10, 5000], [93.3, -10, 10000], [96.3, -10, 16000], [98.5, -10, 20000], [100.2, -10, 25000], [100.8, -10, 29000], [101, -10, 33000], [100.9, -10, 37000],
    [88.6, -20, 5000], [91.5, -20, 10000], [94.5, -20, 16000], [96.6, -20, 20000], [99.2, -20, 25000], [100.1, -20, 29000], [100.1, -20, 33000], [99.8, -20, 37000],
    [87.8, -30, 5000], [90.6, -30, 10000], [93.5, -30, 16000], [95.6, -30, 20000], [97.3, -30, 25000], [98.1, -30, 29000], [98.2, -30, 33000], [97.9, -30, 37000],
    [87.8, -40, 5000], [90.6, -40, 10000], [93.5, -40, 16000], [95.6, -40, 20000], [96.3, -40, 25000], [96, -40, 29000], [96.1, -40, 33000], [95.9, -40, 37000],
    [87.8, -50, 5000], [90.6, -50, 10000], [93.5, -50, 16000], [95.6, -50, 20000], [95.3, -50, 25000], [95, -50, 29000], [94.9, -50, 33000], [93.8, -50, 37000]
]);
B748EngineData.lrc_mach = new LerpLookupTable([
    // At weight 1014300/460t:
    [0.852, 1014300, 25000], [0.86, 1014300, 27000], [0.86, 1014300, 29000], [0.859, 1014300, 31000], [0.857, 1014300, 33000], [0.853, 1014300, 35000],
    [0.847, 1014300, 37000], [0.839, 1014300, 39000], [0.832, 1014300, 41000], [0.824, 1014300, 43000],
    // At weight 970200/440t:
    [0.845, 970200, 25000], [0.858, 970200, 27000], [0.86, 970200, 29000], [0.859, 970200, 31000], [0.857, 970200, 33000], [0.853, 970200, 35000],
    [0.848, 970200, 37000], [0.840, 970200, 39000], [0.833, 970200, 41000], [0.827, 970200, 43000],
    // At weight 926100/420t:
    [0.836, 926100, 25000], [0.852, 926100, 27000], [0.86, 926100, 29000], [0.86, 926100, 31000], [0.859, 926100, 33000], [0.857, 926100, 35000],
    [0.852, 926100, 37000], [0.846, 926100, 39000], [0.841, 926100, 41000], [0.837, 926100, 43000],
    // At weight 882000/400t:
    [0.827, 882000, 25000], [0.843, 882000, 27000], [0.858, 882000, 29000], [0.86, 882000, 31000], [0.859, 882000, 33000], [0.854, 882000, 35000],
    [0.854, 882000, 37000], [0.848, 882000, 39000], [0.844, 882000, 41000], [0.840, 882000, 43000],
    // At weight 837900/380t:
    [0.817, 837900, 25000], [0.834, 837900, 27000], [0.85, 837900, 29000], [0.859, 837900, 31000], [0.86, 837900, 33000], [0.859, 837900, 35000],
    [0.856, 837900, 37000], [0.853, 837900, 39000], [0.849, 837900, 41000], [0.841, 837900, 43000],
    // At weight 793800/360t:
    [0.805, 793800, 25000], [0.824, 793800, 27000], [0.84, 793800, 29000], [0.856, 793800, 31000], [0.86, 793800, 33000], [0.859, 793800, 35000],
    [0.856, 793800, 37000], [0.853, 793800, 39000], [0.849, 793800, 41000], [0.841, 793800, 43000],
    // At weight 749700/340t:
    [0.792, 749700, 25000], [0.812, 749700, 27000], [0.83, 749700, 29000], [0.846, 749700, 31000], [0.859, 749700, 33000], [0.86, 749700, 35000],
    [0.859, 749700, 37000], [0.849, 749700, 39000], [0.845, 749700, 41000], [0.841, 749700, 43000],
    // At weight 705600/320t:
    [0.776, 705600, 25000], [0.798, 705600, 27000], [0.818, 705600, 29000], [0.836, 705600, 31000], [0.852, 705600, 33000], [0.86, 705600, 35000],
    [0.859, 705600, 37000], [0.858, 705600, 39000], [0.854, 705600, 41000], [0.847, 705600, 43000],
    // At weight 661500/300t:
    [0.758, 661500, 25000], [0.782, 661500, 27000], [0.804, 661500, 29000], [0.823, 661500, 31000], [0.841, 661500, 33000], [0.857, 661500, 35000],
    [0.86, 661500, 37000], [0.859, 661500, 39000], [0.854, 661500, 41000], [0.849, 661500, 43000],
    // At weight 617400/280t:
    [0.737, 617400, 25000], [0.763, 617400, 27000], [0.787, 617400, 29000], [0.809, 617400, 31000], [0.828, 617400, 33000], [0.845, 617400, 35000],
    [0.859, 617400, 37000], [0.86, 617400, 39000], [0.859, 617400, 41000], [0.850, 617400, 43000],
    // At weight 529200/240t:
    [0.686, 529200, 25000], [0.716, 529200, 27000], [0.744, 529200, 29000], [0.771, 529200, 31000], [0.795, 529200, 33000], [0.816, 529200, 35000],
    [0.835, 529200, 37000], [0.852, 529200, 39000], [0.86, 529200, 41000], [0.859, 529200, 43000],
    // At weight 441000/200t:
    [0.626, 441000, 25000], [0.654, 441000, 27000], [0.684, 441000, 29000], [0.715, 441000, 31000], [0.744, 441000, 33000], [0.772, 441000, 35000],
    [0.797, 441000, 37000], [0.818, 441000, 39000], [0.837, 441000, 41000], [0.853, 441000, 43000]
]);
/** Output: Opt Altitude in Ft; Term 1: Weight in LBS */
B748EngineData.alt_opt = new LerpLookupTable([
    [29000, 1014125.2],
    [30000, 970032.8],
    [31000, 925940.4],
    [32100, 881848],
    [33200, 837755.6],
    [34300, 793663.2],
    [35500, 749570.8],
    [36800, 705478.4],
    [38100, 661386],
    [39600, 617293.6],
    [41100, 573201.2],
    [42800, 529108.8],
    [43100, 485016.4],
    [43100, 440924]
]);
/** Output: Max Altitude in Ft; Term 1: Weight in LBS; Term 2: ISA Tem Deviation in C */
B748EngineData.alt_max = new LerpLookupTable([
    [32500, 1014125.2, -100], [32500, 1014125.2, 10], [31300, 1014125.2, 15], [29600, 1014125.2, 20],
    [33700, 970032.8, -100], [33700, 970032.8, 10], [32800, 970032.8, 15], [31000, 970032.8, 20],
    [34800, 925940.4, -100], [34800, 925940.4, 10], [34100, 925940.4, 15], [32500, 925940.4, 20],
    [35800, 881848, -100], [35800, 881848, 10], [35500, 881848, 15], [33900, 881848, 20],
    [36800, 837755.6, -100], [36800, 837755.6, 10], [36600, 837755.6, 15], [35500, 837755.6, 20],
    [38000, 793663.2, -100], [38000, 793663.2, 10], [37700, 793663.2, 15], [36700, 793663.2, 20],
    [39200, 749570.8, -100], [39200, 749570.8, 10], [38800, 749570.8, 15], [37800, 749570.8, 20],
    [40400, 705478.4, -100], [40400, 705478.4, 10], [40000, 705478.4, 15], [38900, 705478.4, 20],
    [41700, 661386, -100], [41700, 661386, 10], [41200, 661386, 15], [40100, 661386, 20],
    [43100, 617293.6, -100], [43100, 617293.6, 10], [42400, 617293.6, 15], [41300, 617293.6, 20],
    [43100, 573201.2, -100], [43100, 573201.2, 10], [43100, 573201.2, 15], [42600, 573201.2, 20],
    [43100, 529108.8, -100], [43100, 529108.8, 10], [43100, 529108.8, 15], [43100, 529108.8, 20],
    [43100, 485016.4, -100], [43100, 485016.4, 10], [43100, 485016.4, 15], [43100, 485016.4, 20],
    [43100, 440924, -100], [43100, 440924, 10], [43100, 440924, 15], [43100, 440924, 20]
]);

/** B747-8i Performance Math Utility Class. */
class B748PerformanceMath extends BoeingPerformanceDataProvider {
    /** @inheritDoc */
    get operatingEmptyWeight() {
        return 467160; // 211,900 kg
    }
    /** @inheritDoc */
    get maxZeroFuelWeight() {
        return 651000; // 295,288 kg
    }
    /** @inheritDoc */
    get maxGrossWeight() {
        return 975000; // 442,252 kg
    }
    /** @inheritDoc */
    get maxReserveFuel() {
        return Number.MAX_SAFE_INTEGER; // TODO Replace with actual value
    }
    /** @inheritDoc */
    get fuelFreezeTemp() {
        return -37;
    }
    /** @inheritDoc */
    get minCenterOfGravity() {
        return 11;
    }
    /** @inheritDoc */
    get maxCenterOfGravity() {
        return 33;
    }
    /** @inheritdoc */
    getAircraftFlightModel() {
        return {
            wing_span: 224.57,
            wing_area: 5960,
            //From the lift_coef_aoa_table: the value at aoa_0.
            cl_cd: [[0.23, 0.018], [0.2764, 0.0533], [0.4554, 0.0644], [0.5659, 0.0778], [0.7648, 0.0994], [0.8747, 0.1144], [1.0926, 0.1237]],
            induced_drag_scalar: 1,
            oswald_efficiency_factor: 0.75,
            inlet_area: 60,
            low_idle_n1: 23.2,
            mach_influence_on_n1: 10,
            static_thrust: 66500,
            ThrustSpecificFuelConsumption: 0.27,
            n1_and_mach_on_thrust_table: new LerpLookupTable([
                [0, 0, 0], [0, 0.45, 0], [0, 0.9, 0],
                [0.053978, 0, 20], [0.034816, 0.45, 20], [0.080724, 0.9, 20],
                [0.072647, 0, 25], [0.042137, 0.45, 25], [0.153968, 0.9, 25],
                [0.092571, 0, 30], [0.055766, 0.45, 30], [0.352444, 0.9, 30],
                [0.114397, 0, 35], [0.087857, 0.45, 35], [0.382598, 0.9, 35],
                [0.133584, 0, 40], [0.129235, 0.45, 40], [0.401433, 0.9, 40],
                [0.163657, 0, 45], [0.179995, 0.45, 45], [0.424077, 0.9, 45],
                [0.201611, 0, 50], [0.227881, 0.45, 50], [0.453427, 0.9, 50],
                [0.247145, 0, 55], [0.284959, 0.45, 55], [0.489514, 0.9, 55],
                [0.306598, 0, 60], [0.357671, 0.45, 60], [0.526682, 0.9, 60],
                [0.404374, 0, 65], [0.458374, 0.45, 65], [0.565243, 0.9, 65],
                [0.472288, 0, 70], [0.53715, 0.45, 70], [0.610145, 0.9, 70],
                [0.543975, 0, 75], [0.608862, 0.45, 75], [0.67375, 0.9, 75],
                [0.628349, 0, 80], [0.697486, 0.45, 80], [0.766623, 0.9, 80],
                [0.735036, 0, 85], [0.796225, 0.45, 85], [0.857414, 0.9, 85],
                [0.837808, 0, 90], [0.906299, 0.45, 90], [0.97479, 0.9, 90],
                [0.956614, 0, 95], [1.020258, 0.45, 95], [1.083902, 0.9, 95],
                [1.090953, 0, 100], [1.156054, 0.45, 100], [1.221156, 0.9, 100],
                [1.234866, 0, 105], [1.296368, 0.45, 105], [1.35787, 0.9, 105],
                [1.325555, 0, 110], [1.380287, 0.45, 110], [1.43502, 0.9, 110]
            ]),
            thrust_and_mach_on_n1_table: new LerpLookupTable([
                [0, 0, 0], [0, 0.45, 0], [0, 0.9, 0],
                [20, 0, 0.053978], [20, 0.45, 0.034816], [20, 0.9, 0.080724],
                [25, 0, 0.072647], [25, 0.45, 0.042137], [25, 0.9, 0.153968],
                [30, 0, 0.092571], [30, 0.45, 0.055766], [30, 0.9, 0.352444],
                [35, 0, 0.114397], [35, 0.45, 0.087857], [35, 0.9, 0.382598],
                [40, 0, 0.133584], [40, 0.45, 0.129235], [40, 0.9, 0.401433],
                [45, 0, 0.163657], [45, 0.45, 0.179995], [45, 0.9, 0.424077],
                [50, 0, 0.201611], [50, 0.45, 0.227881], [50, 0.9, 0.453427],
                [55, 0, 0.247145], [55, 0.45, 0.284959], [55, 0.9, 0.489514],
                [60, 0, 0.306598], [60, 0.45, 0.357671], [60, 0.9, 0.526682],
                [65, 0, 0.404374], [65, 0.45, 0.458374], [65, 0.9, 0.565243],
                [70, 0, 0.472288], [70, 0.45, 0.53715], [70, 0.9, 0.610145],
                [75, 0, 0.543975], [75, 0.45, 0.608862], [75, 0.9, 0.67375],
                [80, 0, 0.628349], [80, 0.45, 0.697486], [80, 0.9, 0.766623],
                [85, 0, 0.735036], [85, 0.45, 0.796225], [85, 0.9, 0.857414],
                [90, 0, 0.837808], [90, 0.45, 0.906299], [90, 0.9, 0.97479],
                [95, 0, 0.956614], [95, 0.45, 1.020258], [95, 0.9, 1.083902],
                [100, 0, 1.090953], [100, 0.45, 1.156054], [100, 0.9, 1.221156],
                [105, 0, 1.234866], [105, 0.45, 1.296368], [105, 0.9, 1.35787],
                [110, 0, 1.325555], [110, 0.45, 1.380287], [110, 0.9, 1.43502]
            ]),
            corrected_airflow_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.9],
                [4.29, 20, 0], [14.081, 20, 0.9],
                [22, 85, 0], [24, 85, 0.9],
                [25, 90, 0], [25, 90, 0.9],
                [27, 95, 0], [27, 95, 0.9],
                [28, 100, 0], [28, 100, 0.9],
                [29, 105, 0], [29, 105, 0.9],
                [30, 110, 0], [30, 110, 0.9]
            ])
        };
    }
}

/* eslint-disable max-len */
/**
 * A provider of Boeing 747-8 reference airspeeds.
 */
class B748SpeedData extends AbstractBoeingSpeedProvider {
    /**
     * Creates a new instance of B748SpeedData.
     * @param bus The event bus.
     * @param engineDataProvider A provider of airplane engine data.
     */
    constructor(bus, engineDataProvider) {
        super(engineDataProvider);
        this.bus = bus;
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.pressureAlt.setConsumer(this.bus.getSubscriber().on('pressure_alt'));
    }
    /** @inheritdoc */
    getFlapManeuverSpeed(flapPos, weight, pressureAlt) {
        return B748SpeedData.flap_maneuver_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVrefSpeed(flapPos, weight, pressureAlt) {
        if (flapPos === 25 || flapPos === 30) {
            // the flap maneuver speeds for 25 and 30 are vref
            return this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
        }
        throw new Error('25 and 30 are the only valid 748 VREF flap positions');
    }
    /** @inheritdoc */
    getHoldingSpeed(flapPos, weight, pressureAlt) {
        return B748SpeedData.holding_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVmo() {
        return B748SpeedData.vmo;
    }
    /** @inheritdoc */
    getMmo() {
        return B748SpeedData.mmo;
    }
    /** @inheritdoc */
    getGearLimitSpeed() {
        return B748SpeedData.vle;
    }
}
/** Maximum Speed Limit Mach Number */
B748SpeedData.mmo = 0.9;
/** Maximum Speed Limit KCAS */
B748SpeedData.vmo = 365;
/** Landing Gear Placard Speed KIAS */
B748SpeedData.vle = 270;
/** Flap Maneuver Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B748SpeedData.flap_maneuver_speeds = new LerpLookupTable([
    [266, 1014126, 0, 0], [244, 1014126, 1, 0], [224, 1014126, 5, 0], [204, 1014126, 10, 0], [194, 1014126, 20, 0], [191, 1014126, 25, 0], [187, 1014126, 30, 0],
    [260, 970034, 0, 0], [240, 970034, 1, 0], [220, 970034, 5, 0], [201, 970034, 10, 0], [190, 970034, 20, 0], [187, 970034, 25, 0], [183, 970034, 30, 0],
    [256, 925942, 0, 0], [236, 925942, 1, 0], [216, 925942, 5, 0], [198, 925942, 10, 0], [186, 925942, 20, 0], [182, 925942, 25, 0], [178, 925942, 30, 0],
    [252, 881849, 0, 0], [232, 881849, 1, 0], [212, 881849, 5, 0], [195, 881849, 10, 0], [181, 881849, 20, 0], [177, 881849, 25, 0], [173, 881849, 30, 0],
    [247, 837757, 0, 0], [227, 837757, 1, 0], [207, 837757, 5, 0], [192, 837757, 10, 0], [177, 837757, 20, 0], [172, 837757, 25, 0], [169, 837757, 30, 0],
    [243, 793664, 0, 0], [223, 793664, 1, 0], [202, 793664, 5, 0], [190, 793664, 10, 0], [174, 793664, 20, 0], [167, 793664, 25, 0], [164, 793664, 30, 0],
    [239, 749572, 0, 0], [219, 749572, 1, 0], [199, 749572, 5, 0], [186, 749572, 10, 0], [172, 749572, 20, 0], [163, 749572, 25, 0], [160, 749572, 30, 0],
    [234, 705479, 0, 0], [214, 705479, 1, 0], [194, 705479, 5, 0], [180, 705479, 10, 0], [166, 705479, 20, 0], [158, 705479, 25, 0], [155, 705479, 30, 0],
    [229, 661387, 0, 0], [209, 661387, 1, 0], [189, 661387, 5, 0], [174, 661387, 10, 0], [161, 661387, 20, 0], [153, 661387, 25, 0], [150, 661387, 30, 0],
    [224, 617294, 0, 0], [204, 617294, 1, 0], [184, 617294, 5, 0], [168, 617294, 10, 0], [155, 617294, 20, 0], [147, 617294, 25, 0], [144, 617294, 30, 0],
    [219, 573202, 0, 0], [199, 573202, 1, 0], [178, 573202, 5, 0], [162, 573202, 10, 0], [150, 573202, 20, 0], [141, 573202, 25, 0], [139, 573202, 30, 0],
    [213, 529109, 0, 0], [193, 529109, 1, 0], [173, 529109, 5, 0], [155, 529109, 10, 0], [144, 529109, 20, 0], [136, 529109, 25, 0], [133, 529109, 30, 0],
    [208, 485017, 0, 0], [188, 485017, 1, 0], [168, 485017, 5, 0], [149, 485017, 10, 0], [138, 485017, 20, 0], [130, 485017, 25, 0], [127, 485017, 30, 0],
    [205, 440925, 0, 0], [185, 440925, 1, 0], [164, 440925, 5, 0], [144, 440925, 10, 0], [134, 440925, 20, 0], [124, 440925, 25, 0], [121, 440925, 30, 0],
    [271, 1014126, 0, 10000], [247, 1014126, 1, 10000], [227, 1014126, 5, 10000], [211, 1014126, 10, 10000], [197, 1014126, 20, 10000], [191, 1014126, 25, 10000], [187, 1014126, 30, 10000],
    [265, 970034, 0, 10000], [243, 970034, 1, 10000], [223, 970034, 5, 10000], [207, 970034, 10, 10000], [193, 970034, 20, 10000], [187, 970034, 25, 10000], [183, 970034, 30, 10000],
    [259, 925942, 0, 10000], [238, 925942, 1, 10000], [218, 925942, 5, 10000], [204, 925942, 10, 10000], [189, 925942, 20, 10000], [182, 925942, 25, 10000], [178, 925942, 30, 10000],
    [254, 881849, 0, 10000], [234, 881849, 1, 10000], [213, 881849, 5, 10000], [200, 881849, 10, 10000], [184, 881849, 20, 10000], [177, 881849, 25, 10000], [173, 881849, 30, 10000],
    [249, 837757, 0, 10000], [229, 837757, 1, 10000], [209, 837757, 5, 10000], [197, 837757, 10, 10000], [180, 837757, 20, 10000], [172, 837757, 25, 10000], [169, 837757, 30, 10000],
    [244, 793664, 0, 10000], [224, 793664, 1, 10000], [206, 793664, 5, 10000], [194, 793664, 10, 10000], [176, 793664, 20, 10000], [167, 793664, 25, 10000], [164, 793664, 30, 10000],
    [240, 749572, 0, 10000], [220, 749572, 1, 10000], [204, 749572, 5, 10000], [190, 749572, 10, 10000], [173, 749572, 20, 10000], [163, 749572, 25, 10000], [160, 749572, 30, 10000],
    [235, 705479, 0, 10000], [215, 705479, 1, 10000], [197, 705479, 5, 10000], [184, 705479, 10, 10000], [168, 705479, 20, 10000], [158, 705479, 25, 10000], [155, 705479, 30, 10000],
    [230, 661387, 0, 10000], [210, 661387, 1, 10000], [190, 661387, 5, 10000], [177, 661387, 10, 10000], [162, 661387, 20, 10000], [153, 661387, 25, 10000], [150, 661387, 30, 10000],
    [225, 617294, 0, 10000], [205, 617294, 1, 10000], [185, 617294, 5, 10000], [170, 617294, 10, 10000], [156, 617294, 20, 10000], [147, 617294, 25, 10000], [144, 617294, 30, 10000],
    [220, 573202, 0, 10000], [200, 573202, 1, 10000], [179, 573202, 5, 10000], [163, 573202, 10, 10000], [150, 573202, 20, 10000], [141, 573202, 25, 10000], [139, 573202, 30, 10000],
    [214, 529109, 0, 10000], [194, 529109, 1, 10000], [174, 529109, 5, 10000], [157, 529109, 10, 10000], [144, 529109, 20, 10000], [136, 529109, 25, 10000], [133, 529109, 30, 10000],
    [208, 485017, 0, 10000], [188, 485017, 1, 10000], [168, 485017, 5, 10000], [150, 485017, 10, 10000], [138, 485017, 20, 10000], [130, 485017, 25, 10000], [127, 485017, 30, 10000],
    [205, 440925, 0, 10000], [185, 440925, 1, 10000], [164, 440925, 5, 10000], [144, 440925, 10, 10000], [134, 440925, 20, 10000], [124, 440925, 25, 10000], [121, 440925, 30, 10000],
    [288, 1014126, 0, 20000], [252, 1014126, 1, 20000], [232, 1014126, 5, 20000], [219, 1014126, 10, 20000], [202, 1014126, 20, 20000], [191, 1014126, 25, 20000], [187, 1014126, 30, 20000],
    [280, 970034, 0, 20000], [247, 970034, 1, 20000], [227, 970034, 5, 20000], [215, 970034, 10, 20000], [198, 970034, 20, 20000], [187, 970034, 25, 20000], [183, 970034, 30, 20000],
    [271, 925942, 0, 20000], [242, 925942, 1, 20000], [222, 925942, 5, 20000], [209, 925942, 10, 20000], [194, 925942, 20, 20000], [182, 925942, 25, 20000], [178, 925942, 30, 20000],
    [263, 881849, 0, 20000], [237, 881849, 1, 20000], [217, 881849, 5, 20000], [204, 881849, 10, 20000], [189, 881849, 20, 20000], [177, 881849, 25, 20000], [173, 881849, 30, 20000],
    [255, 837757, 0, 20000], [232, 837757, 1, 20000], [214, 837757, 5, 20000], [200, 837757, 10, 20000], [184, 837757, 20, 20000], [172, 837757, 25, 20000], [169, 837757, 30, 20000],
    [250, 793664, 0, 20000], [227, 793664, 1, 20000], [214, 793664, 5, 20000], [197, 793664, 10, 20000], [180, 793664, 20, 20000], [167, 793664, 25, 20000], [164, 793664, 30, 20000],
    [246, 749572, 0, 20000], [223, 749572, 1, 20000], [211, 749572, 5, 20000], [193, 749572, 10, 20000], [177, 749572, 20, 20000], [163, 749572, 25, 20000], [160, 749572, 30, 20000],
    [238, 705479, 0, 20000], [218, 705479, 1, 20000], [203, 705479, 5, 20000], [186, 705479, 10, 20000], [171, 705479, 20, 20000], [158, 705479, 25, 20000], [155, 705479, 30, 20000],
    [233, 661387, 0, 20000], [213, 661387, 1, 20000], [196, 661387, 5, 20000], [180, 661387, 10, 20000], [165, 661387, 20, 20000], [153, 661387, 25, 20000], [150, 661387, 30, 20000],
    [227, 617294, 0, 20000], [207, 617294, 1, 20000], [188, 617294, 5, 20000], [173, 617294, 10, 20000], [159, 617294, 20, 20000], [147, 617294, 25, 20000], [144, 617294, 30, 20000],
    [221, 573202, 0, 20000], [201, 573202, 1, 20000], [181, 573202, 5, 20000], [166, 573202, 10, 20000], [153, 573202, 20, 20000], [141, 573202, 25, 20000], [139, 573202, 30, 20000],
    [215, 529109, 0, 20000], [195, 529109, 1, 20000], [175, 529109, 5, 20000], [158, 529109, 10, 20000], [146, 529109, 20, 20000], [136, 529109, 25, 20000], [133, 529109, 30, 20000],
    [209, 485017, 0, 20000], [189, 485017, 1, 20000], [169, 485017, 5, 20000], [151, 485017, 10, 20000], [139, 485017, 20, 20000], [130, 485017, 25, 20000], [127, 485017, 30, 20000],
    [205, 440925, 0, 20000], [185, 440925, 1, 20000], [164, 440925, 5, 20000], [145, 440925, 10, 20000], [134, 440925, 20, 20000], [124, 440925, 25, 20000], [121, 440925, 30, 20000],
]);
/** Holding Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B748SpeedData.holding_speeds = new LerpLookupTable([
    [267, 1014126, 0, 1500], [269, 1014126, 0, 5000], [271, 1014126, 0, 10000], [277, 1014126, 0, 15000], [318, 1014126, 0, 20000], [323, 1014126, 0, 25000], [316, 1014126, 0, 30000],
    [261, 970034, 0, 1500], [263, 970034, 0, 5000], [265, 970034, 0, 10000], [269, 970034, 0, 15000], [311, 970034, 0, 20000], [315, 970034, 0, 25000], [316, 970034, 0, 30000],
    [257, 925942, 0, 1500], [257, 925942, 0, 5000], [259, 925942, 0, 10000], [262, 925942, 0, 15000], [303, 925942, 0, 20000], [307, 925942, 0, 25000], [312, 925942, 0, 30000],
    [252, 881849, 0, 1500], [252, 881849, 0, 5000], [254, 881849, 0, 10000], [255, 881849, 0, 15000], [296, 881849, 0, 20000], [299, 881849, 0, 25000], [304, 881849, 0, 30000], [283, 881849, 0, 35000],
    [248, 837757, 0, 1500], [248, 837757, 0, 5000], [249, 837757, 0, 10000], [250, 837757, 0, 15000], [288, 837757, 0, 20000], [291, 837757, 0, 25000], [295, 837757, 0, 30000], [283, 837757, 0, 35000],
    [243, 793664, 0, 1500], [243, 793664, 0, 5000], [244, 793664, 0, 10000], [246, 793664, 0, 15000], [280, 793664, 0, 20000], [283, 793664, 0, 25000], [287, 793664, 0, 30000], [283, 793664, 0, 35000],
    [239, 749572, 0, 1500], [239, 749572, 0, 5000], [240, 749572, 0, 10000], [242, 749572, 0, 15000], [272, 749572, 0, 20000], [275, 749572, 0, 25000], [278, 749572, 0, 30000], [283, 749572, 0, 35000],
    [235, 705479, 0, 1500], [235, 705479, 0, 5000], [235, 705479, 0, 10000], [237, 705479, 0, 15000], [263, 705479, 0, 20000], [266, 705479, 0, 25000], [269, 705479, 0, 30000], [273, 705479, 0, 35000], [252, 705479, 0, 40000],
    [230, 661387, 0, 1500], [230, 661387, 0, 5000], [230, 661387, 0, 10000], [231, 661387, 0, 15000], [254, 661387, 0, 20000], [257, 661387, 0, 25000], [260, 661387, 0, 30000], [264, 661387, 0, 35000], [252, 661387, 0, 40000],
    [224, 617294, 0, 1500], [224, 617294, 0, 5000], [225, 617294, 0, 10000], [226, 617294, 0, 15000], [246, 617294, 0, 20000], [248, 617294, 0, 25000], [250, 617294, 0, 30000], [254, 617294, 0, 35000], [252, 617294, 0, 40000], [235, 617294, 0, 43000],
    [219, 573202, 0, 1500], [219, 573202, 0, 5000], [220, 573202, 0, 10000], [220, 573202, 0, 15000], [236, 573202, 0, 20000], [238, 573202, 0, 25000], [241, 573202, 0, 30000], [244, 573202, 0, 35000], [247, 573202, 0, 40000], [235, 573202, 0, 43000],
    [213, 529109, 0, 1500], [213, 529109, 0, 5000], [214, 529109, 0, 10000], [214, 529109, 0, 15000], [227, 529109, 0, 20000], [228, 529109, 0, 25000], [231, 529109, 0, 30000], [233, 529109, 0, 35000], [237, 529109, 0, 40000], [234, 529109, 0, 43000],
    [208, 485017, 0, 1500], [208, 485017, 0, 5000], [208, 485017, 0, 10000], [209, 485017, 0, 15000], [217, 485017, 0, 20000], [218, 485017, 0, 25000], [220, 485017, 0, 30000], [223, 485017, 0, 35000], [226, 485017, 0, 40000], [228, 485017, 0, 43000],
    [205, 440925, 0, 1500], [205, 440925, 0, 5000], [205, 440925, 0, 10000], [205, 440925, 0, 15000], [208, 440925, 0, 20000], [209, 440925, 0, 25000], [210, 440925, 0, 30000], [212, 440925, 0, 35000], [215, 440925, 0, 40000], [216, 440925, 0, 43000],
    [245, 1014126, 1, 1500], [246, 1014126, 1, 5000], [247, 1014126, 1, 10000], [249, 1014126, 1, 15000], [252, 1014126, 1, 20000],
    [241, 970034, 1, 1500], [241, 970034, 1, 5000], [243, 970034, 1, 10000], [245, 970034, 1, 15000], [247, 970034, 1, 20000],
    [236, 925942, 1, 1500], [237, 925942, 1, 5000], [238, 925942, 1, 10000], [240, 925942, 1, 15000], [242, 925942, 1, 20000],
    [232, 881849, 1, 1500], [232, 881849, 1, 5000], [234, 881849, 1, 10000], [235, 881849, 1, 15000], [237, 881849, 1, 20000],
    [227, 837757, 1, 1500], [228, 837757, 1, 5000], [229, 837757, 1, 10000], [230, 837757, 1, 15000], [232, 837757, 1, 20000],
    [223, 793664, 1, 1500], [223, 793664, 1, 5000], [224, 793664, 1, 10000], [225, 793664, 1, 15000], [227, 793664, 1, 20000],
    [219, 749572, 1, 1500], [219, 749572, 1, 5000], [220, 749572, 1, 10000], [221, 749572, 1, 15000], [223, 749572, 1, 20000],
    [214, 705479, 1, 1500], [215, 705479, 1, 5000], [215, 705479, 1, 10000], [216, 705479, 1, 15000], [218, 705479, 1, 20000],
    [209, 661387, 1, 1500], [210, 661387, 1, 5000], [210, 661387, 1, 10000], [211, 661387, 1, 15000], [213, 661387, 1, 20000],
    [204, 617294, 1, 1500], [204, 617294, 1, 5000], [205, 617294, 1, 10000], [206, 617294, 1, 15000], [207, 617294, 1, 20000],
    [199, 573202, 1, 1500], [199, 573202, 1, 5000], [200, 573202, 1, 10000], [200, 573202, 1, 15000], [201, 573202, 1, 20000],
    [193, 529109, 1, 1500], [193, 529109, 1, 5000], [194, 529109, 1, 10000], [194, 529109, 1, 15000], [195, 529109, 1, 20000],
    [188, 485017, 1, 1500], [188, 485017, 1, 5000], [188, 485017, 1, 10000], [189, 485017, 1, 15000], [189, 485017, 1, 20000],
    [185, 440925, 1, 1500], [185, 440925, 1, 5000], [185, 440925, 1, 10000], [185, 440925, 1, 15000], [185, 440925, 1, 20000],
]);

/**
 * Automatically selects the best ADC for a Boeing 747-8.
 *
 * The selected ADC depends on the state of the AIR DATA source select knob. If the knob has Left, Center, or Right
 * selected, then that ADC will be selected. If the knob has Auto selected, then the most desirable from among all
 * three ADCs will be selected. Systems that are providing valid data are considered more desirable than those that
 * are not.
 */
class B748AdcSystemSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines the preferred ADC and which ADC candidates
     * are available from which to select.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        this.candidates = SetSubject.create([1, 2, 3]);
        this.selector = new AdcSystemSelector(1, this.bus, this.candidates, this.sourceSelectSide === 'right' ? [3, 2, 1] : [1, 2, 3]);
        this.isAlive = true;
        this.isInit = false;
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('B748AdcSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b74_air_data_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            let left = false, center = false, right = false;
            switch (state) {
                case AirDataSourceKnobState.Left:
                    left = true;
                    break;
                case AirDataSourceKnobState.Right:
                    right = true;
                    break;
                default:
                    left = true;
                    center = true;
                    right = true;
            }
            this.candidates.toggle(1, left);
            this.candidates.toggle(2, center);
            this.candidates.toggle(3, right);
        });
        this.selector.init();
    }
}

/**
 * Automatically selects the best IRS for a Boeing 747-8.
 *
 * The selected IRS depends on the state of the IRS source select knob. If the knob has Left, Center, or Right
 * selected, then that IRS will be selected. If the knob has Auto selected, then the most desirable from among all
 * three IRSes will be selected. Desirability is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class B748IrsSystemSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines the preferred IRS and which IRS candidates
     * are available from which to select.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        this.candidates = SetSubject.create([1, 2, 3]);
        this.selector = new IrsSystemSelector(1, this.bus, this.candidates, this.sourceSelectSide === 'right' ? [3, 2, 1] : [1, 2, 3]);
        this.isAlive = true;
        this.isInit = false;
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('B748IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b74_irs_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            let left = false, center = false, right = false;
            switch (state) {
                case IrsSourceKnobState.Left:
                    left = true;
                    break;
                case IrsSourceKnobState.Center:
                    center = true;
                    break;
                case IrsSourceKnobState.Right:
                    right = true;
                    break;
                default:
                    left = true;
                    center = true;
                    right = true;
            }
            this.candidates.toggle(1, left);
            this.candidates.toggle(2, center);
            this.candidates.toggle(3, right);
        });
        this.selector.init();
    }
}

/**
 * A TCAS II implementation for the B748.
 */
class B748TCAS extends BoeingTCAS {
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * A common instrument for the B747-8i displays.
 */
class WTB748FsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        this.instrument = instrument;
        this.config = config;
        this.isInstrumentPowered = false;
        this.isPowerValid = false;
        this.isPowered = undefined;
        this.bus = new EventBus();
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.flightPathCalculator = new FlightPathCalculator(this.facLoader, {
            defaultClimbRate: 2000,
            defaultSpeed: 180,
            bankAngle: BoeingFlightPathUtils.flightPathBankAngleTable,
            holdBankAngle: null,
            courseReversalBankAngle: null,
            turnAnticipationBankAngle: null,
            maxBankAngle: 25,
            airplaneSpeedMode: FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
        }, this.bus);
        this.flightPlanner = FlightPlanner.getPlanner(this.bus, this.flightPathCalculator, BoeingFmsUtils.buildBoeingLegName);
        this.perfPlanRepository = new PerformancePlanRepository(this.flightPlanner, this.bus);
        this.activeRoutePerformancePlan = this.perfPlanRepository.getActivePlan();
        this.performanceMath = new B748PerformanceMath();
        this.pathPerformanceProvider = new DefaultBoeingPathPerformanceProvider(this.performanceMath);
        this.engineDataProvider = new B748EngineData(this.bus, this.performanceMath);
        this.speedData = new B748SpeedData(this.bus, this.engineDataProvider);
        this.windPlanner = new InterpolatingWindPlanner(this.bus, this.flightPlanner, {
            numberOfClimbAltitudes: 4,
            numberOfDescentAltitudes: 4,
            numberOfLegAltitudes: 4,
        });
        this.verticalPathCalculator = new BoeingPathCalculator(this.bus, this.flightPlanner, BoeingFlightPlans.ACT_RTE_PLAN_INDEX, this.pathPerformanceProvider, this.engineDataProvider, this.speedData, this.perfPlanRepository, this.windPlanner, this.getVerticalPathCalculatorOptions());
        this.activeRoutePredictor = new BoeingFlightPlanPredictionsProvider(this.bus, 1, BoeingFlightPlans.ACT_RTE_PLAN_INDEX, 1000, this.flightPlanner, this.windPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.pathPerformanceProvider, this.facLoader);
        this.backplane = new InstrumentBackplane();
        this.clock = new Clock(this.bus);
        this.baseInstrumentPublisher = new BaseInstrumentPublisher(this.instrument, this.bus);
        this.ambientPublisher = new AmbientPublisher(this.bus);
        this.gnssPublisher = new GNSSPublisher(this.bus);
        this.adcPublisher = new AdcPublisher(this.bus);
        this.ahrsPublisher = new AhrsPublisher(this.bus);
        this.boeingApPublisher = new BoeingAPSimVarPublisher(this.bus);
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavDataPublisher = new BoeingLNavDataSimVarPublisher(this.bus);
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.boeingVNavPublisher = new BoeingVNavSimVarPublisher(this.bus);
        this.navComSimVarPublisher = new NavComSimVarPublisher(this.bus);
        this.cockpitVarsPublisher = new CockpitVarsPublisher(this.bus);
        this.electricalPublisher = new ElectricalPublisher(this.bus);
        this.eisPublisher = new EISPublisher(this.bus);
        this.timerPublisher = new FlightTimerPublisher(this.bus, 3);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.weightAndBalancePublisher = new WeightBalanceSimvarPublisher(this.bus);
        this.tcas = new B748TCAS(this.bus, this.trafficInstrument, 30, 2, 1);
        this.gameUnitsPublisher = new BoeingGameUnitsPublisher(this.bus);
        this.xpdrInstrument = new XPDRInstrument(this.bus);
        this.brakesPublisher = new BrakeSimvarPublisher(this.bus);
        this.fmsOperatingPhasePublisher = new FmsOperatingPhasePublisher(this.bus);
        this.flapComputer = new FlapComputer(this.bus, {
            flap_positions: [
                { label: 0, flapAngle: 0, slatAngle: 0, speedLimit: Infinity },
                { label: 1, flapAngle: 0, slatAngle: 21, speedLimit: 285 },
                { label: 5, flapAngle: 5, slatAngle: 21, speedLimit: 265 },
                { label: 10, flapAngle: 10, slatAngle: 21, speedLimit: 245 },
                { label: 20, flapAngle: 20, slatAngle: 21, speedLimit: 235 },
                { label: 25, flapAngle: 25, slatAngle: 21, speedLimit: 210 },
                { label: 30, flapAngle: 30, slatAngle: 21, speedLimit: 185 },
            ],
            speed_data: this.speedData,
        });
        /** Videos show the radio altimeter at about -8 on the ground,
         * the RADIO HEIGHT simvar is about +16 feet, so we use offset of -24. */
        this.radioAltimeterOffset = -24;
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.apRadioNavInstrument = new APRadioNavInstrument(this.bus);
        this.systems = [];
        this.sourceSelectSide = this.getSourceSelectSide();
        this.irsSystemSelector = new B748IrsSystemSelector(this.bus, this.sourceSelectSide);
        this.adcSystemSelector = new B748AdcSystemSelector(this.bus, this.sourceSelectSide);
        /** Whether this instrument has started updating. */
        this.haveUpdatesStarted = false;
        this.backplane.addInstrument(InstrumentBackplaneNames.Clock, this.clock);
        this.backplane.addInstrument(InstrumentBackplaneNames.Autopilot, this.apInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.AutopilotRadioNav, this.apRadioNavInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Traffic, this.trafficInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Xpdr, this.xpdrInstrument);
        this.backplane.addPublisher(InstrumentBackplaneNames.Base, this.baseInstrumentPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.HEvents, this.hEventPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ambient, this.ambientPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Adc, this.adcPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ahrs, this.ahrsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Gnss, this.gnssPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingAutopilot, this.boeingApPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNav, this.lNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNavData, this.lNavDataPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.VNav, this.vNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingVNav, this.boeingVNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.NavCom, this.navComSimVarPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.CockpitVars, this.cockpitVarsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Electrical, this.electricalPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Eis, this.eisPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.WeightAndBalance, this.weightAndBalancePublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Units, this.gameUnitsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Timer, this.timerPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Brakes, this.brakesPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.FmsOperatingPhase, this.fmsOperatingPhasePublisher);
        this.tcas.init();
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
        // Wait until game has entered briefing or in-game mode before initializing the avionics status client. This
        // ensures that we do not publish any statuses based on erroneous power states.
        Wait.awaitSubscribable(GameStateProvider.get(), gameState => gameState === GameState.briefing || gameState === GameState.ingame, true).then(async () => {
            this.isPowerValid = true;
            // Wait until updates have started before initializing the power state because instrument power is not
            // initialized until the first update.
            await Wait.awaitCondition(() => this.haveUpdatesStarted);
            if (this.isPowered === undefined) {
                this.isPowered = this.isInstrumentPowered;
                this.onPowerChanged(this.isPowered, undefined);
            }
        });
    }
    /**
     * Gets configuration options for the vertical path calculator.
     * @returns Configuration options for the vertical path calculator.
     */
    getVerticalPathCalculatorOptions() {
        return {
            engineCount: 4
        };
    }
    /**
     * Whether to locally calculate predictions
     *
     * @returns a boolean
     */
    getLocallyCalculatePredictions() {
        return false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSoundEnd(soundEventId) {
        // noop
    }
    /** @inheritdoc */
    Update() {
        this.haveUpdatesStarted = true;
        this.backplane.onUpdate();
        this.updateSystems();
    }
    /**
     * Updates this instrument's systems.
     */
    updateSystems() {
        for (let i = 0; i < this.systems.length; i++) {
            this.systems[i].onUpdate();
        }
    }
    /**
     * Creates this instrument's avionics systems. This method should be called after `this.iauIndex` has been defined.
     */
    createSystems() {
        // TODO the B787 doesn't have a magnetometer
        const magnetometers = [new MagnetometerSystem(1, this.bus, 'elec_master_battery')];
        const adcSystems = [1, 2, 3].map(index => {
            return new AdcSystem(index, this.bus, 1, 1, `elec_circuit_on_${132 + index}`);
        });
        const raSystems = this.config.sensors.radarAltimeterDefinitions.slice(1, this.config.sensors.radarAltimeterCount + 1).map((def, index) => {
            return new RASystem(index + 1, this.bus, this.radioAltimeterOffset, def.electricity);
        });
        const gpsSystems = [1, 2].map(index => new GpsReceiverSystem(index, this.bus, new GPSSatComputer(index, this.bus, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/Data/gps_ephemeris.json', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/Data/gps_sbas.json', 5000, [], this.instrument.instrumentIndex === 3 ? 'primary' : 'replica')));
        const irsAlignTimeSetting = BoeingMsfsUserSettings.getManager(this.bus).getSetting('boeingMsfsIrsAlignTime');
        const irsAttitudeAndRealignDuration = irsAlignTimeSetting.map(setting => setting === BoeingIrsAlignTimeMode.Instant ? 0 : undefined);
        const irsFullAlignDuration = irsAlignTimeSetting.map(setting => {
            switch (setting) {
                case BoeingIrsAlignTimeMode.Instant:
                    return 0;
                case BoeingIrsAlignTimeMode.Realistic:
                    return undefined;
                default:
                    return 60000;
            }
        });
        const irsSystems = [1, 2, 3].map(index => {
            const modeSetting = ConsumerSubject.create(this.bus.getSubscriber().on(`b74_irs_knob_state_${index}`), IrsKnobState.Nav)
                .map(state => {
                switch (state) {
                    case IrsKnobState.Align:
                        return IrsSystemOperatingModeSetting.Align;
                    case IrsKnobState.Nav:
                        return IrsSystemOperatingModeSetting.Navigation;
                    case IrsKnobState.Att:
                        return IrsSystemOperatingModeSetting.Attitude;
                    default:
                        return IrsSystemOperatingModeSetting.Off;
                }
            });
            return new IrsSystem(index, this.bus, 1, 1, true, modeSetting, `elec_circuit_on_${124 + index}`, undefined, irsAttitudeAndRealignDuration, irsFullAlignDuration, irsAttitudeAndRealignDuration);
        });
        this.gpsReceiverSelector = new GpsReceiverSelector(this.bus, Array.from({ length: this.config.sensors.gpsCount }, (v, index) => index + 1), 1 // Math.min(this.iauIndex, this.config.sensors.gpsCount)
        );
        this.gpsReceiverSelector.init();
        // One FMS geo-positioning system for each PFD (technically IAU)
        const fmsPosSystems = [0].map(index => {
            return new FmsPositionSystem(index + 1, this.bus, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.gpsReceiverSelector.selectedIndex, 1, // pfdSettingManager.getSetting('pfdAdcIndex'),
            1);
        });
        this.systems.push(...magnetometers, ...adcSystems, ...raSystems, ...gpsSystems, ...irsSystems, ...fmsPosSystems, new AoaSystem(1, this.bus, 'elec_master_battery'), new MarkerBeaconSystem(1, this.bus, 'elec_master_battery'));
        this.irsSystemSelector.init();
        this.adcSystemSelector.init();
        this.activeRoutePredictor.init(this.getLocallyCalculatePredictions());
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
    /** @inheritdoc */
    onFlightStart() {
        SimVar.SetSimVarValue('L:WT_Flight_Started', SimVarValueType.Bool, true);
    }
    /**
     * Attempt to run onFlightStart in case the instrument was reloaded.
     */
    tryRunOnFlightStart() {
        // Only try to start if ingame during the constructor.
        // If not ingame, then user will get a briefing and will eventually trigger onFlightStart.
        if (GameStateProvider.get().get() === GameState.ingame) {
            this.onFlightStart();
        }
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onGameStateChanged(oldState, newState) {
        // TODO
    }
    /**
     * A callback which is executed when this instrument transitions from a power-off to power-on state.
     */
    onPowerOn() {
        this.isInstrumentPowered = true;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = true;
            if (old !== true) {
                this.onPowerChanged(true, old);
            }
        }
    }
    /**
     * A callback which is executed when this instrument transitions from a power-on to power-off state.
     */
    onPowerOff() {
        this.isInstrumentPowered = false;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = false;
            if (old !== false) {
                this.onPowerChanged(false, old);
            }
        }
    }
    /**
     * Responds to when this instrument's power state changes.
     * @param current The current power state.
     * @param previous The previous power state, or `undefined` if the previous state was invalid.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPowerChanged(current, previous) {
        //
    }
}

/**
 * A controller that listens to H Events sent for Minimums Indications.
 * Sends Key Events to MinimumsManager.
 */
class B748MinimumsStateController extends BoeingMinimumsStateController {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        super(bus, ConsumerSubject.create(bus.getSubscriber().on('b74_minimums_mode').whenChanged(), MinimumsMode.OFF));
    }
}

/**
 * A provider of 747-8 minimums data.
 */
class B748MinimumsDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.bus);
        /** @inheritdoc */
        this.minimumsMode = this.cockpitUserSettings.getSetting('minimumsMode');
        /** @inheritdoc */
        this.baroMinimums = MappedSubject.create(([mode, minimums]) => mode === MinimumsMode.BARO ? minimums : null, this.minimumsMode, this.cockpitUserSettings.getSetting('decisionAltitudeFeet'));
        /** @inheritdoc */
        this.radioMinimums = MappedSubject.create(([mode, minimums]) => mode === MinimumsMode.RA ? minimums : null, this.minimumsMode, this.cockpitUserSettings.getSetting('decisionHeightFeet'));
        this.minimumsAlertState = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isBaroMinimumsAlertActive = MappedSubject.create(([mode, alertState]) => mode === MinimumsMode.BARO && alertState, this.minimumsMode, this.minimumsAlertState);
        this._isRadioMinimumsAlertActive = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isRadioMinimumsAlertActive = this._isRadioMinimumsAlertActive;
        this.pauseable = [
            this.baroMinimums,
            this.radioMinimums,
            this.minimumsAlertState,
            this.isBaroMinimumsAlertActive,
            this._isRadioMinimumsAlertActive
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('B748MinimumsDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.minimumsAlertState.setConsumer(sub.on('minimums_alert'));
        this._isRadioMinimumsAlertActive.setConsumer(sub.on('radio_minimums_alert'));
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('B748MinimumsDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('B748MinimumsDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

var _a;
/** Collection of common data used by the map system. */
class MapSystemCommon {
}
_a = MapSystemCommon;
// Should really only be 1 or 0.5
MapSystemCommon.canvasScale = 1;
/** The number to scale elements designed for MAX displays by so it will be the correct size for the older square Boeing displays. */
MapSystemCommon.maxToOldBoeingScale = 0.765;
MapSystemCommon.labelFontSize = 22 * _a.canvasScale;
MapSystemCommon.fontOutlineWidth = 1 * _a.canvasScale;
MapSystemCommon.labelLineHeight = 20 * _a.canvasScale;
MapSystemCommon.strokeWidth = 3 * _a.canvasScale;
MapSystemCommon.arrowStrokeWidth = 2 * _a.canvasScale;
MapSystemCommon.outlineWidth = 1 * _a.canvasScale;
MapSystemCommon.smallLabelOffsetPx = 9 * _a.canvasScale;
MapSystemCommon.smallLabelOffset = new Float64Array([_a.smallLabelOffsetPx, _a.smallLabelOffsetPx]);
MapSystemCommon.bigLabelOffsetPx = 14 * _a.canvasScale;
MapSystemCommon.bigLabelOffset = new Float64Array([_a.bigLabelOffsetPx, _a.bigLabelOffsetPx]);
MapSystemCommon.mapIconSize = 38 * _a.canvasScale;
MapSystemCommon.mapStyles = {
    canvasScale: MapSystemCommon.canvasScale,
    labelFontSize: MapSystemCommon.labelFontSize,
    fontOutlineWidth: MapSystemCommon.fontOutlineWidth,
    labelLineHeight: MapSystemCommon.labelLineHeight,
    strokeWidth: MapSystemCommon.strokeWidth,
    arrowStrokeWidth: MapSystemCommon.arrowStrokeWidth,
    outlineWidth: MapSystemCommon.outlineWidth,
    smallLabelOffsetPx: MapSystemCommon.smallLabelOffsetPx,
    smallLabelOffset: MapSystemCommon.smallLabelOffset,
    bigLabelOffsetPx: MapSystemCommon.bigLabelOffsetPx,
    bigLabelOffset: MapSystemCommon.bigLabelOffset,
    mapIconSize: MapSystemCommon.mapIconSize,
    maxToOldBoeingScale: MapSystemCommon.maxToOldBoeingScale,
};
MapSystemCommon.mapCompassMaskHeight = 660 * _a.canvasScale;
MapSystemCommon.rangeTickWidth = 13 * _a.canvasScale;
MapSystemCommon.mapCompassRadiusUnscaled = 536;
MapSystemCommon.mapCtrCompassRadiusUnscaled = 260;
MapSystemCommon.planCompassRadiusUnscaled = 330;
MapSystemCommon.mapCompassRadius = _a.mapCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.mapCtrCompassRadius = _a.mapCtrCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.planCompassRadius = _a.planCompassRadiusUnscaled * _a.canvasScale;

/* eslint-disable @typescript-eslint/no-non-null-assertion */
// Every 5deg of heading is 8deg on our circle
const degreesPer5Heading = 8;
// 1.6
const ratio = degreesPer5Heading / 5;
// 576
const totalCircleRotation = 360 * ratio;
// Heading labels divisible by 3 should be big font
const bigLabelDivisor = 3;
// The compass shows labels for every 10deg of heading, so that's 16deg of our circle rotation
const degreesPerLabel = 16;
// because we'll be off by 5deg after 360deg rotation, we need all 36 labels
const totalLabelPositions = 36;
const smallNumberFontSize = '22px';
const bigNumberFontSize = '30px';
const EMPTY_STRING = '';
const compassSvgSize = 600;
const compassRadius = 250;
const labelRadiusSmall = compassRadius - 32;
const labelRadiusBig = compassRadius - 37;
const tickLengthSmall = 6;
const tickLengthBig = 12;
const trackLineTranslateY = -compassRadius / 2;
/** Map compass overlay components which go below the flight plan rotue lines. */
class PfdCompass extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ndMapHeadingRotatingSvgRef = FSComponent.createRef();
        this.headingBugRef = FSComponent.createRef();
        this.trackLineRef = FSComponent.createRef();
        this.numberLabelRefs = new Map();
        this.stringCache = new Map();
        // TODO Use AhrsSystemEvents for heading once it works
        // private readonly currentHeadingMag = ConsumerSubject.create(
        //   this.props.bus.getSubscriber<AhrsSystemEvents>().on('ahrs_hdg_deg_1').withPrecision(2), 0);
        this.currentHeadingMag = ConsumerSubject.create(this.props.bus.getSubscriber().on('hdg_deg').withPrecision(2), 0);
        this.currentTrackMag = ConsumerSubject.create(this.props.bus.getSubscriber().on('track_deg_magnetic').withPrecision(2), 0);
        this.groundSpeed = ConsumerSubject.create(this.props.bus.getSubscriber().on('ground_speed').withPrecision(2), 0);
        this.selectedHeading = ConsumerSubject.create(this.props.bus.getSubscriber().on('ap_heading_selected'), 0);
        this.isHeadingDataValid = ConsumerSubject.create(null, true);
        // Multiply by ratio so that 5deg of heading will rotate our circle 8deg
        // The + and % is to keep the result in the range [0, totalCircleRotation)
        this.circleRotation = this.currentHeadingMag.map(hdg => ((hdg * ratio) + totalCircleRotation) % totalCircleRotation);
        this.trackLineRotation = MappedSubject.create(([hdg, trk, groundSpeed]) => {
            if (groundSpeed < 50) {
                return 0;
            }
            else {
                return this.fixDelta(trk - hdg) * ratio;
            }
        }, this.currentHeadingMag, this.currentTrackMag, this.groundSpeed);
        this.headingBugRotation = MappedSubject.create(([hdg, selHdg]) => {
            return this.fixDelta(selHdg - hdg) * ratio;
        }, this.currentHeadingMag, this.selectedHeading);
        this.classList = SetSubject.create([
            'pfd-compass',
            'map-compass-overlay',
        ]);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isHeadingDataValid.setConsumer(this.props.bus.getSubscriber().on('irs_selector_heading_data_valid_1'));
        this.circleRotation.map(SubscribableMapFunctions.changedBy(5)).sub(this.updateLabelsAndTicks.bind(this), true);
        this.circleRotation.sub(circleRotation => {
            this.ndMapHeadingRotatingSvgRef.instance.style.transform = `rotate3d(0, 0, 1, ${-circleRotation}deg)`;
        }, true);
        this.trackLineRotation.sub(trkLineRot => {
            this.trackLineRef.instance.style.transform = `translateY(${trackLineTranslateY}px) rotate3d(0, 0, 1, ${trkLineRot}deg)`;
        }, true);
        this.headingBugRotation.sub(hdgBugRot => {
            this.headingBugRef.instance.style.transform = `rotate3d(0, 0, 1, ${hdgBugRot}deg) translateY(${-compassRadius}px)`;
        }, true);
    }
    /**
     * Not sure how to explain what this does, but it works, there's probably a simpler way to do this
     * @param delta The delta.
     * @returns The fixed delta.
     */
    fixDelta(delta) {
        if (delta < -180) {
            return (delta + 360) % 360;
        }
        else if (delta > 180) {
            return (delta - 360) % 360;
        }
        else {
            return delta;
        }
    }
    /** Updates the labels and tick marks as needed. */
    updateLabelsAndTicks() {
        const circleRotation = this.circleRotation.get();
        for (const [deg, data] of this.numberLabelRefs) {
            // deg is the fix label position on the circle
            // currentNormalPositionDeg is the position that that label is currently sitting at after being rotated
            // so at heading 180, the circle will have rotated 288deg, so now the label at 228deg is now at the 0deg position
            // The + 720 and % 360 keeps the number in the range [0, 360)
            const currentNormalPositionDeg = (deg - circleRotation + 720) % 360;
            // Render zone is top half of the circle, with deg 0/360 at the top
            const isInRenderZone = currentNormalPositionDeg > 270 || currentNormalPositionDeg < 90;
            if (isInRenderZone) {
                let newLabelNumber;
                // The special sauce, takes the fix label deg position and the current circle rotation
                // and spits out what the label should be at that position
                if (circleRotation - deg > 180) {
                    newLabelNumber = ((deg + 360) / degreesPerLabel) % totalLabelPositions;
                }
                else if (circleRotation - deg < -180) {
                    newLabelNumber = ((totalCircleRotation - (360 - deg)) / degreesPerLabel) % totalLabelPositions;
                }
                else {
                    newLabelNumber = deg / degreesPerLabel;
                }
                // Always show 36 instead of 0 when displaying a heading/bearing/track/etc
                newLabelNumber = newLabelNumber === 0 ? 36 : newLabelNumber;
                if (newLabelNumber % 1 !== 0) {
                    // Don't show the label if not a whole number
                    data.label.set(EMPTY_STRING);
                    // Small ticks when no label
                    data.tickLength.set(tickLengthSmall);
                }
                else {
                    // Caching strings to avoid garbage, even though this runs pretty rarely
                    const newLabel = this.stringCache.has(newLabelNumber)
                        ? this.stringCache.get(newLabelNumber)
                        : newLabelNumber.toFixed(0);
                    this.stringCache.set(newLabelNumber, newLabel);
                    const isBigLabel = newLabelNumber % bigLabelDivisor === 0;
                    data.label.set(newLabel);
                    data.fontSize.set(isBigLabel ? bigNumberFontSize : smallNumberFontSize);
                    // Different radius for the label for different font sizes so they line up close to the ticks
                    data.labelRadius.set(isBigLabel ? labelRadiusBig : labelRadiusSmall);
                    // Big tick when there is a label
                    data.tickLength.set(tickLengthBig);
                }
            }
        }
    }
    /** Builds the compass rose letter markings.
     * @returns A collection of letter marking text elements. */
    buildRoseNumbers() {
        const half = compassSvgSize / 2;
        const texts = [];
        for (let deg = 0; deg < 360; deg += degreesPer5Heading) {
            const label = Subject.create('');
            const fontSize = Subject.create(smallNumberFontSize);
            const labelRadius = Subject.create(labelRadiusSmall);
            const tickLength = Subject.create(tickLengthSmall);
            this.numberLabelRefs.set(deg, { label, fontSize, labelRadius, tickLength });
            texts.push(this.buildNumber(half, labelRadius, deg, label, fontSize, tickLength));
        }
        return texts;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    buildNumber(half, radius, angle, label, fontSize, tickLength) {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(OutlinedElement, { tag: "line", outlineClass: "nd-path-shadow", x1: half, y1: half - compassRadius, x2: half, y2: tickLength.map(l => half - compassRadius + l), transform: `rotate(${angle}, ${half}, ${half})` }),
            FSComponent.buildComponent("text", { x: half, y: radius.map(r => half - r), transform: `rotate(${angle}, ${half}, ${half})`, fill: "var(--boeing-colors-black)", "text-anchor": "middle", "font-size": fontSize, stroke: "var(--boeing-colors-black)", "stroke-width": 1.5 }, label),
            FSComponent.buildComponent("text", { x: half, y: radius.map(r => half - r), transform: `rotate(${angle}, ${half}, ${half})`, fill: "var(--boeing-colors-white)", "text-anchor": "middle", "font-size": fontSize, stroke: "none" }, label)));
    }
    /** @inheritdoc */
    render() {
        const trackLineSvgPaddingY = 10;
        const trackLineSvgWidth = compassSvgSize;
        const trackLineSvgHeight = compassRadius + trackLineSvgPaddingY;
        const trackLineSvgMinY = -(trackLineSvgHeight - (trackLineSvgPaddingY / 2));
        const trackLinePath = `M 0 0 l 0 ${-compassRadius}`;
        const rangeTickWidth = MapSystemCommon.rangeTickWidth;
        const rangeTickPath = `
      M ${-(rangeTickWidth / 2)} ${-((compassRadius / 4) * 2.85)} l ${rangeTickWidth} 0
    `;
        return (FSComponent.buildComponent("div", { class: this.classList },
            FSComponent.buildComponent("div", { class: {
                    'pfd-compass-hdg-fail': true,
                    'hidden': this.isHeadingDataValid,
                } }, "HDG"),
            FSComponent.buildComponent("div", { class: {
                    'pfd-compass-hdg-valid': true,
                    'hidden': this.isHeadingDataValid.map(x => !x),
                } },
                FSComponent.buildComponent("svg", { ref: this.ndMapHeadingRotatingSvgRef, class: "pfd-compass-heading-container", viewBox: `0 0 ${compassSvgSize} ${compassSvgSize}`, width: compassSvgSize, height: compassSvgSize, style: "position: absolute;" },
                    FSComponent.buildComponent("circle", { class: "pfd-compass-background", cx: compassSvgSize / 2, cy: compassSvgSize / 2, r: compassRadius, fill: "var(--boeing-colors-darker-gray)", stroke: "none" }),
                    FSComponent.buildComponent("g", { class: "pfd-compass-numbers-ticks" }, this.buildRoseNumbers())),
                SelectedHeadingBug.build(this.headingBugRef, undefined, MapSystemCommon.maxToOldBoeingScale),
                CurrentHeadingTriangle.build(compassRadius, undefined, undefined, MapSystemCommon.maxToOldBoeingScale),
                FSComponent.buildComponent("svg", { ref: this.trackLineRef, class: "pfd-compass-track-line", viewBox: `${-trackLineSvgWidth / 2} ${trackLineSvgMinY} ${trackLineSvgWidth} ${trackLineSvgHeight}`, width: trackLineSvgWidth, height: trackLineSvgHeight, style: `position: absolute; transform-origin: 50% ${trackLineSvgHeight - (trackLineSvgPaddingY / 2)}px;` },
                    FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: `${trackLinePath} ${rangeTickPath}` })),
                FSComponent.buildComponent("div", { class: "pfd-compass-mask" }),
                FSComponent.buildComponent("div", { class: "pfd-sel-hdg-trk" },
                    FSComponent.buildComponent("span", { class: "value" }, this.selectedHeading.map(value => {
                        value = Math.round(value) % 360;
                        value = value === 0 ? 360 : value;
                        return value.toFixed(0).padStart(3, '0');
                    })),
                    FSComponent.buildComponent("span", { class: "mode", style: "font-size: 0.75em;" }, "H")),
                FSComponent.buildComponent("div", { class: "pfd-compass-mag-tru" },
                    FSComponent.buildComponent("span", { style: "font-size: 0.75em;" }, "MAG")))));
    }
}

/**
 * A Boeing 747-8 PFD airspeed indicator.
 */
class B748AirspeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-airspeed-container': true,
                'gray-box': true,
                'outlined-box': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent(AirspeedIndicator, { ref: this.ref, dataProvider: this.props.dataProvider, flapRetractionDataProvider: this.props.flapRetractionDataProvider, flapSpeedBugDataProvider: this.props.flapSpeedBugDataProvider, vnavSpeedBandDataProvider: this.props.vnavSpeedBandDataProvider, performancePlan: this.props.performancePlan, vSpeedSettings: this.props.vSpeedSettings, windowHeight: 543, v1BugPositionClamp: 24, vrefBugPositionClamp: 500 })));
    }
}

/**
 * A Boeing 747-8 PFD selected airspeed display box.
 */
class B748AirspeedSelectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(AirspeedSelectBox, { ref: this.ref, dataProvider: this.props.dataProvider }));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A provider of Boeing 747-8 flap speed bug data.
 */
class B748FlapSpeedBugDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param speedProvider A speed provider.
     * @param adcIndex The index of the ADC that is the source of this provider's pressure altitude data.
     */
    constructor(bus, speedProvider, adcIndex) {
        this.bus = bus;
        this.speedProvider = speedProvider;
        this.flapPositions = [0, 1, 5, 10, 20];
        this._data = new Map(Array.from(this.flapPositions, position => {
            return [
                position,
                {
                    position,
                    maneuverIas: Subject.create(null),
                    lastPressureAlt: undefined,
                    lastWeight: undefined
                }
            ];
        }));
        /** @inheritdoc */
        this.data = this._data;
        this.isOnGround = ConsumerValue.create(null, false).pause();
        this.pressureAltitude = ConsumerValue.create(null, 0).pause();
        this.grossWeight = ConsumerValue.create(null, 0);
        this.flapsHandleIndex = ConsumerValue.create(null, 0).pause();
        this.simRate = ConsumerValue.create(null, 1);
        this.pauseable = [
            this.pressureAltitude,
            this.isOnGround,
            this.flapsHandleIndex,
            this.grossWeight,
            this.simRate
        ];
        this.lastUpdateTime = undefined;
        this.isAltBelow20k = false;
        this.nominalFlapsHandleIndex = 0;
        this.flapsHandleIndexDelay = 0;
        this.flapsHandleArmedIndex = undefined;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('B748FlapSpeedBugDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.adcIndexSub = this.adcIndex.sub(index => {
            this.pressureAltitude.setConsumer(sub.on(`adc_pressure_alt_${index}`));
        }, true);
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.flapsHandleIndex.setConsumer(sub.on('flaps_handle_index'));
        this.grossWeight.setConsumer(sub.on('total_weight'));
        this.simRate.setConsumer(sub.on('simRate'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('B748FlapSpeedBugDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        this.updateSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('B748FlapSpeedBugDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        this.updateSub.pause();
        this.lastUpdateTime = undefined;
        this.flapsHandleArmedIndex = undefined;
        this.flapsHandleIndexDelay = 0;
    }
    /**
     * Executes this data provider's periodic updates.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        var _a;
        const dt = Math.max(time - ((_a = this.lastUpdateTime) !== null && _a !== void 0 ? _a : time), 0) * this.simRate.get();
        this.lastUpdateTime = time;
        this.updateNominalFlapsHandleIndex(dt);
        const pressureAlt = MathUtils.round(this.pressureAltitude.get(), 10);
        const weight = MathUtils.round(this.grossWeight.get(), 100);
        // Calculate visibilities for all the bugs.
        this.isAltBelow20k = pressureAlt < (this.isAltBelow20k ? 20100 : 19900);
        // FUP -> visible if handle up or 1
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex <= 1) {
            this.updateFlapManeuveringSpeed(this._data.get(0), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(0));
        }
        // F1 ->  visible if handle 1 or 5
        if (this.isAltBelow20k && (this.nominalFlapsHandleIndex === 1 || this.nominalFlapsHandleIndex === 2)) {
            this.updateFlapManeuveringSpeed(this._data.get(1), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(1));
        }
        // F5 ->  visible if handle in 5, 10, 20
        if (this.isAltBelow20k && (this.nominalFlapsHandleIndex >= 2 && this.nominalFlapsHandleIndex <= 4)) {
            this.updateFlapManeuveringSpeed(this._data.get(5), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(5));
        }
        // F10 -> visible if handle 10
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 3) {
            this.updateFlapManeuveringSpeed(this._data.get(10), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(10));
        }
        // F20 -> visible if handle 20
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 4) {
            this.updateFlapManeuveringSpeed(this._data.get(20), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(20));
        }
    }
    /**
     * Updates the nominal flaps handle index, which is the flaps handle index after applying a 1 second delay.
     * @param dt The amount of time elapsed since the last update, in milliseconds.
     */
    updateNominalFlapsHandleIndex(dt) {
        const currentIndex = this.flapsHandleIndex.get();
        if (currentIndex === this.nominalFlapsHandleIndex) {
            this.flapsHandleArmedIndex = undefined;
            return;
        }
        if (this.flapsHandleArmedIndex !== currentIndex) {
            this.flapsHandleIndexDelay = 1000;
            this.flapsHandleArmedIndex = currentIndex;
            return;
        }
        this.flapsHandleIndexDelay -= dt;
        if (this.flapsHandleIndexDelay <= 0) {
            this.nominalFlapsHandleIndex = this.flapsHandleArmedIndex;
            this.flapsHandleArmedIndex = undefined;
        }
    }
    /**
     * Updates one of this data provider's flap maneuvering speeds.
     * @param data The data for the flap speed bug to update.
     * @param pressureAlt The current pressure altitude, in feet.
     * @param weight The current airplane weight, in pounds.
     */
    updateFlapManeuveringSpeed(data, pressureAlt, weight) {
        if (pressureAlt === data.lastPressureAlt && weight === data.lastWeight) {
            return;
        }
        data.lastPressureAlt = pressureAlt;
        data.lastWeight = weight;
        data.maneuverIas.set(Math.floor(this.speedProvider.getFlapManeuverSpeed(data.position, weight, pressureAlt)));
    }
    /**
     * Sets one of this data provider's flap speed bugs to be hidden.
     * @param data The data for the flap speed bug to hide.
     */
    hideFlapSpeedBug(data) {
        data.lastPressureAlt = undefined;
        data.lastWeight = undefined;
        data.maneuverIas.set(null);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        (_a = this.adcIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.updateSub) === null || _b === void 0 ? void 0 : _b.destroy();
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * A Boeing 747-8 PFD groundspeed/mach digital readout display.
 */
class B748GsMachReadout extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.showGs = this.props.airspeedIndicatorDataProvider.isAdcDataFailed.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(GsMachReadout, { ref: this.ref, groundSpeedDataProvider: this.props.groundSpeedDataProvider, airspeedIndicatorDataProvider: this.props.airspeedIndicatorDataProvider, showGs: this.showGs }));
    }
}

/**
 * A Boeing 747-8 PFD "NO VSPD" failure flag.
 */
class B748NoVSpdFlag extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(NoVSpdFlag, { ref: this.ref, bus: this.props.bus, isAirspeedDataFailed: this.props.isAirspeedDataFailed }));
    }
}

/**
 * A Boeing 747-8 PFD altitude preselect display.
 */
class B748AltPreselectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(AltPreselectBox, { ref: this.ref, selectedAltitude: this.props.dataProvider.selectedAltitude, altitudeAlertState: this.props.dataProvider.altitudeAlertState, showMetric: this.props.showMetric }));
    }
}

/**
 * A Boeing 747-8 PFD altimeter.
 */
class B748Altimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.hidden.sub(hidden => {
            if (hidden) {
                this.ref.instance.pause();
            }
            else {
                this.ref.instance.resume();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-altimeter-container': true,
                'gray-box': true,
                'outlined-box': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent(Altimeter, { ref: this.ref, dataProvider: this.props.dataProvider, minimumsDataProvider: this.props.minimumsDataProvider, showMetric: this.props.showMetric, isQfe: this.props.isQfe, windowHeight: 543 })));
    }
}

/**
 * A Boeing 747-8 PFD altimeter barometric settings display.
 */
class B748AltimeterBaroDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.hidden.sub(hidden => {
            if (hidden) {
                this.ref.instance.pause();
            }
            else {
                this.ref.instance.resume();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'pfd-alt-baro-container': true, 'hidden': this.hidden } },
            FSComponent.buildComponent(AltimeterBaroDisplay, { ref: this.ref, dataProvider: this.props.dataProvider, showMetric: this.props.showMetric })));
    }
}

/** Class to manage the altitude alerter on the PFD Altimeter */
class B748AltitudeAlertController extends BoeingAltitudeAlertController {
    /** @inheritdoc */
    getIsApproachModeSubscribable() {
        return MappedSubject.create(([gearDown, flapPosition, approachFlapsSpeed, inApproachLock]) => {
            var _a;
            // if no landing flaps are selected, check for flaps full
            const landingFlaps = approachFlapsSpeed ? (_a = approachFlapsSpeed[0]) !== null && _a !== void 0 ? _a : 30 : 30;
            let isLandingFlapsSet;
            switch (landingFlaps) {
                case 25:
                    isLandingFlapsSet = flapPosition === 5;
                    break;
                case 30:
                default:
                    isLandingFlapsSet = flapPosition === 6;
            }
            return inApproachLock || (gearDown && isLandingFlapsSet);
        }, this.isGearDown, this.flapsPosition, this.performancePlan.approachFlapSpeed, this.inApproachLock);
    }
}

/**
 * A Boeing 747-8 PFD approach reference display.
 */
class B748ApproachReference extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(ApproachReference, { ref: this.ref, dataProvider: this.props.dataProvider }));
    }
}

/**
 * A Boeing 747-8 PFD lateral deviation indicator.
 */
class LateralDeviationIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.isNpScaleVisible = MappedSubject.create(SubscribableMapFunctions.or(), this.props.dataProvider.isLateralNavSourceNp, this.props.dataProvider.isApLateralTogaActive, this.props.dataProvider.isApVerticalTogaActive);
        this.isNpDeviationVisible = this.props.dataProvider.npDeviation.map(deviation => deviation !== null);
        this.isFacScaleVisible = this.props.dataProvider.facDeviation.map(deviation => deviation !== null);
        this.isLsScaleVisible = this.props.dataProvider.locDeviation.map(deviation => deviation !== null);
        this.isLocCaptured = MappedSubject.create(([isLocActive, locDeviation]) => isLocActive && locDeviation !== null && Math.abs(locDeviation) < 0.5, this.props.dataProvider.isApLocActive, this.props.dataProvider.locDeviation);
        this.expandedLsScale = Subject.create(false);
        this.expandedLsScaleTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        const activateExpandedLsScale = this.expandedLsScale.set.bind(this.expandedLsScale, true);
        this.isLocCaptured.sub((captured) => {
            if (captured) {
                this.expandedLsScaleTimer.schedule(activateExpandedLsScale, LateralDeviationIndicator.EXPANDED_LS_SCALE_DELAY);
            }
            else {
                this.expandedLsScaleTimer.clear();
                this.expandedLsScale.set(false);
            }
        }, true);
        if (this.props.expandedLocScale) {
            this.expandedLsScalePipe = this.expandedLsScale.pipe(this.props.expandedLocScale);
        }
        this.ref.instance.wake();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "lateral-deviation-box" },
            FSComponent.buildComponent(DeviationIndicator, { ref: this.ref, rnp: this.props.dataProvider.rnp, anp: this.props.dataProvider.anp, npDeviation: this.props.dataProvider.npDeviation, isUnableRnpAlertActive: this.props.dataProvider.isUnableRnp, isNpDeviationAlertActive: this.props.dataProvider.isNpDeviationExcessive, npDeviationVisible: this.isNpDeviationVisible, npScaleVisible: this.isNpScaleVisible, ianDeviation: this.props.dataProvider.facDeviation, isIanDeviationAlertActive: this.props.dataProvider.isFacDeviationExcessive, ianDeviationVisible: this.isFacScaleVisible, ianScaleVisible: this.isFacScaleVisible, lsDeviation: this.props.dataProvider.locDeviation, lsScaleVisible: this.isLsScaleVisible, isLsDeviationAlertActive: this.props.dataProvider.isLocDeviationExcessive, isLsPointerFlashing: this.props.isLocPointerFlashing, expandedLsScale: this.expandedLsScale })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isNpScaleVisible.destroy();
        this.isNpDeviationVisible.destroy();
        this.isLsScaleVisible.destroy();
        this.isLocCaptured.destroy();
        this.expandedLsScaleTimer.clear();
        (_b = this.expandedLsScalePipe) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}
LateralDeviationIndicator.EXPANDED_LS_SCALE_DELAY = 10000; // ms

/** The RisingRunwayIndicator component. */
class RisingRunwayIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.raHeight = ConsumerSubject.create(null, 0);
        this.isHidden = MappedSubject.create(([radioAltitude, locDeviation]) => radioAltitude >= 2500 || locDeviation === null, this.raHeight, this.props.lateralDeviationDataProvider.locDeviation);
        this.transform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.positionSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.raHeight.setConsumer(sub.on('ra_radio_alt_1').whenChangedBy(10));
        const positionHandler = this.moveRisingRunwaySymbol.bind(this);
        this.positionSubs.push(this.raHeight.sub(positionHandler), this.props.lateralDeviationDataProvider.locDeviation.sub(positionHandler));
        this.isHidden.sub(isHidden => {
            if (isHidden) {
                for (const positionSub of this.positionSubs) {
                    positionSub.pause();
                }
            }
            else {
                for (const positionSub of this.positionSubs) {
                    positionSub.resume();
                }
                this.moveRisingRunwaySymbol();
            }
        }, true);
    }
    /**
     * Method to move the rising runway within the surrounding div:
     */
    moveRisingRunwaySymbol() {
        var _a;
        // The symbol moves vertically according to the radio altitude over ground (<200) and laterally with the LOC deviation indicator:
        const raHeight = this.raHeight.get();
        const locDeviation = (_a = this.props.lateralDeviationDataProvider.locDeviation.get()) !== null && _a !== void 0 ? _a : 0;
        const verticalDeviationInPixel = MathUtils.clamp(raHeight !== null ? raHeight * 100 / 200 : 100, 0, 100);
        const locDeviationInPixel = locDeviation * 60;
        // Now move the symbol:
        this.transform.transform.set(locDeviationInPixel, verticalDeviationInPixel, 0, 0.1, 0.1);
        this.transform.resolve();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'rising-runway-box': true, 'hidden': this.isHidden } },
            FSComponent.buildComponent("div", { class: "rising-runway-symbol", style: { 'transform': this.transform } },
                FSComponent.buildComponent("svg", { "stroke-linejoin": "round", fill: "none" },
                    FSComponent.buildComponent("path", { d: "M 60 3 l 110 0 l 7 22 l -124 0 z M 115 3 l 0 22", "stroke-width": "6", stroke: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M 60 3 l 110 0 l 7 22 l -124 0 z M 115 3 l 0 22", "stroke-width": "4", stroke: "var(--boeing-colors-green)" })),
                FSComponent.buildComponent("svg", { style: "height:200px", "stroke-linejoin": "round", fill: "none" },
                    FSComponent.buildComponent("path", { d: "M 111 28 l 0 400 M 119 28 l 0 400", "stroke-width": "6", stroke: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M 111 28 l 0 400 M 119 28 l 0 400", "stroke-width": "4", stroke: "var(--boeing-colors-magenta)" })))));
    }
}

/**
 * A Boeing 747-8 PFD vertical deviation indicator.
 */
class VerticalDeviationIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.isNpScaleVisible = MappedSubject.create(SubscribableMapFunctions.or(), this.props.dataProvider.isVerticalNavSourceNp, this.props.dataProvider.isApLateralTogaActive, this.props.dataProvider.isApVerticalTogaActive);
        this.isNpDeviationVisible = MappedSubject.create(([isVerticalPathAvailable, isVerticalNavSourceNp, npDeviation]) => {
            return isVerticalNavSourceNp && npDeviation !== null && isVerticalPathAvailable;
        }, this.props.dataProvider.isVerticalPathAvailable, this.props.dataProvider.isVerticalNavSourceNp, this.props.dataProvider.npDeviation);
        this.isGpScaleVisible = this.props.dataProvider.gpDeviation.map(deviation => deviation !== null);
        this.isLsScaleVisible = this.props.dataProvider.gsDeviation.map(deviation => deviation !== null);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.wake();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "vertical-deviation-box" },
            FSComponent.buildComponent(DeviationIndicator, { ref: this.ref, rnp: this.props.dataProvider.rnp, anp: this.props.dataProvider.anp, npDeviation: this.props.dataProvider.npDeviation, isUnableRnpAlertActive: this.props.dataProvider.isUnableRnp, isNpDeviationAlertActive: this.props.dataProvider.isNpDeviationExcessive, npDeviationVisible: this.isNpDeviationVisible, npScaleVisible: this.isNpScaleVisible, ianDeviation: this.props.dataProvider.gpDeviation, isIanDeviationAlertActive: this.props.dataProvider.isGpDeviationExcessive, ianDeviationVisible: this.isGpScaleVisible, ianScaleVisible: this.isGpScaleVisible, lsDeviation: this.props.dataProvider.gsDeviation, lsScaleVisible: this.isLsScaleVisible, isLsDeviationAlertActive: this.props.dataProvider.isGsDeviationExcessive })));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isNpScaleVisible.destroy();
        this.isNpDeviationVisible.destroy();
        this.isGpScaleVisible.destroy();
        this.isLsScaleVisible.destroy();
        super.destroy();
    }
}

/** The Marker Beacon Display Component. */
class MarkerBeacon extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.markerBeaconRef = FSComponent.createRef();
        this.textSub = ComputedSubject.create(MarkerBeaconState.Inactive, (state) => MarkerBeacon.TEXT[state]);
        /**
         * Handle a marker beacon state change event.
         * @param state is the marker beacon state.
         */
        this.onMarkerBeacon = (state) => {
            this.textSub.set(state);
            switch (state) {
                case MarkerBeaconState.Inactive:
                    this.markerBeaconRef.instance.classList.remove('outer-animation', 'middle-animation', 'inner-animation');
                    break;
                case MarkerBeaconState.Outer:
                    this.markerBeaconRef.instance.classList.remove('middle-animation', 'inner-animation');
                    this.markerBeaconRef.instance.classList.add('outer-animation');
                    break;
                case MarkerBeaconState.Middle:
                    this.markerBeaconRef.instance.classList.remove('outer-animation', 'inner-animation');
                    this.markerBeaconRef.instance.classList.add('middle-animation');
                    break;
                case MarkerBeaconState.Inner:
                    this.markerBeaconRef.instance.classList.remove('outer-animation', 'middle-animation');
                    this.markerBeaconRef.instance.classList.add('inner-animation');
                    break;
            }
        };
    }
    /** A callback called after the component renders. */
    onAfterRender() {
        this.props.dataProvider.markerBeaconState.sub(this.onMarkerBeacon.bind(this));
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "marker-beacon-box", ref: this.markerBeaconRef }, this.textSub));
    }
}
MarkerBeacon.TEXT = {
    [MarkerBeaconState.Inactive]: '',
    [MarkerBeaconState.Outer]: 'OM',
    [MarkerBeaconState.Middle]: 'MM',
    [MarkerBeaconState.Inner]: 'IM',
};

/** The MinimumsIndicator component. */
class MinimumsIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.props.bus);
        this.modeSetting = this.cockpitUserSettings.getSetting('minimumsMode');
        this.baroMinimumsSetting = this.cockpitUserSettings.getSetting('decisionAltitudeFeet');
        this.radioMinimumsSetting = this.cockpitUserSettings.getSetting('decisionHeightFeet');
        this.radioMinimumsSelected = Subject.create(this.modeSetting.get() === MinimumsMode.RA);
        this.minimumsLabel = this.modeSetting.map(mode => {
            switch (mode) {
                case MinimumsMode.BARO:
                    this.radioMinimumsSelected.set(false);
                    return 'BARO';
                case MinimumsMode.RA:
                    this.radioMinimumsSelected.set(true);
                    return 'RADIO';
                default:
                    this.radioMinimumsSelected.set(false);
                    return '';
            }
        });
        this.minimumsValue = MappedSubject.create(([mode, baroMins, radioMins]) => {
            switch (mode) {
                case MinimumsMode.BARO:
                    return baroMins.toFixed(0);
                case MinimumsMode.RA:
                    return radioMins.toFixed(0);
                default:
                    return '';
            }
        }, this.modeSetting, this.baroMinimumsSetting, this.radioMinimumsSetting);
        this.isAlertActive = ConsumerSubject.create(null, false);
        this.isFlashing = Subject.create(false);
        this.flashTimer = new DebounceTimer();
        this.isHidden = MappedSubject.create(([show, mode]) => !show || mode === MinimumsMode.OFF, this.props.show, this.modeSetting);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isAlertActive.setConsumer(this.props.bus.getSubscriber().on('minimums_alert'));
        const deactivateFlashing = this.isFlashing.set.bind(this.isFlashing, false);
        this.isAlertActive.sub(isActive => {
            if (isActive) {
                this.isFlashing.set(true);
                this.flashTimer.schedule(deactivateFlashing, MinimumsIndicator.FLASH_DURATION);
            }
            else {
                this.flashTimer.clear();
                deactivateFlashing();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'minimums-indicator': true,
                'hidden': this.isHidden,
                'minimums-indicator-alert': this.isAlertActive,
                'minimums-indicator-flash': this.isFlashing,
                'radio-minimums': this.radioMinimumsSelected
            } },
            FSComponent.buildComponent("div", { class: "minimums-indicator-text" },
                FSComponent.buildComponent("div", { class: "minimums-indicator-text-label" }, this.minimumsLabel),
                FSComponent.buildComponent("div", { class: "minimums-indicator-text-value" }, this.minimumsValue))));
    }
    /** @inheritdoc */
    destroy() {
        this.minimumsValue.destroy();
        this.minimumsLabel.destroy();
        this.isAlertActive.destroy();
        this.isHidden.destroy();
        this.flashTimer.clear();
        super.destroy();
    }
}
MinimumsIndicator.FLASH_DURATION = 3000; // milliseconds

/**
 * A Boeing 747-8 PFD navigation source display.
 */
class B748NavigationSourceDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(NavigationSourceDisplay, { ref: this.ref, lateralDeviationDataProvider: this.props.lateralDeviationDataProvider, verticalDeviationDataProvider: this.props.verticalDeviationDataProvider, isVerticalTogaNp: true }));
    }
}

/** The Altimeter component. */
class RadioAltimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** above this height the RA is not displayed */
        this.RADIO_ALT_MAX = 2500;
        /** below this height the RA value is quantised in twos, above this it's tens */
        this.RADIO_ALT_TENS_THRESHOLD = 100;
        /** below this height the RA value is quantised in tens, above it's twenties */
        this.RADIO_ALT_TWENTIES_THRESHOLD = 500;
        /** the value will be boxed for this time [ms] on first appearing */
        this.RADIO_ALT_ALERT_TIME = 10000;
        this.quantisedRadioAltitude = ComputedSubject.create(0, (ra) => {
            if (ra >= this.RADIO_ALT_TWENTIES_THRESHOLD) {
                return MathUtils.ceil(ra, 20);
            }
            else if (ra >= this.RADIO_ALT_TENS_THRESHOLD) {
                return MathUtils.ceil(ra, 10);
            }
            return MathUtils.ceil(ra, 2);
        });
        this.radioAltitudeText = Subject.create('0');
        this.radioAltClasses = SetSubject.create(['radio-alt', 'black-box', 'hidden']);
        this.radioAltVisible = Subject.create(false);
        this.alertTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        const raSystem = this.props.bus.getSubscriber();
        this.radioAltVisible.sub(this.onRAVisibilityChanged.bind(this));
        this.quantisedRadioAltitude.sub(this.onRaHeightChanged.bind(this));
        this.rawRadioAltitude = raSystem.on('ra_radio_alt_1').handle(this.quantisedRadioAltitude.set.bind(this.quantisedRadioAltitude));
        raSystem.on('ra_state_1').whenChanged().handle(this.onRaStateChanged.bind(this));
        const controlSub = this.props.bus.getSubscriber();
        controlSub.on('radio_minimums_alert').handle(this.onRadioMinimumsAlertChanged.bind(this));
    }
    /**
     * Handle changes in RA height
     * @param ra current height
     */
    onRaHeightChanged(ra) {
        const visible = ra <= this.RADIO_ALT_MAX;
        this.radioAltVisible.set(visible);
        if (visible) {
            this.radioAltitudeText.set(ra.toFixed(0));
        }
    }
    /**
     * Handle changes in RA system state
     * @param state Current state
     */
    onRaStateChanged(state) {
        var _a, _b;
        const failed = state.current !== AvionicsSystemState.On;
        if (failed) {
            (_a = this.rawRadioAltitude) === null || _a === void 0 ? void 0 : _a.pause();
            this.radioAltitudeText.set('RA');
            this.radioAltVisible.set(true);
        }
        else {
            this.radioAltClasses.delete('radio-alt-failed');
            this.onRaHeightChanged(this.quantisedRadioAltitude.get());
            (_b = this.rawRadioAltitude) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
        this.radioAltClasses.toggle('radio-alt-failed', failed);
    }
    /**
     * Handles changes in RA component visibility
     * @param visible Whether RA value should be visible
     */
    onRAVisibilityChanged(visible) {
        if (visible) {
            this.radioAltClasses.delete('hidden');
            // box it for 10 seconds
            this.radioAltClasses.add('radio-alt-alert');
            this.alertTimer.schedule(() => this.radioAltClasses.delete('radio-alt-alert'), this.RADIO_ALT_ALERT_TIME);
        }
        else {
            this.radioAltClasses.add('hidden');
        }
    }
    /**
     * Handle changes in RA minima alert state
     * @param alert below radio minima
     */
    onRadioMinimumsAlertChanged(alert) {
        this.radioAltClasses.toggle('radio-alt-below-minima', alert);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.radioAltClasses }, this.radioAltitudeText));
    }
}

/**
 * A Boeing 747-8 PFD vertical speed indicator.
 */
class B748VerticalSpeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.hidden.sub(hidden => {
            if (hidden) {
                this.ref.instance.pause();
            }
            else {
                this.ref.instance.resume();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-vertical-speed-container': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent("svg", { class: 'pfd-vertical-speed-background' },
                FSComponent.buildComponent("path", { d: 'M 0 0 l 33 0 l 33 86.07 l 0 201.87 l -33 86.07 l -33 0 l 0 -121.28 l 19.64 -11.74 l 0 -107.97 l -19.64 -11.74 z' })),
            FSComponent.buildComponent(VerticalSpeedIndicator, { ref: this.ref, dataProvider: this.props.dataProvider, scaleWidth: 42, scaleHeight: 344, scaleTickOffset: -6, scaleTickLength: 6, scaleZeroTickLength: 19, pointerOriginOffset: 38 })));
    }
}

/**
 * All possible AFDS modes to display
 */
var AfdsStates;
(function (AfdsStates) {
    AfdsStates["None"] = "";
    AfdsStates["FlightDirector"] = "FD";
    AfdsStates["Autopilot"] = "CMD";
    AfdsStates["Land2"] = "LAND 2";
    AfdsStates["Land3"] = "LAND 3";
    /** amber */
    AfdsStates["NoAutoland"] = "NO AUTOLAND";
})(AfdsStates || (AfdsStates = {}));
/**
 * The 748 AFDS display showing the currently active autopilot mode.
 */
class AfdsStatus extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.alertTimer = new DebounceTimer();
        this.statusCssClass = SetSubject.create(['afds-status']);
        this.ap = this.props.bus.getSubscriber();
        this.ra = this.props.bus.getSubscriber();
        this.control = this.props.bus.getSubscriber();
        this.autopilotMaster = ConsumerSubject.create(this.ap.on('ap_master_status'), false);
        this.flightDirector1 = ConsumerSubject.create(this.ap.on('ap_boeing_flight_director_is_active_1'), false);
        this.flightDirector2 = ConsumerSubject.create(this.ap.on('ap_boeing_flight_director_is_active_2'), false);
        this.approachActive = ConsumerSubject.create(this.ap.on('ap_glideslope_hold'), false);
        this.radioAlt = ConsumerSubject.create(this.ra.on('ra_radio_alt_1').atFrequency(1), 0);
        this.radioAltHealthy = Subject.create(false);
        this.autolandCapability = ConsumerSubject.create(this.control.on('autoland_capability'), AutolandCapability.None);
        this.afdsActiveMode = MappedSubject.create(([autopilotMaster, flightDirector1, flightDirector2, radioAlt, radioAltHealthy, approachActive, autolandCapability]) => this.determineState(autopilotMaster, flightDirector1, flightDirector2, radioAlt, radioAltHealthy, approachActive, autolandCapability), this.autopilotMaster, this.flightDirector1, this.flightDirector2, this.radioAlt, this.radioAltHealthy, this.approachActive, this.autolandCapability);
        this.afdsActiveModeSub = this.afdsActiveMode.sub(this.onStatusChanged.bind(this));
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ra.on('ra_state_1').handle((state) => this.radioAltHealthy.set(state.current === AvionicsSystemState.On));
    }
    /**
     * Determine current AFDS state
     * @param autopilotMaster Is AP engaged
     * @param flightDirector1 Is FD1 engaged
     * @param flightDirector2 Is FD2 engaged
     * @param radioAlt Current radio altitude
     * @param radioAltHealthy Is the RA healthy?
     * @param approachActive are the LOC + GS modes active?
     * @param autolandCapability current FMC autoland capability
     * @returns Current AFDS State
     */
    determineState(autopilotMaster, flightDirector1, flightDirector2, radioAlt, radioAltHealthy, approachActive, autolandCapability) {
        const ra = radioAltHealthy ? radioAlt : Infinity;
        if (autopilotMaster) {
            if (approachActive) {
                if (autolandCapability === AutolandCapability.FailOperational) {
                    return AfdsStates.Land3;
                }
                else if (autolandCapability === AutolandCapability.FailPassive) {
                    return AfdsStates.Land2;
                }
                else if (ra < 300) {
                    return AfdsStates.NoAutoland;
                }
            }
            return AfdsStates.Autopilot;
        }
        else if (flightDirector1 || flightDirector2) {
            return AfdsStates.FlightDirector;
        }
        return AfdsStates.None;
    }
    /**
     * Update the display when status changes
     * @param state The new AFDS status
     */
    onStatusChanged(state) {
        if (state === AfdsStates.None) {
            this.removeBox();
        }
        else {
            this.addBox();
        }
        // set the colour and/or arrows
        if (state === AfdsStates.NoAutoland) {
            this.statusCssClass.add('afds-status-failed');
        }
        else {
            this.statusCssClass.delete('afds-status-failed');
        }
    }
    /** box the status for 10 seconds */
    addBox() {
        // schedule clears/overwrites pending timers
        this.alertTimer.schedule(() => {
            this.statusCssClass.delete('afds-status-alert');
        }, AfdsStatus.ALERT_DURATION);
        this.statusCssClass.add('afds-status-alert');
    }
    /** remove the box around the status */
    removeBox() {
        this.statusCssClass.delete('afds-status-alert');
        this.alertTimer.clear();
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "pfd-afds-display" },
            FSComponent.buildComponent("div", { class: this.statusCssClass },
                FSComponent.buildComponent("div", { class: "afds-status-active" }, this.afdsActiveMode),
                FSComponent.buildComponent("div", { class: "afds-status-border" }))));
    }
    /** @inheritdoc */
    destroy() {
        this.afdsActiveModeSub.destroy();
    }
}
AfdsStatus.ALERT_DURATION = 10000; // milliseconds

/**
 * The 748 FMA showing the autothrust, lateral and vertical modes
 */
class Fma extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.apFmalastData = {
            verticalActive: APVerticalModes.NONE,
            verticalArmed: APVerticalModes.NONE,
            verticalDegraded: false,
            lateralActive: APLateralModes.NONE,
            lateralArmed: APLateralModes.NONE,
            lateralDegraded: false,
        };
        this.subscriptions = [];
        this.atFmalastData = {
            status: BoeingAutothrottleStatus.Off,
            armedMode: BoeingAutothrottleModes.NONE,
            activeMode: BoeingAutothrottleModes.NONE,
            isActiveModeFail: false,
            targetIas: null,
            targetMach: null
        };
        this.lateralSlotActiveText = Subject.create('');
        this.isLateralDegraded = Subject.create(false);
        this.verticalSlotActiveText = Subject.create('');
        this.isVerticalDegraded = Subject.create(false);
        this.autothrottleSlotActiveText = Subject.create('');
        this.isAutothrottleDegraded = Subject.create(false);
        this.lateralArmedText = Subject.create('');
        this.verticalArmedText = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.subscriptions.push(sub.on('fma_data').handle((data) => {
            this.updateFromFmaData(data, this.apFmalastData);
            Object.assign(this.apFmalastData, data);
        }));
        this.subscriptions.push(sub.on('boeing_at_fma_data').handle((data) => {
            this.updateFromAutoThrottleFmaData(data, this.atFmalastData);
            Object.assign(this.atFmalastData, data);
        }));
    }
    /**
     * Updates this FMA from a specific set of data.
     * @param data The FMA data from which to update.
     * @param lastData The previous FMA data.
     */
    updateFromFmaData(data, lastData) {
        this.isAutothrottleDegraded.set(false);
        if (data.lateralActive !== (lastData === null || lastData === void 0 ? void 0 : lastData.lateralActive)) {
            this.lateralSlotActiveText.set(this.getLateralActiveString(data.lateralActive));
        }
        this.isLateralDegraded.set(data.lateralDegraded && this.lateralSlotActiveText.get().length > 0);
        if (data.verticalActive !== (lastData === null || lastData === void 0 ? void 0 : lastData.verticalActive)) {
            this.verticalSlotActiveText.set(this.getVerticalActiveString(data.verticalActive));
        }
        this.isVerticalDegraded.set(data.verticalDegraded && this.verticalSlotActiveText.get().length > 0);
        this.lateralArmedText.set(this.getLateralArmedString(data.lateralArmed));
        this.verticalArmedText.set(this.getVerticalArmedString(data.verticalArmed));
    }
    /**
     * Updates this FMA from a specific set of data.
     * @param data The FMA data from which to update.
     * @param lastData The previous FMA data.
     */
    updateFromAutoThrottleFmaData(data, lastData) {
        if (data.status === BoeingAutothrottleStatus.On) {
            if (data.activeMode !== (lastData === null || lastData === void 0 ? void 0 : lastData.activeMode)) {
                this.autothrottleSlotActiveText.set(this.getAutothrottleActiveString(data.activeMode));
            }
        }
        else {
            this.autothrottleSlotActiveText.set('');
        }
    }
    /**
     * Gets the display text for an active autopilot vertical mode given a specific altitude capture mode.
     * @param mode An active autopilot vertical mode.
     * @returns The display text for the specified active autopilot vertical mode and altitude capture mode.
     */
    getVerticalActiveString(mode) {
        switch (mode) {
            case APVerticalModes.TO:
            case APVerticalModes.GA:
                return 'TO/GA';
            case BoeingVNavModes.ALT:
                return 'VNAV ALT';
            case BoeingVNavModes.PATH_IDLE:
            case BoeingVNavModes.PATH_DESCENT:
            case BoeingVNavModes.PATH_LEVEL:
            case APVerticalModes.PATH:
                return 'VNAV PTH';
            case BoeingVNavModes.SPD_CLIMB:
            case BoeingVNavModes.SPD_DESCENT:
            case BoeingVNavModes.THR_DESCENT:
                return 'VNAV SPD';
            case APVerticalModes.VS:
                return 'V/S';
            case APVerticalModes.FPA:
                return 'FPA';
            case APVerticalModes.FLC:
                return 'FLCH SPD';
            case APVerticalModes.CAP:
            case APVerticalModes.ALT:
                return 'ALT';
            case APVerticalModes.GS:
                return 'G/S';
            case APVerticalModes.GP:
                return 'G/P';
            case APVerticalModes.FLARE:
                return 'FLARE';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an armed autopilot vertical mode given a specific active vertical mode, armed altitude
     * capture mode, and VNAV path mode.
     * @param mode An armed autopilot vertical mode.
     * @returns The display text for the specified armed autopilot vertical mode, active vertical mode, armed altitude
     * capture mode, and VNAV path mode.
     */
    getVerticalArmedString(mode) {
        switch (mode) {
            case BoeingVNavModes.ARMED:
                return 'VNAV';
            case APVerticalModes.FLARE:
                return 'FLARE';
            case APVerticalModes.GS:
                return 'G/S';
            case APVerticalModes.GP:
                return 'G/P';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an active autopilot lateral mode.
     * @param mode An active autopilot lateral mode.
     * @returns The display text for the specified active autopilot lateral mode.
     */
    getLateralActiveString(mode) {
        switch (mode) {
            case APLateralModes.NAV:
            case APLateralModes.GPSS:
                return 'LNAV';
            case APLateralModes.HEADING:
                return 'HDG SEL';
            case APLateralModes.HEADING_HOLD:
                return 'HDG HOLD';
            case APLateralModes.TRACK:
                return 'TRK SEL';
            case APLateralModes.TRACK_HOLD:
                return 'TRK HOLD';
            case APLateralModes.LOC:
                return 'LOC';
            case APLateralModes.FMS_LOC:
                return 'FAC';
            case APLateralModes.BC:
                return 'B/CRS';
            case APLateralModes.TO:
            case APLateralModes.GA:
                return 'TO/GA';
            /*case APLateralModes.HUDTOGA:
              return 'HUD TO/GA'; */
            case APLateralModes.ROLLOUT:
                return 'ROLLOUT';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an armed autopilot lateral mode.
     * @param mode An armed autopilot lateral mode.
     * @returns The display text for the specified armed autopilot lateral mode.
     */
    getLateralArmedString(mode) {
        switch (mode) {
            case APLateralModes.NAV:
            case APLateralModes.GPSS:
                return 'LNAV';
            case APLateralModes.LOC:
                return 'LOC';
            case APLateralModes.FMS_LOC:
                return 'FAC';
            case APLateralModes.BC:
                return 'B/CRS';
            case APLateralModes.ROLLOUT:
                return 'ROLLOUT';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an active autothrottle mode.
     * @param mode An active autothrottle mode.
     * @returns The display text for the specified active autothrottle mode.
     */
    getAutothrottleActiveString(mode) {
        switch (mode) {
            case BoeingAutothrottleModes.SPD:
                return 'SPD';
            case BoeingAutothrottleModes.TAKEOFF_HOLD:
            case BoeingAutothrottleModes.HOLD:
            case BoeingAutothrottleModes.HOLD_FAIL:
                return 'HOLD';
            case BoeingAutothrottleModes.GA_THR:
            case BoeingAutothrottleModes.THR:
                return 'THR';
            case BoeingAutothrottleModes.CLIMB:
            case BoeingAutothrottleModes.CON:
            case BoeingAutothrottleModes.GA:
            case BoeingAutothrottleModes.TO:
                return 'THR REF';
            case BoeingAutothrottleModes.IDLE:
            case BoeingAutothrottleModes.RETARD:
                return 'IDLE';
            case BoeingAutothrottleModes.NONE:
                return '';
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("div", { class: 'gray-box fma-background' }),
            FSComponent.buildComponent("div", { class: 'fma' },
                FSComponent.buildComponent(FmaModeSlot, { active: this.autothrottleSlotActiveText, isFailed: this.isAutothrottleDegraded, class: 'fma-active fma-autothrottle-active' }),
                FSComponent.buildComponent("svg", { style: "grid-area: splitter-l", class: "fma-splitter" },
                    FSComponent.buildComponent("line", { x1: "2.5", x2: "2.5", y1: "0", y2: "100%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "2.5", x2: "2.5", y1: "0", y2: "100%" })),
                FSComponent.buildComponent(FmaModeSlot, { active: this.lateralSlotActiveText, isFailed: this.isLateralDegraded, class: 'fma-active fma-lateral-active' }),
                FSComponent.buildComponent("svg", { style: "grid-area: splitter-r", class: "fma-splitter" },
                    FSComponent.buildComponent("line", { x1: "2.5", x2: "2.5", y1: "0", y2: "100%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "2.5", x2: "2.5", y1: "0", y2: "100%" })),
                FSComponent.buildComponent(FmaModeSlot, { active: this.verticalSlotActiveText, isFailed: this.isVerticalDegraded, class: 'fma-active fma-vertical-active' }),
                FSComponent.buildComponent("div", { class: 'fma-armed' }),
                FSComponent.buildComponent("div", { class: 'fma-armed fma-lateral-armed' }, this.lateralArmedText),
                FSComponent.buildComponent("div", { class: 'fma-armed fma-vertical-armed' }, this.verticalArmedText))));
    }
    /** @inheritDoc */
    destroy() {
        for (const it of this.subscriptions) {
            it.destroy();
        }
    }
}

/**
 * A Boeing 747-8 PFD horizon display.
 */
class B748PfdHorizonDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.wake();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "pfd-horizon-container" },
            FSComponent.buildComponent(PfdHorizonDisplay, { ref: this.ref, bus: this.props.bus, adcAirspeedSelectorIndex: 1, adcAltitudeSelectorIndex: 1, irsSelectorIndex: 1, aoaDataProvider: this.props.aoaDataProvider, tcasRaCommandDataProvider: this.props.tcasRaCommandDataProvider, updateFreq: B748PfdHorizonDisplay.UPDATE_FREQ, projectedSize: B748PfdHorizonDisplay.PROJECTED_SIZE, fov: B748PfdHorizonDisplay.FOV, fovEndpoints: B748PfdHorizonDisplay.FOV_ENDPOINTS, projectedOffset: B748PfdHorizonDisplay.PROJECTED_OFFSET, artificialHorizonOptions: B748PfdHorizonDisplay.ARTIFICIAL_HORIZON_OPTIONS, horizonLineConformalBounds: B748PfdHorizonDisplay.HORIZON_LINE_CONFORMAL_BOUNDS, pitchLadderOptions: B748PfdHorizonDisplay.PITCH_LADDER_OPTIONS, pitchLadderClipBounds: B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS, horizonLineOptions: B748PfdHorizonDisplay.HORIZON_LINE_OPTIONS, tcasRaPitchCueOptions: B748PfdHorizonDisplay.TCAS_RA_PITCH_CUE_OPTIONS, tcasRaPitchCueConformalBounds: B748PfdHorizonDisplay.TCAS_RA_PITCH_CUE_CONFORMAL_BOUNDS, bankIndicatorOptions: B748PfdHorizonDisplay.BANK_INDICATOR_OPTIONS, fdConformalBounds: B748PfdHorizonDisplay.FD_CONFORMAL_BOUNDS, showFpv: CockpitUserSettings.getManager(this.props.bus).getSetting('fpvActive'), fpvConformalBounds: B748PfdHorizonDisplay.FPV_CONFORMAL_BOUNDS, showSelectedFpa: false, pitchLimitOptions: B748PfdHorizonDisplay.PITCH_LIMIT_OPTIONS, pitchLimitConformalBounds: B748PfdHorizonDisplay.PITCH_LIMIT_CONFORMAL_BOUNDS, showFdFailureFlagWhenAttFail: false }),
            FSComponent.buildComponent("svg", { class: "pfd-horizon-mask", viewBox: "-10 -10 394 408" },
                FSComponent.buildComponent("path", { d: "M 40 0 L 334 0 C 354 0 374 20 374 40 L 374 348 C 374 368 354 388 334 388 L 40 388 C 20 388 0 368 0 348 L 0 40 C 0 20 20 0 40 0 M -10 -10 L -10 398 L 384 398 L 384 -10 L -10 -10", fill: "#000000", "fill-rule": "nonzero" }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}
B748PfdHorizonDisplay.UPDATE_FREQ = 30;
B748PfdHorizonDisplay.PROJECTED_SIZE = Vec2Math.create(374, 388);
B748PfdHorizonDisplay.PROJECTED_OFFSET = Vec2Math.create(0, 5);
B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS = VecNMath.create(4, 60, 50, 314, 385);
B748PfdHorizonDisplay.FOV = 20;
B748PfdHorizonDisplay.FOV_ENDPOINTS = VecNMath.create(4, 0.5 + B748PfdHorizonDisplay.PROJECTED_OFFSET[0] / B748PfdHorizonDisplay.PROJECTED_SIZE[0], 0.5 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] / B748PfdHorizonDisplay.PROJECTED_SIZE[1], 0.5 + B748PfdHorizonDisplay.PROJECTED_OFFSET[0] / B748PfdHorizonDisplay.PROJECTED_SIZE[0], B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1] / B748PfdHorizonDisplay.PROJECTED_SIZE[1]);
B748PfdHorizonDisplay.ARTIFICIAL_HORIZON_OPTIONS = {
    groundColor: '#aa6d2a',
    skyColor: '#006efb'
};
B748PfdHorizonDisplay.HORIZON_LINE_CONFORMAL_BOUNDS = VecNMath.create(4, 50, 50, 324, 338);
B748PfdHorizonDisplay.PITCH_LADDER_OPTIONS = {
    majorLineIncrement: 10,
    mediumLineFactor: 2,
    minorLineFactor: 2,
    majorLineLength: 160,
    mediumLineLength: 80,
    minorLineLength: 40,
    majorLineShowLabel: true,
    labelMargin: 20,
    labelOffsetY: 2
};
B748PfdHorizonDisplay.HORIZON_LINE_OPTIONS = {
    length: 540
};
// TODO: No idea whether this is correct due to lack of references.
B748PfdHorizonDisplay.TCAS_RA_PITCH_CUE_CONFORMAL_BOUNDS = VecNMath.create(4, -(B748PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] - B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]), -(B748PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] - B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]), (B748PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] - B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]), (B748PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] - B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]));
B748PfdHorizonDisplay.TCAS_RA_PITCH_CUE_OPTIONS = {
    noflyCueHeight: 350,
    noflyCueClosedWidth: 50,
    noflyCueOpenWidth: 254,
    cueStrokeWidth: 4,
    cueOutlineWidth: 1
};
B748PfdHorizonDisplay.BANK_INDICATOR_OPTIONS = {
    radius: 186,
    majorTickLength: 28,
    mediumTickLength: 20,
    minorTickLength: 12,
    pointerSize: Vec2Math.create(31, 21),
    pointerOffset: 2,
    slipSkidIndicatorOffset: 0,
    slipSkidIndicatorHeight: 7
};
B748PfdHorizonDisplay.FD_CONFORMAL_BOUNDS = VecNMath.create(4, B748PfdHorizonDisplay.PROJECTED_SIZE[0] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[0] - 110, B748PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] - 110, B748PfdHorizonDisplay.PROJECTED_SIZE[0] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[0] + 110, B748PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B748PfdHorizonDisplay.PROJECTED_OFFSET[1] + 110);
B748PfdHorizonDisplay.FPV_CONFORMAL_BOUNDS = VecNMath.create(4, 36, B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1] + 20, B748PfdHorizonDisplay.PROJECTED_SIZE[0] - 36, B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[3] - 12);
B748PfdHorizonDisplay.PITCH_LIMIT_OPTIONS = {
    maxPitch: 30
};
B748PfdHorizonDisplay.PITCH_LIMIT_CONFORMAL_BOUNDS = Vec2Math.create(B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1] + 18, B748PfdHorizonDisplay.PITCH_LADDER_BOUNDS[3] - 13);

/**
 * The PFD container component.
 */
class WTB748PfdContainer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.airspeedIndicatorDataProvider = new DefaultAirspeedIndicatorDataProvider(this.props.bus, 1, undefined, true);
        this.flapSpeedBugDataProvider = new B748FlapSpeedBugDataProvider(this.props.bus, this.props.speedProvider, 1);
        this.vnavSpeedBandDataProvider = new DefaultVNavSpeedBandDataProvider(this.props.bus);
        this.groundSpeedDataProvider = new DefaultGroundSpeedDataProvider(this.props.bus, 1, true);
        this.verticalSpeedDataProvider = new DefaultVerticalSpeedDataProvider(this.props.bus, 1, true);
        this.altimeterDataProvider = new DefaultAltimeterDataProvider(this.props.bus, this.props.performancePlan, 1, 24, true);
        this.baroDataProvider = new DefaultBaroDataProvider(this.props.bus, this.props.performancePlan, 1, true);
        this.lateralDeviationDataProvider = new DefaultLateralDeviationDataProvider(this.props.bus, this.props.navIndicators.get('ils'), 1);
        this.verticalDeviationDataProvider = new DefaultVerticalDeviationDataProvider(this.props.bus, this.props.navIndicators.get('ils'), 1);
        this.approachReferenceDataProvider = new DefaultApproachReferenceDataProvider(this.props.bus, this.props.navIndicators.get('ils'));
        this.markerBeaconDataProvider = new MarkerBeaconDataProvider(this.props.bus, 1);
        this.minimumsDataProvider = new B748MinimumsDataProvider(this.props.bus);
        this.flapRetractionDataProvider = new DefaultFlapRetractionDataProvider(this.props.bus);
        this.tcasRaCommandDataProvider = new DefaultTcasRaCommandDataProvider(this.props.bus, this.props.tcas);
        this.altitudeAlertController = new B748AltitudeAlertController(this.props.bus, this.props.performancePlan, this.altimeterDataProvider);
        this.altitudeAlerts = new AltitudeCrewAlerts(this.props.bus);
        this.showMinimumsIndicator = Subject.create(true);
        this.showMetricAltitude = CockpitUserSettings.getManager(this.props.bus).getSetting('metricAltitudeDisplay');
        this.showAirspeedIndicator = this.airspeedIndicatorDataProvider.isAdcDataFailed.map(SubscribableMapFunctions.not());
        this.showAltimeter = this.altimeterDataProvider.isAdcDataFailed.map(SubscribableMapFunctions.not());
        this.showVsi = this.verticalSpeedDataProvider.isDataFailed.map(SubscribableMapFunctions.not());
        this.showBaroDisplay = this.baroDataProvider.isDataFailed.map(SubscribableMapFunctions.not());
        this.useBaroHpa = ConsumerSubject.create(this.props.bus.getSubscriber().on('baro_ref_hpa_1'), false);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.airspeedIndicatorDataProvider.init();
        this.flapSpeedBugDataProvider.init();
        this.vnavSpeedBandDataProvider.init();
        this.groundSpeedDataProvider.init();
        this.verticalSpeedDataProvider.init();
        this.altimeterDataProvider.init();
        this.baroDataProvider.init();
        this.lateralDeviationDataProvider.init();
        this.verticalDeviationDataProvider.init();
        this.approachReferenceDataProvider.init();
        this.minimumsDataProvider.init();
        this.markerBeaconDataProvider.init();
        this.flapRetractionDataProvider.init();
        this.tcasRaCommandDataProvider.init();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "pfd-display-container" },
            FSComponent.buildComponent(B748PfdHorizonDisplay, { bus: this.props.bus, aoaDataProvider: this.props.aoaDataProvider, tcasRaCommandDataProvider: this.tcasRaCommandDataProvider }),
            FSComponent.buildComponent("div", { class: "pfd-fma-box" },
                FSComponent.buildComponent(Fma, { bus: this.props.bus })),
            FSComponent.buildComponent(AfdsStatus, { bus: this.props.bus }),
            FSComponent.buildComponent(B748AirspeedIndicator, { show: this.showAirspeedIndicator, dataProvider: this.airspeedIndicatorDataProvider, flapRetractionDataProvider: this.flapRetractionDataProvider, flapSpeedBugDataProvider: this.flapSpeedBugDataProvider, vnavSpeedBandDataProvider: this.vnavSpeedBandDataProvider, performancePlan: this.props.performancePlan, vSpeedSettings: VSpeedUserSettings.getManager(this.props.bus) }),
            FSComponent.buildComponent(B748AirspeedSelectBox, { dataProvider: this.airspeedIndicatorDataProvider }),
            FSComponent.buildComponent(B748GsMachReadout, { groundSpeedDataProvider: this.groundSpeedDataProvider, airspeedIndicatorDataProvider: this.airspeedIndicatorDataProvider }),
            FSComponent.buildComponent(B748VerticalSpeedIndicator, { show: this.showVsi, dataProvider: this.verticalSpeedDataProvider }),
            FSComponent.buildComponent(B748Altimeter, { show: this.showAltimeter, dataProvider: this.altimeterDataProvider, minimumsDataProvider: this.minimumsDataProvider, showMetric: this.showMetricAltitude, isQfe: this.baroDataProvider.isQfe }),
            FSComponent.buildComponent(B748AltimeterBaroDisplay, { show: this.showBaroDisplay, dataProvider: this.baroDataProvider, showMetric: this.useBaroHpa }),
            FSComponent.buildComponent(B748AltPreselectBox, { dataProvider: this.altimeterDataProvider, showMetric: this.showMetricAltitude }),
            FSComponent.buildComponent("div", { class: "pfd-radio-altimeter-container" },
                FSComponent.buildComponent(RadioAltimeter, { bus: this.props.bus })),
            FSComponent.buildComponent(LateralDeviationIndicator, { dataProvider: this.lateralDeviationDataProvider }),
            FSComponent.buildComponent(VerticalDeviationIndicator, { dataProvider: this.verticalDeviationDataProvider }),
            FSComponent.buildComponent(B748NavigationSourceDisplay, { lateralDeviationDataProvider: this.lateralDeviationDataProvider, verticalDeviationDataProvider: this.verticalDeviationDataProvider }),
            FSComponent.buildComponent(B748ApproachReference, { dataProvider: this.approachReferenceDataProvider }),
            FSComponent.buildComponent(RisingRunwayIndicator, { bus: this.props.bus, lateralDeviationDataProvider: this.lateralDeviationDataProvider }),
            FSComponent.buildComponent(MarkerBeacon, { bus: this.props.bus, dataProvider: this.markerBeaconDataProvider }),
            FSComponent.buildComponent(PfdCompass, { bus: this.props.bus }),
            FSComponent.buildComponent(MinimumsIndicator, { bus: this.props.bus, show: this.showMinimumsIndicator }),
            FSComponent.buildComponent(B748NoVSpdFlag, { bus: this.props.bus, isAirspeedDataFailed: this.airspeedIndicatorDataProvider.isAdcDataFailed }),
            this.renderFailureFlag('S\nP\nD', this.showAirspeedIndicator, 'pfd-failure-flag-boxed pfd-failure-flag-vert pfd-spd-flag'),
            this.renderFailureFlag('MACH', this.showAirspeedIndicator, 'pfd-failure-flag-boxed pfd-mach-flag'),
            this.renderFailureFlag('A\nL\nT', this.showAltimeter, 'pfd-failure-flag-boxed pfd-failure-flag-vert pfd-alt-flag'),
            this.renderFailureFlag('V\nE\nR\nT', this.showVsi, 'pfd-failure-flag-boxed pfd-failure-flag-vert pfd-vert-flag')));
    }
    /**
     * Renders a generic failure flag.
     * @param text The text of the flag.
     * @param hidden Whether to hide the flag.
     * @param cssClass CSS class(es) to apply to the flag's root element.
     * @returns The specified failure flag, as a VNode.
     */
    renderFailureFlag(text, hidden, cssClass) {
        const cssClassRecord = {
            'pfd-failure-flag': true,
            'hidden': hidden
        };
        if (cssClass) {
            FSComponent.addCssClassesToRecord(cssClassRecord, cssClass, false);
        }
        return (FSComponent.buildComponent("div", { class: cssClassRecord }, text));
    }
}

/**
 * A Boeing 747-8i PFD instrument.
 * Primary Flight Display showing the the basic flight instruments.
 */
class WTB748PfdInstrument extends WTB748FsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        super(instrument, config);
        this.minimumsStateController = new B748MinimumsStateController(this.bus);
        this.minimumsManager = new MinimumsManager(this.bus);
        this.minimumsPublisher = new MinimumsSimVarPublisher(this.bus);
        this.minimumsAlertController = new MinimumsAlertController(this.bus);
        this.waypointAlerter = new WaypointAlerter(this.bus);
        this.efisEventPublisher = new EfisEventPublisher(this.bus, false, 1);
        this.efisPfdController = new EfisPfdController(this.bus);
        /** @inheritdoc */
        this.iauIndex = this.instrument.instrumentIndex;
        // TODO: Support switching between IAU and ADC indices with a switch.
        this.iauAdcIndex = this.instrument.instrumentIndex;
        // FIXME: Provide appropriate way to source AOA Index used for DefaultAoaProvider.
        this.aoaIndex = 1;
        this.createSystems();
        // initialize onInGame callback
        const instrSub = this.bus.getSubscriber();
        const onInGameSub = instrSub.on('vc_game_state').whenChanged().handle(state => {
            if (state === GameState.ingame) {
                this.onInGame();
                onInGameSub.destroy();
            }
        }, true);
        onInGameSub.resume(true);
        this.backplane.addPublisher(InstrumentBackplaneNames.Minimums, this.minimumsPublisher);
        this.controlSurfacesPublisher = new ControlSurfacesPublisher(this.bus, 3);
        this.backplane.addPublisher(InstrumentBackplaneNames.ControlSurfaces, this.controlSurfacesPublisher);
        this.navSources = new NavSources(new AdfRadioSource(this.bus, 'ADF1', 1), new AdfRadioSource(this.bus, 'ADF2', 2), new NavRadioNavSource(this.bus, 'ILS1', 3));
        this.backplane.addInstrument('navSources', this.navSources);
        this.navIndicators = new NavIndicators(new Map([
            ['adfLeft', new NavIndicator(this.navSources, 'ADF1')],
            ['adfRight', new NavIndicator(this.navSources, 'ADF2')],
            ['ils', new NavIndicator(this.navSources, 'ILS1')],
        ]));
        this.backplane.addInstrument('navIndicators', this.navIndicators);
        this.xmlLogicHost = new CompositeLogicXMLHost(true);
        this.auralsConfig = new B78XmlAuralsConfig(this.instrument, this.xmlLogicHost, this.bus);
        this.aoaDataProvider = new DefaultAoaDataProvider(this.bus, this.aoaIndex, this.iauAdcIndex);
        this.aoaDataProvider.init();
        this.speedLimitPublisher = new SpeedLimitPublisher(this.bus, this.speedData, 1, 1, 0.95);
        this.backplane.addPublisher('speedLimits', this.speedLimitPublisher);
        this.doInit();
    }
    /** @inheritdoc */
    getSourceSelectSide() {
        return this.instrument.instrumentIndex === 2 ? 'right' : 'left';
    }
    /**
     * Performs initialization tasks.
     */
    async doInit() {
        this.backplane.init();
        // Make sure to init plan and await it before rendering anything, to avoid plan doesn't exist errors
        await this.initFlightPlan();
        FSComponent.render(this.renderComponents(), document.getElementById('Electricity'));
        this.tryRunOnFlightStart();
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        if (!this.efisEventPublisher.handleHEvent(args[0])) {
            super.onInteractionEvent(args);
        }
    }
    /**
     * Callback for when the game state transitions to either briefing or in-game.
     * This can be used as a "last chance" hook to initialize things that need to wait
     * until a plane has loaded and everything is in a stable state.
     */
    onInGame() {
        this.xmlLogicHost.setIsPaused(false);
    }
    /**
     * Renders this instrument's components.
     * @returns This instrument's rendered components, as a VNode.
     */
    renderComponents() {
        return (FSComponent.buildComponent(B748Square, { pfdOrMfd: "PFD", instrumentIndex: this.instrument.instrumentIndex },
            FSComponent.buildComponent(WTB748PfdContainer, { bus: this.bus, performancePlan: this.activeRoutePerformancePlan, navIndicators: this.navIndicators, speedProvider: this.speedData, aoaDataProvider: this.aoaDataProvider, tcas: this.tcas })));
    }
    /** Makes sure that we have the flight plan, requesting sync if needed. */
    async initFlightPlan() {
        // Wait for primary CDU to init the plan
        await Wait.awaitDelay(3000);
        // Request sync from primary CDU
        this.flightPlanner.requestSync();
        // Wait for sync
        await Wait.awaitDelay(500);
    }
    /** @inheritdoc */
    Update() {
        super.Update();
        this.xmlLogicHost.update(this.instrument.deltaTime);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A Boeing 747-8i PFD BaseInstrument.
 */
class WTB748_PFD extends FsBaseInstrument {
    /** @inheritdoc */
    get isInteractive() {
        return true; // Enabling touch for all instruments for development.
    }
    /** @inheritdoc */
    constructInstrument() {
        return new WTB748PfdInstrument(this, new AvionicsConfig(this, this.xmlConfig));
    }
    /** @inheritdoc */
    get templateID() {
        return 'WTB748_PFD';
    }
    /** @inheritdoc */
    onPowerOn() {
        super.onPowerOn();
        this.fsInstrument.onPowerOn();
    }
    /** @inheritdoc */
    onShutDown() {
        super.onShutDown();
        this.fsInstrument.onPowerOff();
    }
}
registerInstrument('wtb748-pfd', WTB748_PFD);
